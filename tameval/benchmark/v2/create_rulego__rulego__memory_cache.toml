[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.20"

[repo_info]
repository = "rulego/rulego"
sha = "22ba0b1e693a9fafb84858dffec8ff8cf5509925"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out utils/cache/memory_cache.go utils/cache/memory_cache_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting utils/cache/memory_cache.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 86.0
original_coverage = 86.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = [ 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 86, 87, 88, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 104, 116, 117, 118, 119, 120, 121, 122, 123, 125, 126, 127, 128, 129, 131, 140, 141, 142, 143, 144, 145, 146, 147, 149, 150, 151, 153, 156, 157, 158, 159, 160, 161, 169, 170, 171, 172, 173, 174, 175, 177, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 201, 207, 208, 215, 216, 217, 218, 219, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 252, 253, 254, 255, 256, 259, 260, 261, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 288, 289, 290, 291, 292, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 314, 321, 322, 323, 324, 325, 326, 329, 330, 331, 332, 333, 357, 361, 362, 363, 364, 375, 379, 389, 393, 402, 406, 415, 419, 429, 433, 436, 440, 441, 442, 443, 444, 445, 447,]
missed_lines = [ 209, 210, 211, 212, 223, 224, 225, 226, 257, 358, 359, 360, 376, 377, 378, 390, 391, 392, 403, 404, 405, 416, 417, 418, 430, 431, 432, 437, 438, 439,]

[input_info]
test_file_path = "utils/cache/memory_cache_test.go"
focal_file_path = "utils/cache/memory_cache.go"
test_file_url = "https://github.com/rulego/rulego/blob/22ba0b1e693a9fafb84858dffec8ff8cf5509925/utils/cache/memory_cache_test.go"
focal_file_url = "https://github.com/rulego/rulego/blob/22ba0b1e693a9fafb84858dffec8ff8cf5509925/utils/cache/memory_cache.go"
first_commit_date = "2025-05-17"
last_commit_date = "2025-05-18"
test_file_content = "/*\n * Copyright 2025 The RuleGo Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage cache\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/rulego/rulego/test/assert\"\n)\n\nfunc TestMemoryCache(t *testing.T) {\n\tc := NewMemoryCache(time.Minute)\n\n\tt.Run(\"SetAndGet\", func(t *testing.T) {\n\t\terr := c.Set(\"key1\", \"value1\", \"1m\")\n\t\tassert.Equal(t, \"value1\", c.Get(\"key1\"))\n\t\tassert.Nil(t, err)\n\n\t\t// 测试过期时间\n\t\terr = c.Set(\"key2\", \"value2\", \"1s\")\n\t\tassert.Nil(t, err)\n\t\ttime.Sleep(2 * time.Second)\n\t\tassert.Nil(t, c.Get(\"key2\"))\n\t})\n\n\tt.Run(\"Has\", func(t *testing.T) {\n\t\tc.Set(\"key1\", \"value1\", \"1m\")\n\t\tif !c.Has(\"key1\") {\n\t\t\tt.Errorf(\"c.Has(\\\"key1\\\") should be true\")\n\t\t}\n\t\tif c.Has(\"nonexistent\") {\n\t\t\tt.Errorf(\"c.Has(\\\"nonexistent\\\") should be false\")\n\t\t}\n\n\t\t// 测试过期后Has返回false\n\t\tc.Set(\"key2\", \"value2\", \"1s\")\n\t\ttime.Sleep(2 * time.Second)\n\t\tif c.Has(\"key2\") {\n\t\t\tt.Errorf(\"c.Has(\\\"key2\\\") should be false after expiration\")\n\t\t}\n\t})\n\n\tt.Run(\"Delete\", func(t *testing.T) {\n\t\tc.Set(\"key1\", \"value1\", \"1m\")\n\t\tassert.Nil(t, c.Delete(\"key1\"))\n\t\tassert.Nil(t, c.Get(\"key1\"))\n\t\tif c.Has(\"key1\") {\n\t\t\tt.Errorf(\"c.Has(\\\"key1\\\") should be false after deletion\")\n\t\t}\n\t})\n\n\tt.Run(\"DeleteByPrefix\", func(t *testing.T) {\n\t\tc.Set(\"prefix_key1\", \"value1\", \"1m\")\n\t\tc.Set(\"prefix_key2\", \"value2\", \"1m\")\n\t\tc.Set(\"other_key\", \"value3\", \"1m\")\n\n\t\tassert.Nil(t, c.DeleteByPrefix(\"prefix_\"))\n\t\tassert.Nil(t, c.Get(\"prefix_key1\"))\n\t\tassert.Nil(t, c.Get(\"prefix_key2\"))\n\t\tassert.Equal(t, \"value3\", c.Get(\"other_key\"))\n\t})\n\n\tt.Run(\"SetWithInvalidTTL\", func(t *testing.T) {\n\t\tc := NewMemoryCache(time.Minute)\n\t\terr := c.Set(\"key_invalid_ttl\", \"value\", \"invalid-duration-string\")\n\t\tassert.NotNil(t, err)\n\t\tassert.Nil(t, c.Get(\"key_invalid_ttl\")) // Should not be set\n\t})\n\n}\n\nfunc TestMemoryCache_GC_Lifecycle(t *testing.T) {\n\tc := NewMemoryCache(50 * time.Millisecond) // Use a short GC interval for testing\n\n\tt.Run(\"GCNotStartedWithoutExpirableItems\", func(t *testing.T) {\n\t\tc.Set(\"key_no_expire\", \"value_no_expire\", \"\") // No TTL, should not start GC\n\t\tc.mu.RLock()\n\t\ttickerRunning := c.ticker != nil\n\t\tc.mu.RUnlock()\n\t\tif tickerRunning {\n\t\t\tt.Errorf(\"GC should not be running without expirable items\")\n\t\t}\n\t})\n\n\tt.Run(\"GCStartsWhenExpirableItemAdded\", func(t *testing.T) {\n\t\tc.Set(\"key_expire_1\", \"value_expire_1\", \"100ms\") // Expirable item\n\t\t// GC should start automatically due to the Set method's logic\n\t\ttime.Sleep(60 * time.Millisecond) // Give GC a chance to start\n\t\tc.mu.RLock()\n\t\ttickerRunning := c.ticker != nil\n\t\tc.mu.RUnlock()\n\t\tif !tickerRunning {\n\t\t\tt.Errorf(\"GC should be running after adding an expirable item\")\n\t\t}\n\t})\n\n\tt.Run(\"GCStopsWhenAllExpirableItemsGone\", func(t *testing.T) {\n\t\t// Wait for key_expire_1 to expire and be collected\n\t\ttime.Sleep(150 * time.Millisecond) // key_expire_1 (100ms) + gcInterval (50ms)\n\n\t\tc.mu.RLock()\n\t\titem1Exists := c.items[\"key_expire_1\"].expiration > 0 && time.Now().UnixNano() < c.items[\"key_expire_1\"].expiration\n\t\ttickerRunningAfterExpiry := c.ticker != nil\n\t\tc.mu.RUnlock()\n\n\t\tif item1Exists {\n\t\t\tt.Errorf(\"key_expire_1 should have expired and been collected\")\n\t\t}\n\t\t// GC should stop because no expirable items are left (key_no_expire is non-expirable)\n\t\tif tickerRunningAfterExpiry {\n\t\t\tt.Errorf(\"GC should stop when no expirable items remain\")\n\t\t}\n\t})\n\n\tt.Run(\"GCRestartsWhenNewExpirableItemAdded\", func(t *testing.T) {\n\t\tc.Set(\"key_expire_2\", \"value_expire_2\", \"100ms\") // Add another expirable item\n\t\t// GC should restart\n\t\ttime.Sleep(60 * time.Millisecond) // Give GC a chance to start\n\t\tc.mu.RLock()\n\t\ttickerRunning := c.ticker != nil\n\t\tc.mu.RUnlock()\n\t\tif !tickerRunning {\n\t\t\tt.Errorf(\"GC should restart after adding a new expirable item\")\n\t\t}\n\t\tc.StopGC() // Clean up GC for this test case\n\t})\n\n\tt.Run(\"GCStopsAfterStopGCCalled\", func(t *testing.T) {\n\t\tcache := NewMemoryCache(50 * time.Millisecond)\n\t\tcache.Set(\"key_temp_expire\", \"value\", \"100ms\") // Starts GC\n\t\ttime.Sleep(60 * time.Millisecond)              // Ensure GC is running\n\t\tcache.mu.RLock()\n\t\tinitialTickerState := cache.ticker != nil\n\t\tcache.mu.RUnlock()\n\t\tif !initialTickerState {\n\t\t\tt.Errorf(\"GC should be running initially\")\n\t\t}\n\n\t\tcache.StopGC()\n\t\ttime.Sleep(60 * time.Millisecond) // Allow time for GC to fully stop\n\n\t\tcache.mu.RLock()\n\t\tfinalTickerState := cache.ticker != nil\n\t\tcache.mu.RUnlock()\n\t\tif finalTickerState {\n\t\t\tt.Errorf(\"GC should be stopped after StopGC() is called\")\n\t\t}\n\t})\n\n}\n\nfunc TestMemoryCache_GetByPrefix(t *testing.T) {\n\tc := NewMemoryCache(time.Second)\n\n\tt.Run(\"EmptyPrefix\", func(t *testing.T) {\n\t\tc.Set(\"key1\", \"value1\", \"1m\")\n\t\tc.Set(\"key2\", \"value2\", \"1m\")\n\t\tresult := c.GetByPrefix(\"\")\n\t\tassert.Equal(t, 2, len(result))\n\t\tassert.Equal(t, \"value1\", result[\"key1\"])\n\t\tassert.Equal(t, \"value2\", result[\"key2\"])\n\t})\n\n\tt.Run(\"FullMatchPrefix\", func(t *testing.T) {\n\t\tc.Set(\"prefix_key1\", \"value1\", \"1m\")\n\t\tc.Set(\"prefix_key2\", \"value2\", \"1m\")\n\t\tc.Set(\"other_key\", \"value3\", \"1m\")\n\t\tresult := c.GetByPrefix(\"prefix_\")\n\t\tassert.Equal(t, 2, len(result))\n\t\tassert.Equal(t, \"value1\", result[\"prefix_key1\"])\n\t\tassert.Equal(t, \"value2\", result[\"prefix_key2\"])\n\t})\n\n\tt.Run(\"PartialMatchPrefix\", func(t *testing.T) {\n\t\tc.Set(\"prefix:sub1\", \"value1\", \"1m\")\n\t\tc.Set(\"prefix:sub2\", \"value2\", \"1m\")\n\t\tc.Set(\"other_key\", \"value3\", \"1m\")\n\t\tresult := c.GetByPrefix(\"prefix:\")\n\t\tassert.Equal(t, 2, len(result))\n\t\tassert.Equal(t, \"value1\", result[\"prefix:sub1\"])\n\t\tassert.Equal(t, \"value2\", result[\"prefix:sub2\"])\n\t})\n\n\tt.Run(\"ExpiredItems\", func(t *testing.T) {\n\t\tc.Set(\"prefix3_key1\", \"value1\", \"1s\")\n\t\ttime.Sleep(2 * time.Second)\n\t\tresult := c.GetByPrefix(\"prefix3_\")\n\t\tassert.Equal(t, 0, len(result))\n\t})\n}\n\nfunc TestNamespaceCache(t *testing.T) {\n\t// 创建底层缓存和命名空间缓存\n\tbaseCache := NewMemoryCache(time.Minute * 5)\n\tnamespace := \"test:\"\n\tcache := NewNamespaceCache(baseCache, namespace)\n\n\t// 测试Set和Get\n\tt.Run(\"SetAndGet\", func(t *testing.T) {\n\t\terr := cache.Set(\"key1\", \"value1\", \"1m\")\n\t\tassert.Nil(t, err)\n\n\t\tvalue := cache.Get(\"key1\")\n\t\tassert.Equal(t, \"value1\", value)\n\n\t\t// 验证底层缓存key是否正确添加前缀\n\t\tbaseValue := baseCache.Get(namespace + \"key1\")\n\t\tassert.Equal(t, \"value1\", baseValue)\n\t})\n\n\t// 测试Has\n\tt.Run(\"Has\", func(t *testing.T) {\n\t\tif !cache.Has(\"key1\") {\n\t\t\tt.Errorf(\"cache.Has(\\\"key1\\\") should be true\")\n\t\t}\n\t\tif cache.Has(\"nonexistent\") {\n\t\t\tt.Errorf(\"cache.Has(\\\"nonexistent\\\") should be false\")\n\t\t}\n\t})\n\n\t// 测试Delete\n\tt.Run(\"Delete\", func(t *testing.T) {\n\t\terr := cache.Delete(\"key1\")\n\t\tassert.Nil(t, err)\n\t\tassert.Nil(t, cache.Get(\"key1\"))\n\t\tif cache.Has(\"key1\") {\n\t\t\tt.Errorf(\"cache.Has(\\\"key1\\\") should be false after deletion\")\n\t\t}\n\t})\n\n\t// 测试DeleteByPrefix\n\tt.Run(\"DeleteByPrefix\", func(t *testing.T) {\n\t\t// 添加多个带前缀的key\n\t\tcache.Set(\"key2\", \"value2\", \"1m\")\n\t\tcache.Set(\"key3\", \"value3\", \"1m\")\n\n\t\t// 删除所有带前缀的key\n\t\terr := cache.DeleteByPrefix(\"\")\n\t\tassert.Nil(t, err)\n\n\t\t// 验证所有key已被删除\n\t\tassert.Nil(t, cache.Get(\"key2\"))\n\t\tassert.Nil(t, cache.Get(\"key3\"))\n\t\tif cache.Has(\"key2\") {\n\t\t\tt.Errorf(\"cache.Has(\\\"key2\\\") should be false after DeleteByPrefix\")\n\t\t}\n\t\tif cache.Has(\"key3\") {\n\t\t\tt.Errorf(\"cache.Has(\\\"key3\\\") should be false after DeleteByPrefix\")\n\t\t}\n\t})\n\n\t// 测试自定义前缀删除\n\tt.Run(\"DeleteWithCustomPrefix\", func(t *testing.T) {\n\t\tcache.Set(\"sub:key4\", \"value4\", \"1m\")\n\t\tcache.Set(\"sub:key5\", \"value5\", \"1m\")\n\n\t\t// 删除特定前缀的key\n\t\terr := cache.DeleteByPrefix(\"sub:\")\n\t\tassert.Nil(t, err)\n\n\t\tassert.Nil(t, cache.Get(\"sub:key4\"))\n\t\tassert.Nil(t, cache.Get(\"sub:key5\"))\n\t})\n\n\t// 测试GetByPrefix返回的key是否已正确截取命名空间前缀\n\tt.Run(\"GetByPrefixKeyFormat\", func(t *testing.T) {\n\t\tcache.Set(\"prefix1\", \"value1\", \"1m\")\n\t\tcache.Set(\"prefix2\", \"value2\", \"1m\")\n\t\tcache.Set(\"prefix3\", \"value3\", \"1m\")\n\n\t\tresult := cache.GetByPrefix(\"\")\n\t\tassert.Equal(t, 3, len(result))\n\n\t\t// 验证返回的key不包含命名空间前缀\n\t\tfor k := range result {\n\t\t\tif len(k) >= len(namespace) && k[:len(namespace)] == namespace {\n\t\t\t\tt.Errorf(\"GetByPrefix returned key contains namespace prefix: %s\", k)\n\t\t\t}\n\t\t}\n\n\t\t// 测试带前缀查询\n\t\tresult = cache.GetByPrefix(\"pre\")\n\t\tassert.Equal(t, 3, len(result))\n\t\tfor k := range result {\n\t\t\tif !strings.HasPrefix(k, \"pre\") {\n\t\t\t\tt.Errorf(\"GetByPrefix returned key does not match prefix: %s\", k)\n\t\t\t}\n\t\t}\n\t})\n\n}\n"
