[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "notaryproject/ratify"
sha = "67aa7a4993f915deac10ae371cdafb67a4bf697c"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/cloudprovider/azure/tokencredential.go internal/cloudprovider/azure/tokencredential_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/cloudprovider/azure/tokencredential.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 87.0
original_coverage = 87.0
mutation_kill_rate = 67.0
original_mutation_kill_rate = 67.0
covered_lines = [ 25, 26, 27, 28, 29, 30, 31, 32, 33, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 51,]
missed_lines = [ 34, 35, 36,]

[input_info]
test_file_path = "internal/cloudprovider/azure/tokencredential_test.go"
focal_file_path = "internal/cloudprovider/azure/tokencredential.go"
test_file_url = "https://github.com/notaryproject/ratify/blob/67aa7a4993f915deac10ae371cdafb67a4bf697c/internal/cloudprovider/azure/tokencredential_test.go"
focal_file_url = "https://github.com/notaryproject/ratify/blob/67aa7a4993f915deac10ae371cdafb67a4bf697c/internal/cloudprovider/azure/tokencredential.go"
first_commit_date = "2025-07-02"
last_commit_date = "2025-07-02"
test_file_content = "/*\nCopyright The Ratify Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage azure\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCreateCredentialChain(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tclientID string\n\t\ttenantID string\n\t}{\n\t\t{\n\t\t\tname:     \"with both clientID and tenantID\",\n\t\t\tclientID: \"test-client-id\",\n\t\t\ttenantID: \"test-tenant-id\",\n\t\t},\n\t\t{\n\t\t\tname:     \"with only clientID\",\n\t\t\tclientID: \"test-client-id\",\n\t\t\ttenantID: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"with only tenantID\",\n\t\t\tclientID: \"\",\n\t\t\ttenantID: \"test-tenant-id\",\n\t\t},\n\t\t{\n\t\t\tname:     \"with empty clientID and tenantID\",\n\t\t\tclientID: \"\",\n\t\t\ttenantID: \"\",\n\t\t},\n\t\t{\n\t\t\tname:     \"with special characters in clientID\",\n\t\t\tclientID: \"test-client-id-with-special-chars-123\",\n\t\t\ttenantID: \"test-tenant-id\",\n\t\t},\n\t\t{\n\t\t\tname:     \"with UUID format clientID and tenantID\",\n\t\t\tclientID: \"12345678-1234-1234-1234-123456789abc\",\n\t\t\ttenantID: \"87654321-4321-4321-4321-cba987654321\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tcredential, err := CreateCredentialChain(tt.clientID, tt.tenantID)\n\n\t\t\t// The function should always succeed in creating a chained credential\n\t\t\t// even if the underlying credentials don't work in the test environment\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"unexpected error creating credential chain: %v\", err)\n\t\t\t}\n\n\t\t\tif credential == nil {\n\t\t\t\tt.Error(\"expected non-nil credential\")\n\t\t\t}\n\n\t\t\t// Verify that the returned credential implements the TokenCredential interface\n\t\t\tvar _ = credential\n\t\t})\n\t}\n}\n\nfunc TestCreateCredentialChain_WorkloadIdentitySuccess(t *testing.T) {\n\t// Test case that ensures workload identity credential creation is attempted\n\t// This covers the path where wiCred is created successfully (err == nil)\n\t// and added to sources (lines 33-35 in the original code)\n\n\tclientID := \"workload-test-client-id\"\n\ttenantID := \"workload-test-tenant-id\"\n\n\tcredential, err := CreateCredentialChain(clientID, tenantID)\n\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tif credential == nil {\n\t\tt.Error(\"expected non-nil credential\")\n\t}\n\n\t// The credential should be a ChainedTokenCredential\n\t// We can't easily verify the internal sources without reflection,\n\t// but we can verify it was created successfully\n}\n\nfunc TestCreateCredentialChain_ManagedIdentityWithClientID(t *testing.T) {\n\t// Test case that ensures managed identity credential with client ID is handled\n\t// This covers the path where clientID != \"\" (lines 38-42 in the original code)\n\n\tclientID := \"managed-identity-client-id\"\n\ttenantID := \"managed-identity-tenant-id\"\n\n\tcredential, err := CreateCredentialChain(clientID, tenantID)\n\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tif credential == nil {\n\t\tt.Error(\"expected non-nil credential\")\n\t}\n}\n\nfunc TestCreateCredentialChain_ManagedIdentityWithoutClientID(t *testing.T) {\n\t// Test case that ensures managed identity credential without client ID is handled\n\t// This covers the path where clientID == \"\" (managed identity uses system-assigned)\n\n\tclientID := \"\"\n\ttenantID := \"system-assigned-tenant-id\"\n\n\tcredential, err := CreateCredentialChain(clientID, tenantID)\n\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tif credential == nil {\n\t\tt.Error(\"expected non-nil credential\")\n\t}\n}\n\nfunc TestCreateCredentialChain_ManagedIdentitySuccess(t *testing.T) {\n\t// Test case that ensures managed identity credential creation is attempted\n\t// This covers the path where miCred is created successfully (err == nil)\n\t// and added to sources (lines 44-46 in the original code)\n\n\tclientID := \"managed-test-client-id\"\n\ttenantID := \"\"\n\n\tcredential, err := CreateCredentialChain(clientID, tenantID)\n\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tif credential == nil {\n\t\tt.Error(\"expected non-nil credential\")\n\t}\n}\n\nfunc TestCreateCredentialChain_ChainedCredentialCreation(t *testing.T) {\n\t// Test case that ensures the chained credential is created\n\t// This covers line 49: azidentity.NewChainedTokenCredential(sources, nil)\n\n\tclientID := \"chain-test-client-id\"\n\ttenantID := \"chain-test-tenant-id\"\n\n\tcredential, err := CreateCredentialChain(clientID, tenantID)\n\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tif credential == nil {\n\t\tt.Error(\"expected non-nil credential\")\n\t}\n\n\t// Verify the credential type\n\tvar _ = credential\n}\n\nfunc TestCreateCredentialChain_EmptySourcesList(t *testing.T) {\n\t// Test edge case where both workload identity and managed identity fail\n\t// but ChainedTokenCredential should still be created with empty sources\n\t// This tests the robustness of the function\n\n\tclientID := \"\"\n\ttenantID := \"\"\n\n\tcredential, err := CreateCredentialChain(clientID, tenantID)\n\n\t// Even with empty sources, ChainedTokenCredential should be created\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tif credential == nil {\n\t\tt.Error(\"expected non-nil credential\")\n\t}\n}\n\nfunc TestCreateCredentialChain_LongIdentifiers(t *testing.T) {\n\t// Test with very long identifiers to ensure no length limitations\n\n\tlongClientID := \"very-long-client-id-that-might-be-used-in-some-environments-with-extensive-naming-conventions-12345678901234567890\"\n\tlongTenantID := \"very-long-tenant-id-that-might-be-used-in-some-environments-with-extensive-naming-conventions-09876543210987654321\"\n\n\tcredential, err := CreateCredentialChain(longClientID, longTenantID)\n\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error with long identifiers: %v\", err)\n\t}\n\n\tif credential == nil {\n\t\tt.Error(\"expected non-nil credential with long identifiers\")\n\t}\n}\n\nfunc TestCreateCredentialChain_ReturnType(t *testing.T) {\n\t// Test that the return type implements azcore.TokenCredential interface\n\n\tclientID := \"interface-test-client-id\"\n\ttenantID := \"interface-test-tenant-id\"\n\n\tcredential, err := CreateCredentialChain(clientID, tenantID)\n\n\tif err != nil {\n\t\tt.Errorf(\"unexpected error: %v\", err)\n\t}\n\n\tif credential == nil {\n\t\tt.Error(\"expected non-nil credential\")\n\t}\n\n\t// This line ensures the returned credential implements azcore.TokenCredential\n\tvar tokenCredential = credential\n\tif tokenCredential == nil {\n\t\tt.Error(\"credential does not implement azcore.TokenCredential interface\")\n\t}\n}\n\nfunc TestCreateCredentialChain_AllPaths(t *testing.T) {\n\t// Comprehensive test that tries to exercise all code paths\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tclientID string\n\t\ttenantID string\n\t\tdesc     string\n\t}{\n\t\t{\n\t\t\tname:     \"both_empty\",\n\t\t\tclientID: \"\",\n\t\t\ttenantID: \"\",\n\t\t\tdesc:     \"Tests empty client and tenant IDs\",\n\t\t},\n\t\t{\n\t\t\tname:     \"client_only\",\n\t\t\tclientID: \"test-client\",\n\t\t\ttenantID: \"\",\n\t\t\tdesc:     \"Tests with only client ID\",\n\t\t},\n\t\t{\n\t\t\tname:     \"tenant_only\",\n\t\t\tclientID: \"\",\n\t\t\ttenantID: \"test-tenant\",\n\t\t\tdesc:     \"Tests with only tenant ID\",\n\t\t},\n\t\t{\n\t\t\tname:     \"both_present\",\n\t\t\tclientID: \"test-client\",\n\t\t\ttenantID: \"test-tenant\",\n\t\t\tdesc:     \"Tests with both client and tenant IDs\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tcredential, err := CreateCredentialChain(tc.clientID, tc.tenantID)\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"case %s (%s): unexpected error: %v\", tc.name, tc.desc, err)\n\t\t\t}\n\n\t\t\tif credential == nil {\n\t\t\t\tt.Errorf(\"case %s (%s): expected non-nil credential\", tc.name, tc.desc)\n\t\t\t}\n\t\t})\n\t}\n}\n"
