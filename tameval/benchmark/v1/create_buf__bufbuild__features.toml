[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Go"
go_version = "1.23.0"

[repo_info]
repository = "bufbuild/buf"
sha = "37b5a2a496a2279aa03507be64cba00193644a1e"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out private/buf/bufgen/features.go private/buf/bufgen/features_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting private/buf/bufgen/features.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 90.59
original_coverage = 87.0
mutation_kill_rate = 68.75
original_mutation_kill_rate = nan
covered_lines = [ 47, 48, 49, 50, 51, 52, 59, 60, 61, 62, 63, 64, 67, 68, 69, 70, 73, 74, 76, 77, 78, 79, 80, 81, 82, 83, 85, 93, 94, 95, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 129, 130, 131, 132, 133, 134, 135, 136, 139, 140, 141, 142, 146, 147, 148, 149, 150, 151, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 175, 176, 177, 178, 179, 181, 184, 188, 189, 190, 191, 192, 196, 199, 200, 201, 202, 204, 205, 206, 207, 215, 216, 217, 218, 219, 220, 221, 223, 224, 225, 226, 227, 228, 229, 230, 231, 233, 236, 237, 238, 239, 240, 250, 251, 252,]
missed_lines = [ 96, 97, 98, 123, 124, 125, 126, 127, 128, 143, 144, 145, 185, 186, 187, 242, 243, 244, 245, 247,]

[input_info]
test_file_path = "private/buf/bufgen/features_test.go"
focal_file_path = "private/buf/bufgen/features.go"
test_file_url = "https://github.com/bufbuild/buf/blob/37b5a2a496a2279aa03507be64cba00193644a1e/private/buf/bufgen/features_test.go"
focal_file_url = "https://github.com/bufbuild/buf/blob/37b5a2a496a2279aa03507be64cba00193644a1e/private/buf/bufgen/features.go"
first_commit_date = "2022-09-09"
last_commit_date = "2025-01-02"
test_file_content = "// Copyright 2020-2025 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage bufgen\n\nimport (\n\t\"bytes\"\n\t\"log/slog\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/bufbuild/buf/private/bufpkg/bufconfig\"\n\t\"github.com/bufbuild/buf/private/bufpkg/bufimage\"\n\t\"github.com/google/uuid\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/descriptorpb\"\n\t\"google.golang.org/protobuf/types/pluginpb\"\n)\n\nfunc TestComputeRequiredFeatures(t *testing.T) {\n\tt.Parallel()\n\tnoRequiredFeatures := makeImageNoRequiredFeatures(t)\n\trequiresProto3Optional := makeImageRequiresProto3Optional(t)\n\trequiresEditions := makeImageRequiresEditions(t)\n\trequiresBoth := makeImageRequiresBoth(t)\n\n\trequired := computeRequiredFeatures(noRequiredFeatures)\n\tassert.Empty(t, required.featureToFilenames)\n\tassert.Empty(t, required.editionToFilenames)\n\n\trequired = computeRequiredFeatures(requiresProto3Optional)\n\tassert.Equal(t, map[pluginpb.CodeGeneratorResponse_Feature][]string{\n\t\tpluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL: {\"proto3_optional.proto\"},\n\t}, required.featureToFilenames)\n\tassert.Empty(t, required.editionToFilenames)\n\n\trequired = computeRequiredFeatures(requiresEditions)\n\tassert.Equal(t, map[pluginpb.CodeGeneratorResponse_Feature][]string{\n\t\tpluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS: {\"editions.proto\"},\n\t}, required.featureToFilenames)\n\tassert.Equal(t, map[descriptorpb.Edition][]string{\n\t\tdescriptorpb.Edition_EDITION_2023: {\"editions.proto\"},\n\t}, required.editionToFilenames)\n\t// Note that we can't really test a wider range here right now because\n\t// we don't support building an editions file for anything other than\n\t// edition 2023 right now.\n\tassert.Equal(t, descriptorpb.Edition_EDITION_2023, required.minEdition)\n\tassert.Equal(t, descriptorpb.Edition_EDITION_2023, required.maxEdition)\n\n\trequired = computeRequiredFeatures(requiresBoth)\n\tassert.Equal(t, map[pluginpb.CodeGeneratorResponse_Feature][]string{\n\t\tpluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL:   {\"proto3_optional.proto\"},\n\t\tpluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS: {\"editions.proto\"},\n\t}, required.featureToFilenames)\n\tassert.Equal(t, map[descriptorpb.Edition][]string{\n\t\tdescriptorpb.Edition_EDITION_2023: {\"editions.proto\"},\n\t}, required.editionToFilenames)\n\tassert.Equal(t, descriptorpb.Edition_EDITION_2023, required.minEdition)\n\tassert.Equal(t, descriptorpb.Edition_EDITION_2023, required.maxEdition)\n}\n\nfunc TestCheckRequiredFeatures(t *testing.T) {\n\tt.Parallel()\n\tnoRequiredFeatures := makeImageNoRequiredFeatures(t)\n\trequiresProto3Optional := makeImageRequiresProto3Optional(t)\n\trequiresEditions := makeImageRequiresEditions(t)\n\trequiresBoth := makeImageRequiresBoth(t)\n\n\tsupportsNoFeatures := &pluginpb.CodeGeneratorResponse{}\n\tsupportsBoth := &pluginpb.CodeGeneratorResponse{\n\t\tSupportedFeatures: proto.Uint64(uint64(\n\t\t\tpluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL |\n\t\t\t\tpluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS,\n\t\t)),\n\t\tMinimumEdition: (*int32)(descriptorpb.Edition_EDITION_2023.Enum()),\n\t\tMaximumEdition: (*int32)(descriptorpb.Edition_EDITION_2024.Enum()),\n\t}\n\tsupportsEditionsButOutOfRange := &pluginpb.CodeGeneratorResponse{\n\t\tSupportedFeatures: proto.Uint64(uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)),\n\t\tMinimumEdition:    (*int32)(descriptorpb.Edition_EDITION_2024.Enum()),\n\t\tMaximumEdition:    (*int32)(descriptorpb.Edition_EDITION_MAX.Enum()),\n\t}\n\tsupportsEditionsButNoRange := &pluginpb.CodeGeneratorResponse{\n\t\tSupportedFeatures: proto.Uint64(uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)),\n\t}\n\tsupportsEditionsButMalformedRange := &pluginpb.CodeGeneratorResponse{\n\t\tSupportedFeatures: proto.Uint64(uint64(pluginpb.CodeGeneratorResponse_FEATURE_SUPPORTS_EDITIONS)),\n\t\tMinimumEdition:    (*int32)(descriptorpb.Edition_EDITION_2024.Enum()),\n\t\tMaximumEdition:    (*int32)(descriptorpb.Edition_EDITION_2023.Enum()),\n\t}\n\n\t// Successful cases\n\ttestCheckRequiredFeatures(t, noRequiredFeatures, supportsNoFeatures, \"\", \"\")\n\ttestCheckRequiredFeatures(t, requiresProto3Optional, supportsBoth, \"\", \"\")\n\ttestCheckRequiredFeatures(t, requiresEditions, supportsBoth, \"\", \"\")\n\ttestCheckRequiredFeatures(t, requiresBoth, supportsBoth, \"\", \"\")\n\t// These are successful because we intentionally don't validate the editions range unless the\n\t// file uses editions. This is to work around known issue in older versions of plugins in protoc\n\t// from when editions were still experimental. These plugins advertise supported for plugins but\n\t// don't correctly set the min and max edition fields.\n\ttestCheckRequiredFeatures(t, noRequiredFeatures, supportsEditionsButNoRange, \"\", \"\")\n\ttestCheckRequiredFeatures(t, noRequiredFeatures, supportsEditionsButMalformedRange, \"\", \"\")\n\n\t// Error cases\n\ttestCheckRequiredFeatures(\n\t\tt,\n\t\trequiresProto3Optional,\n\t\tsupportsNoFeatures,\n\t\t`plugin \"test\" does not support required features.\n  Feature \"proto3 optional\" is required by 1 file(s):\n    proto3_optional.proto`,\n\t\t\"\", // No error expected\n\t)\n\ttestCheckRequiredFeatures(\n\t\tt,\n\t\trequiresEditions,\n\t\tsupportsNoFeatures,\n\t\t\"\", // No stderr expected\n\t\t`plugin \"test\" does not support feature \"supports editions\" which is required by \"editions.proto\"`,\n\t)\n\ttestCheckRequiredFeatures(\n\t\tt,\n\t\trequiresBoth,\n\t\tsupportsNoFeatures,\n\t\t`plugin \"test\" does not support required features.\n  Feature \"proto3 optional\" is required by 1 file(s):\n    proto3_optional.proto`,\n\t\t`plugin \"test\" does not support feature \"supports editions\" which is required by \"editions.proto\"`,\n\t)\n\ttestCheckRequiredFeatures(\n\t\tt,\n\t\trequiresEditions,\n\t\tsupportsEditionsButOutOfRange,\n\t\t\"\", // No stderr expected\n\t\t`plugin \"test\" does not support edition \"2023\" which is required by \"editions.proto\"`,\n\t)\n\ttestCheckRequiredFeatures(\n\t\tt,\n\t\trequiresEditions,\n\t\tsupportsEditionsButNoRange,\n\t\t\"\", // No stderr expected\n\t\t`plugin \"test\" advertises that it supports editions but did not indicate a minimum supported edition`,\n\t)\n\ttestCheckRequiredFeatures(\n\t\tt,\n\t\trequiresEditions,\n\t\tsupportsEditionsButMalformedRange,\n\t\t\"\", // No stderr expected\n\t\t`plugin \"test\" indicates a maximum supported edition (EDITION_2023) that is less than its minimum supported edition (EDITION_2024)`,\n\t)\n}\n\nfunc testCheckRequiredFeatures(\n\tt *testing.T,\n\timage bufimage.Image,\n\tcodeGenResponse *pluginpb.CodeGeneratorResponse,\n\texpectedStdErr string,\n\texpectedErr string,\n) {\n\tt.Helper()\n\trequired := computeRequiredFeatures(image)\n\tbuffer := bytes.NewBuffer(nil)\n\tlogger := slog.New(slog.NewTextHandler(buffer, &slog.HandlerOptions{}))\n\terr := checkRequiredFeatures(\n\t\tlogger,\n\t\trequired,\n\t\t[]*pluginpb.CodeGeneratorResponse{\n\t\t\tcodeGenResponse,\n\t\t\t// this makes sure we handle multiple responses; this one never fails\n\t\t\t{\n\t\t\t\tSupportedFeatures: proto.Uint64(math.MaxUint), // all features enabled\n\t\t\t\tMinimumEdition:    proto.Int32(0),\n\t\t\t\tMaximumEdition:    proto.Int32(int32(descriptorpb.Edition_EDITION_MAX)),\n\t\t\t},\n\t\t},\n\t\t[]bufconfig.GeneratePluginConfig{\n\t\t\tnewMockPluginConfig(\"test\"),\n\t\t\tnewMockPluginConfig(\"never_fails\"),\n\t\t},\n\t)\n\tif expectedStdErr != \"\" {\n\t\trequire.NotEmpty(t, buffer.String())\n\t} else {\n\t\trequire.Empty(t, buffer.String())\n\t}\n\tif expectedErr != \"\" {\n\t\trequire.ErrorContains(t, err, expectedErr)\n\t} else {\n\t\trequire.NoError(t, err)\n\t}\n}\n\nfunc makeImageNoRequiredFeatures(t *testing.T) bufimage.Image {\n\tt.Helper()\n\ttestFile, err := bufimage.NewImageFile(\n\t\t&descriptorpb.FileDescriptorProto{\n\t\t\tName:   proto.String(\"test.proto\"),\n\t\t\tSyntax: proto.String(\"proto3\"),\n\t\t\tDependency: []string{\n\t\t\t\t\"imported_editions.proto\",\n\t\t\t\t\"imported_proto3_optional.proto\",\n\t\t\t},\n\t\t},\n\t\tnil,\n\t\tuuid.UUID{},\n\t\t\"test.proto\",\n\t\t\"test.proto\",\n\t\tfalse,\n\t\tfalse,\n\t\t[]int32{0, 1},\n\t)\n\trequire.NoError(t, err)\n\t// Imported files can use features since we're not doing code gen for them.\n\timportedFileEditions := makeImageFileRequiresEditions(t, \"imported_editions.proto\", true)\n\timportedFileProto3Optional := makeImageFileRequiresProto3Optional(t, \"imported_proto3_optional.proto\", true)\n\timage, err := bufimage.NewImage([]bufimage.ImageFile{importedFileEditions, importedFileProto3Optional, testFile})\n\trequire.NoError(t, err)\n\treturn image\n}\n\nfunc makeImageRequiresProto3Optional(t *testing.T) bufimage.Image {\n\tt.Helper()\n\tproto3OptionalFile := makeImageFileRequiresProto3Optional(t, \"proto3_optional.proto\", false)\n\timage, err := bufimage.NewImage([]bufimage.ImageFile{proto3OptionalFile})\n\trequire.NoError(t, err)\n\treturn image\n}\n\nfunc makeImageRequiresEditions(t *testing.T) bufimage.Image {\n\tt.Helper()\n\teditionsFile := makeImageFileRequiresEditions(t, \"editions.proto\", false)\n\timage, err := bufimage.NewImage([]bufimage.ImageFile{editionsFile})\n\trequire.NoError(t, err)\n\treturn image\n}\n\nfunc makeImageRequiresBoth(t *testing.T) bufimage.Image {\n\tt.Helper()\n\teditionsFile := makeImageFileRequiresEditions(t, \"editions.proto\", false)\n\tproto3OptionalFile := makeImageFileRequiresProto3Optional(t, \"proto3_optional.proto\", false)\n\timage, err := bufimage.NewImage([]bufimage.ImageFile{editionsFile, proto3OptionalFile})\n\trequire.NoError(t, err)\n\treturn image\n}\n\nfunc makeImageFileRequiresProto3Optional(t *testing.T, name string, isImport bool) bufimage.ImageFile {\n\tt.Helper()\n\timageFile, err := bufimage.NewImageFile(\n\t\t&descriptorpb.FileDescriptorProto{\n\t\t\tSyntax: proto.String(\"proto3\"),\n\t\t\tName:   proto.String(name),\n\t\t\tMessageType: []*descriptorpb.DescriptorProto{\n\t\t\t\t{\n\t\t\t\t\tName: proto.String(\"Foo\"),\n\t\t\t\t\tField: []*descriptorpb.FieldDescriptorProto{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName:           proto.String(\"bar\"),\n\t\t\t\t\t\t\tLabel:          descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL.Enum(),\n\t\t\t\t\t\t\tType:           descriptorpb.FieldDescriptorProto_TYPE_STRING.Enum(),\n\t\t\t\t\t\t\tJsonName:       proto.String(\"bar\"),\n\t\t\t\t\t\t\tOneofIndex:     proto.Int32(0),\n\t\t\t\t\t\t\tProto3Optional: proto.Bool(true),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tOneofDecl: []*descriptorpb.OneofDescriptorProto{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName: proto.String(\"_bar\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tnil,\n\t\tuuid.UUID{},\n\t\tname,\n\t\tname,\n\t\tisImport,\n\t\tfalse,\n\t\tnil,\n\t)\n\trequire.NoError(t, err)\n\treturn imageFile\n}\n\nfunc makeImageFileRequiresEditions(t *testing.T, name string, isImport bool) bufimage.ImageFile {\n\tt.Helper()\n\timageFile, err := bufimage.NewImageFile(\n\t\t&descriptorpb.FileDescriptorProto{\n\t\t\tSyntax:  proto.String(\"editions\"),\n\t\t\tEdition: descriptorpb.Edition_EDITION_2023.Enum(),\n\t\t\tName:    proto.String(name),\n\t\t\tMessageType: []*descriptorpb.DescriptorProto{\n\t\t\t\t{\n\t\t\t\t\tName: proto.String(\"Bar\"),\n\t\t\t\t\tField: []*descriptorpb.FieldDescriptorProto{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName:     proto.String(\"baz\"),\n\t\t\t\t\t\t\tLabel:    descriptorpb.FieldDescriptorProto_LABEL_OPTIONAL.Enum(),\n\t\t\t\t\t\t\tType:     descriptorpb.FieldDescriptorProto_TYPE_STRING.Enum(),\n\t\t\t\t\t\t\tJsonName: proto.String(\"baz\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tnil,\n\t\tuuid.UUID{},\n\t\tname,\n\t\tname,\n\t\tisImport,\n\t\tfalse,\n\t\tnil,\n\t)\n\trequire.NoError(t, err)\n\treturn imageFile\n}\n\ntype mockPluginConfig struct {\n\tbufconfig.GeneratePluginConfig\n\n\tname string\n}\n\nfunc newMockPluginConfig(name string) bufconfig.GeneratePluginConfig {\n\treturn mockPluginConfig{name: name}\n}\n\nfunc (p mockPluginConfig) Name() string {\n\treturn p.name\n}\n"
