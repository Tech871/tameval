[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "ArduPilot/MethodicConfigurator"
sha = "8f14cac0abb19c133ba74e6693d4efb6385cb8f0"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "(pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=ardupilot_methodic_configurator/annotate_params.py -m pytest -q --junit-xml=test_output.xml tests/test_annotate_params.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target ardupilot_methodic_configurator.annotate_params --unit-test tests.test_annotate_params --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target ardupilot_methodic_configurator/annotate_params.py --unit-test tests/test_annotate_params.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 78.0
original_coverage = 81.0
mutation_kill_rate = 67.0
original_mutation_kill_rate = 74.0
covered_lines = [ 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 39, 40, 41, 44, 46, 47, 50, 51, 52, 57, 58, 62, 66, 72, 78, 85, 92, 99, 104, 112, 113, 116, 117, 119, 121, 124, 127, 128, 132, 134, 136, 139, 149, 150, 151, 153, 155, 156, 157, 159, 163, 164, 175, 176, 177, 178, 179, 180, 181, 182, 184, 186, 189, 192, 194, 200, 201, 202, 207, 208, 217, 220, 223, 226, 227, 229, 230, 231, 240, 241, 252, 254, 256, 257, 276, 277, 278, 279, 281, 282, 284, 285, 286, 287, 288, 289, 293, 295, 296, 297, 298, 299, 300, 302, 304, 305, 307, 308, 330, 331, 368, 382, 384, 386, 387, 388, 394, 396, 397, 400, 401, 402, 403, 404, 406, 407, 408, 409, 410, 414, 415, 417, 418, 419, 420, 421, 425, 426, 427, 428, 429, 430, 432, 433, 435, 436, 437, 443, 446, 447, 453, 455, 456, 459, 460, 463, 474, 486, 487, 488, 491, 503, 505, 508, 522, 525, 526, 527, 528, 529, 532, 534, 535, 536, 537, 538, 541, 543, 544, 545, 546, 547, 548, 549, 552, 557, 564, 567, 583, 585, 586, 589, 591, 595, 596, 597, 600, 602, 604, 605, 606, 607, 608, 609, 610, 612, 613, 615, 618, 620, 621, 622, 625, 628, 630, 633, 650, 651, 652, 654, 655, 656, 657, 658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 670, 698, 700, 701, 705, 706, 708, 709, 712, 713, 717, 718, 720, 725, 733, 735, 736, 737, 738, 739, 740, 741, 742, 743, 744, 745, 746, 748, 751, 752, 755, 756, 757, 758, 759, 760, 763, 764, 765, 766, 769, 770, 771, 772, 774, 775, 777, 780, 783, 784, 787, 795, 796, 797, 798, 801, 805, 806, 818, 819, 820, 821, 822, 824, 825, 826, 827, 830, 833, 837, 838, 839, 840, 841, 843, 865, 866, 867, 870,]
missed_lines = [ 122, 129, 130, 131, 161, 183, 185, 187, 188, 191, 195, 196, 198, 199, 203, 204, 205, 218, 219, 221, 222, 224, 225, 228, 232, 233, 234, 235, 236, 237, 238, 320, 321, 322, 324, 325, 326, 327, 328, 346, 347, 349, 352, 353, 356, 359, 360, 361, 362, 363, 364, 365, 390, 391, 411, 412, 413, 422, 423, 424, 438, 439, 440, 457, 464, 466, 467, 468, 469, 470, 471, 530, 703, 714, 761, 762, 802, 834, 846, 847, 850, 851, 854, 855, 856, 857, 858, 859, 863, 871,]

[input_info]
test_file_path = "tests/test_annotate_params.py"
focal_file_path = "ardupilot_methodic_configurator/annotate_params.py"
test_file_url = "https://github.com/ArduPilot/MethodicConfigurator/blob/8f14cac0abb19c133ba74e6693d4efb6385cb8f0/tests/test_annotate_params.py"
focal_file_url = "https://github.com/ArduPilot/MethodicConfigurator/blob/8f14cac0abb19c133ba74e6693d4efb6385cb8f0/ardupilot_methodic_configurator/annotate_params.py"
first_commit_date = "2024-12-02"
last_commit_date = "2025-06-24"
test_file_content = "#!/usr/bin/python3\n\n\"\"\"\nTests for the annotate_params.py script.\n\nThese are the unit tests for the python script that fetches online ArduPilot\nparameter documentation (if not cached) and adds it to the specified file or\nto all *.param and *.parm files in the specified directory.\n\nSPDX-FileCopyrightText: 2024-2025 Amilcar do Carmo Lucas <amilcar.lucas@iav.de>\n\nSPDX-License-Identifier: GPL-3.0-or-later\n\"\"\"\n\nimport contextlib\nimport os\nimport tempfile\nimport unittest\nfrom unittest import mock\nfrom unittest.mock import patch\nfrom xml.etree import ElementTree as ET  # no parsing, just data-structure manipulation\n\nimport pytest\nimport requests  # type: ignore[import-untyped]\nfrom defusedxml import ElementTree as DET  # noqa: N814, just parsing, no data-structure manipulation\n\nfrom ardupilot_methodic_configurator.annotate_params import (\n    BASE_URL,\n    PARAM_DEFINITION_XML_FILE,\n    Par,\n    create_doc_dict,\n    extract_parameter_name_and_validate,\n    format_columns,\n    get_xml_data,\n    get_xml_url,\n    main,\n    parse_arguments,\n    print_read_only_params,\n    remove_prefix,\n    split_into_lines,\n    update_parameter_documentation,\n)\n\n\n@pytest.fixture\ndef mock_update() -> mock.Mock:\n    with patch(\"ardupilot_methodic_configurator.annotate_params.update_parameter_documentation\") as mock_fun:\n        yield mock_fun\n\n\n@pytest.fixture\ndef mock_get_xml_dir() -> mock.Mock:\n    with patch(\"ardupilot_methodic_configurator.annotate_params.get_xml_dir\") as mock_fun:\n        yield mock_fun\n\n\n@pytest.fixture\ndef mock_get_xml_url() -> mock.Mock:\n    with patch(\"ardupilot_methodic_configurator.annotate_params.get_xml_url\") as mock_fun:\n        yield mock_fun\n\n\nclass TestParamDocsUpdate(unittest.TestCase):  # pylint: disable=missing-class-docstring, too-many-public-methods\n    def setUp(self) -> None:\n        # Create a temporary directory\n        self.temp_dir = tempfile.mkdtemp()\n\n        # Create a temporary file\n        # pylint: disable=consider-using-with\n        self.temp_file = tempfile.NamedTemporaryFile(delete=False)  # noqa: SIM115\n        # pylint: enable=consider-using-with\n\n        # Create a dictionary of parameter documentation\n        self.doc_dict = {\n            \"PARAM1\": {\n                \"humanName\": \"Param 1\",\n                \"documentation\": [\"Documentation for Param 1\"],\n                \"fields\": {\"Field1\": \"Value1\", \"Field2\": \"Value2\"},\n                \"values\": {\"Code1\": \"Value1\", \"Code2\": \"Value2\"},\n            },\n            \"PARAM2\": {\n                \"humanName\": \"Param 2\",\n                \"documentation\": [\"Documentation for Param 2\"],\n                \"fields\": {\"Field3\": \"Value3\", \"Field4\": \"Value4\"},\n                \"values\": {\"Code3\": \"Value3\", \"Code4\": \"Value4\"},\n            },\n            \"PARAM_1\": {\n                \"humanName\": \"Param _ 1\",\n                \"documentation\": [\"Documentation for Param_1\"],\n                \"fields\": {\"Field_1\": \"Value_1\", \"Field_2\": \"Value_2\"},\n                \"values\": {\"Code_1\": \"Value_1\", \"Code_2\": \"Value_2\"},\n            },\n        }\n\n    @patch(\"builtins.open\", new_callable=mock.mock_open, read_data=\"<root></root>\")\n    @patch(\"os.path.isfile\")\n    @patch(\"ardupilot_methodic_configurator.annotate_params.Par.load_param_file_into_dict\")\n    def test_get_xml_data_local_file(self, mock_load_param, mock_isfile, mock_open_) -> None:\n        # Mock the isfile function to return True\n        mock_isfile.return_value = True\n\n        # Mock the load_param_file_into_dict function to raise FileNotFoundError\n        mock_load_param.side_effect = FileNotFoundError\n\n        # Call the function with a local file\n        result = get_xml_data(\"/path/to/local/file/\", \".\", \"test.xml\", \"ArduCopter\")\n\n        # Check the result\n        assert isinstance(result, ET.Element)\n\n        # Assert that the file was opened correctly\n        mock_open_.assert_called_once_with(os.path.join(\".\", \"test.xml\"), encoding=\"utf-8\")\n\n    @patch(\"requests.get\")\n    def test_get_xml_data_remote_file(self, mock_get) -> None:\n        # Mock the response\n        mock_get.return_value.status_code = 200\n        mock_get.return_value.text = \"<root></root>\"\n\n        # Remove the test.xml file if it exists\n        with contextlib.suppress(FileNotFoundError):\n            os.remove(\"test.xml\")\n\n        # Call the function with a remote file\n        result = get_xml_data(\"http://example.com/\", \".\", \"test.xml\", \"ArduCopter\")\n\n        # Check the result\n        assert isinstance(result, ET.Element)\n\n        # Assert that the requests.get function was called once\n        mock_get.assert_called_once_with(\"http://example.com/test.xml\", timeout=5)\n\n    @patch(\"os.path.isfile\")\n    @patch(\"ardupilot_methodic_configurator.annotate_params.Par.load_param_file_into_dict\")\n    def test_get_xml_data_script_dir_file(self, mock_load_param, mock_isfile) -> None:\n        # Mock the isfile function to return False for the current directory and True for the script directory\n        def side_effect(_filename) -> bool:\n            return True\n\n        mock_isfile.side_effect = side_effect\n\n        # Mock the load_param_file_into_dict function to raise FileNotFoundError\n        mock_load_param.side_effect = FileNotFoundError\n\n        # Mock the open function to return a dummy XML string\n        mock_open = mock.mock_open(read_data=\"<root></root>\")\n        with patch(\"builtins.open\", mock_open):\n            # Call the function with a filename that exists in the script directory\n            result = get_xml_data(BASE_URL, \".\", PARAM_DEFINITION_XML_FILE, \"ArduCopter\")\n\n        # Check the result\n        assert isinstance(result, ET.Element)\n\n        # Assert that the file was opened correctly\n        mock_open.assert_called_once_with(os.path.join(\".\", PARAM_DEFINITION_XML_FILE), encoding=\"utf-8\")\n\n    def test_get_xml_data_no_requests_package(self) -> None:\n        # Temporarily remove the requests module\n        with patch.dict(\"sys.modules\", {\"requests\": None}):\n            # Remove the test.xml file if it exists\n            with contextlib.suppress(FileNotFoundError):\n                os.remove(\"test.xml\")\n\n            # Call the function with a remote file\n            with pytest.raises(SystemExit):\n                get_xml_data(\"http://example.com/\", \".\", \"test.xml\", \"ArduCopter\")\n\n    @patch(\"requests.get\")\n    def test_get_xml_data_request_failure(self, mock_get) -> None:\n        # Mock the response\n        mock_get.side_effect = requests.exceptions.RequestException\n\n        # Remove the test.xml file if it exists\n        with contextlib.suppress(FileNotFoundError):\n            os.remove(\"test.xml\")\n\n        # Call the function with a remote file\n        with pytest.raises(SystemExit):\n            get_xml_data(\"http://example.com/\", \".\", \"test.xml\", \"ArduCopter\")\n\n    @patch(\"requests.get\")\n    def test_get_xml_data_valid_xml(self, mock_get) -> None:\n        # Mock the response\n        mock_get.return_value.status_code = 200\n        mock_get.return_value.text = \"<root></root>\"\n\n        # Call the function with a remote file\n        result = get_xml_data(\"http://example.com/\", \".\", \"test.xml\", \"ArduCopter\")\n\n        # Check the result\n        assert isinstance(result, ET.Element)\n\n    @patch(\"requests.get\")\n    def test_get_xml_data_invalid_xml(self, mock_get) -> None:\n        # Mock the response\n        mock_get.return_value.status_code = 200\n        mock_get.return_value.text = \"<root><invalid></root>\"\n\n        # Remove the test.xml file if it exists\n        with contextlib.suppress(FileNotFoundError):\n            os.remove(\"test.xml\")\n\n        # Call the function with a remote file\n        with pytest.raises(ET.ParseError):\n            get_xml_data(\"http://example.com/\", \".\", \"test.xml\", \"ArduCopter\")\n\n    @patch(\"requests.get\")\n    @patch(\"os.path.isfile\")\n    def test_get_xml_data_missing_file(self, mock_isfile, mock_get) -> None:\n        # Mock the isfile function to return False\n        mock_isfile.return_value = False\n        # Mock the requests.get call to raise FileNotFoundError\n        mock_get.side_effect = FileNotFoundError\n\n        # Remove the test.xml file if it exists\n        with contextlib.suppress(FileNotFoundError):\n            os.remove(\"test.xml\")\n\n        # Call the function with a local file\n        with pytest.raises(FileNotFoundError):\n            get_xml_data(\"/path/to/local/file/\", \".\", \"test.xml\", \"ArduCopter\")\n\n    @patch(\"requests.get\")\n    def test_get_xml_data_network_issue(self, mock_get) -> None:\n        # Mock the response\n        mock_get.side_effect = requests.exceptions.ConnectionError\n\n        # Call the function with a remote file\n        with pytest.raises(SystemExit):\n            get_xml_data(\"http://example.com/\", \".\", \"test.xml\", \"ArduCopter\")\n\n    def test_remove_prefix(self) -> None:\n        # Test case 1: Normal operation\n        assert remove_prefix(\"prefix_test\", \"prefix_\") == \"test\"\n\n        # Test case 2: Prefix not present\n        assert remove_prefix(\"test\", \"prefix_\") == \"test\"\n\n        # Test case 3: Empty string\n        assert remove_prefix(\"\", \"prefix_\") == \"\"\n\n    def test_split_into_lines(self) -> None:\n        # Test case 1: Normal operation\n        string_to_split = \"This is a test string. It should be split into several lines.\"\n        maximum_line_length = 12\n        expected_output = [\"This is a\", \"test string.\", \"It should be\", \"split into\", \"several\", \"lines.\"]\n        assert split_into_lines(string_to_split, maximum_line_length) == expected_output\n\n        # Test case 2: String shorter than maximum line length\n        string_to_split = \"Short\"\n        maximum_line_length = 10\n        expected_output = [\"Short\"]\n        assert split_into_lines(string_to_split, maximum_line_length) == expected_output\n\n        # Test case 3: Empty string\n        string_to_split = \"\"\n        maximum_line_length = 10\n        expected_output = []\n        assert split_into_lines(string_to_split, maximum_line_length) == expected_output\n\n    def test_create_doc_dict(self) -> None:\n        # Mock XML data\n        xml_data = \"\"\"\n        <root>\n            <param name=\"PARAM1\" humanName=\"Param 1\" documentation=\"Documentation for Param 1\">\n                <field name=\"Field1\">Value1</field>\n                <field name=\"Field2\">Value2</field>\n                <values>\n                    <value code=\"Code1\">Value1</value>\n                    <value code=\"Code2\">Value2</value>\n                </values>\n            </param>\n            <param name=\"PARAM2\" humanName=\"Param 2\" documentation=\"Documentation for Param 2\">\n                <field name=\"Units\">m/s</field>\n                <field name=\"UnitText\">meters per second</field>\n                <values>\n                    <value code=\"Code3\">Value3</value>\n                    <value code=\"Code4\">Value4</value>\n                </values>\n            </param>\n        </root>\n        \"\"\"\n        root = DET.fromstring(xml_data)\n\n        # Expected output\n        expected_output = {\n            \"PARAM1\": {\n                \"humanName\": \"Param 1\",\n                \"documentation\": [\"Documentation for Param 1\"],\n                \"fields\": {\"Field1\": \"Value1\", \"Field2\": \"Value2\"},\n                \"values\": {\"Code1\": \"Value1\", \"Code2\": \"Value2\"},\n            },\n            \"PARAM2\": {\n                \"humanName\": \"Param 2\",\n                \"documentation\": [\"Documentation for Param 2\"],\n                \"fields\": {\"Units\": \"m/s (meters per second)\"},\n                \"values\": {\"Code3\": \"Value3\", \"Code4\": \"Value4\"},\n            },\n        }\n\n        # Call the function with the mock XML data\n        result = create_doc_dict(root, \"VehicleType\")\n\n        # Check the result\n        assert result == expected_output\n\n    def test_format_columns(self) -> None:\n        # Define the input\n        values = {\n            \"Key1\": \"Value1\",\n            \"Key2\": \"Value2\",\n            \"Key3\": \"Value3\",\n            \"Key4\": \"Value4\",\n            \"Key5\": \"Value5\",\n            \"Key6\": \"Value6\",\n            \"Key7\": \"Value7\",\n            \"Key8\": \"Value8\",\n            \"Key9\": \"Value9\",\n            \"Key10\": \"Value10\",\n            \"Key11\": \"Value11\",\n            \"Key12\": \"Value12\",\n        }\n\n        # Define the expected output\n        expected_output = [\n            \"Key1: Value1                                         Key7: Value7\",\n            \"Key2: Value2                                         Key8: Value8\",\n            \"Key3: Value3                                         Key9: Value9\",\n            \"Key4: Value4                                         Key10: Value10\",\n            \"Key5: Value5                                         Key11: Value11\",\n            \"Key6: Value6                                         Key12: Value12\",\n        ]\n\n        # Call the function with the input\n        result = format_columns(values)\n\n        # Check the result\n        assert result == expected_output\n\n        assert not format_columns({})\n\n    def test_update_parameter_documentation(self) -> None:\n        # Write some initial content to the temporary file\n        with open(self.temp_file.name, \"w\", encoding=\"utf-8\") as file:\n            file.write(\"PARAM1 100\\n\")\n\n        # Call the function with the temporary file\n        update_parameter_documentation(self.doc_dict, self.temp_file.name)\n\n        # Read the updated content from the temporary file\n        with open(self.temp_file.name, encoding=\"utf-8\") as file:\n            updated_content = file.read()\n\n        # Check if the file has been updated correctly\n        assert \"Param 1\" in updated_content\n        assert \"Documentation for Param 1\" in updated_content\n        assert \"Field1: Value1\" in updated_content\n        assert \"Field2: Value2\" in updated_content\n        assert \"Code1: Value1\" in updated_content\n        assert \"Code2: Value2\" in updated_content\n\n    def test_update_parameter_documentation_sorting_none(self) -> None:\n        # Write some initial content to the temporary file\n        # With stray leading and trailing whitespaces\n        with open(self.temp_file.name, \"w\", encoding=\"utf-8\") as file:\n            file.write(\"PARAM2 100\\n PARAM_1 100 \\nPARAM3 3\\nPARAM4 4\\nPARAM5 5\\nPARAM1 100\\n\")\n\n        # Call the function with the temporary file\n        update_parameter_documentation(self.doc_dict, self.temp_file.name)\n\n        # Read the updated content from the temporary file\n        with open(self.temp_file.name, encoding=\"utf-8\") as file:\n            updated_content = file.read()\n\n        expected_content = \"\"\"# Param 2\n# Documentation for Param 2\n# Field3: Value3\n# Field4: Value4\n# Code3: Value3\n# Code4: Value4\nPARAM2 100\n\n# Param _ 1\n# Documentation for Param_1\n# Field_1: Value_1\n# Field_2: Value_2\n# Code_1: Value_1\n# Code_2: Value_2\nPARAM_1 100\nPARAM3 3\nPARAM4 4\nPARAM5 5\n\n# Param 1\n# Documentation for Param 1\n# Field1: Value1\n# Field2: Value2\n# Code1: Value1\n# Code2: Value2\nPARAM1 100\n\"\"\"\n        assert updated_content == expected_content\n\n    def test_update_parameter_documentation_sorting_missionplanner(self) -> None:\n        # Write some initial content to the temporary file\n        with open(self.temp_file.name, \"w\", encoding=\"utf-8\") as file:\n            file.write(\"PARAM2 100 # ignore, me\\nPARAM_1\\t100\\nPARAM1,100\\n\")\n\n        # Call the function with the temporary file\n        update_parameter_documentation(self.doc_dict, self.temp_file.name, \"missionplanner\")\n\n        # Read the updated content from the temporary file\n        with open(self.temp_file.name, encoding=\"utf-8\") as file:\n            updated_content = file.read()\n\n        expected_content = \"\"\"# Param _ 1\n# Documentation for Param_1\n# Field_1: Value_1\n# Field_2: Value_2\n# Code_1: Value_1\n# Code_2: Value_2\nPARAM_1\\t100\n\n# Param 1\n# Documentation for Param 1\n# Field1: Value1\n# Field2: Value2\n# Code1: Value1\n# Code2: Value2\nPARAM1,100\n\n# Param 2\n# Documentation for Param 2\n# Field3: Value3\n# Field4: Value4\n# Code3: Value3\n# Code4: Value4\nPARAM2 100 # ignore, me\n\"\"\"\n        assert updated_content == expected_content\n\n    def test_update_parameter_documentation_sorting_mavproxy(self) -> None:\n        # Write some initial content to the temporary file\n        with open(self.temp_file.name, \"w\", encoding=\"utf-8\") as file:\n            file.write(\"PARAM2 100\\nPARAM_1\\t100\\nPARAM1,100\\n\")\n\n        # Call the function with the temporary file\n        update_parameter_documentation(self.doc_dict, self.temp_file.name, \"mavproxy\")\n\n        # Read the updated content from the temporary file\n        with open(self.temp_file.name, encoding=\"utf-8\") as file:\n            updated_content = file.read()\n\n        expected_content = \"\"\"# Param 1\n# Documentation for Param 1\n# Field1: Value1\n# Field2: Value2\n# Code1: Value1\n# Code2: Value2\nPARAM1,100\n\n# Param 2\n# Documentation for Param 2\n# Field3: Value3\n# Field4: Value4\n# Code3: Value3\n# Code4: Value4\nPARAM2 100\n\n# Param _ 1\n# Documentation for Param_1\n# Field_1: Value_1\n# Field_2: Value_2\n# Code_1: Value_1\n# Code_2: Value_2\nPARAM_1\\t100\n\"\"\"\n        assert updated_content == expected_content\n\n    def test_update_parameter_documentation_invalid_line_format(self) -> None:\n        # Write some initial content to the temporary file with an invalid line format\n        with open(self.temp_file.name, \"w\", encoding=\"utf-8\") as file:\n            file.write(\"%INVALID_LINE_FORMAT\\n\")\n\n        # Call the function with the temporary file\n        with pytest.raises(SystemExit) as cm:\n            update_parameter_documentation(self.doc_dict, self.temp_file.name)\n\n        # Check if the SystemExit exception contains the expected message\n        assert cm.value.code == \"Invalid line in input file\"\n\n    @patch(\"logging.Logger.info\")\n    def test_print_read_only_params(self, mock_info) -> None:\n        # Mock XML data\n        xml_data = \"\"\"\n        <root>\n            <param name=\"PARAM1\" humanName=\"Param 1\" documentation=\"Documentation for Param 1\">\n                <field name=\"ReadOnly\">True</field>\n                <field name=\"Field1\">Value1</field>\n                <field name=\"Field2\">Value2</field>\n                <values>\n                    <value code=\"Code1\">Value1</value>\n                    <value code=\"Code2\">Value2</value>\n                </values>\n            </param>\n            <param name=\"PARAM2\" humanName=\"Param 2\" documentation=\"Documentation for Param 2\">\n                <field name=\"Field3\">Value3</field>\n                <field name=\"Field4\">Value4</field>\n                <values>\n                    <value code=\"Code3\">Value3</value>\n                    <value code=\"Code4\">Value4</value>\n                </values>\n            </param>\n        </root>\n        \"\"\"\n        root = DET.fromstring(xml_data)\n        doc_dict = create_doc_dict(root, \"VehicleType\")\n\n        # Call the function with the mock XML data\n        print_read_only_params(doc_dict)\n\n        # Check if the parameter name was logged\n        mock_info.assert_has_calls([mock.call(\"ReadOnly parameters:\"), mock.call(\"PARAM1\")])\n\n    def test_update_parameter_documentation_invalid_target(self) -> None:\n        with pytest.raises(ValueError, match=\"Target 'invalid_target' is neither a file nor a directory.\"):\n            update_parameter_documentation(self.doc_dict, \"invalid_target\")\n\n    def test_invalid_parameter_name(self) -> None:\n        # Write some initial content to the temporary file\n        with open(self.temp_file.name, \"w\", encoding=\"utf-8\") as file:\n            file.write(\"INVALID_$PARAM 100\\n\")\n\n        # Call the function with the temporary file\n        with pytest.raises(SystemExit):\n            update_parameter_documentation(self.doc_dict, self.temp_file.name)\n\n    def test_update_parameter_documentation_too_long_parameter_name(self) -> None:\n        # Write some initial content to the temporary file\n        with open(self.temp_file.name, \"w\", encoding=\"utf-8\") as file:\n            file.write(\"TOO_LONG_PARAMETER_NAME 100\\n\")\n\n        # Call the function with the temporary file\n        with pytest.raises(SystemExit):\n            update_parameter_documentation(self.doc_dict, self.temp_file.name)\n\n    @patch(\"logging.Logger.warning\")\n    def test_missing_parameter_documentation(self, mock_warning) -> None:\n        # Write some initial content to the temporary file\n        with open(self.temp_file.name, \"w\", encoding=\"utf-8\") as file:\n            file.write(\"MISSING_DOC_PARA 100\\n\")\n\n        # Call the function with the temporary file\n        update_parameter_documentation(self.doc_dict, self.temp_file.name)\n\n        # Check if the warnings were logged\n        mock_warning.assert_has_calls(\n            [\n                mock.call(\"Read file %s with %d parameters, but only %s of which got documented\", self.temp_file.name, 1, 0),\n                mock.call(\"No documentation found for: %s\", \"MISSING_DOC_PARA\"),\n            ]\n        )\n\n    def test_empty_parameter_file(self) -> None:\n        # Call the function with the temporary file\n        update_parameter_documentation(self.doc_dict, self.temp_file.name)\n\n        # Read the updated content from the temporary file\n        with open(self.temp_file.name, encoding=\"utf-8\") as file:\n            updated_content = file.read()\n\n        # Check if the file is still empty\n        assert updated_content == \"\"\n\n    def test_get_xml_url_valid_vehicles(self) -> None:\n        \"\"\"Test get_xml_url with all valid vehicle types.\"\"\"\n        vehicle_types = [\"ArduCopter\", \"ArduPlane\", \"Rover\", \"ArduSub\", \"AntennaTracker\", \"AP_Periph\", \"Blimp\", \"Heli\", \"SITL\"]\n        for vehicle in vehicle_types:\n            url = get_xml_url(vehicle, \"4.3\")\n            assert url.startswith(BASE_URL)\n            assert \"stable-4.3\" in url\n            assert url.endswith(\"/\")\n\n    def test_get_xml_url_invalid_vehicle(self) -> None:\n        \"\"\"Test get_xml_url with invalid vehicle type.\"\"\"\n        with pytest.raises(ValueError, match=\"Vehicle type 'InvalidVehicle' is not supported.\"):\n            get_xml_url(\"InvalidVehicle\", \"4.3\")\n\n    def test_split_into_lines_edge_cases(self) -> None:\n        \"\"\"Test split_into_lines with edge cases.\"\"\"\n        # Test with various line lengths\n        # Function will return largest possible chunks based on max length\n        assert split_into_lines(\"a b c\", 2) == [\"a\", \"b\", \"c\"]\n        assert split_into_lines(\"\", 10) == []\n\n    def test_format_columns_edge_cases(self) -> None:\n        \"\"\"Test format_columns with edge cases.\"\"\"\n        # Empty dictionary\n        assert not format_columns({})\n\n        # Single item\n        assert format_columns({\"Key\": \"Value\"}) == [\"Key: Value\"]\n\n        # Test with different max widths\n        values = {\"K1\": \"V1\", \"K2\": \"V2\"}\n        assert len(format_columns(values, max_width=20)[0]) <= 20\n\n        # Test with many columns\n        many_values = {f\"Key{i}\": f\"Value{i}\" for i in range(20)}\n        result = format_columns(many_values, max_width=200, max_columns=5)\n        assert all(len(line) <= 200 for line in result)\n\n    def test_create_doc_dict_edge_cases(self) -> None:\n        \"\"\"Test create_doc_dict with edge cases.\"\"\"\n        # Test with empty XML\n        empty_root = ET.Element(\"root\")\n        assert not create_doc_dict(empty_root, \"ArduCopter\")\n\n        # Test with missing attributes\n        param = ET.SubElement(empty_root, \"param\")\n        assert not create_doc_dict(empty_root, \"ArduCopter\")\n\n        # Test with minimal valid param\n        param.set(\"name\", \"TEST_PARAM\")\n        param.set(\"humanName\", \"Test Parameter\")\n        param.set(\"documentation\", \"Test documentation\")\n        doc_dict = create_doc_dict(empty_root, \"ArduCopter\")\n        assert \"TEST_PARAM\" in doc_dict\n        assert doc_dict[\"TEST_PARAM\"][\"humanName\"] == \"Test Parameter\"\n\n    @patch(\"os.path.isfile\")\n    def test_update_parameter_documentation_sorting(self, mock_isfile) -> None:\n        \"\"\"Test parameter sorting in update_parameter_documentation.\"\"\"\n        # Mock file existence check\n        mock_isfile.return_value = True\n\n        test_content = \"PARAM_Z 100\\nPARAM_A 200\\nPARAM_M 300\\n\"\n\n        # Create a real temporary file for testing\n        with tempfile.NamedTemporaryFile(mode=\"w\", delete=False) as temp_file:\n            temp_file.write(test_content)\n            temp_file_name = temp_file.name\n\n        doc = {\n            \"PARAM_Z\": {\"humanName\": \"Z\", \"documentation\": [\"Z doc\"], \"fields\": {}, \"values\": {}},\n            \"PARAM_A\": {\"humanName\": \"A\", \"documentation\": [\"A doc\"], \"fields\": {}, \"values\": {}},\n            \"PARAM_M\": {\"humanName\": \"M\", \"documentation\": [\"M doc\"], \"fields\": {}, \"values\": {}},\n        }\n\n        try:\n            # Test MissionPlanner sorting\n            update_parameter_documentation(doc, temp_file_name, \"missionplanner\")\n\n            with open(temp_file_name, encoding=\"utf-8\") as f:\n                content = f.read()\n\n            # Verify content and order\n            assert \"PARAM_A\" in content\n            assert \"PARAM_M\" in content\n            assert \"PARAM_Z\" in content\n            assert content.index(\"PARAM_A\") < content.index(\"PARAM_M\") < content.index(\"PARAM_Z\")\n\n            # Test MAVProxy sorting\n            # Reset file content\n            with open(temp_file_name, \"w\", encoding=\"utf-8\") as f:\n                f.write(test_content)\n\n            update_parameter_documentation(doc, temp_file_name, \"mavproxy\")\n\n            with open(temp_file_name, encoding=\"utf-8\") as f:\n                content = f.read()\n\n            # Verify content for MAVProxy format\n            assert \"PARAM_A\" in content\n            assert \"PARAM_M\" in content\n            assert \"PARAM_Z\" in content\n\n        finally:\n            # Clean up\n            os.unlink(temp_file_name)\n\n    def test_extract_parameter_name_and_validate_invalid_cases(self) -> None:\n        \"\"\"Test parameter name validation with invalid cases.\"\"\"\n        # Test invalid parameter name pattern\n        with pytest.raises(SystemExit):\n            extract_parameter_name_and_validate(\"invalid_param 100\", \"test.param\", 1)\n\n        # Test too long parameter name\n        with pytest.raises(SystemExit):\n            extract_parameter_name_and_validate(\"VERY_LONG_PARAMETER_NAME_THAT_EXCEEDS_LIMIT 100\", \"test.param\", 1)\n\n        # Test invalid separator\n        with pytest.raises(SystemExit):\n            extract_parameter_name_and_validate(\"PARAM:100\", \"test.param\", 1)\n\n    def test_par_class_methods(self) -> None:\n        \"\"\"Test Par class methods.\"\"\"\n        # Test equality\n        par1 = Par(100.0, \"comment1\")\n        par2 = Par(100.0, \"comment1\")\n        par3 = Par(200.0, \"comment2\")\n\n        assert par1 == par2\n        assert par1 != par3\n        assert par1 != \"not a Par object\"\n\n        # Test load_param_file with invalid values\n        with tempfile.NamedTemporaryFile(mode=\"w\", delete=False) as tf:\n            tf.write(\"PARAM1 invalid_value\\n\")\n            tf.flush()\n\n            with pytest.raises(SystemExit):\n                Par.load_param_file_into_dict(tf.name)\n\n    def test_format_params_methods(self) -> None:\n        \"\"\"Test Par.format_params method.\"\"\"\n        param_dict = {\"PARAM1\": Par(100.0, \"comment1\"), \"PARAM2\": Par(200.0), \"PARAM3\": 300.0}\n\n        # Test MissionPlanner format\n        mp_format = Par.format_params(param_dict, \"missionplanner\")\n        assert any(\"PARAM1,100\" in line for line in mp_format)\n        assert any(\"# comment1\" in line for line in mp_format)\n\n        # Test MAVProxy format\n        mavproxy_format = Par.format_params(param_dict, \"mavproxy\")\n        # Use correct spacing format - 16 chars for name, 8 for value\n        assert any(\"PARAM1           100.000000\" in line for line in mavproxy_format)\n        assert any(\"# comment1\" in line for line in mavproxy_format)\n\n        # Test invalid format\n        with pytest.raises(SystemExit):\n            Par.format_params(param_dict, \"invalid_format\")\n\n\nclass AnnotateParamsTest(unittest.TestCase):\n    \"\"\"Test annotate parameters.\"\"\"\n\n    def test_arg_parser_valid_arguments(self) -> None:\n        test_args = [\"annotate_params\", \"--vehicle-type\", \"ArduCopter\", \"--sort\", \"none\", \"parameters\"]\n        with patch(\"sys.argv\", test_args):\n            args = parse_arguments()\n            assert args.vehicle_type == \"ArduCopter\"\n            assert args.sort == \"none\"\n            assert args.target == \"parameters\"\n            assert args.verbose is False\n            assert args.max_line_length == 100\n\n    def test_arg_parser_invalid_vehicle_type(self) -> None:\n        test_args = [\"annotate_params\", \"--vehicle-type\", \"InvalidType\", \"--sort\", \"none\", \"parameters\"]\n        with patch(\"sys.argv\", test_args), pytest.raises(SystemExit):\n            parse_arguments()\n\n    def test_arg_parser_invalid_sort_option(self) -> None:\n        test_args = [\"annotate_params\", \"--vehicle-type\", \"ArduCopter\", \"--sort\", \"invalid\", \"parameters\"]\n        with patch(\"sys.argv\", test_args), pytest.raises(SystemExit):\n            parse_arguments()\n\n    def test_arg_parser_invalid_line_length_option(self) -> None:\n        test_args = [\"annotate_params\", \"--vehicle-type\", \"ArduCopter\", \"--sort\", \"none\", \"-m\", \"invalid\", \"parameters\"]\n        with patch(\"sys.argv\", test_args), pytest.raises(SystemExit):\n            parse_arguments()\n\n\nclass TestAnnotateParamsExceptionHandling(unittest.TestCase):\n    \"\"\"Test parameter exception handling.\"\"\"\n\n    @pytest.mark.usefixtures(\"mock_update\", \"mock_get_xml_dir\", \"mock_get_xml_url\")\n    @patch(\"builtins.open\", new_callable=mock.mock_open)\n    def test_main_ioerror(self, mock_file) -> None:\n        with patch(\"ardupilot_methodic_configurator.annotate_params.parse_arguments\") as mock_arg_parser:\n            mock_arg_parser.return_value = mock.Mock(\n                vehicle_type=\"ArduCopter\",\n                firmware_version=\"4.0\",\n                target=\".\",\n                sort=\"none\",\n                delete_documentation_annotations=False,\n                verbose=False,\n            )\n            mock_file.side_effect = OSError(\"Mocked IO Error\")\n\n            with pytest.raises(SystemExit) as cm:\n                main()\n\n            assert cm.value.code in [1, 2]\n\n    @pytest.mark.usefixtures(\"mock_update\", \"mock_get_xml_dir\", \"mock_get_xml_url\")\n    @patch(\"builtins.open\", new_callable=mock.mock_open)\n    def test_main_oserror(self, mock_file) -> None:\n        with patch(\"ardupilot_methodic_configurator.annotate_params.parse_arguments\") as mock_arg_parser:\n            mock_arg_parser.return_value = mock.Mock(\n                vehicle_type=\"ArduCopter\",\n                firmware_version=\"4.0\",\n                target=\".\",\n                sort=\"none\",\n                delete_documentation_annotations=False,\n                verbose=False,\n            )\n            mock_file.side_effect = OSError(\"Mocked OS Error\")\n\n            with pytest.raises(SystemExit) as cm:\n                main()\n\n            assert cm.value.code in [1, 2]\n\n    @patch(\"ardupilot_methodic_configurator.annotate_params.get_xml_url\")\n    def test_get_xml_url_exception(self, mock_get_xml_url_) -> None:\n        mock_get_xml_url_.side_effect = ValueError(\"Mocked Value Error\")\n        with pytest.raises(ValueError, match=\"Vehicle type 'NonExistingVehicle' is not supported.\"):  # noqa: PT012\n            get_xml_url(\"NonExistingVehicle\", \"4.0\")\n\n            @patch(\"requests.get\")\n            def test_get_xml_data_remote_file(mock_get) -> None:\n                \"\"\"Test fetching XML data from remote file.\"\"\"\n                # Mock the response\n                mock_get.return_value.status_code = 200\n                mock_get.return_value.text = \"<root></root>\"\n\n                # Remove the test.xml file if it exists\n                with contextlib.suppress(FileNotFoundError):\n                    os.remove(\"test.xml\")\n\n                # Call the function with a remote file\n                result = get_xml_data(\"http://example.com/\", \".\", \"test.xml\", \"ArduCopter\")\n\n                # Check the result\n                assert isinstance(result, ET.Element)\n\n                # Assert that requests.get was called once with correct parameters including proxies\n                mock_get.assert_called_once_with(\"http://example.com/test.xml\", timeout=5, proxies=None)\n\n            @patch(\"requests.get\")\n            def test_get_xml_data_remote_file_with_proxies(mock_get) -> None:\n                \"\"\"Test fetching XML data with proxy configuration.\"\"\"\n                # Mock environment variables\n                with patch.dict(\n                    os.environ,\n                    {\"HTTP_PROXY\": \"http://proxy:8080\", \"HTTPS_PROXY\": \"https://proxy:8080\", \"NO_PROXY\": \"localhost\"},\n                ):\n                    # Mock the response\n                    mock_get.return_value.status_code = 200\n                    mock_get.return_value.text = \"<root></root>\"\n\n                    # Call the function\n                    result = get_xml_data(\"http://example.com/\", \".\", \"test.xml\", \"ArduCopter\")\n\n                    # Check the result\n                    assert isinstance(result, ET.Element)\n\n                    # Assert that requests.get was called with proxy settings\n                    expected_proxies = {\"http\": \"http://proxy:8080\", \"https\": \"https://proxy:8080\", \"no_proxy\": \"localhost\"}\n                    mock_get.assert_called_once_with(\"http://example.com/test.xml\", timeout=5, proxies=expected_proxies)\n\n            @patch(\"requests.get\")\n            def test_get_xml_data_remote_file_no_proxies(mock_get) -> None:\n                \"\"\"Test fetching XML data with no proxy configuration.\"\"\"\n                # Clear environment variables\n                with patch.dict(os.environ, {}, clear=True):\n                    # Mock the response\n                    mock_get.return_value.status_code = 200\n                    mock_get.return_value.text = \"<root></root>\"\n\n                    # Call the function\n                    result = get_xml_data(\"http://example.com/\", \".\", \"test.xml\", \"ArduCopter\")\n\n                    # Check the result\n                    assert isinstance(result, ET.Element)\n\n                    # Assert that requests.get was called with no proxies\n                    mock_get.assert_called_once_with(\"http://example.com/test.xml\", timeout=5, proxies=None)\n\n\nif __name__ == \"__main__\":\n    unittest.main()"
