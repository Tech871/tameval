[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "datolabs-io/opsy"
sha = "34d0c4dd506970419e9238a3343710100422dd33"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/toolmanager/toolmanager.go internal/toolmanager/toolmanager_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/toolmanager/toolmanager.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 95.0
mutation_kill_rate = nan
original_mutation_kill_rate = 71.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "internal/toolmanager/toolmanager_test.go"
focal_file_path = "internal/toolmanager/toolmanager.go"
test_file_url = "https://github.com/datolabs-io/opsy/blob/34d0c4dd506970419e9238a3343710100422dd33/internal/toolmanager/toolmanager_test.go"
focal_file_url = "https://github.com/datolabs-io/opsy/blob/34d0c4dd506970419e9238a3343710100422dd33/internal/toolmanager/toolmanager.go"
first_commit_date = "2025-02-19"
last_commit_date = "2025-03-02"
test_file_content = "package toolmanager\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log/slog\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/datolabs-io/sredo/internal/agent\"\n\t\"github.com/datolabs-io/sredo/internal/config\"\n\t\"github.com/datolabs-io/sredo/internal/tool\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\n// newTestAgent creates a new agent for testing\nfunc newTestAgent() *agent.Agent {\n\treturn agent.New(\n\t\tagent.WithConfig(config.New().GetConfig()),\n\t\tagent.WithLogger(slog.New(slog.DiscardHandler)),\n\t)\n}\n\n// TestNew tests the creation of a new tool manager with various options.\nfunc TestNew(t *testing.T) {\n\tt.Run(\"creates default tool manager\", func(t *testing.T) {\n\t\ttm := New()\n\t\tassert.NotNil(t, tm)\n\t\tassert.Equal(t, \"tools\", tm.dir)\n\t\tassert.NotNil(t, tm.tools)\n\t\tassert.Nil(t, tm.agent)\n\t})\n\n\tt.Run(\"creates tool manager with options\", func(t *testing.T) {\n\t\tlogger := slog.New(slog.NewTextHandler(os.Stdout, nil))\n\t\tcfg := config.New().GetConfig()\n\t\tctx := context.Background()\n\t\tagent := newTestAgent()\n\n\t\ttm := New(\n\t\t\tWithLogger(logger),\n\t\t\tWithConfig(cfg),\n\t\t\tWithContext(ctx),\n\t\t\tWithDirectory(\"testdata\"),\n\t\t\tWithAgent(agent),\n\t\t)\n\n\t\tassert.NotNil(t, tm)\n\t\tassert.Equal(t, \".\", tm.dir)\n\t\tassert.Equal(t, cfg, tm.cfg)\n\t\tassert.Equal(t, ctx, tm.ctx)\n\t\tassert.Equal(t, agent, tm.agent)\n\t})\n}\n\n// TestLoadTools tests loading tools from the filesystem.\nfunc TestLoadTools(t *testing.T) {\n\tt.Run(\"loads valid tools\", func(t *testing.T) {\n\t\ttm := New(\n\t\t\tWithDirectory(\"testdata\"),\n\t\t\tWithAgent(newTestAgent()),\n\t\t)\n\t\terr := tm.LoadTools()\n\t\trequire.NoError(t, err)\n\n\t\ttools := tm.GetTools()\n\t\tassert.Len(t, tools, 3) // Should load test_tool.yaml, executable_tool.yaml and exec tool\n\n\t\ttl, ok := tools[\"test_tool\"]\n\t\trequire.True(t, ok)\n\t\tassert.Equal(t, \"Test Tool\", tl.GetDisplayName())\n\t\tassert.Equal(t, \"A tool for testing purposes\", tl.GetDescription())\n\n\t\t// Verify executable tool is loaded\n\t\texecutableTool, ok := tools[\"executable_tool\"]\n\t\trequire.True(t, ok)\n\t\tassert.Equal(t, \"Executable Tool\", executableTool.GetDisplayName())\n\t\tassert.Equal(t, \"A test tool with executable\", executableTool.GetDescription())\n\n\t\t// Verify exec tool is loaded\n\t\texecTool, ok := tools[tool.ExecToolName]\n\t\trequire.True(t, ok)\n\t\tassert.Equal(t, \"Exec\", execTool.GetDisplayName())\n\t})\n\n\tt.Run(\"handles invalid tool definitions\", func(t *testing.T) {\n\t\t// The invalid tool should be skipped during loading\n\t\ttm := New(\n\t\t\tWithDirectory(\"testdata\"),\n\t\t\tWithAgent(newTestAgent()),\n\t\t)\n\t\terr := tm.LoadTools()\n\t\trequire.NoError(t, err)\n\n\t\t_, err = tm.GetTool(\"invalid_tool\")\n\t\tassert.ErrorContains(t, err, ErrToolNotFound)\n\t})\n\n\tt.Run(\"validates required fields\", func(t *testing.T) {\n\t\tdef := &tool.Definition{\n\t\t\tDisplayName: \"Test Tool\",\n\t\t\tDescription: \"Test Description\",\n\t\t\tInputs: map[string]tool.Input{\n\t\t\t\t\"test_input\": {\n\t\t\t\t\tDescription: \"Test Input\", // Missing type\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\terr := tool.ValidateDefinition(def)\n\t\tassert.ErrorContains(t, err, fmt.Sprintf(\"%s: %q\", tool.ErrToolInputMissingType, \"test_input\"))\n\n\t\tdef.Inputs[\"test_input\"] = tool.Input{\n\t\t\tType: \"string\", // Missing description\n\t\t}\n\t\terr = tool.ValidateDefinition(def)\n\t\tassert.ErrorContains(t, err, fmt.Sprintf(\"%s: %q\", tool.ErrToolInputMissingDescription, \"test_input\"))\n\n\t\tdef.DisplayName = \"\"\n\t\terr = tool.ValidateDefinition(def)\n\t\tassert.ErrorContains(t, err, tool.ErrToolMissingDisplayName)\n\n\t\tdef.DisplayName = \"Test Tool\"\n\t\tdef.Description = \"\"\n\t\terr = tool.ValidateDefinition(def)\n\t\tassert.ErrorContains(t, err, tool.ErrToolMissingDescription)\n\t})\n\n\tt.Run(\"handles non-existent directory\", func(t *testing.T) {\n\t\ttm := New(WithDirectory(\"nonexistent\"))\n\t\terr := tm.LoadTools()\n\t\tassert.ErrorContains(t, err, ErrLoadingTools)\n\t})\n\n\tt.Run(\"handles non-yaml files\", func(t *testing.T) {\n\t\t// Create a temporary directory for test files\n\t\ttmpDir := t.TempDir()\n\n\t\t// Create a non-YAML file\n\t\terr := os.WriteFile(filepath.Join(tmpDir, \"not_a_tool.txt\"), []byte(\"not a tool\"), 0644)\n\t\trequire.NoError(t, err)\n\n\t\t// Create a valid YAML file\n\t\terr = os.WriteFile(filepath.Join(tmpDir, \"valid_tool.yaml\"), []byte(`\ndisplay_name: \"Valid Tool\"\ndescription: \"A valid tool\"\ninputs:\n  test_input:\n    type: \"string\"\n    description: \"Test input\"\n`), 0644)\n\t\trequire.NoError(t, err)\n\n\t\ttm := New(WithDirectory(tmpDir))\n\t\terr = tm.LoadTools()\n\t\trequire.NoError(t, err)\n\n\t\ttools := tm.GetTools()\n\t\tassert.Len(t, tools, 2) // Should only load valid_tool.yaml and exec tool\n\t})\n\n\tt.Run(\"handles empty directory\", func(t *testing.T) {\n\t\ttmpDir := t.TempDir()\n\t\ttm := New(\n\t\t\tWithDirectory(tmpDir),\n\t\t\tWithAgent(newTestAgent()),\n\t\t)\n\t\terr := tm.LoadTools()\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, tm.GetTools(), 1) // Should only have exec tool\n\t})\n\n\tt.Run(\"handles directory with only invalid tools\", func(t *testing.T) {\n\t\ttmpDir := t.TempDir()\n\n\t\t// Create an invalid YAML file\n\t\terr := os.WriteFile(filepath.Join(tmpDir, \"invalid.yaml\"), []byte(\"invalid: yaml: content\"), 0644)\n\t\trequire.NoError(t, err)\n\n\t\ttm := New(\n\t\t\tWithDirectory(tmpDir),\n\t\t\tWithAgent(newTestAgent()),\n\t\t)\n\t\terr = tm.LoadTools()\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, tm.GetTools(), 1) // Should only have exec tool\n\t})\n\n\tt.Run(\"handles invalid executable path\", func(t *testing.T) {\n\t\ttmpDir := t.TempDir()\n\n\t\t// Create a tool with invalid executable path\n\t\terr := os.WriteFile(filepath.Join(tmpDir, \"invalid_exec.yaml\"), []byte(`\ndisplay_name: \"Invalid Exec Tool\"\ndescription: \"A tool with invalid executable\"\nexecutable: \"/nonexistent/path\"\ninputs:\n  test_input:\n    type: \"string\"\n    description: \"Test input\"\n`), 0644)\n\t\trequire.NoError(t, err)\n\n\t\ttm := New(\n\t\t\tWithDirectory(tmpDir),\n\t\t\tWithAgent(newTestAgent()),\n\t\t)\n\t\terr = tm.LoadTools()\n\t\trequire.NoError(t, err)\n\t\tassert.Len(t, tm.GetTools(), 1) // Should only have exec tool\n\t})\n\n\tt.Run(\"handles_invalid_system_prompt\", func(t *testing.T) {\n\t\t// Create a temporary directory for the test\n\t\tdir := t.TempDir()\n\t\trequire.NoError(t, os.WriteFile(filepath.Join(dir, \"invalid_prompt.yaml\"), []byte(`\ndisplay_name: Invalid Prompt Tool\ndescription: A tool with an invalid system prompt\nrules:\n  - \"valid rule\"\nexecutable: /path/to/nonexistent/executable # This will cause system prompt validation to fail\ninputs:\n  input1:\n    type: string\n    description: Test input\n`), 0644))\n\n\t\t// Create a test logger that captures logs\n\t\tvar logBuffer strings.Builder\n\t\tlogger := slog.New(slog.NewTextHandler(&logBuffer, &slog.HandlerOptions{\n\t\t\tLevel: slog.LevelError,\n\t\t}))\n\n\t\t// Create a tool manager with the test directory and logger\n\t\ttm := New(WithDirectory(dir), WithLogger(logger))\n\n\t\t// Load tools\n\t\trequire.NoError(t, tm.LoadTools())\n\n\t\t// Verify that the error was logged\n\t\trequire.Contains(t, logBuffer.String(), ErrInvalidToolDefinition)\n\t\trequire.Contains(t, logBuffer.String(), \"invalid_prompt\")\n\n\t\t// Verify that getting the invalid tool returns an error\n\t\t_, err := tm.GetTool(\"invalid_prompt\")\n\t\trequire.Error(t, err)\n\t\trequire.Contains(t, err.Error(), ErrToolNotFound)\n\t})\n}\n\n// TestGetTool tests retrieving specific tools.\nfunc TestGetTool(t *testing.T) {\n\ttm := New(\n\t\tWithDirectory(\"testdata\"),\n\t\tWithAgent(newTestAgent()),\n\t)\n\trequire.NoError(t, tm.LoadTools())\n\n\tt.Run(\"gets existing tool\", func(t *testing.T) {\n\t\ttool, err := tm.GetTool(\"test_tool\")\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, \"Test Tool\", tool.GetDisplayName())\n\t})\n\n\tt.Run(\"gets exec tool\", func(t *testing.T) {\n\t\ttool, err := tm.GetTool(tool.ExecToolName)\n\t\trequire.NoError(t, err)\n\t\tassert.Equal(t, \"Exec\", tool.GetDisplayName())\n\t})\n\n\tt.Run(\"returns error for non-existent tool\", func(t *testing.T) {\n\t\t_, err := tm.GetTool(\"nonexistent\")\n\t\tassert.ErrorContains(t, err, ErrToolNotFound)\n\t})\n}\n\n// TestGetTools tests retrieving all tools.\nfunc TestGetTools(t *testing.T) {\n\ttm := New(\n\t\tWithDirectory(\"testdata\"),\n\t\tWithAgent(newTestAgent()),\n\t)\n\trequire.NoError(t, tm.LoadTools())\n\n\ttools := tm.GetTools()\n\tassert.Len(t, tools, 3) // Should have test_tool, executable_tool and exec tool\n\n\t// Verify test_tool\n\ttestTool, ok := tools[\"test_tool\"]\n\trequire.True(t, ok, \"test_tool should be present\")\n\tassert.Equal(t, \"Test Tool\", testTool.GetDisplayName())\n\n\t// Verify executable_tool\n\texecutableTool, ok := tools[\"executable_tool\"]\n\trequire.True(t, ok, \"executable_tool should be present\")\n\tassert.Equal(t, \"Executable Tool\", executableTool.GetDisplayName())\n\n\t// Verify exec tool\n\texecTool, ok := tools[tool.ExecToolName]\n\trequire.True(t, ok, \"exec tool should be present\")\n\tassert.Equal(t, \"Exec\", execTool.GetDisplayName())\n}\n\n// TestConcurrentAccess tests thread safety of the tool manager.\nfunc TestConcurrentAccess(t *testing.T) {\n\ttm := New(\n\t\tWithDirectory(\"testdata\"),\n\t\tWithAgent(newTestAgent()),\n\t)\n\trequire.NoError(t, tm.LoadTools())\n\n\tvar wg sync.WaitGroup\n\tnumGoroutines := 10\n\n\t// Test concurrent tool access\n\twg.Add(numGoroutines)\n\tfor i := 0; i < numGoroutines; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\ttools := tm.GetTools()\n\t\t\tassert.NotEmpty(t, tools)\n\t\t\ttool, err := tm.GetTool(\"test_tool\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, \"Test Tool\", tool.GetDisplayName())\n\t\t}()\n\t}\n\twg.Wait()\n\n\t// Test concurrent tool loading and access\n\twg.Add(numGoroutines * 2)\n\tfor i := 0; i < numGoroutines; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terr := tm.LoadTools()\n\t\t\tassert.NoError(t, err)\n\t\t}()\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\ttools := tm.GetTools()\n\t\t\tassert.NotEmpty(t, tools)\n\t\t}()\n\t}\n\twg.Wait()\n}"
