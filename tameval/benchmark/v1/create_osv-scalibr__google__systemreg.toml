[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.23.4"

[repo_info]
repository = "google/osv-scalibr"
sha = "68757353cde699f714e3edbe2ef641c84e737ac6"

[run_info]
docker_image = "golang:1.23.4"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out detector/weakcredentials/winlocal/systemreg/systemreg.go detector/weakcredentials/winlocal/systemreg/systemreg_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting detector/weakcredentials/winlocal/systemreg/systemreg.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 78.57
original_coverage = 77.0
mutation_kill_rate = 85.0
original_mutation_kill_rate = nan
covered_lines = [ 54, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66, 68, 73, 76, 81, 82, 83, 84, 86, 87, 88, 89, 90, 91, 93, 96, 97, 98, 99, 100, 102, 107, 108, 109, 114, 118,]
missed_lines = [ 40, 41, 42, 43, 44, 45, 47, 69, 70, 71, 77, 78, 79, 103, 104, 105, 110, 111, 112,]

[input_info]
test_file_path = "detector/weakcredentials/winlocal/systemreg/systemreg_test.go"
focal_file_path = "detector/weakcredentials/winlocal/systemreg/systemreg.go"
test_file_url = "https://github.com/google/osv-scalibr/blob/68757353cde699f714e3edbe2ef641c84e737ac6/detector/weakcredentials/winlocal/systemreg/systemreg_test.go"
focal_file_url = "https://github.com/google/osv-scalibr/blob/68757353cde699f714e3edbe2ef641c84e737ac6/detector/weakcredentials/winlocal/systemreg/systemreg.go"
first_commit_date = "2024-10-07"
last_commit_date = "2025-03-10"
test_file_content = "// Copyright 2025 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage systemreg\n\nimport (\n\t\"slices\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/osv-scalibr/common/windows/registry\"\n\t\"github.com/google/osv-scalibr/testing/mockregistry\"\n)\n\n\nfunc TestSyskey(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tregistry    *mockregistry.MockRegistry\n\t\twant        []byte\n\t\twantErr     bool\n\t\twantErrText string\n\t}{\n\t\t{\n\t\t\tname: \"Parses syskey correctly\",\n\t\t\tregistry: &mockregistry.MockRegistry{\n\t\t\t\tKeys: map[string]registry.Key{\n\t\t\t\t\t`Select`: &mockregistry.MockKey{\n\t\t\t\t\t\tKValues: []registry.Value{\n\t\t\t\t\t\t\t&mockregistry.MockValue{\n\t\t\t\t\t\t\t\tVName: \"Current\",\n\t\t\t\t\t\t\t\tVData: []byte{0x01},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet001\\Control\\Lsa\\JD`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x32\\x00\\x35\\x00\\x33\\x00\\x35\\x00\\x39\\x00\\x33\\x00\\x64\\x00\\x64\\x00\",\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet001\\Control\\Lsa\\Skew1`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x61\\x00\\x65\\x00\\x39\\x00\\x33\\x00\\x34\\x00\\x37\\x00\\x30\\x00\\x30\\x00\",\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet001\\Control\\Lsa\\GBG`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x38\\x00\\x38\\x00\\x31\\x00\\x33\\x00\\x39\\x00\\x64\\x00\\x34\\x00\\x35\\x00\",\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet001\\Control\\Lsa\\Data`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x31\\x00\\x36\\x00\\x62\\x00\\x64\\x00\\x33\\x00\\x65\\x00\\x33\\x00\\x33\\x00\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"\\x88\\x93\\xae\\x93\\x45\\x13\\xbd\\xdd\\x25\\x47\\x35\\x16\\x3e\\x9d\\x33\\x00\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Parses syskey correctly with different control set\",\n\t\t\tregistry: &mockregistry.MockRegistry{\n\t\t\t\tKeys: map[string]registry.Key{\n\t\t\t\t\t`Select`: &mockregistry.MockKey{\n\t\t\t\t\t\tKValues: []registry.Value{\n\t\t\t\t\t\t\t&mockregistry.MockValue{\n\t\t\t\t\t\t\t\tVName: \"Current\",\n\t\t\t\t\t\t\t\tVData: []byte{0x02},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet002\\Control\\Lsa\\JD`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x32\\x00\\x35\\x00\\x33\\x00\\x35\\x00\\x39\\x00\\x33\\x00\\x64\\x00\\x64\\x00\",\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet002\\Control\\Lsa\\Skew1`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x61\\x00\\x65\\x00\\x39\\x00\\x33\\x00\\x34\\x00\\x37\\x00\\x30\\x00\\x30\\x00\",\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet002\\Control\\Lsa\\GBG`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x38\\x00\\x38\\x00\\x31\\x00\\x33\\x00\\x39\\x00\\x64\\x00\\x34\\x00\\x35\\x00\",\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet002\\Control\\Lsa\\Data`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x31\\x00\\x36\\x00\\x62\\x00\\x64\\x00\\x33\\x00\\x65\\x00\\x33\\x00\\x33\\x00\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: []byte(\"\\x88\\x93\\xae\\x93\\x45\\x13\\xbd\\xdd\\x25\\x47\\x35\\x16\\x3e\\x9d\\x33\\x00\"),\n\t\t},\n\t\t{\n\t\t\tname: \"Parts of the syskey are missing\",\n\t\t\tregistry: &mockregistry.MockRegistry{\n\t\t\t\tKeys: map[string]registry.Key{\n\t\t\t\t\t`Select`: &mockregistry.MockKey{\n\t\t\t\t\t\tKValues: []registry.Value{\n\t\t\t\t\t\t\t&mockregistry.MockValue{\n\t\t\t\t\t\t\t\tVName: \"Current\",\n\t\t\t\t\t\t\t\tVData: []byte{0x01},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet001\\Control\\Lsa\\JD`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x32\\x00\\x35\\x00\\x33\\x00\\x35\\x00\\x39\\x00\\x33\\x00\\x64\\x00\\x64\\x00\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:     true,\n\t\t\twantErrText: `failed to open key`,\n\t\t},\n\t\t{\n\t\t\tname: \"The key does not decode as hexadecimal\",\n\t\t\tregistry: &mockregistry.MockRegistry{\n\t\t\t\tKeys: map[string]registry.Key{\n\t\t\t\t\t`Select`: &mockregistry.MockKey{\n\t\t\t\t\t\tKValues: []registry.Value{\n\t\t\t\t\t\t\t&mockregistry.MockValue{\n\t\t\t\t\t\t\t\tVName: \"Current\",\n\t\t\t\t\t\t\t\tVData: []byte{0x01},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet001\\Control\\Lsa\\JD`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x32\\xFF\\x35\\xFF\\x33\\xFF\\x35\\xFF\\x39\\xFF\\x33\\xFF\\x64\\xFF\\x64\\xFF\",\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet001\\Control\\Lsa\\Skew1`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x61\\x00\\x65\\x00\\x39\\x00\\x33\\x00\\x34\\x00\\x37\\x00\\x30\\x00\\x30\\x00\",\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet001\\Control\\Lsa\\GBG`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x38\\x00\\x38\\x00\\x31\\x00\\x33\\x00\\x39\\x00\\x64\\x00\\x34\\x00\\x35\\x00\",\n\t\t\t\t\t},\n\t\t\t\t\t`ControlSet001\\Control\\Lsa\\Data`: &mockregistry.MockKey{\n\t\t\t\t\t\tKClassName: \"\\x31\\x00\\x36\\x00\\x62\\x00\\x64\\x00\\x33\\x00\\x65\\x00\\x33\\x00\\x33\\x00\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:     true,\n\t\t\twantErrText: `encoding/hex: invalid byte: U+00EF 'Ã¯'`,\n\t\t},\n\t\t{\n\t\t\tname: \"Select registry key not found\",\n\t\t\tregistry: &mockregistry.MockRegistry{\n\t\t\t\tKeys: map[string]registry.Key{},\n\t\t\t},\n\t\t\twantErr:     true,\n\t\t\twantErrText: `failed to open key`,\n\t\t},\n\t\t{\n\t\t\tname: \"Current control set not found\",\n\t\t\tregistry: &mockregistry.MockRegistry{\n\t\t\t\tKeys: map[string]registry.Key{\n\t\t\t\t\t`Select`: &mockregistry.MockKey{},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr:     true,\n\t\t\twantErrText: errNoCurrentControlSet.Error(),\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tsysreg := &SystemRegistry{tc.registry}\n\t\t\tgot, err := sysreg.Syskey()\n\n\t\t\tif (err != nil) != tc.wantErr {\n\t\t\t\tt.Errorf(\"Syskey() unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif tc.wantErr {\n\t\t\t\tif !strings.Contains(err.Error(), tc.wantErrText) {\n\t\t\t\t\tt.Errorf(\"Syskey() unexpected error: got: %v, want: %v\", err.Error(), tc.wantErrText)\n\t\t\t\t}\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !slices.Equal(got, tc.want) {\n\t\t\t\tt.Errorf(\"Syskey() unexpected result: got: %v, want: %v\", got, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
