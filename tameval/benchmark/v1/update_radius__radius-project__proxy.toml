[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.24.1"

[repo_info]
repository = "radius-project/radius"
sha = "202e099e4d5cb300b34a39d5e9cc5aa2c04bda1d"

[run_info]
docker_image = "golang:1.24.1"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/ucp/frontend/controller/radius/proxy.go pkg/ucp/frontend/controller/radius/proxy_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/ucp/frontend/controller/radius/proxy.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 26.0
original_coverage = 67.0
mutation_kill_rate = 100.0
original_mutation_kill_rate = 31.0
covered_lines = [ 78, 79, 84, 85, 86, 87, 88, 89, 90, 94, 95, 96, 97, 104, 105, 106, 107, 108, 115, 116, 117, 118, 119, 120, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 213, 214, 215, 216, 217, 218, 219,]
missed_lines = [ 80, 81, 82, 98, 99, 100, 109, 110, 111, 112, 113, 121, 122, 123, 125, 126, 127, 129, 130, 131, 132, 133, 135, 136, 137, 138, 140, 141, 142, 143, 144, 145, 146, 147, 150, 151, 152, 153, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 180, 181, 182, 183, 184, 186, 223, 224, 225, 226, 227, 230, 231, 232, 234, 235, 236, 238, 242, 243, 244, 247, 248, 249, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 288, 289, 290, 291, 292, 293, 294, 298, 299, 300, 301, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 314, 318, 319, 320, 322, 323, 324, 325, 327, 341, 342, 343, 344,]

[input_info]
test_file_path = "pkg/ucp/frontend/controller/radius/proxy_test.go"
focal_file_path = "pkg/ucp/frontend/controller/radius/proxy.go"
test_file_url = "https://github.com/radius-project/radius/blob/202e099e4d5cb300b34a39d5e9cc5aa2c04bda1d/pkg/ucp/frontend/controller/radius/proxy_test.go"
focal_file_url = "https://github.com/radius-project/radius/blob/202e099e4d5cb300b34a39d5e9cc5aa2c04bda1d/pkg/ucp/frontend/controller/radius/proxy.go"
first_commit_date = "2023-12-10"
last_commit_date = "2025-01-30"
test_file_content = "/*\nCopyright 2023 The Radius Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage radius\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"testing\"\n\n\tv1 \"github.com/radius-project/radius/pkg/armrpc/api/v1\"\n\t\"github.com/radius-project/radius/pkg/armrpc/asyncoperation/statusmanager\"\n\t\"github.com/radius-project/radius/pkg/armrpc/frontend/controller\"\n\t\"github.com/radius-project/radius/pkg/armrpc/rest\"\n\t\"github.com/radius-project/radius/pkg/components/database\"\n\t\"github.com/radius-project/radius/pkg/ucp/datamodel\"\n\t\"github.com/radius-project/radius/pkg/ucp/resources\"\n\t\"github.com/radius-project/radius/pkg/ucp/trackedresource\"\n\t\"github.com/radius-project/radius/test/testcontext\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n)\n\nconst (\n\tapiVersion = \"2025-01-01\"\n\tlocation   = \"global\"\n)\n\n// The Run function is also tested by integration tests in the pkg/ucp/integrationtests/radius package.\n\nfunc createController(t *testing.T) (*ProxyController, *database.MockClient, *mockUpdater, *mockRoundTripper, *statusmanager.MockStatusManager) {\n\tctrl := gomock.NewController(t)\n\tdatabaseClient := database.NewMockClient(ctrl)\n\tstatusManager := statusmanager.NewMockStatusManager(ctrl)\n\n\troundTripper := mockRoundTripper{}\n\n\tp, err := NewProxyController(\n\t\tcontroller.Options{DatabaseClient: databaseClient, StatusManager: statusManager},\n\t\t&roundTripper,\n\t\t\"http://localhost:1234\")\n\trequire.NoError(t, err)\n\n\tupdater := mockUpdater{}\n\n\tpc := p.(*ProxyController)\n\tpc.updater = &updater\n\n\treturn pc, databaseClient, &updater, &roundTripper, statusManager\n}\n\nfunc Test_Run(t *testing.T) {\n\tid := resources.MustParse(\"/planes/test/local/resourceGroups/test-rg/providers/Applications.Test/testResources/my-resource\")\n\n\t// This test covers the legacy (pre-UDT) behavior for looking up the downstream URL. Update\n\t// this when the old behavior is removed.\n\tresourceTypeID, err := datamodel.ResourceTypeIDFromResourceID(id)\n\trequire.NoError(t, err)\n\n\tplane := datamodel.RadiusPlane{\n\t\tProperties: datamodel.RadiusPlaneProperties{\n\t\t\tResourceProviders: map[string]string{\n\t\t\t\t\"Applications.Test\": \"https://localhost:1234\",\n\t\t\t},\n\t\t},\n\t}\n\tresourceGroup := datamodel.ResourceGroup{}\n\n\tt.Run(\"success (non-tracked)\", func(t *testing.T) {\n\t\tp, databaseClient, _, roundTripper, _ := createController(t)\n\n\t\tsvcContext := &v1.ARMRequestContext{\n\t\t\tAPIVersion: apiVersion,\n\t\t\tResourceID: id,\n\t\t}\n\t\tctx := testcontext.New(t)\n\t\tctx = v1.WithARMRequestContext(ctx, svcContext)\n\n\t\tw := httptest.NewRecorder()\n\n\t\t// Not a mutating request\n\t\treq := httptest.NewRequest(http.MethodGet, id.String()+\"?api-version=\"+apiVersion, nil)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), resourceTypeID.String(), gomock.Any()).\n\t\t\tReturn(nil, &database.ErrNotFound{}).Times(1)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), \"/planes/\"+id.PlaneNamespace(), gomock.Any()).\n\t\t\tReturn(&database.Object{Data: plane}, nil).Times(1)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), id.RootScope(), gomock.Any()).\n\t\t\tReturn(&database.Object{Data: resourceGroup}, nil).Times(1)\n\n\t\tdownstreamResponse := httptest.NewRecorder()\n\t\tdownstreamResponse.WriteHeader(http.StatusOK)\n\t\troundTripper.Response = downstreamResponse.Result()\n\n\t\tresponse, err := p.Run(ctx, w, req.WithContext(ctx))\n\t\trequire.NoError(t, err)\n\t\trequire.Nil(t, response)\n\t})\n\n\tt.Run(\"success (tracked terminal response)\", func(t *testing.T) {\n\t\tp, databaseClient, updater, roundTripper, _ := createController(t)\n\n\t\tsvcContext := &v1.ARMRequestContext{\n\t\t\tAPIVersion: apiVersion,\n\t\t\tResourceID: id,\n\t\t}\n\t\tctx := testcontext.New(t)\n\t\tctx = v1.WithARMRequestContext(ctx, svcContext)\n\n\t\tw := httptest.NewRecorder()\n\n\t\t// Mutating request that will complete synchronously\n\t\treq := httptest.NewRequest(http.MethodDelete, id.String()+\"?api-version=\"+apiVersion, nil)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), resourceTypeID.String(), gomock.Any()).\n\t\t\tReturn(nil, &database.ErrNotFound{}).Times(1)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), \"/planes/\"+id.PlaneNamespace(), gomock.Any()).\n\t\t\tReturn(&database.Object{Data: plane}, nil).Times(1)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), id.RootScope(), gomock.Any()).\n\t\t\tReturn(&database.Object{Data: resourceGroup}, nil).Times(1)\n\n\t\tdownstreamResponse := httptest.NewRecorder()\n\t\tdownstreamResponse.WriteHeader(http.StatusOK)\n\t\troundTripper.Response = downstreamResponse.Result()\n\n\t\t// Successful update\n\t\tupdater.Result = nil\n\n\t\tresponse, err := p.Run(ctx, w, req.WithContext(ctx))\n\t\trequire.NoError(t, err)\n\t\trequire.Nil(t, response)\n\t})\n\n\tt.Run(\"success (fallback to async)\", func(t *testing.T) {\n\t\tp, databaseClient, updater, roundTripper, statusManager := createController(t)\n\n\t\tsvcContext := &v1.ARMRequestContext{\n\t\t\tAPIVersion: apiVersion,\n\t\t\tResourceID: id,\n\t\t}\n\t\tctx := testcontext.New(t)\n\t\tctx = v1.WithARMRequestContext(ctx, svcContext)\n\n\t\tw := httptest.NewRecorder()\n\n\t\t// Mutating request that will complete synchronously\n\t\treq := httptest.NewRequest(http.MethodDelete, id.String()+\"?api-version=\"+apiVersion, nil)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), resourceTypeID.String(), gomock.Any()).\n\t\t\tReturn(nil, &database.ErrNotFound{}).Times(1)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), \"/planes/\"+id.PlaneNamespace(), gomock.Any()).\n\t\t\tReturn(&database.Object{Data: plane}, nil).Times(1)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), id.RootScope(), gomock.Any()).\n\t\t\tReturn(&database.Object{Data: resourceGroup}, nil).Times(1)\n\n\t\t// Tracking entry created\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), gomock.Any(), gomock.Any()).\n\t\t\tReturn(nil, &database.ErrNotFound{}).Times(1)\n\t\tdatabaseClient.EXPECT().\n\t\t\tSave(gomock.Any(), gomock.Any(), gomock.Any()).\n\t\t\tReturn(nil).Times(1)\n\n\t\tdownstreamResponse := httptest.NewRecorder()\n\t\tdownstreamResponse.WriteHeader(http.StatusOK)\n\t\troundTripper.Response = downstreamResponse.Result()\n\n\t\t// Contended update, fallback to async\n\t\tupdater.Result = &trackedresource.InProgressErr{}\n\n\t\tstatusManager.EXPECT().\n\t\t\tQueueAsyncOperation(gomock.Any(), gomock.Any(), gomock.Any()).\n\t\t\tReturn(nil).Times(1)\n\n\t\tresponse, err := p.Run(ctx, w, req.WithContext(ctx))\n\t\trequire.NoError(t, err)\n\t\trequire.Nil(t, response)\n\t})\n\n\tt.Run(\"success (fallback to async without workitem)\", func(t *testing.T) {\n\t\tp, databaseClient, updater, roundTripper, _ := createController(t)\n\n\t\tsvcContext := &v1.ARMRequestContext{\n\t\t\tAPIVersion: apiVersion,\n\t\t\tResourceID: id,\n\t\t}\n\t\tctx := testcontext.New(t)\n\t\tctx = v1.WithARMRequestContext(ctx, svcContext)\n\n\t\tw := httptest.NewRecorder()\n\n\t\t// Mutating request that will complete asynchronously\n\t\treq := httptest.NewRequest(http.MethodDelete, id.String()+\"?api-version=\"+apiVersion, nil)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), resourceTypeID.String(), gomock.Any()).\n\t\t\tReturn(nil, &database.ErrNotFound{}).Times(1)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), \"/planes/\"+id.PlaneNamespace(), gomock.Any()).\n\t\t\tReturn(&database.Object{Data: plane}, nil).Times(1)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), id.RootScope(), gomock.Any()).\n\t\t\tReturn(&database.Object{Data: resourceGroup}, nil).Times(1)\n\n\t\t// Tracking entry created\n\t\texistingEntry := &database.Object{\n\t\t\tData: &datamodel.GenericResource{\n\t\t\t\tBaseResource: v1.BaseResource{\n\t\t\t\t\tInternalMetadata: v1.InternalMetadata{\n\t\t\t\t\t\tAsyncProvisioningState: v1.ProvisioningStateAccepted,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), gomock.Any(), gomock.Any()).\n\t\t\tReturn(existingEntry, nil).Times(1)\n\t\tdatabaseClient.EXPECT().\n\t\t\tSave(gomock.Any(), gomock.Any(), gomock.Any()).\n\t\t\tReturn(nil).Times(1)\n\n\t\tdownstreamResponse := httptest.NewRecorder()\n\t\tdownstreamResponse.WriteHeader(http.StatusAccepted)\n\t\troundTripper.Response = downstreamResponse.Result()\n\n\t\t// Contended update, fallback to async\n\t\tupdater.Result = &trackedresource.InProgressErr{}\n\n\t\t// No work item created, it was already in the queue.\n\n\t\tresponse, err := p.Run(ctx, w, req.WithContext(ctx))\n\t\trequire.NoError(t, err)\n\t\trequire.Nil(t, response)\n\t})\n\n\tt.Run(\"failure (validate downstream: not found)\", func(t *testing.T) {\n\t\tp, databaseClient, _, _, _ := createController(t)\n\n\t\tsvcContext := &v1.ARMRequestContext{\n\t\t\tAPIVersion: apiVersion,\n\t\t\tResourceID: id,\n\t\t}\n\t\tctx := testcontext.New(t)\n\t\tctx = v1.WithARMRequestContext(ctx, svcContext)\n\n\t\tw := httptest.NewRecorder()\n\t\treq := httptest.NewRequest(http.MethodPut, id.String()+\"?api-version=\"+apiVersion, nil)\n\n\t\tdatabaseClient.EXPECT().\n\t\t\tGet(gomock.Any(), \"/planes/\"+id.PlaneNamespace(), gomock.Any()).\n\t\t\tReturn(nil, &database.ErrNotFound{}).Times(1)\n\n\t\texpected := rest.NewNotFoundResponseWithCause(id, \"plane \\\"/planes/test/local\\\" not found\")\n\n\t\tresponse, err := p.Run(ctx, w, req)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, expected, response)\n\t})\n}\n\nfunc Test_ProxyController_PrepareProxyRequest(t *testing.T) {\n\tdownstream := \"http://localhost:7443\"\n\trelativePath := \"/planes/radius/local/resourceGroups/test-group/providers/System.TestRP\"\n\tt.Run(\"success (http)\", func(t *testing.T) {\n\t\toriginalURL, err := url.Parse(\"http://localhost:9443/path/base/planes/radius/local/resourceGroups/test-group/providers/System.TestRP?test=yes\")\n\t\trequire.NoError(t, err)\n\t\toriginalReq := &http.Request{\n\t\t\tHost:   originalURL.Host,\n\t\t\tHeader: http.Header{\"Copied\": []string{\"yes\"}},\n\t\t\tTLS:    nil,\n\t\t\tURL:    originalURL}\n\n\t\tp, _, _, _, _ := createController(t)\n\t\tproxyReq, err := p.PrepareProxyRequest(testcontext.New(t), originalReq, downstream, relativePath)\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, proxyReq)\n\n\t\trequire.Equal(t, \"http://localhost:7443/planes/radius/local/resourceGroups/test-group/providers/System.TestRP?test=yes\", proxyReq.URL.String())\n\t\trequire.Equal(t, \"http\", proxyReq.Header.Get(\"X-Forwarded-Proto\"))\n\t\trequire.Equal(t, \"http://localhost:9443/path/base/planes/radius/local/resourceGroups/test-group/providers/System.TestRP?test=yes\", proxyReq.Header.Get(\"Referer\"))\n\t\trequire.Equal(t, \"yes\", proxyReq.Header.Get(\"Copied\"))\n\t})\n\n\tt.Run(\"success (http)\", func(t *testing.T) {\n\t\toriginalURL, err := url.Parse(\"http://localhost:9443/path/base/planes/radius/local/resourceGroups/test-group/providers/System.TestRP?test=yes\")\n\t\trequire.NoError(t, err)\n\t\toriginalReq := &http.Request{\n\t\t\tHost:   originalURL.Host,\n\t\t\tHeader: http.Header{\"Copied\": []string{\"yes\"}},\n\t\t\tTLS:    &tls.ConnectionState{},\n\t\t\tURL:    originalURL}\n\n\t\tp, _, _, _, _ := createController(t)\n\t\tproxyReq, err := p.PrepareProxyRequest(testcontext.New(t), originalReq, downstream, relativePath)\n\t\trequire.NoError(t, err)\n\t\trequire.NotNil(t, proxyReq)\n\n\t\trequire.Equal(t, \"http://localhost:7443/planes/radius/local/resourceGroups/test-group/providers/System.TestRP?test=yes\", proxyReq.URL.String())\n\t\trequire.Equal(t, \"https\", proxyReq.Header.Get(\"X-Forwarded-Proto\"))\n\t\trequire.Equal(t, \"https://localhost:9443/path/base/planes/radius/local/resourceGroups/test-group/providers/System.TestRP?test=yes\", proxyReq.Header.Get(\"Referer\"))\n\t\trequire.Equal(t, \"yes\", proxyReq.Header.Get(\"Copied\"))\n\t})\n\n\tt.Run(\"invalid downstream URL\", func(t *testing.T) {\n\t\toriginalReq := &http.Request{Header: http.Header{}, URL: &url.URL{}}\n\n\t\tp, _, _, _, _ := createController(t)\n\t\tproxyReq, err := p.PrepareProxyRequest(testcontext.New(t), originalReq, \"\\ninvalid\", relativePath)\n\t\trequire.Error(t, err)\n\t\trequire.Equal(t, \"failed to parse downstream URL: parse \\\"\\\\ninvalid\\\": net/url: invalid control character in URL\", err.Error())\n\t\trequire.Nil(t, proxyReq)\n\t})\n}\n\ntype mockUpdater struct {\n\tResult error\n}\n\nfunc (u *mockUpdater) Update(ctx context.Context, downstreamURL string, originalID resources.ID, version string) error {\n\treturn u.Result\n}\n\ntype mockRoundTripper struct {\n\tResponse *http.Response\n\tErr      error\n}\n\nfunc (rt *mockRoundTripper) RoundTrip(r *http.Request) (*http.Response, error) {\n\tif rt.Response != nil {\n\t\trt.Response.Request = r\n\t}\n\treturn rt.Response, rt.Err\n}"
