[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Java"
java_version = "8"
java_builder = "Maven"
is_multi_module = true

[repo_info]
repository = "databricks/databricks-sdk-java"
sha = "1aaab52533750ad00bb98d0a13d3895f384e77e0"

[run_info]
docker_image = "maven:3.8.6-jdk-8"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "mvn -Dmaven.repo.local=/.m2 -T 4 clean install"
test_run_command = "mvn clean -Dmaven.repo.local=/.m2 test -q -pl databricks-sdk-java -Dtest=CliTokenSourceTest && mvn jacoco:report -Djacoco.append=false"
mutation_run_command = "mvn -Dmaven.repo.local=/.m2 org.pitest:pitest-maven:mutationCoverage -pl databricks-sdk-java -DtargetClasses=**.CliTokenSource  -DtargetTests=**.CliTokenSourceTest  -DoutputFormats=XML"
coverage_report_path = "databricks-sdk-java/target/site/jacoco/jacoco.xml"
coverage_report_type = "jacoco"
mutation_report_path = "databricks-sdk-java/target/pit-reports/mutations.xml"
mutation_report_type = "pitest"

[coverage]
coverage = 0
original_coverage = 84.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "databricks-sdk-java/src/test/java/com/databricks/sdk/core/CliTokenSourceTest.java"
focal_file_path = "databricks-sdk-java/src/main/java/com/databricks/sdk/core/CliTokenSource.java"
test_file_url = "https://github.com/databricks/databricks-sdk-java/blob/1aaab52533750ad00bb98d0a13d3895f384e77e0/databricks-sdk-java/src/test/java/com/databricks/sdk/core/CliTokenSourceTest.java"
focal_file_url = "https://github.com/databricks/databricks-sdk-java/blob/1aaab52533750ad00bb98d0a13d3895f384e77e0/databricks-sdk-java/src/main/java/com/databricks/sdk/core/CliTokenSource.java"
first_commit_date = "2023-05-10"
last_commit_date = "2025-06-26"
test_file_content = "package com.databricks.sdk.core;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.mockConstruction;\nimport static org.mockito.Mockito.mockStatic;\nimport static org.mockito.Mockito.when;\n\nimport com.databricks.sdk.core.oauth.Token;\nimport com.databricks.sdk.core.utils.Environment;\nimport com.databricks.sdk.core.utils.OSUtilities;\nimport com.databricks.sdk.core.utils.OSUtils;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.LocalDateTime;\nimport java.time.ZoneId;\nimport java.time.ZonedDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.time.format.DateTimeParseException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TimeZone;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\nimport org.mockito.MockedConstruction;\nimport org.mockito.MockedStatic;\n\npublic class CliTokenSourceTest {\n  String getExpiryStr(String dateFormat, Duration offset) {\n    ZonedDateTime futureExpiry = ZonedDateTime.now().plus(offset);\n    return futureExpiry.format(DateTimeFormatter.ofPattern(dateFormat));\n  }\n\n  private static Stream<Arguments> provideTimezoneTestCases() {\n    // Generate timezones from GMT-12 to GMT+12.\n    List<String> timezones =\n        IntStream.rangeClosed(-12, 12)\n            .mapToObj(offset -> offset == 0 ? \"GMT\" : String.format(\"GMT%+d\", offset))\n            .collect(Collectors.toList());\n\n    // Time to expiry of tokens (minutes, shouldBeExpired).\n    List<Arguments> minutesUntilExpiry =\n        Arrays.asList(\n            Arguments.of(5, false), // 5 minutes remaining\n            Arguments.of(30, false), // 30 minutes remaining\n            Arguments.of(60, false), // 1 hour remaining\n            Arguments.of(120, false), // 2 hours remaining\n            Arguments.of(-5, true), // 5 minutes ago\n            Arguments.of(-30, true), // 30 minutes ago\n            Arguments.of(-60, true), // 1 hour ago\n            Arguments.of(-120, true) // 2 hours ago\n            );\n\n    // Create cross product of timezones and minutesUntilExpiry cases.\n    return timezones.stream()\n        .flatMap(\n            timezone -> {\n              List<String> dateFormats =\n                  new ArrayList<>(\n                      Arrays.asList(\n                          \"yyyy-MM-dd HH:mm:ss\",\n                          \"yyyy-MM-dd HH:mm:ss.SSS\",\n                          \"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\"));\n\n              if (timezone.equals(\"GMT\")) {\n                // The Databricks CLI outputs timestamps with 'Z' suffix (e.g.,\n                // 2024-03-14T10:30:00.000Z) only when in UTC/GMT+0 timezone.\n                // Thus, we only test with this format together with the GMT timezone.\n                dateFormats.add(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n              }\n\n              return dateFormats.stream()\n                  .flatMap(\n                      dateFormat ->\n                          minutesUntilExpiry.stream()\n                              .map(\n                                  minutesUntilExpiryCase -> {\n                                    Object[] args = minutesUntilExpiryCase.get();\n                                    return Arguments.of(timezone, args[0], args[1], dateFormat);\n                                  }));\n            });\n  }\n\n  @ParameterizedTest(name = \"Test in {0} with {1} minutes offset using format {3}\")\n  @MethodSource(\"provideTimezoneTestCases\")\n  public void testRefreshWithDifferentTimezone(\n      String timezone, int minutesUntilExpiry, boolean shouldBeExpired, String dateFormat)\n      throws IOException, InterruptedException {\n    // Save original timezone.\n    TimeZone originalTimeZone = TimeZone.getDefault();\n    try {\n      TimeZone.setDefault(TimeZone.getTimeZone(timezone));\n      testRefreshWithExpiry(\"Test in \" + timezone, minutesUntilExpiry, shouldBeExpired, dateFormat);\n    } finally {\n      // Restore original timezone.\n      TimeZone.setDefault(originalTimeZone);\n    }\n  }\n\n  public void testRefreshWithExpiry(\n      String testName, int minutesUntilExpiry, boolean shouldBeExpired, String dateFormat)\n      throws IOException, InterruptedException {\n    // Mock environment.\n    Environment env = mock(Environment.class);\n    Map<String, String> envMap = new HashMap<>();\n    when(env.getEnv()).thenReturn(envMap);\n\n    // Create test command.\n    List<String> cmd = Arrays.asList(\"test\", \"command\");\n\n    // Mock OSUtilities.\n    OSUtilities osUtils = mock(OSUtilities.class);\n    when(osUtils.getCliExecutableCommand(any())).thenReturn(cmd);\n\n    try (MockedStatic<OSUtils> mockedOSUtils = mockStatic(OSUtils.class)) {\n      mockedOSUtils.when(() -> OSUtils.get(any())).thenReturn(osUtils);\n\n      CliTokenSource tokenSource =\n          new CliTokenSource(cmd, \"token_type\", \"access_token\", \"expiry\", env);\n\n      String expiryStr = getExpiryStr(dateFormat, Duration.ofMinutes(minutesUntilExpiry));\n\n      // Mock process to return the specified expiry string.\n      Process process = mock(Process.class);\n      when(process.getInputStream())\n          .thenReturn(\n              new ByteArrayInputStream(\n                  String.format(\n                          \"{\\\"token_type\\\": \\\"Bearer\\\", \\\"access_token\\\": \\\"test-token\\\", \\\"expiry\\\": \\\"%s\\\"}\",\n                          expiryStr)\n                      .getBytes()));\n      when(process.getErrorStream()).thenReturn(new ByteArrayInputStream(new byte[0]));\n      when(process.waitFor()).thenReturn(0);\n\n      // Mock ProcessBuilder constructor.\n      try (MockedConstruction<ProcessBuilder> mocked =\n          mockConstruction(\n              ProcessBuilder.class,\n              (mock, context) -> {\n                when(mock.start()).thenReturn(process);\n              })) {\n        // Test refresh.\n        Token token = tokenSource.refresh();\n        assertEquals(\"Bearer\", token.getTokenType());\n        assertEquals(\"test-token\", token.getAccessToken());\n        assertEquals(shouldBeExpired, token.getExpiry().isBefore(Instant.now()));\n      }\n    }\n  }\n\n  private static Stream<Arguments> expiryProvider() {\n    return Stream.of(\n        Arguments.of(\n            \"2023-07-17T09:02:22.330612218Z\",\n            Instant.parse(\"2023-07-17T09:02:22.330612218Z\"),\n            \"9-digit nanos\"),\n        Arguments.of(\n            \"2023-07-17T09:02:22.33061221Z\",\n            Instant.parse(\"2023-07-17T09:02:22.330612210Z\"),\n            \"8-digit nanos\"),\n        Arguments.of(\n            \"2023-07-17T09:02:22.330612Z\",\n            Instant.parse(\"2023-07-17T09:02:22.330612000Z\"),\n            \"6-digit nanos\"),\n        Arguments.of(\n            \"2023-07-17T10:02:22.330612218+01:00\",\n            Instant.parse(\"2023-07-17T09:02:22.330612218Z\"),\n            \"+01:00 offset, 9-digit nanos\"),\n        Arguments.of(\n            \"2023-07-17T04:02:22.330612218-05:00\",\n            Instant.parse(\"2023-07-17T09:02:22.330612218Z\"),\n            \"-05:00 offset, 9-digit nanos\"),\n        Arguments.of(\n            \"2023-07-17T10:02:22.330612+01:00\",\n            Instant.parse(\"2023-07-17T09:02:22.330612000Z\"),\n            \"+01:00 offset, 6-digit nanos\"),\n        Arguments.of(\"2023-07-17T09:02:22.33061221987Z\", null, \"Invalid: >9 nanos\"),\n        Arguments.of(\"17-07-2023 09:02:22\", null, \"Invalid date format\"),\n        Arguments.of(\n            \"2023-07-17 09:02:22.330612218\",\n            LocalDateTime.parse(\"2023-07-17T09:02:22.330612218\")\n                .atZone(ZoneId.systemDefault())\n                .toInstant(),\n            \"Space separator, 9-digit nanos\"),\n        Arguments.of(\n            \"2023-07-17 09:02:22.330612\",\n            LocalDateTime.parse(\"2023-07-17T09:02:22.330612\")\n                .atZone(ZoneId.systemDefault())\n                .toInstant(),\n            \"Space separator, 6-digit nanos\"),\n        Arguments.of(\n            \"2023-07-17 09:02:22.33061221987\", null, \"Space separator, Invalid: >9 nanos\"));\n  }\n\n  @ParameterizedTest(name = \"{2}\")\n  @MethodSource(\"expiryProvider\")\n  public void testParseExpiry(String input, Instant expectedInstant, String description) {\n    if (expectedInstant == null) {\n      assertThrows(DateTimeParseException.class, () -> CliTokenSource.parseExpiry(input));\n    } else {\n      Instant parsedInstant = CliTokenSource.parseExpiry(input);\n      assertEquals(expectedInstant, parsedInstant);\n    }\n  }\n}"
