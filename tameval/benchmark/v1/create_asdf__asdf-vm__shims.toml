[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.23.4"

[repo_info]
repository = "asdf-vm/asdf"
sha = "74d7b17a1cc9f640cf0f5134416d1cf7a56fe19f"

[run_info]
docker_image = "golang:1.23.4"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/shims/shims.go internal/shims/shims_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/shims/shims.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 76.47
original_coverage = 78.0
mutation_kill_rate = 63.27
original_mutation_kill_rate = nan
covered_lines = [ 31, 32, 33, 40, 41, 42, 58, 59, 60, 61, 62, 63, 65, 70, 71, 72, 73, 74, 75, 76, 77, 82, 83, 84, 85, 86, 88, 89, 90, 91, 92, 95, 96, 97, 98, 103, 104, 105, 107, 108, 109, 110, 111, 112, 113, 118, 119, 120, 121, 122, 127, 128, 129, 130, 146, 147, 148, 149, 150, 155, 156, 157, 158, 159, 160, 163, 164, 169, 170, 171, 172, 173, 174, 177, 182, 183, 184, 192, 193, 198, 199, 200, 201, 204, 205, 206, 207, 208, 209, 210, 211, 216, 217, 218, 219, 246, 247, 252, 253, 259, 264, 265, 270, 271, 272, 273, 274, 279, 280, 284, 289, 290, 296, 300, 304, 305, 310, 311, 312, 313, 314, 315, 319, 322, 326, 327, 328, 332, 333, 334, 336, 337, 338, 341, 342, 347, 348, 353, 354, 355, 356, 357, 360, 363, 368, 369, 374, 375, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 417, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 433, 434, 435, 438, 439, 440, 441, 443,]
missed_lines = [ 52, 53, 54, 66, 67, 68, 78, 79, 80, 115, 124, 134, 135, 136, 137, 138, 139, 141, 165, 166, 167, 178, 179, 180, 186, 194, 195, 196, 212, 213, 214, 221, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 237, 238, 239, 241, 248, 249, 250, 254, 255, 256, 266, 267, 268, 281, 282, 283, 285, 286, 287, 291, 292, 293, 297, 298, 299, 306, 307, 308, 316, 317, 318, 343, 344, 345, 349, 350, 351, 370, 371, 372, 391, 395, 396, 397, 398, 399, 400, 402,]

[input_info]
test_file_path = "internal/shims/shims_test.go"
focal_file_path = "internal/shims/shims.go"
test_file_url = "https://github.com/asdf-vm/asdf/blob/74d7b17a1cc9f640cf0f5134416d1cf7a56fe19f/internal/shims/shims_test.go"
focal_file_url = "https://github.com/asdf-vm/asdf/blob/74d7b17a1cc9f640cf0f5134416d1cf7a56fe19f/internal/shims/shims.go"
first_commit_date = "2024-12-18"
last_commit_date = "2025-02-17"
test_file_content = "package shims\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/asdf-vm/asdf/internal/config\"\n\t\"github.com/asdf-vm/asdf/internal/installs\"\n\t\"github.com/asdf-vm/asdf/internal/installtest\"\n\t\"github.com/asdf-vm/asdf/internal/plugins\"\n\t\"github.com/asdf-vm/asdf/internal/repotest\"\n\t\"github.com/asdf-vm/asdf/internal/toolversions\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst testPluginName = \"lua\"\n\nfunc TestFindExecutable(t *testing.T) {\n\tversion := \"1.1.0\"\n\tconf, plugin := generateConfig(t)\n\tinstallVersion(t, conf, plugin, version)\n\tstdout, stderr := buildOutputs()\n\tassert.Nil(t, GenerateAll(conf, &stdout, &stderr))\n\tcurrentDir := t.TempDir()\n\n\tt.Run(\"returns error when shim with name does not exist\", func(t *testing.T) {\n\t\texecutable, _, version, found, err := FindExecutable(conf, \"foo\", currentDir)\n\t\tassert.Empty(t, executable)\n\t\tassert.False(t, found)\n\t\tassert.Empty(t, version)\n\t\tassert.Equal(t, err.(UnknownCommandError).Error(), \"unknown command: foo\")\n\t})\n\n\tt.Run(\"returns error when shim is present but no version is set\", func(t *testing.T) {\n\t\texecutable, _, version, found, err := FindExecutable(conf, \"dummy\", currentDir)\n\t\tassert.Empty(t, executable)\n\t\tassert.False(t, found)\n\t\tassert.Empty(t, version)\n\t\tassert.Equal(t, err.(NoVersionSetError).Error(), \"no versions set for dummy\")\n\t})\n\n\tt.Run(\"returns string containing path to executable when found\", func(t *testing.T) {\n\t\t// write a version file\n\t\tdata := []byte(\"lua 1.1.0\")\n\t\tassert.Nil(t, os.WriteFile(filepath.Join(currentDir, \".tool-versions\"), data, 0o666))\n\n\t\texecutable, gotPlugin, version, found, err := FindExecutable(conf, \"dummy\", currentDir)\n\t\tassert.Equal(t, filepath.Base(filepath.Dir(filepath.Dir(executable))), \"1.1.0\")\n\t\tassert.Equal(t, filepath.Base(executable), \"dummy\")\n\t\tassert.Equal(t, plugin, gotPlugin)\n\t\tassert.Equal(t, version, \"1.1.0\")\n\t\tassert.True(t, found)\n\t\tassert.Nil(t, err)\n\t})\n\n\tt.Run(\"returns string containing path to system executable when system version set\", func(t *testing.T) {\n\t\t// Create dummy `ls` executable\n\t\tversionStruct := toolversions.Version{Type: \"version\", Value: version}\n\t\tpath := filepath.Join(installs.InstallPath(conf, plugin, versionStruct), \"bin\", \"ls\")\n\t\tassert.Nil(t, os.WriteFile(path, []byte(\"echo 'I'm ls'\"), 0o777))\n\n\t\t// write system version to version file\n\t\ttoolpath := filepath.Join(currentDir, \".tool-versions\")\n\t\tassert.Nil(t, os.WriteFile(toolpath, []byte(\"lua system\\n\"), 0o666))\n\t\tassert.Nil(t, GenerateAll(conf, &stdout, &stderr))\n\n\t\texecutable, gotPlugin, version, found, err := FindExecutable(conf, \"ls\", currentDir)\n\t\tassert.Equal(t, plugin, gotPlugin)\n\t\tassert.Equal(t, version, \"system\")\n\t\tassert.True(t, found)\n\t\tassert.Nil(t, err)\n\n\t\t// see that it actually returns path to system ls\n\t\tassert.Equal(t, filepath.Base(executable), \"ls\")\n\t\tassert.NotEqual(t, executable, path)\n\t})\n\n\tt.Run(\"returns path to executable on path when path version set\", func(t *testing.T) {\n\t\t// write system version to version file\n\t\ttoolpath := filepath.Join(currentDir, \".tool-versions\")\n\t\tdir := installs.InstallPath(conf, plugin, toolversions.Version{Type: \"version\", Value: \"1.1.0\"})\n\t\tpathVersion := fmt.Sprintf(\"path:%s/./\", dir)\n\t\tassert.Nil(t, os.WriteFile(toolpath, []byte(fmt.Sprintf(\"lua %s\\n\", pathVersion)), 0o666))\n\t\tassert.Nil(t, GenerateAll(conf, &stdout, &stderr))\n\n\t\texecutable, gotPlugin, version, found, err := FindExecutable(conf, \"dummy\", currentDir)\n\t\tassert.Equal(t, plugin, gotPlugin)\n\t\tassert.Equal(t, version, pathVersion)\n\t\tassert.True(t, found)\n\t\tassert.Nil(t, err)\n\n\t\t// see that it actually returns path to system ls\n\t\tassert.Equal(t, filepath.Base(executable), \"dummy\")\n\t\tassert.True(t, strings.HasPrefix(executable, dir))\n\t})\n}\n\n\n\nfunc TestGenerateAll(t *testing.T) {\n\tversion := \"1.1.0\"\n\tversion2 := \"2.0.0\"\n\tconf, plugin := generateConfig(t)\n\tinstallVersion(t, conf, plugin, version)\n\tinstallPlugin(t, conf, \"dummy_plugin\", \"ruby\")\n\tinstallVersion(t, conf, plugin, version2)\n\texecutables, err := ToolExecutables(conf, plugin, toolversions.Version{Type: \"version\", Value: version})\n\tassert.Nil(t, err)\n\tstdout, stderr := buildOutputs()\n\n\tt.Run(\"generates shim script for every executable in every version of every tool\", func(t *testing.T) {\n\t\tassert.Nil(t, GenerateAll(conf, &stdout, &stderr))\n\n\t\t// check for generated shims\n\t\tfor _, executable := range executables {\n\t\t\tshimName := filepath.Base(executable)\n\t\t\tshimPath := Path(conf, shimName)\n\t\t\tassert.Nil(t, unix.Access(shimPath, unix.X_OK))\n\n\t\t\t// shim exists and has expected contents\n\t\t\tcontent, err := os.ReadFile(shimPath)\n\t\t\tassert.Nil(t, err)\n\t\t\twant := fmt.Sprintf(\"#!/usr/bin/env bash\\n# asdf-plugin: lua 2.0.0\\n# asdf-plugin: lua 1.1.0\\nexec asdf exec \\\"%s\\\" \\\"$@\\\"\", shimName)\n\t\t\tassert.Equal(t, want, string(content))\n\t\t}\n\t})\n}\n\nfunc TestGenerateForPluginVersions(t *testing.T) {\n\tt.Setenv(\"ASDF_CONFIG_FILE\", \"testdata/asdfrc\")\n\tversion := \"1.1.0\"\n\tversion2 := \"2.0.0\"\n\tconf, plugin := generateConfig(t)\n\tinstallVersion(t, conf, plugin, version)\n\tinstallVersion(t, conf, plugin, version2)\n\texecutables, err := ToolExecutables(conf, plugin, toolversions.Version{Type: \"version\", Value: version})\n\tassert.Nil(t, err)\n\tstdout, stderr := buildOutputs()\n\n\tt.Run(\"generates shim script for every executable in every version the tool\", func(t *testing.T) {\n\t\tassert.Nil(t, GenerateForPluginVersions(conf, plugin, &stdout, &stderr))\n\n\t\t// check for generated shims\n\t\tfor _, executable := range executables {\n\t\t\tshimName := filepath.Base(executable)\n\t\t\tshimPath := Path(conf, shimName)\n\t\t\tassert.Nil(t, unix.Access(shimPath, unix.X_OK))\n\n\t\t\t// shim exists and has expected contents\n\t\t\tcontent, err := os.ReadFile(shimPath)\n\t\t\tassert.Nil(t, err)\n\n\t\t\twant := fmt.Sprintf(\"#!/usr/bin/env bash\\n# asdf-plugin: lua 2.0.0\\n# asdf-plugin: lua 1.1.0\\nexec asdf exec \\\"%s\\\" \\\"$@\\\"\", shimName)\n\t\t\tassert.Equal(t, want, string(content))\n\t\t}\n\t})\n\n\tt.Run(\"runs pre and post reshim hooks\", func(t *testing.T) {\n\t\tstdout, stderr := buildOutputs()\n\t\tassert.Nil(t, GenerateForPluginVersions(conf, plugin, &stdout, &stderr))\n\n\t\twant := \"pre_reshim 1.1.0\\npost_reshim 1.1.0\\npre_reshim 2.0.0\\npost_reshim 2.0.0\\n\"\n\t\tassert.Equal(t, want, stdout.String())\n\t})\n}\n\n\n\n\n\n\n// Helper functions\nfunc buildOutputs() (strings.Builder, strings.Builder) {\n\tvar stdout strings.Builder\n\tvar stderr strings.Builder\n\n\treturn stdout, stderr\n}\n\nfunc generateConfig(t *testing.T) (config.Config, plugins.Plugin) {\n\tt.Helper()\n\ttestDataDir := t.TempDir()\n\tconf, err := config.LoadConfig()\n\tassert.Nil(t, err)\n\tconf.DataDir = testDataDir\n\n\treturn conf, installPlugin(t, conf, \"dummy_plugin\", testPluginName)\n}\n\nfunc installDummyExecPathScript(t *testing.T, conf config.Config, plugin plugins.Plugin, version toolversions.Version, name, script string) {\n\tt.Helper()\n\texecPath := filepath.Join(plugin.Dir, \"bin\", \"exec-path\")\n\tcontents := fmt.Sprintf(\"#!/usr/bin/env bash\\n%s\\n\", script)\n\terr := os.WriteFile(execPath, []byte(contents), 0o777)\n\tassert.Nil(t, err)\n\n\tinstallPath := installs.InstallPath(conf, plugin, version)\n\terr = os.MkdirAll(filepath.Join(installPath, \"bin\", \"custom\"), 0o777)\n\tassert.Nil(t, err)\n\n\terr = os.WriteFile(filepath.Join(installPath, \"bin\", \"custom\", name), []byte{}, 0o777)\n\tassert.Nil(t, err)\n}\n\nfunc installPlugin(t *testing.T, conf config.Config, fixture, pluginName string) plugins.Plugin {\n\t_, err := repotest.InstallPlugin(fixture, conf.DataDir, pluginName)\n\tassert.Nil(t, err)\n\n\treturn plugins.New(conf, pluginName)\n}\n\nfunc installVersion(t *testing.T, conf config.Config, plugin plugins.Plugin, version string) {\n\tt.Helper()\n\terr := installtest.InstallOneVersion(conf, plugin, \"version\", version)\n\tassert.Nil(t, err)\n}\n"
