[meta]
task = "repair"
scenario = "repair_no_new_covered_logic"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "mathLab/PINA"
sha = "03ef90c358d3f5802db96b0092d5c874bd7c0636"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "(pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=pina/label_tensor.py -m pytest -q --junit-xml=test_output.xml tests/test_label_tensor/test_label_tensor.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target pina.label_tensor --unit-test tests.test_label_tensor.test_label_tensor --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target pina/label_tensor.py --unit-test tests/test_label_tensor/test_label_tensor.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 76.0
original_coverage = 76.0
mutation_kill_rate = 84.0
original_mutation_kill_rate = 84.0
covered_lines = [ 2, 3, 4, 7, 13, 14, 28, 29, 30, 32, 33, 42, 44, 76, 77, 78, 82, 83, 91, 92, 93, 94, 95, 97, 98, 100, 101, 108, 110, 111, 118, 119, 122, 123, 137, 138, 139, 140, 141, 142, 149, 159, 161, 163, 165, 166, 171, 172, 173, 174, 175, 177, 178, 179, 180, 185, 198, 200, 210, 213, 215, 241, 242, 243, 244, 254, 255, 257, 260, 261, 262, 265, 266, 267, 268, 271, 277, 278, 284, 285, 286, 288, 289, 290, 292, 294, 296, 306, 307, 308, 309, 310, 311, 313, 314, 330, 332, 336, 337, 341, 342, 343, 353, 356, 357, 358, 359, 361, 364, 365, 367, 368, 389, 407, 408, 419, 433, 448, 469, 471, 474, 475, 477, 478, 479, 480, 481, 482, 485, 488, 491, 492, 504, 507, 522, 523, 525, 528, 534, 536, 537, 538, 552, 571, 578, 579, 582, 583, 586, 587, 590, 591, 592, 593, 595, 596, 602, 608, 611, 612, 614, 625, 626, 628, 629, 630, 632, 633, 635, 637, 638, 640, 655, 677, 693, 694, 711, 714, 718, 719, 722, 723, 724, 727, 730, 731, 736, 738,]
missed_lines = [ 80, 120, 143, 144, 145, 147, 164, 176, 181, 187, 192, 272, 279, 331, 333, 347, 381, 384, 385, 386, 387, 403, 404, 405, 417, 429, 430, 431, 443, 446, 489, 526, 529, 547, 575, 580, 594, 603, 607, 631, 651, 652, 653, 666, 669, 670, 671, 674, 675, 686, 689, 690, 691, 712, 715, 751, 752, 753, 754, 755,]

[input_info]
test_file_path = "tests/test_label_tensor/test_label_tensor.py"
focal_file_path = "pina/label_tensor.py"
test_file_url = "https://github.com/mathLab/PINA/blob/03ef90c358d3f5802db96b0092d5c874bd7c0636/tests/test_label_tensor/test_label_tensor.py"
focal_file_url = "https://github.com/mathLab/PINA/blob/03ef90c358d3f5802db96b0092d5c874bd7c0636/pina/label_tensor.py"
first_commit_date = "2021-11-29"
last_commit_date = "2025-03-19"
test_file_content = "import torch\nimport pytest\n\nfrom pina.label_tensor import LabelTensor\n\ndata = torch.rand((20, 3))\nlabels_column = {1: {\"name\": \"space\", \"dof\": [\"x\", \"y\", \"z\"]}}\nlabels_row = {0: {\"name\": \"samples\", \"dof\": range(20)}}\nlabels_list = [\"x\", \"y\", \"z\"]\nlabels_all = labels_column.copy()\nlabels_all.update(labels_row)\n\n\n@pytest.mark.parametrize(\n    \"labels\", [labels_column, labels_row, labels_all, labels_list]\n)\ndef test_constructor(labels):\n    print(LabelTensor(data, labels))\n\n\ndef test_wrong_constructor():\n    with pytest.raises(ValueError):\n        LabelTensor(data, [\"a\", \"b\"])\n\n\n@pytest.mark.parametrize(\"labels\", [labels_column, labels_all])\n@pytest.mark.parametrize(\"labels_te\", [\"z\", [\"z\"], {\"space\": [\"z\"]}])\ndef test_extract_column(labels, labels_te):\n    tensor = LabelTensor(data, labels)\n    new = tensor.extract(labels_te)\n    assert new.ndim == tensor.ndim\n    assert new.shape[1] == 1\n    assert new.shape[0] == 20\n    assert torch.all(torch.isclose(data[:, 2].reshape(-1, 1), new))\n\n\n@pytest.mark.parametrize(\"labels\", [labels_row, labels_all])\n@pytest.mark.parametrize(\"labels_te\", [{\"samples\": [2]}])\ndef test_extract_row(labels, labels_te):\n    tensor = LabelTensor(data, labels)\n    new = tensor.extract(labels_te)\n    assert new.ndim == tensor.ndim\n    assert new.shape[1] == 3\n    assert new.shape[0] == 1\n    assert torch.all(torch.isclose(data[2].reshape(1, -1), new))\n\n\n@pytest.mark.parametrize(\n    \"labels_te\",\n    [{\"samples\": [2], \"space\": [\"z\"]}, {\"space\": \"z\", \"samples\": 2}],\n)\ndef test_extract_2D(labels_te):\n    labels = labels_all\n    tensor = LabelTensor(data, labels)\n    new = tensor.extract(labels_te)\n    assert new.ndim == tensor.ndim\n    assert new.shape[1] == 1\n    assert new.shape[0] == 1\n    assert torch.all(torch.isclose(data[2, 2].reshape(1, 1), new))\n\n\ndef test_extract_3D():\n    data = torch.rand(20, 3, 4)\n    labels = {\n        1: {\"name\": \"space\", \"dof\": [\"x\", \"y\", \"z\"]},\n        2: {\"name\": \"time\", \"dof\": range(4)},\n    }\n    labels_te = {\"space\": [\"x\", \"z\"], \"time\": range(1, 4)}\n\n    tensor = LabelTensor(data, labels)\n    new = tensor.extract(labels_te)\n    tensor2 = LabelTensor(data, labels)\n    assert new.ndim == tensor.ndim\n    assert new.shape[0] == 20\n    assert new.shape[1] == 2\n    assert new.shape[2] == 3\n    assert torch.all(torch.isclose(data[:, 0::2, 1:4].reshape(20, 2, 3), new))\n    assert tensor2.ndim == tensor.ndim\n    assert tensor2.shape == tensor.shape\n    assert tensor.full_labels == tensor2.full_labels\n    assert new.shape != tensor.shape\n\n\ndef test_concatenation_3D():\n    data_1 = torch.rand(20, 3, 4)\n    labels_1 = [\"x\", \"y\", \"z\", \"w\"]\n    lt1 = LabelTensor(data_1, labels_1)\n    data_2 = torch.rand(50, 3, 4)\n    labels_2 = [\"x\", \"y\", \"z\", \"w\"]\n    lt2 = LabelTensor(data_2, labels_2)\n    lt_cat = LabelTensor.cat([lt1, lt2])\n    assert lt_cat.shape == (70, 3, 4)\n    assert lt_cat.full_labels[0][\"dof\"] == range(70)\n    assert lt_cat.full_labels[1][\"dof\"] == range(3)\n    assert lt_cat.full_labels[2][\"dof\"] == [\"x\", \"y\", \"z\", \"w\"]\n\n    data_1 = torch.rand(20, 3, 4)\n    labels_1 = [\"x\", \"y\", \"z\", \"w\"]\n    lt1 = LabelTensor(data_1, labels_1)\n    data_2 = torch.rand(20, 2, 4)\n    labels_2 = [\"x\", \"y\", \"z\", \"w\"]\n    lt2 = LabelTensor(data_2, labels_2)\n    lt_cat = LabelTensor.cat([lt1, lt2], dim=1)\n    assert lt_cat.shape == (20, 5, 4)\n    assert lt_cat.full_labels[0][\"dof\"] == range(20)\n    assert lt_cat.full_labels[1][\"dof\"] == range(5)\n    assert lt_cat.full_labels[2][\"dof\"] == [\"x\", \"y\", \"z\", \"w\"]\n\n    data_1 = torch.rand(20, 3, 2)\n    labels_1 = [\"x\", \"y\"]\n    lt1 = LabelTensor(data_1, labels_1)\n    data_2 = torch.rand(20, 3, 3)\n    labels_2 = [\"z\", \"w\", \"a\"]\n    lt2 = LabelTensor(data_2, labels_2)\n    lt_cat = LabelTensor.cat([lt1, lt2], dim=2)\n    assert lt_cat.shape == (20, 3, 5)\n    assert lt_cat.full_labels[2][\"dof\"] == [\"x\", \"y\", \"z\", \"w\", \"a\"]\n    assert lt_cat.full_labels[0][\"dof\"] == range(20)\n    assert lt_cat.full_labels[1][\"dof\"] == range(3)\n\n    data_1 = torch.rand(20, 2, 4)\n    labels_1 = [\"x\", \"y\", \"z\", \"w\"]\n    lt1 = LabelTensor(data_1, labels_1)\n    data_2 = torch.rand(20, 3, 4)\n    labels_2 = [\"x\", \"y\", \"z\", \"w\"]\n    lt2 = LabelTensor(data_2, labels_2)\n    with pytest.raises(RuntimeError):\n        LabelTensor.cat([lt1, lt2], dim=2)\n    data_1 = torch.rand(20, 3, 2)\n    labels_1 = [\"x\", \"y\"]\n    lt1 = LabelTensor(data_1, labels_1)\n    data_2 = torch.rand(20, 3, 3)\n    labels_2 = [\"z\", \"w\", \"a\"]\n    lt2 = LabelTensor(data_2, labels_2)\n    lt_cat = LabelTensor.cat([lt1, lt2], dim=2)\n    assert lt_cat.shape == (20, 3, 5)\n    assert lt_cat.full_labels[2][\"dof\"] == [\"x\", \"y\", \"z\", \"w\", \"a\"]\n    assert lt_cat.full_labels[0][\"dof\"] == range(20)\n    assert lt_cat.full_labels[1][\"dof\"] == range(3)\n\n\ndef test_summation():\n    lt1 = LabelTensor(torch.ones(20, 3), labels_all)\n    lt2 = LabelTensor(torch.ones(30, 3), [\"x\", \"y\", \"z\"])\n    with pytest.raises(RuntimeError):\n        LabelTensor.summation([lt1, lt2])\n    lt1 = LabelTensor(torch.ones(20, 3), labels_all)\n    lt2 = LabelTensor(torch.ones(20, 3), labels_all)\n    lt_sum = LabelTensor.summation([lt1, lt2])\n    assert lt_sum.ndim == lt_sum.ndim\n    assert lt_sum.shape[0] == 20\n    assert lt_sum.shape[1] == 3\n    assert lt_sum.full_labels[0] == labels_all[0]\n    assert lt_sum.labels == [\"x+x\", \"y+y\", \"z+z\"]\n    assert torch.eq(lt_sum.tensor, torch.ones(20, 3) * 2).all()\n    lt1 = LabelTensor(torch.ones(20, 3), labels_all)\n    lt2 = LabelTensor(torch.ones(20, 3), labels_all)\n    lt3 = LabelTensor(torch.zeros(20, 3), labels_all)\n    lt_sum = LabelTensor.summation([lt1, lt2, lt3])\n    assert lt_sum.ndim == lt_sum.ndim\n    assert lt_sum.shape[0] == 20\n    assert lt_sum.shape[1] == 3\n    assert lt_sum.full_labels[0] == labels_all[0]\n    assert lt_sum.labels == [\"x+x+x\", \"y+y+y\", \"z+z+z\"]\n    assert torch.eq(lt_sum.tensor, torch.ones(20, 3) * 2).all()\n\n\ndef test_append_3D():\n    data_1 = torch.rand(20, 3, 2)\n    labels_1 = [\"x\", \"y\"]\n    lt1 = LabelTensor(data_1, labels_1)\n    data_2 = torch.rand(20, 3, 2)\n    labels_2 = [\"z\", \"w\"]\n    lt2 = LabelTensor(data_2, labels_2)\n    lt1 = lt1.append(lt2)\n    assert lt1.shape == (20, 3, 4)\n    assert lt1.full_labels[0][\"dof\"] == range(20)\n    assert lt1.full_labels[1][\"dof\"] == range(3)\n    assert lt1.full_labels[2][\"dof\"] == [\"x\", \"y\", \"z\", \"w\"]\n\n\ndef test_append_2D():\n    data_1 = torch.rand(20, 2)\n    labels_1 = [\"x\", \"y\"]\n    lt1 = LabelTensor(data_1, labels_1)\n    data_2 = torch.rand(20, 2)\n    labels_2 = [\"z\", \"w\"]\n    lt2 = LabelTensor(data_2, labels_2)\n    lt1 = lt1.append(lt2, mode=\"cross\")\n    assert lt1.shape == (400, 4)\n    assert lt1.full_labels[0][\"dof\"] == range(400)\n    assert lt1.full_labels[1][\"dof\"] == [\"x\", \"y\", \"z\", \"w\"]\n\n\ndef test_vstack_3D():\n    data_1 = torch.rand(20, 3, 2)\n    labels_1 = {\n        1: {\"dof\": [\"a\", \"b\", \"c\"], \"name\": \"first\"},\n        2: {\"dof\": [\"x\", \"y\"], \"name\": \"second\"},\n    }\n    lt1 = LabelTensor(data_1, labels_1)\n    data_2 = torch.rand(20, 3, 2)\n    labels_1 = {\n        1: {\"dof\": [\"a\", \"b\", \"c\"], \"name\": \"first\"},\n        2: {\"dof\": [\"x\", \"y\"], \"name\": \"second\"},\n    }\n    lt2 = LabelTensor(data_2, labels_1)\n    lt_stacked = LabelTensor.vstack([lt1, lt2])\n    assert lt_stacked.shape == (40, 3, 2)\n    assert lt_stacked.full_labels[0][\"dof\"] == range(40)\n    assert lt_stacked.full_labels[1][\"dof\"] == [\"a\", \"b\", \"c\"]\n    assert lt_stacked.full_labels[2][\"dof\"] == [\"x\", \"y\"]\n    assert lt_stacked.full_labels[1][\"name\"] == \"first\"\n    assert lt_stacked.full_labels[2][\"name\"] == \"second\"\n\n\ndef test_vstack_2D():\n    data_1 = torch.rand(20, 2)\n    labels_1 = {1: {\"dof\": [\"x\", \"y\"], \"name\": \"second\"}}\n    lt1 = LabelTensor(data_1, labels_1)\n    data_2 = torch.rand(20, 2)\n    labels_1 = {1: {\"dof\": [\"x\", \"y\"], \"name\": \"second\"}}\n    lt2 = LabelTensor(data_2, labels_1)\n    lt_stacked = LabelTensor.vstack([lt1, lt2])\n    assert lt_stacked.shape == (40, 2)\n    assert lt_stacked.full_labels[0][\"dof\"] == range(40)\n    assert lt_stacked.full_labels[1][\"dof\"] == [\"x\", \"y\"]\n    assert lt_stacked.full_labels[0][\"name\"] == 0\n    assert lt_stacked.full_labels[1][\"name\"] == \"second\"\n\n\ndef test_sorting():\n    data = torch.ones(20, 5)\n    data[:, 0] = data[:, 0] * 4\n    data[:, 1] = data[:, 1] * 2\n    data[:, 2] = data[:, 2]\n    data[:, 3] = data[:, 3] * 5\n    data[:, 4] = data[:, 4] * 3\n    labels = [\"d\", \"b\", \"a\", \"e\", \"c\"]\n    lt_data = LabelTensor(data, labels)\n    lt_sorted = LabelTensor.sort_labels(lt_data)\n    assert lt_sorted.shape == (20, 5)\n    assert lt_sorted.labels == [\"a\", \"b\", \"c\", \"d\", \"e\"]\n    assert torch.eq(lt_sorted.tensor[:, 0], torch.ones(20) * 1).all()\n    assert torch.eq(lt_sorted.tensor[:, 1], torch.ones(20) * 2).all()\n    assert torch.eq(lt_sorted.tensor[:, 2], torch.ones(20) * 3).all()\n    assert torch.eq(lt_sorted.tensor[:, 3], torch.ones(20) * 4).all()\n    assert torch.eq(lt_sorted.tensor[:, 4], torch.ones(20) * 5).all()\n\n    data = torch.ones(20, 4, 5)\n    data[:, 0, :] = data[:, 0] * 4\n    data[:, 1, :] = data[:, 1] * 2\n    data[:, 2, :] = data[:, 2]\n    data[:, 3, :] = data[:, 3] * 3\n    labels = {1: {\"dof\": [\"d\", \"b\", \"a\", \"c\"], \"name\": 1}}\n    lt_data = LabelTensor(data, labels)\n    lt_sorted = LabelTensor.sort_labels(lt_data, dim=1)\n    assert lt_sorted.shape == (20, 4, 5)\n    assert lt_sorted.full_labels[1][\"dof\"] == [\"a\", \"b\", \"c\", \"d\"]\n    assert torch.eq(lt_sorted.tensor[:, 0, :], torch.ones(20, 5) * 1).all()\n    assert torch.eq(lt_sorted.tensor[:, 1, :], torch.ones(20, 5) * 2).all()\n    assert torch.eq(lt_sorted.tensor[:, 2, :], torch.ones(20, 5) * 3).all()\n    assert torch.eq(lt_sorted.tensor[:, 3, :], torch.ones(20, 5) * 4).all()\n\n\n@pytest.mark.parametrize(\n    \"labels\",\n    [\n        [f\"s{i}\" for i in range(10)],\n        {0: {\"dof\": [\"a\", \"b\", \"c\"]}, 1: {\"dof\": [f\"s{i}\" for i in range(10)]}},\n    ],\n)\ndef test_cat_bool(labels):\n    out = torch.randn((3, 10))\n    out = LabelTensor(out, labels)\n    selected = out[torch.tensor([True, True, False])]\n    assert selected.shape == (2, 10)\n    assert selected.stored_labels[1][\"dof\"] == [f\"s{i}\" for i in range(10)]\n    if isinstance(labels, dict):\n        assert selected.stored_labels[0][\"dof\"] == [\"a\", \"b\"]\n\n\ndef test_vertical_stack():\n    data_1 = torch.rand(20, 3, 2)\n    labels_1 = {\n        1: {\"dof\": [\"a\", \"b\", \"c\"], \"name\": \"first\"},\n        2: {\"dof\": [\"x\", \"y\"], \"name\": \"second\"},\n    }\n    lt1 = LabelTensor(data_1, labels_1)\n    data_2 = torch.rand(20, 3, 2)\n    labels_2 = {\n        1: {\"dof\": [\"a\", \"b\", \"c\"], \"name\": \"first\"},\n        2: {\"dof\": [\"x\", \"y\"], \"name\": \"second\"},\n    }\n    lt2 = LabelTensor(data_2, labels_2)\n    lt_stacked = LabelTensor.vstack([lt1, lt2])\n    assert lt_stacked.shape == (40, 3, 2)\n    assert lt_stacked.full_labels[0][\"dof\"] == range(40)\n    assert lt_stacked.full_labels[1][\"dof\"] == [\"a\", \"b\", \"c\"]\n    assert lt_stacked.full_labels[1][\"name\"] == \"first\"\n\n\ndef test_label_order():\n    data = torch.ones(20, 5)\n    data[:, 0] = data[:, 0] * 5\n    data[:, 1] = data[:, 1] * 3\n    data[:, 2] = data[:, 2]\n    data[:, 3] = data[:, 3] * 4\n    data[:, 4] = data[:, 4] * 2\n    labels = [\"e\", \"c\", \"a\", \"d\", \"b\"]\n    lt_data = LabelTensor(data, labels)\n    lt_sorted = lt_data.sort_labels()\n    assert lt_sorted.shape == (20, 5)\n    assert lt_sorted.labels == [\"a\", \"b\", \"c\", \"d\", \"e\"]\n    assert torch.eq(lt_sorted.tensor[:, 0], torch.ones(20) * 1).all()\n    assert torch.eq(lt_sorted.tensor[:, 1], torch.ones(20) * 2).all()\n    assert torch.eq(lt_sorted.tensor[:, 2], torch.ones(20) * 3).all()\n    assert torch.eq(lt_sorted.tensor[:, 3], torch.ones(20) * 4).all()\n    assert torch.eq(lt_sorted.tensor[:, 4], torch.ones(20) * 5).all()"
