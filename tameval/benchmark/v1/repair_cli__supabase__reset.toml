[meta]
task = "repair"
scenario = "repair_invalid_constructor"

[lang_info]
lang = "Go"
go_version = "1.23.2"

[repo_info]
repository = "supabase/cli"
sha = "418caee001449f782a775b0f13af09b25dd581da"

[run_info]
docker_image = "golang:1.23.2"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/db/reset/reset.go internal/db/reset/reset_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/db/reset/reset.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 66.0
mutation_kill_rate = 0.0
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "internal/db/reset/reset_test.go"
focal_file_path = "internal/db/reset/reset.go"
test_file_url = "https://github.com/supabase/cli/blob/418caee001449f782a775b0f13af09b25dd581da/internal/db/reset/reset_test.go"
focal_file_url = "https://github.com/supabase/cli/blob/418caee001449f782a775b0f13af09b25dd581da/internal/db/reset/reset.go"
first_commit_date = "2021-11-25"
last_commit_date = "2025-01-31"
test_file_content = "package reset\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/docker/docker/api/types\"\n\t\"github.com/docker/docker/api/types/container\"\n\t\"github.com/h2non/gock\"\n\t\"github.com/jackc/pgconn\"\n\t\"github.com/jackc/pgerrcode\"\n\t\"github.com/spf13/afero\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/supabase/cli/internal/db/start\"\n\t\"github.com/supabase/cli/internal/testing/apitest\"\n\t\"github.com/supabase/cli/internal/testing/fstest\"\n\t\"github.com/supabase/cli/internal/testing/helper\"\n\t\"github.com/supabase/cli/internal/utils\"\n\t\"github.com/supabase/cli/pkg/migration\"\n\t\"github.com/supabase/cli/pkg/pgtest\"\n\t\"github.com/supabase/cli/pkg/storage\"\n)\n\nfunc TestResetCommand(t *testing.T) {\n\tutils.Config.Hostname = \"127.0.0.1\"\n\tutils.Config.Db.Port = 5432\n\n\tvar dbConfig = pgconn.Config{\n\t\tHost:     utils.Config.Hostname,\n\t\tPort:     utils.Config.Db.Port,\n\t\tUser:     \"admin\",\n\t\tPassword: \"password\",\n\t\tDatabase: \"postgres\",\n\t}\n\n\tt.Run(\"seeds storage after reset\", func(t *testing.T) {\n\t\tutils.DbId = \"test-reset\"\n\t\tutils.ConfigId = \"test-config\"\n\t\tutils.Config.Db.MajorVersion = 15\n\t\t// Setup in-memory fs\n\t\tfsys := afero.NewMemMapFs()\n\t\t// Setup mock docker\n\t\trequire.NoError(t, apitest.MockDocker(utils.Docker))\n\t\tdefer gock.OffAll()\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tGet(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + utils.DbId).\n\t\t\tReply(http.StatusOK).\n\t\t\tJSON(container.InspectResponse{})\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tDelete(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + utils.DbId).\n\t\t\tReply(http.StatusOK)\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tDelete(\"/v\" + utils.Docker.ClientVersion() + \"/volumes/\" + utils.DbId).\n\t\t\tReply(http.StatusOK)\n\t\tapitest.MockDockerStart(utils.Docker, utils.GetRegistryImageUrl(utils.Config.Db.Image), utils.DbId)\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tGet(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + utils.DbId + \"/json\").\n\t\t\tReply(http.StatusOK).\n\t\t\tJSON(container.InspectResponse{ContainerJSONBase: &container.ContainerJSONBase{\n\t\t\t\tState: &container.State{\n\t\t\t\t\tRunning: true,\n\t\t\t\t\tHealth:  &container.Health{Status: types.Healthy},\n\t\t\t\t},\n\t\t\t}})\n\t\t// Setup mock postgres\n\t\tconn := pgtest.NewConn()\n\t\tdefer conn.Close(t)\n\t\t// Restarts services\n\t\tutils.StorageId = \"test-storage\"\n\t\tutils.GotrueId = \"test-auth\"\n\t\tutils.RealtimeId = \"test-realtime\"\n\t\tutils.PoolerId = \"test-pooler\"\n\t\tfor _, container := range listServicesToRestart() {\n\t\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\t\tPost(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + container + \"/restart\").\n\t\t\t\tReply(http.StatusOK)\n\t\t}\n\t\t// Seeds storage\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tGet(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + utils.StorageId + \"/json\").\n\t\t\tReply(http.StatusOK).\n\t\t\tJSON(container.InspectResponse{ContainerJSONBase: &container.ContainerJSONBase{\n\t\t\t\tState: &container.State{\n\t\t\t\t\tRunning: true,\n\t\t\t\t\tHealth:  &container.Health{Status: types.Healthy},\n\t\t\t\t},\n\t\t\t}})\n\t\tgock.New(utils.Config.Api.ExternalUrl).\n\t\t\tGet(\"/storage/v1/bucket\").\n\t\t\tReply(http.StatusOK).\n\t\t\tJSON([]storage.BucketResponse{})\n\t\t// Run test\n\t\terr := Run(context.Background(), \"\", dbConfig, fsys, conn.Intercept)\n\t\t// Check error\n\t\tassert.NoError(t, err)\n\t\tassert.Empty(t, apitest.ListUnmatchedRequests())\n\t})\n\n\tt.Run(\"throws error on context canceled\", func(t *testing.T) {\n\t\t// Setup in-memory fs\n\t\tfsys := afero.NewMemMapFs()\n\t\t// Run test\n\t\terr := Run(context.Background(), \"\", pgconn.Config{Host: \"db.supabase.co\"}, fsys)\n\t\t// Check error\n\t\tassert.ErrorIs(t, err, context.Canceled)\n\t})\n\n\tt.Run(\"throws error on invalid port\", func(t *testing.T) {\n\t\tt.Cleanup(fstest.MockStdin(t, \"y\"))\n\t\t// Setup in-memory fs\n\t\tfsys := afero.NewMemMapFs()\n\t\t// Run test\n\t\terr := Run(context.Background(), \"\", pgconn.Config{Host: \"db.supabase.co\"}, fsys)\n\t\t// Check error\n\t\tassert.ErrorContains(t, err, \"invalid port (outside range)\")\n\t})\n\n\tt.Run(\"throws error on db is not started\", func(t *testing.T) {\n\t\t// Setup in-memory fs\n\t\tfsys := afero.NewMemMapFs()\n\t\t// Setup mock docker\n\t\trequire.NoError(t, apitest.MockDocker(utils.Docker))\n\t\tdefer gock.OffAll()\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tGet(\"/v\" + utils.Docker.ClientVersion() + \"/containers\").\n\t\t\tReply(http.StatusNotFound)\n\t\t// Run test\n\t\terr := Run(context.Background(), \"\", dbConfig, fsys)\n\t\t// Check error\n\t\tassert.ErrorIs(t, err, utils.ErrNotRunning)\n\t\tassert.Empty(t, apitest.ListUnmatchedRequests())\n\t})\n\n\tt.Run(\"throws error on failure to recreate\", func(t *testing.T) {\n\t\tutils.DbId = \"test-reset\"\n\t\tutils.Config.Db.MajorVersion = 15\n\t\t// Setup in-memory fs\n\t\tfsys := afero.NewMemMapFs()\n\t\t// Setup mock docker\n\t\trequire.NoError(t, apitest.MockDocker(utils.Docker))\n\t\tdefer gock.OffAll()\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tGet(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + utils.DbId).\n\t\t\tReply(http.StatusOK).\n\t\t\tJSON(container.InspectResponse{})\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tDelete(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + utils.DbId).\n\t\t\tReplyError(errors.New(\"network error\"))\n\t\t// Run test\n\t\terr := Run(context.Background(), \"\", dbConfig, fsys)\n\t\t// Check error\n\t\tassert.ErrorContains(t, err, \"network error\")\n\t\tassert.Empty(t, apitest.ListUnmatchedRequests())\n\t})\n}\n\nfunc TestInitDatabase(t *testing.T) {\n\tt.Run(\"initializes postgres database\", func(t *testing.T) {\n\t\tutils.Config.Db.Port = 54322\n\t\tutils.InitialSchemaPg14Sql = \"create schema private\"\n\t\t// Setup mock postgres\n\t\tconn := pgtest.NewConn()\n\t\tdefer conn.Close(t)\n\t\tconn.Query(utils.InitialSchemaPg14Sql).\n\t\t\tReply(\"CREATE SCHEMA\")\n\t\t// Run test\n\t\tassert.NoError(t, initDatabase(context.Background(), conn.Intercept))\n\t})\n\n\tt.Run(\"throws error on connect failure\", func(t *testing.T) {\n\t\tutils.Config.Db.Port = 0\n\t\t// Run test\n\t\terr := initDatabase(context.Background())\n\t\t// Check error\n\t\tassert.ErrorContains(t, err, \"invalid port (outside range)\")\n\t})\n\n\tt.Run(\"throws error on duplicate schema\", func(t *testing.T) {\n\t\tutils.Config.Db.Port = 54322\n\t\tutils.InitialSchemaPg14Sql = \"create schema private\"\n\t\t// Setup mock postgres\n\t\tconn := pgtest.NewConn()\n\t\tdefer conn.Close(t)\n\t\tconn.Query(utils.InitialSchemaPg14Sql).\n\t\t\tReplyError(pgerrcode.DuplicateSchema, `schema \"public\" already exists`)\n\t\t// Run test\n\t\terr := initDatabase(context.Background(), conn.Intercept)\n\t\t// Check error\n\t\tassert.ErrorContains(t, err, `ERROR: schema \"public\" already exists (SQLSTATE 42P06)`)\n\t})\n}\n\nfunc TestRecreateDatabase(t *testing.T) {\n\tt.Run(\"resets postgres database\", func(t *testing.T) {\n\t\tutils.Config.Db.Port = 54322\n\t\t// Setup mock postgres\n\t\tconn := pgtest.NewConn()\n\t\tdefer conn.Close(t)\n\t\tconn.Query(\"ALTER DATABASE postgres ALLOW_CONNECTIONS false\").\n\t\t\tReply(\"ALTER DATABASE\").\n\t\t\tQuery(\"ALTER DATABASE _supabase ALLOW_CONNECTIONS false\").\n\t\t\tReply(\"ALTER DATABASE\").\n\t\t\tQuery(TERMINATE_BACKENDS).\n\t\t\tReply(\"SELECT 1\").\n\t\t\tQuery(COUNT_REPLICATION_SLOTS).\n\t\t\tReply(\"SELECT 1\", []interface{}{0}).\n\t\t\tQuery(\"DROP DATABASE IF EXISTS postgres WITH (FORCE)\").\n\t\t\tReply(\"DROP DATABASE\").\n\t\t\tQuery(\"CREATE DATABASE postgres WITH OWNER postgres\").\n\t\t\tReply(\"CREATE DATABASE\").\n\t\t\tQuery(\"DROP DATABASE IF EXISTS _supabase WITH (FORCE)\").\n\t\t\tReply(\"DROP DATABASE\").\n\t\t\tQuery(\"CREATE DATABASE _supabase WITH OWNER postgres\").\n\t\t\tReply(\"CREATE DATABASE\")\n\t\t// Run test\n\t\tassert.NoError(t, recreateDatabase(context.Background(), conn.Intercept))\n\t})\n\n\tt.Run(\"throws error on invalid port\", func(t *testing.T) {\n\t\tutils.Config.Db.Port = 0\n\t\tassert.ErrorContains(t, recreateDatabase(context.Background()), \"invalid port\")\n\t})\n\n\tt.Run(\"continues on disconnecting missing database\", func(t *testing.T) {\n\t\tutils.Config.Db.Port = 54322\n\t\t// Setup mock postgres\n\t\tconn := pgtest.NewConn()\n\t\tdefer conn.Close(t)\n\t\tconn.Query(\"ALTER DATABASE postgres ALLOW_CONNECTIONS false\").\n\t\t\tReply(\"ALTER DATABASE\").\n\t\t\tQuery(\"ALTER DATABASE _supabase ALLOW_CONNECTIONS false\").\n\t\t\tReplyError(pgerrcode.InvalidCatalogName, `database \"_supabase\" does not exist`).\n\t\t\tQuery(TERMINATE_BACKENDS).\n\t\t\tQuery(COUNT_REPLICATION_SLOTS).\n\t\t\tReplyError(pgerrcode.UndefinedTable, `relation \"pg_replication_slots\" does not exist`)\n\t\t// Run test\n\t\terr := recreateDatabase(context.Background(), conn.Intercept)\n\t\t// Check error\n\t\tassert.ErrorContains(t, err, `ERROR: relation \"pg_replication_slots\" does not exist (SQLSTATE 42P01)`)\n\t})\n\n\tt.Run(\"throws error on failure to disconnect\", func(t *testing.T) {\n\t\tutils.Config.Db.Port = 54322\n\t\t// Setup mock postgres\n\t\tconn := pgtest.NewConn()\n\t\tdefer conn.Close(t)\n\t\tconn.Query(\"ALTER DATABASE postgres ALLOW_CONNECTIONS false\").\n\t\t\tReplyError(pgerrcode.InvalidParameterValue, `cannot disallow connections for current database`).\n\t\t\tQuery(\"ALTER DATABASE _supabase ALLOW_CONNECTIONS false\").\n\t\t\tQuery(TERMINATE_BACKENDS)\n\t\t// Run test\n\t\terr := recreateDatabase(context.Background(), conn.Intercept)\n\t\t// Check error\n\t\tassert.ErrorContains(t, err, \"ERROR: cannot disallow connections for current database (SQLSTATE 22023)\")\n\t})\n\n\tt.Run(\"throws error on failure to drop\", func(t *testing.T) {\n\t\tutils.Config.Db.Port = 54322\n\t\t// Setup mock postgres\n\t\tconn := pgtest.NewConn()\n\t\tdefer conn.Close(t)\n\t\tconn.Query(\"ALTER DATABASE postgres ALLOW_CONNECTIONS false\").\n\t\t\tReply(\"ALTER DATABASE\").\n\t\t\tQuery(\"ALTER DATABASE _supabase ALLOW_CONNECTIONS false\").\n\t\t\tReply(\"ALTER DATABASE\").\n\t\t\tQuery(TERMINATE_BACKENDS).\n\t\t\tReply(\"SELECT 1\").\n\t\t\tQuery(COUNT_REPLICATION_SLOTS).\n\t\t\tReply(\"SELECT 1\", []interface{}{0}).\n\t\t\tQuery(\"DROP DATABASE IF EXISTS postgres WITH (FORCE)\").\n\t\t\tReplyError(pgerrcode.ObjectInUse, `database \"postgres\" is used by an active logical replication slot`).\n\t\t\tQuery(\"CREATE DATABASE postgres WITH OWNER postgres\").\n\t\t\tQuery(\"DROP DATABASE IF EXISTS _supabase WITH (FORCE)\").\n\t\t\tReply(\"DROP DATABASE\").\n\t\t\tQuery(\"CREATE DATABASE _supabase WITH OWNER postgres\").\n\t\t\tReply(\"CREATE DATABASE\")\n\t\terr := recreateDatabase(context.Background(), conn.Intercept)\n\t\t// Check error\n\t\tassert.ErrorContains(t, err, `ERROR: database \"postgres\" is used by an active logical replication slot (SQLSTATE 55006)`)\n\t})\n}\n\nfunc TestRestartDatabase(t *testing.T) {\n\tt.Run(\"restarts affected services\", func(t *testing.T) {\n\t\tutils.DbId = \"test-reset\"\n\t\t// Setup mock docker\n\t\trequire.NoError(t, apitest.MockDocker(utils.Docker))\n\t\tdefer gock.OffAll()\n\t\t// Restarts postgres\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tPost(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + utils.DbId + \"/restart\").\n\t\t\tReply(http.StatusOK)\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tGet(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + utils.DbId + \"/json\").\n\t\t\tReply(http.StatusOK).\n\t\t\tJSON(container.InspectResponse{ContainerJSONBase: &container.ContainerJSONBase{\n\t\t\t\tState: &container.State{\n\t\t\t\t\tRunning: true,\n\t\t\t\t\tHealth:  &container.Health{Status: types.Healthy},\n\t\t\t\t},\n\t\t\t}})\n\t\t// Restarts services\n\t\tutils.StorageId = \"test-storage\"\n\t\tutils.GotrueId = \"test-auth\"\n\t\tutils.RealtimeId = \"test-realtime\"\n\t\tutils.PoolerId = \"test-pooler\"\n\t\tfor _, container := range listServicesToRestart() {\n\t\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\t\tPost(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + container + \"/restart\").\n\t\t\t\tReply(http.StatusOK)\n\t\t}\n\t\t// Run test\n\t\terr := RestartDatabase(context.Background(), io.Discard)\n\t\t// Check error\n\t\tassert.NoError(t, err)\n\t\tassert.Empty(t, apitest.ListUnmatchedRequests())\n\t})\n\n\tt.Run(\"throws error on service restart failure\", func(t *testing.T) {\n\t\tutils.DbId = \"test-reset\"\n\t\t// Setup mock docker\n\t\trequire.NoError(t, apitest.MockDocker(utils.Docker))\n\t\tdefer gock.OffAll()\n\t\t// Restarts postgres\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tPost(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + utils.DbId + \"/restart\").\n\t\t\tReply(http.StatusOK)\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tGet(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + utils.DbId + \"/json\").\n\t\t\tReply(http.StatusOK).\n\t\t\tJSON(container.InspectResponse{ContainerJSONBase: &container.ContainerJSONBase{\n\t\t\t\tState: &container.State{\n\t\t\t\t\tRunning: true,\n\t\t\t\t\tHealth:  &container.Health{Status: types.Healthy},\n\t\t\t\t},\n\t\t\t}})\n\t\t// Restarts services\n\t\tutils.StorageId = \"test-storage\"\n\t\tutils.GotrueId = \"test-auth\"\n\t\tutils.RealtimeId = \"test-realtime\"\n\t\tutils.PoolerId = \"test-pooler\"\n\t\tfor _, container := range []string{utils.StorageId, utils.GotrueId, utils.RealtimeId} {\n\t\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\t\tPost(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + container + \"/restart\").\n\t\t\t\tReply(http.StatusServiceUnavailable)\n\t\t}\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tPost(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + utils.PoolerId + \"/restart\").\n\t\t\tReply(http.StatusNotFound)\n\t\t// Run test\n\t\terr := RestartDatabase(context.Background(), io.Discard)\n\t\t// Check error\n\t\tassert.ErrorContains(t, err, \"failed to restart \"+utils.StorageId)\n\t\tassert.ErrorContains(t, err, \"failed to restart \"+utils.GotrueId)\n\t\tassert.ErrorContains(t, err, \"failed to restart \"+utils.RealtimeId)\n\t\tassert.Empty(t, apitest.ListUnmatchedRequests())\n\t})\n\n\tt.Run(\"throws error on db restart failure\", func(t *testing.T) {\n\t\tutils.DbId = \"test-reset\"\n\t\t// Setup mock docker\n\t\trequire.NoError(t, apitest.MockDocker(utils.Docker))\n\t\tdefer gock.OffAll()\n\t\t// Restarts postgres\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tPost(\"/v\" + utils.Docker.ClientVersion() + \"/containers/\" + utils.DbId + \"/restart\").\n\t\t\tReply(http.StatusServiceUnavailable)\n\t\t// Run test\n\t\terr := RestartDatabase(context.Background(), io.Discard)\n\t\t// Check error\n\t\tassert.ErrorContains(t, err, \"failed to restart container\")\n\t\tassert.Empty(t, apitest.ListUnmatchedRequests())\n\t})\n\n\tt.Run(\"throws error on health check timeout\", func(t *testing.T) {\n\t\tutils.DbId = \"test-reset\"\n\t\tstart.HealthTimeout = 0 * time.Second\n\t\t// Setup mock docker\n\t\trequire.NoError(t, apitest.MockDocker(utils.Docker))\n\t\tdefer gock.OffAll()\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tPost(\"/v\" + utils.Docker.ClientVersion() + \"/containers/test-reset/restart\").\n\t\t\tReply(http.StatusOK)\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tGet(\"/v\" + utils.Docker.ClientVersion() + \"/containers/test-reset/json\").\n\t\t\tReply(http.StatusOK).\n\t\t\tJSON(container.InspectResponse{ContainerJSONBase: &container.ContainerJSONBase{\n\t\t\t\tState: &container.State{\n\t\t\t\t\tRunning: false,\n\t\t\t\t\tStatus:  \"exited\",\n\t\t\t\t},\n\t\t\t}})\n\t\tgock.New(utils.Docker.DaemonHost()).\n\t\t\tGet(\"/v\" + utils.Docker.ClientVersion() + \"/containers/test-reset/logs\").\n\t\t\tReply(http.StatusServiceUnavailable)\n\t\t// Run test\n\t\terr := RestartDatabase(context.Background(), io.Discard)\n\t\t// Check error\n\t\tassert.ErrorContains(t, err, \"test-reset container is not running: exited\")\n\t\tassert.Empty(t, apitest.ListUnmatchedRequests())\n\t})\n}\n\nvar escapedSchemas = append(migration.ManagedSchemas, \"extensions\", \"public\")\n\nfunc TestResetRemote(t *testing.T) {\n\tdbConfig := pgconn.Config{\n\t\tHost:     \"db.supabase.co\",\n\t\tPort:     5432,\n\t\tUser:     \"admin\",\n\t\tPassword: \"password\",\n\t\tDatabase: \"postgres\",\n\t}\n\n\tt.Run(\"resets remote database\", func(t *testing.T) {\n\t\t// Setup in-memory fs\n\t\tfsys := afero.NewMemMapFs()\n\t\tpath := filepath.Join(utils.MigrationsDir, \"0_schema.sql\")\n\t\trequire.NoError(t, afero.WriteFile(fsys, path, nil, 0644))\n\t\t// Setup mock postgres\n\t\tconn := pgtest.NewConn()\n\t\tdefer conn.Close(t)\n\t\tconn.Query(migration.ListSchemas, escapedSchemas).\n\t\t\tReply(\"SELECT 1\", []interface{}{\"private\"}).\n\t\t\tQuery(\"DROP SCHEMA IF EXISTS private CASCADE\").\n\t\t\tReply(\"DROP SCHEMA\").\n\t\t\tQuery(migration.DropObjects).\n\t\t\tReply(\"INSERT 0\")\n\t\thelper.MockMigrationHistory(conn).\n\t\t\tQuery(migration.INSERT_MIGRATION_VERSION, \"0\", \"schema\", nil).\n\t\t\tReply(\"INSERT 0 1\")\n\t\t// Run test\n\t\terr := resetRemote(context.Background(), \"\", dbConfig, fsys, conn.Intercept)\n\t\t// Check error\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"resets remote database with seed config disabled\", func(t *testing.T) {\n\t\t// Setup in-memory fs\n\t\tfsys := afero.NewMemMapFs()\n\t\tpath := filepath.Join(utils.MigrationsDir, \"0_schema.sql\")\n\t\trequire.NoError(t, afero.WriteFile(fsys, path, nil, 0644))\n\t\tseedPath := filepath.Join(utils.SupabaseDirPath, \"seed.sql\")\n\t\t// Will raise an error when seeding\n\t\trequire.NoError(t, afero.WriteFile(fsys, seedPath, []byte(\"INSERT INTO test_table;\"), 0644))\n\t\t// Setup mock postgres\n\t\tconn := pgtest.NewConn()\n\t\tdefer conn.Close(t)\n\t\tconn.Query(migration.ListSchemas, escapedSchemas).\n\t\t\tReply(\"SELECT 1\", []interface{}{\"private\"}).\n\t\t\tQuery(\"DROP SCHEMA IF EXISTS private CASCADE\").\n\t\t\tReply(\"DROP SCHEMA\").\n\t\t\tQuery(migration.DropObjects).\n\t\t\tReply(\"INSERT 0\")\n\t\thelper.MockMigrationHistory(conn, \"invalid parameter type\", 123).\n\t\t\tQuery(migration.INSERT_MIGRATION_VERSION, \"0\", \"schema\", nil).\n\t\t\tReply(\"INSERT 0 1\")\n\t\tutils.Config.Db.Seed.Enabled = false\n\t\t// Run test\n\t\terr := resetRemote(context.Background(), \"\", dbConfig, fsys, conn.Intercept)\n\t\t// No error should be raised since we're skipping the seed\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"throws error on connect failure\", func(t *testing.T) {\n\t\t// Setup in-memory fs\n\t\tfsys := afero.NewMemMapFs()\n\t\t// Run test\n\t\terr := resetRemote(context.Background(), \"\", pgconn.Config{}, fsys)\n\t\t// Check error\n\t\tassert.ErrorContains(t, err, \"invalid port (outside range)\")\n\t})\n\n\tt.Run(\"throws error on drop schema failure\", func(t *testing.T) {\n\t\t// Setup in-memory fs\n\t\tfsys := afero.NewMemMapFs(\"invalid fsys constructor\")\n\t\t// Setup mock postgres\n\t\tconn := pgtest.NewConn(\"invalid conn parameter\")\n\t\tdefer conn.Close(t, \"too many arguments\")\n\t\tconn.Query(migration.ListSchemas, escapedSchemas, \"extra parameter\").\n\t\t\tReply(\"SELECT 0\").\n\t\t\tQuery(migration.DropObjects).\n\t\t\tReplyError(pgerrcode.InsufficientPrivilege, \"permission denied for relation supabase_migrations\")\n\t\t// Run test\n\t\terr := resetRemote(context.Background(), \"\", dbConfig, fsys, conn.Intercept)\n\t\t// Check error\n\t\tassert.ErrorContains(t, err, \"ERROR: permission denied for relation supabase_migrations (SQLSTATE 42501)\")\n\t})\n}"
