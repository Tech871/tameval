[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "XanaduAI/MrMustard"
sha = "a4e85ddf1df86333ecb8014f36d30e4437cbe4d4"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "(pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=mrmustard/physics/gaussian_integrals.py -m pytest -q --junit-xml=test_output.xml tests/test_physics/test_gaussian_integrals.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target mrmustard.physics.gaussian_integrals --unit-test tests.test_physics.test_gaussian_integrals --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target mrmustard/physics/gaussian_integrals.py --unit-test tests/test_physics/test_gaussian_integrals.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 81.0
original_coverage = 97.0
mutation_kill_rate = nan
original_mutation_kill_rate = 75.0
covered_lines = [ 18, 20, 22, 23, 24, 27, 52, 54, 55, 56, 57, 58, 60, 61, 63, 64, 65, 66, 67, 68, 69, 70, 72, 73, 75, 82, 85, 158, 194, 195, 197, 198, 200, 201, 203, 204, 206, 207, 208, 210, 211, 212, 213, 215, 216, 218, 219, 220, 221, 224, 225, 226, 227, 230, 231, 232, 234, 236, 237, 238, 240, 243, 244, 246, 247, 248, 249, 251, 253, 254, 255, 257, 260, 261, 262, 263, 264, 265, 268, 269, 270, 271, 272, 273, 276, 277, 278, 279, 280, 281, 282, 285, 286, 287, 288, 289, 290, 293, 297, 302, 305, 315, 326, 327, 338, 339, 340, 342, 343, 345, 348, 366, 367, 369, 370, 372, 375, 376, 378, 379, 380, 387, 408, 444, 449, 451, 452, 453, 454, 456, 457, 458, 459, 460, 465, 468, 470, 471, 473, 474, 475, 476, 477, 479, 480, 481, 482, 483, 486, 499, 502, 540, 543, 544, 545, 546, 547, 549,]
missed_lines = [ 105, 106, 107, 108, 109, 114, 117, 118, 120, 121, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 145, 146, 153, 154, 155, 405, 466,]

[input_info]
test_file_path = "tests/test_physics/test_gaussian_integrals.py"
focal_file_path = "mrmustard/physics/gaussian_integrals.py"
test_file_url = "https://github.com/XanaduAI/MrMustard/blob/a4e85ddf1df86333ecb8014f36d30e4437cbe4d4/tests/test_physics/test_gaussian_integrals.py"
focal_file_url = "https://github.com/XanaduAI/MrMustard/blob/a4e85ddf1df86333ecb8014f36d30e4437cbe4d4/mrmustard/physics/gaussian_integrals.py"
first_commit_date = "2024-04-15"
last_commit_date = "2025-07-09"
test_file_content = "# Copyright 2024 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for real and comple gaussian integral functions and related helper functions.\"\"\"\n\nimport numpy as np\n\nfrom mrmustard import math, settings\nfrom mrmustard.physics import triples\nfrom mrmustard.physics.gaussian_integrals import (\n    complex_gaussian_integral_1,\n    complex_gaussian_integral_2,\n    join_Abc,\n    join_Abc_real,\n    real_gaussian_integral,\n)\n\n\ndef test_real_gaussian_integral():\n    \"\"\"Tests the ``real_gaussian_integral`` method with a hard-coded A matric from a Gaussian(3) state.\"\"\"\n    A = math.astensor(\n        [\n            [\n                0.35307718 - 0.09738001j,\n                -0.01297994 + 0.26050244j,\n                0.05349344 - 0.13728068j,\n            ],\n            [\n                -0.01297994 + 0.26050244j,\n                0.05696707 - 0.2351408j,\n                0.18954838 - 0.42959383j,\n            ],\n            [\n                0.05349344 - 0.13728068j,\n                0.18954838 - 0.42959383j,\n                -0.16931712 - 0.09205837j,\n            ],\n        ],\n    )\n    b = math.arange(3, dtype=math.complex128)\n    c = 1.0 + 0j\n    res = real_gaussian_integral((A, b, c), idx=[0, 1])\n    assert math.allclose(res[0], A[2, 2] - A[2:, :2] @ math.inv(A[:2, :2]) @ A[:2, 2:])\n    assert math.allclose(\n        res[1],\n        b[2] - math.sum(A[2:, :2] * math.matvec(math.inv(A[:2, :2]), b[:2])),\n    )\n    assert math.allclose(\n        res[2],\n        c\n        * math.sqrt((-2 * np.pi) ** 2, math.complex128)\n        / math.sqrt(math.det(A[:2, :2]))\n        * math.exp(-0.5 * math.sum(b[:2] * math.matvec(math.inv(A[:2, :2]), b[:2]))),\n    )\n    res2 = real_gaussian_integral((A, b, c), idx=[])\n    assert math.allclose(res2[0], A)\n    assert math.allclose(res2[1], b)\n    assert math.allclose(res2[2], c)\n\n    A2 = math.astensor(\n        [\n            [0.35307718 - 0.09738001j, -0.01297994 + 0.26050244j],\n            [-0.01297994 + 0.26050244j, 0.05696707 - 0.2351408j],\n        ],\n    )\n    b2 = math.cast(math.arange(2), dtype=math.complex128)\n    c2 = 1.0 + 0j\n    res3 = real_gaussian_integral((A2, b2, c2), idx=[0, 1])\n    assert math.allclose(res3[0], math.astensor([]))\n    assert math.allclose(res3[1], math.astensor([]))\n    assert math.allclose(\n        res3[2],\n        c2\n        * math.sqrt((-2 * np.pi) ** 2, math.complex128)\n        / math.sqrt(math.det(A2[:2, :2]))\n        * math.exp(-0.5 * math.sum(b2[:2] * math.matvec(math.inv(A2[:2, :2]), b2[:2]))),\n    )\n\n\ndef test_join_Abc_real():\n    \"\"\"Tests the ``join_Abc_real`` method.\"\"\"\n    A1, b1, c1 = triples.vacuum_state_Abc(1)\n    A2, b2, c2 = triples.displacement_gate_Abc(x=0.1, y=0.3)\n    idx1 = [0]\n    idx2 = [0]\n\n    joined_Abc = join_Abc_real((A1, b1, c1), (A2, b2, c2), idx1, idx2)\n    assert math.allclose(joined_Abc[0], A2)\n    assert math.allclose(joined_Abc[1], b2)\n    assert math.allclose(joined_Abc[2], math.outer(c1, c2))\n\n    joined_Abc1 = join_Abc_real((A2, b2, c2), (A1, b1, c1), idx1, idx2)\n    assert math.allclose(joined_Abc1[0], A2)\n    assert math.allclose(joined_Abc1[1], b2)\n    assert math.allclose(joined_Abc1[2], math.outer(c1, c2))\n\n\ndef test_join_Abc_nonbatched():\n    \"\"\"Tests the ``join_Abc`` method for non-batched inputs.\"\"\"\n    A1 = math.astensor([[1, 2], [3, 4]])\n    b1 = math.astensor([5, 6])\n    c1 = math.astensor(7)\n\n    A2 = math.astensor([[8, 9], [10, 11]])\n    b2 = math.astensor([12, 13])\n    c2 = math.astensor(10)\n\n    A, b, c = join_Abc((A1, b1, c1), (A2, b2, c2), batch_string=None)\n\n    assert math.allclose(\n        A,\n        math.astensor([[1, 2, 0, 0], [3, 4, 0, 0], [0, 0, 8, 9], [0, 0, 10, 11]]),\n    )\n    assert math.allclose(b, math.astensor([5, 6, 12, 13]))\n    assert math.allclose(c, 70)\n\n\ndef test_join_Abc_batched_zip():\n    \"\"\"Tests the ``join_Abc`` method for batched inputs in zip mode (and with polynomial c).\"\"\"\n    A1 = math.astensor([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\n    b1 = math.astensor([[5, 6], [7, 8]])\n    c1 = math.astensor([7, 8])\n\n    A2 = math.astensor([[[8, 9], [10, 11]], [[12, 13], [14, 15]]])\n    b2 = math.astensor([[12, 13], [14, 15]])\n    c2 = math.astensor([10, 100])\n\n    A, b, c = join_Abc((A1, b1, c1), (A2, b2, c2), batch_string=\"i,i->i\")\n\n    assert math.allclose(\n        A,\n        math.astensor(\n            [\n                [[1, 2, 0, 0], [3, 4, 0, 0], [0, 0, 8, 9], [0, 0, 10, 11]],\n                [[5, 6, 0, 0], [7, 8, 0, 0], [0, 0, 12, 13], [0, 0, 14, 15]],\n            ],\n        ),\n    )\n    assert math.allclose(b, math.astensor([[5, 6, 12, 13], [7, 8, 14, 15]]))\n    assert math.allclose(c, math.astensor([70, 800]))\n\n\ndef test_join_Abc_batched_kron():\n    \"\"\"Tests the ``join_Abc`` method for batched inputs in kron mode (and with polynomial c).\"\"\"\n    A1 = math.astensor([[[1, 2], [3, 4]]])\n    b1 = math.astensor([[5, 6]])\n    c1 = math.astensor([7])\n\n    A2 = math.astensor([[[8, 9], [10, 11]], [[12, 13], [14, 15]]])\n    b2 = math.astensor([[12, 13], [14, 15]])\n    c2 = math.astensor([10, 100])\n\n    A, b, c = join_Abc((A1, b1, c1), (A2, b2, c2), batch_string=\"i,j->ij\")\n\n    assert math.allclose(\n        A,\n        math.astensor(\n            [\n                [[1, 2, 0, 0], [3, 4, 0, 0], [0, 0, 8, 9], [0, 0, 10, 11]],\n                [[1, 2, 0, 0], [3, 4, 0, 0], [0, 0, 12, 13], [0, 0, 14, 15]],\n            ],\n        ),\n    )\n    assert math.allclose(b, math.astensor([[5, 6, 12, 13], [5, 6, 14, 15]]))\n    assert math.allclose(c, math.astensor([70, 700]))\n\n\ndef test_complex_gaussian_integral_2_not_batched():\n    \"\"\"Tests the ``complex_gaussian_integral_2`` method for non-batched inputs.\"\"\"\n    A1, b1, c1 = triples.vacuum_state_Abc(2)\n    A2, b2, c2 = triples.displacement_gate_Abc(x=0.1, y=0.3)\n    A3, b3, c3 = triples.displaced_squeezed_vacuum_state_Abc(x=0.1, y=0.3)\n\n    res = complex_gaussian_integral_2((A1, b1, c1), (A2, b2, c2), [0, 1], [0, 1])\n    assert math.allclose(res[0], A3)\n    assert math.allclose(res[1], b3)\n    assert math.allclose(res[2], c3)\n\n\ndef test_complex_gaussian_integral_2_batched():\n    \"\"\"tests that the ``complex_gaussian_integral_2`` method works for batched inputs.\"\"\"\n    A1, b1, c1 = triples.vacuum_state_Abc(1)\n    A2, b2, c2 = triples.squeezing_gate_Abc(r=[0.1, 0.2, 0.3], phi=[0.3, 0.4, 0.5])\n    A3, b3, c3 = triples.squeezed_vacuum_state_Abc(r=[0.1, 0.2, 0.3], phi=[0.3, 0.4, 0.5])\n\n    A1 = math.astensor([A1, A1, A1])\n    b1 = math.astensor([b1, b1, b1])\n    c1 = math.astensor([c1, c1, c1])\n\n    res = complex_gaussian_integral_2((A1, b1, c1), (A2, b2, c2), [0], [1], batch_string=\"i,i->i\")\n    assert math.allclose(res[0], A3)\n    assert math.allclose(res[1], b3)\n    assert math.allclose(res[2], c3)\n\n\ndef test_complex_gaussian_integral_1_not_batched():\n    \"\"\"Tests the ``complex_gaussian_integral_1`` method for non-batched inputs.\"\"\"\n    A, b, c = triples.thermal_state_Abc(nbar=0.5)\n    Ar, br, cr = triples.vacuum_state_Abc(0)\n\n    res = complex_gaussian_integral_1((A, b, c), [0], [1])\n    assert math.allclose(res[0], Ar)\n    assert math.allclose(res[1], br)\n    assert math.allclose(res[2], cr)\n\n    A1, b1, c1 = triples.vacuum_state_Abc(2)\n    A2, b2, c2 = triples.displacement_gate_Abc(x=0.1, y=0.3)\n    A3, b3, c3 = triples.displaced_squeezed_vacuum_state_Abc(x=0.1, y=0.3)\n\n    A, b, c = join_Abc((A1, b1, c1), (A2, b2, c2))\n\n    res = complex_gaussian_integral_1((A, b, c), [0, 1], [2, 3])\n    assert math.allclose(res[0], A3)\n    assert math.allclose(res[1], b3)\n    assert math.allclose(res[2], c3)\n\n\ndef test_complex_gaussian_integral_1_batched():\n    \"\"\"tests that the ``complex_gaussian_integral_2`` method works for batched inputs.\"\"\"\n    A1, b1, c1 = triples.vacuum_state_Abc(1)\n    A2, b2, c2 = triples.squeezing_gate_Abc(r=[0.1, 0.2, 0.3], phi=[0.3, 0.4, 0.5])\n    A3, b3, c3 = triples.squeezed_vacuum_state_Abc(r=[0.1, 0.2, 0.3], phi=[0.3, 0.4, 0.5])\n\n    A1 = math.astensor([A1, A1, A1])\n    b1 = math.astensor([b1, b1, b1])\n    c1 = math.astensor([c1, c1, c1])\n\n    A, b, c = join_Abc((A1, b1, c1), (A2, b2, c2), batch_string=\"i,i->i\")\n    res1 = complex_gaussian_integral_1((A, b, c), [0], [2])\n    assert math.allclose(res1[0], A3)\n    assert math.allclose(res1[1], b3)\n    assert math.allclose(res1[2], c3)\n\n\ndef test_complex_gaussian_integral_1_multidim_batched():\n    \"\"\"tests that the ``complex_gaussian_integral_2`` method works for multi-dimensional batched inputs.\"\"\"\n    A1, b1, c1 = triples.vacuum_state_Abc(1)\n    A2, b2, c2 = triples.squeezing_gate_Abc(\n        r=[[0.1, 0.2, 0.3], [0.1, 0.2, 0.3]],\n        phi=[[0.3, 0.4, 0.5], [0.3, 0.4, 0.5]],\n    )\n    A3, b3, c3 = triples.squeezed_vacuum_state_Abc(\n        r=[[0.1, 0.2, 0.3], [0.1, 0.2, 0.3]],\n        phi=[[0.3, 0.4, 0.5], [0.3, 0.4, 0.5]],\n    )\n\n    A1 = math.astensor([[A1, A1, A1], [A1, A1, A1]])\n    b1 = math.astensor([[b1, b1, b1], [b1, b1, b1]])\n    c1 = math.astensor([[c1, c1, c1], [c1, c1, c1]])\n\n    A, b, c = join_Abc((A1, b1, c1), (A2, b2, c2), batch_string=\"ij,ij->ij\")\n    res1 = complex_gaussian_integral_1((A, b, c), [0], [2])\n    assert math.allclose(res1[0], A3)\n    assert math.allclose(res1[1], b3)\n    assert math.allclose(res1[2], c3)\n\n\ndef test_gaussian_integral_poly_batched():\n    \"\"\"Tests that the Gaussian integral works for batched inputs with polynomial c.\"\"\"\n    # batch 4 and 2 polynomial wires\n    A = settings.rng.random((4, 4, 4))\n    b = settings.rng.random((4, 4))\n    c = settings.rng.random((4, 2, 2))\n    res = complex_gaussian_integral_1((A, b, c), [0], [1])\n    assert res[0].shape == (4, 2, 2)\n    assert res[1].shape == (4, 2)\n    assert res[2].shape == (4, 2, 2)"
