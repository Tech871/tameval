[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Python"
python_version = "3.12"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "flyteorg/flytekit"
sha = "5503ee5e232fdbc633af39c7f4539a04906102fc"

[run_info]
docker_image = "python:3.12"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r dev-requirements.txt && (pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=flytekit/clients/auth_helper.py -m pytest -q --junit-xml=test_output.xml tests/flytekit/unit/clients/test_auth_helper.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target flytekit.clients.auth_helper --unit-test tests.flytekit.unit.clients.test_auth_helper --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target flytekit/clients/auth_helper.py --unit-test tests/flytekit/unit/clients/test_auth_helper.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 26.0
original_coverage = 73.0
mutation_kill_rate = nan
original_mutation_kill_rate = 100.0
covered_lines = [ 0, 1, 2, 4, 5, 6, 7, 9, 18, 19, 20, 21, 24, 29, 32, 51, 109, 116, 134, 149, 162, 176, 230, 244, 249, 253, 264, 280, 297,]
missed_lines = [ 30, 36, 37, 38, 39, 55, 56, 57, 58, 59, 60, 61, 63, 64, 65, 66, 67, 69, 71, 72, 73, 74, 85, 86, 87, 88, 89, 93, 94, 104, 110, 125, 126, 128, 129, 131, 143, 144, 146, 153, 158, 159, 167, 168, 169, 171, 172, 173, 200, 201, 203, 204, 205, 206, 207, 208, 209, 210, 212, 218, 219, 241, 250, 251, 258, 259, 261, 262, 271, 272, 273, 274, 275, 276, 277, 289, 290, 292, 293, 294, 299, 300, 301, 302,]

[input_info]
test_file_path = "tests/flytekit/unit/clients/test_auth_helper.py"
focal_file_path = "flytekit/clients/auth_helper.py"
test_file_url = "https://github.com/flyteorg/flytekit/blob/5503ee5e232fdbc633af39c7f4539a04906102fc/tests/flytekit/unit/clients/test_auth_helper.py"
focal_file_url = "https://github.com/flyteorg/flytekit/blob/5503ee5e232fdbc633af39c7f4539a04906102fc/flytekit/clients/auth_helper.py"
first_commit_date = "2023-02-23"
last_commit_date = "2025-02-07"
test_file_content = "import os.path\nfrom http import HTTPStatus\nfrom unittest.mock import MagicMock, patch\n\nimport pytest\nimport requests\nfrom flyteidl.service.auth_pb2 import OAuth2MetadataResponse, PublicClientAuthConfigResponse\n\nfrom flytekit.clients.auth.authenticator import (\n    ClientConfig,\n    ClientConfigStore,\n    ClientCredentialsAuthenticator,\n    CommandAuthenticator,\n    DeviceCodeAuthenticator,\n    PKCEAuthenticator,\n)\nfrom flytekit.clients.auth.exceptions import AuthenticationError\nfrom flytekit.clients.auth_helper import (\n    RemoteClientConfigStore,\n    get_authenticator,\n    get_session,\n    load_cert,\n    upgrade_channel_to_authenticated,\n    upgrade_channel_to_proxy_authenticated,\n    wrap_exceptions_channel,\n)\nfrom flytekit.clients.grpc_utils.auth_interceptor import AuthUnaryInterceptor\nfrom flytekit.clients.grpc_utils.wrap_exception_interceptor import RetryExceptionWrapperInterceptor\nfrom flytekit.configuration import AuthType, PlatformConfig\n\nREDIRECT_URI = \"http://localhost:53593/callback\"\n\nTOKEN_ENDPOINT = \"https://your.domain.io/oauth2/token\"\n\nCLIENT_ID = \"flytectl\"\n\nOAUTH_AUTHORIZE = \"https://your.domain.io/oauth2/authorize\"\n\nDEVICE_AUTH_ENDPOINT = \"https://your.domain.io/...\"\n\n\ndef get_auth_service_mock() -> MagicMock:\n    auth_stub_mock = MagicMock()\n    auth_stub_mock.GetPublicClientConfig.return_value = PublicClientAuthConfigResponse(\n        client_id=CLIENT_ID,\n        redirect_uri=REDIRECT_URI,\n        scopes=[\"offline\", \"all\"],\n        authorization_metadata_key=\"flyte-authorization\",\n    )\n    auth_stub_mock.GetOAuth2Metadata.return_value = OAuth2MetadataResponse(\n        issuer=\"https://your.domain.io\",\n        authorization_endpoint=OAUTH_AUTHORIZE,\n        token_endpoint=TOKEN_ENDPOINT,\n        response_types_supported=[\"code\", \"token\", \"code token\"],\n        scopes_supported=[\"all\"],\n        token_endpoint_auth_methods_supported=[\"client_secret_basic\"],\n        jwks_uri=\"https://your.domain.io/oauth2/jwks\",\n        code_challenge_methods_supported=[\"S256\"],\n        grant_types_supported=[\"client_credentials\", \"refresh_token\", \"authorization_code\"],\n    )\n    return auth_stub_mock\n\n\n@patch(\"flytekit.clients.auth_helper.AuthMetadataServiceStub\")\ndef test_remote_client_config_store(mock_auth_service: MagicMock):\n    ch = MagicMock()\n    cs = RemoteClientConfigStore(ch)\n    mock_auth_service.return_value = get_auth_service_mock()\n\n    ccfg = cs.get_client_config()\n    assert ccfg is not None\n    assert ccfg.client_id == CLIENT_ID\n    assert ccfg.authorization_endpoint == OAUTH_AUTHORIZE\n\n\ndef get_client_config(**kwargs) -> ClientConfigStore:\n    cfg_store = MagicMock()\n    cfg_store.get_client_config.return_value = ClientConfig(\n        token_endpoint=TOKEN_ENDPOINT,\n        authorization_endpoint=OAUTH_AUTHORIZE,\n        redirect_uri=REDIRECT_URI,\n        client_id=CLIENT_ID,\n        **kwargs,\n    )\n    return cfg_store\n\n\ndef test_get_authenticator_basic():\n    cfg = PlatformConfig(auth_mode=AuthType.BASIC)\n\n    with pytest.raises(ValueError, match=\"Client ID and Client SECRET both are required\"):\n        get_authenticator(cfg, None)\n\n    cfg = PlatformConfig(auth_mode=AuthType.BASIC, client_credentials_secret=\"xyz\", client_id=\"id\")\n    authn = get_authenticator(cfg, get_client_config())\n    assert authn\n    assert isinstance(authn, ClientCredentialsAuthenticator)\n\n    cfg = PlatformConfig(auth_mode=AuthType.CLIENT_CREDENTIALS, client_credentials_secret=\"xyz\", client_id=\"id\")\n    authn = get_authenticator(cfg, get_client_config())\n    assert authn\n    assert isinstance(authn, ClientCredentialsAuthenticator)\n\n    cfg = PlatformConfig(auth_mode=AuthType.CLIENTSECRET, client_credentials_secret=\"xyz\", client_id=\"id\")\n    authn = get_authenticator(cfg, get_client_config())\n    assert authn\n    assert isinstance(authn, ClientCredentialsAuthenticator)\n\n\ndef test_get_authenticator_pkce():\n    cfg = PlatformConfig()\n    authn = get_authenticator(cfg, get_client_config())\n    assert authn\n    assert isinstance(authn, PKCEAuthenticator)\n\n    cfg = PlatformConfig(insecure_skip_verify=True)\n    authn = get_authenticator(cfg, get_client_config())\n    assert authn\n    assert isinstance(authn, PKCEAuthenticator)\n    assert authn._verify is False\n\n    cfg = PlatformConfig(ca_cert_file_path=\"/file\")\n    authn = get_authenticator(cfg, get_client_config())\n    assert authn\n    assert isinstance(authn, PKCEAuthenticator)\n    assert authn._verify == \"/file\"\n\n\ndef test_get_authenticator_cmd():\n    cfg = PlatformConfig(auth_mode=AuthType.EXTERNAL_PROCESS)\n    with pytest.raises(AuthenticationError):\n        get_authenticator(cfg, get_client_config())\n\n    cfg = PlatformConfig(auth_mode=AuthType.EXTERNAL_PROCESS, command=[\"echo\"])\n    authn = get_authenticator(cfg, get_client_config())\n    assert authn\n    assert isinstance(authn, CommandAuthenticator)\n\n    cfg = PlatformConfig(auth_mode=AuthType.EXTERNALCOMMAND, command=[\"echo\"])\n    authn = get_authenticator(cfg, get_client_config())\n    assert authn\n    assert isinstance(authn, CommandAuthenticator)\n    assert authn._cmd == [\"echo\"]\n\n\ndef test_get_authenticator_deviceflow():\n    cfg = PlatformConfig(auth_mode=AuthType.DEVICEFLOW)\n    with pytest.raises(AuthenticationError):\n        get_authenticator(cfg, get_client_config())\n\n    authn = get_authenticator(cfg, get_client_config(device_authorization_endpoint=DEVICE_AUTH_ENDPOINT))\n    assert isinstance(authn, DeviceCodeAuthenticator)\n\n\ndef test_wrap_exceptions_channel():\n    ch = MagicMock()\n    out_ch = wrap_exceptions_channel(PlatformConfig(), ch)\n    assert isinstance(out_ch._interceptor, RetryExceptionWrapperInterceptor)  # noqa\n\n\ndef test_upgrade_channel_to_auth():\n    ch = MagicMock()\n    out_ch = upgrade_channel_to_authenticated(PlatformConfig(), ch)\n    assert isinstance(out_ch._interceptor, AuthUnaryInterceptor)  # noqa\n\n\ndef test_upgrade_channel_to_proxy_auth():\n    ch = MagicMock()\n    out_ch = upgrade_channel_to_proxy_authenticated(\n        PlatformConfig(\n            auth_mode=\"Pkce\",\n            proxy_command=[\"echo\", \"foo-bar\"],\n        ),\n        ch,\n    )\n    assert isinstance(out_ch._interceptor, AuthUnaryInterceptor)\n    assert isinstance(out_ch._interceptor._authenticator, CommandAuthenticator)\n\n\ndef test_load_cert():\n    cert_file = os.path.join(os.path.dirname(__file__), \"testdata\", \"rootCACert.pem\")\n    f = load_cert(cert_file)\n    assert f\n    print(f)\n\n\ndef test_get_proxy_authenticated_session():\n    \"\"\"Test that proxy auth headers are added to http requests if the proxy command is provided in the platform config.\"\"\"\n    expected_token = \"foo-bar\"\n    platform_config = PlatformConfig(\n        endpoint=\"http://my-flyte-deployment.com\",\n        proxy_command=[\"echo\", expected_token],\n    )\n\n    with patch(\"requests.adapters.HTTPAdapter.send\") as mock_send:\n        mock_response = requests.Response()\n        mock_response.status_code = HTTPStatus.UNAUTHORIZED\n        mock_response._content = b\"{}\"\n        mock_send.return_value = mock_response\n\n        session = get_session(platform_config)\n        request = requests.Request(\"GET\", platform_config.endpoint)\n        prepared_request = session.prepare_request(request)\n\n        # Send the request to trigger the addition of the proxy auth headers\n        session.send(prepared_request)\n\n        assert prepared_request.headers[\"proxy-authorization\"] == f\"Bearer {expected_token}\""
