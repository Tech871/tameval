[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.18"

[repo_info]
repository = "bytedance/gg"
sha = "420f8369dd6e235b8124691860e822d015969fb6"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out gvalue/gvalue.go gvalue/gvalue_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting gvalue/gvalue.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 100.0
mutation_kill_rate = nan
original_mutation_kill_rate = 76.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "gvalue/gvalue_test.go"
focal_file_path = "gvalue/gvalue.go"
test_file_url = "https://github.com/bytedance/gg/blob/420f8369dd6e235b8124691860e822d015969fb6/gvalue/gvalue_test.go"
focal_file_url = "https://github.com/bytedance/gg/blob/420f8369dd6e235b8124691860e822d015969fb6/gvalue/gvalue.go"
first_commit_date = "2025-05-19"
last_commit_date = "2025-07-04"
test_file_content = "// Copyright 2025 Bytedance Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gvalue\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"sync\"\n\t\"testing\"\n\n\t\"github.com/bytedance/gg/internal/assert\"\n)\n\nfunc TestZero(t *testing.T) {\n\tassert.Zero(t, Zero[bool]())\n\tassert.Zero(t, Zero[int]())\n\tassert.Zero(t, Zero[*int]())\n\tassert.Zero(t, Zero[string]())\n\tassert.Zero(t, Zero[interface{}]())\n\tassert.Zero(t, Zero[*interface{}]())\n}\n\nfunc TestOr(t *testing.T) {\n\tassert.True(t, Or(false, false, true))\n\tassert.Equal(t, 1, Or(0, 1, 2))\n\tassert.Equal(t, \"1\", Or(\"\", \"1\", \"2\"))\n\tassert.Equal(t, 0, Or(0, 0, 0))\n\tassert.Equal(t, \"\", Or(\"\", \"\", \"\"))\n\tassert.Equal(t, 0, Or[int]())\n}\n\nfunc TestMin(t *testing.T) {\n\tassert.Equal(t, 1, Min(1, 2))\n\tassert.Equal(t, 2, Min(2))\n\tassert.Equal(t, 1, Min(2, 1, 3))\n\tassert.Equal(t, 1, Min(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3))\n\tassert.Equal(t, -2147483648, Min(math.MaxInt32, 0, math.MaxInt64, math.MinInt32))\n\tassert.Equal(t, -1.0, Min[float32](2, -1))\n\tassert.Equal(t, math.E, Min(math.E, 3.0, 2.8))\n\tassert.Equal(t, math.E, Min(3.0, math.E, 2.8))\n\tassert.Equal(t, \"1\", Min(\"1\"))\n\tassert.Equal(t, \"\", Min(\"    \", \"\", \"  \"))\n\tassert.Equal(t, \"1099\", Min(\"1999\", \"2\", \"1099\"))\n\tassert.Equal(t, \"\\nzzz\", Min(\"a\", \"1999\", \"2\", \"\\nzzz\"))\n}\n\nfunc TestMax(t *testing.T) {\n\tassert.Equal(t, 1, Max(1))\n\tassert.Equal(t, 1, Max(0, 1, 0, -1))\n\tassert.Equal(t, 3, Max(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3))\n\tassert.Equal(t, 2147483647, Max[int64](0, math.MinInt64, math.MaxInt32, 0))\n\tassert.Equal(t, -1.0, Max[float32](-1, -2))\n\tassert.Equal(t, math.E, Max(2.0, math.E, 2.718))\n\tassert.Equal(t, \"1\", Max(\"1\"))\n\tassert.Equal(t, \"    \", Max(\"    \", \"\", \"  \"))\n\tassert.Equal(t, \"2\", Max(\"1999\", \"2\", \"1099\"))\n\tassert.Equal(t, \"a\", Max(\"a\", \"1999\", \"2  \", \"\\nzzz\"))\n}\n\ntype Pair[T1, T2 any] struct {\n\tFirst  T1\n\tSecond T2\n}\n\nfunc MakePair[T1, T2 any](first T1, second T2) Pair[T1, T2] {\n\treturn Pair[T1, T2]{first, second}\n}\n\nfunc TestMinMax(t *testing.T) {\n\tassert.Equal(t, MakePair(1, 1), MakePair(MinMax(1)))\n\tassert.Equal(t, MakePair(-1, 1), MakePair(MinMax(0, 1, 0, -1)))\n\tassert.Equal(t, MakePair(1, 3), MakePair(MinMax(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3)))\n\tassert.Equal(t, MakePair[int64, int64](-9223372036854775808, 2147483647), MakePair(MinMax[int64](0, math.MinInt64, math.MaxInt32, 0)))\n\tassert.Equal(t, MakePair[float32, float32](-2.0, -1.0), MakePair(MinMax[float32](-1, -2)))\n\tassert.Equal(t, MakePair(2.0, math.E), MakePair(MinMax(2.0, math.E, 2.718)))\n\tassert.Equal(t, MakePair(\"1\", \"1\"), MakePair(MinMax(\"1\")))\n\tassert.Equal(t, MakePair(\"\", \"    \"), MakePair(MinMax(\"    \", \"\", \"  \")))\n\tassert.Equal(t, MakePair(\"1099\", \"2\"), MakePair(MinMax(\"1999\", \"2\", \"1099\")))\n\tassert.Equal(t, MakePair(\"\\nzzz\", \"a\"), MakePair(MinMax(\"a\", \"1999\", \"2  \", \"\\nzzz\")))\n}\n\nfunc TestClamp(t *testing.T) {\n\tassert.Equal(t, 2, Clamp(1, 2, 3))\n\tassert.Equal(t, 2, Clamp(2, 1, 3))\n\tassert.Equal(t, 2, Clamp(3, 1, 2))\n\tassert.Equal(t, \"11\", Clamp(\"2\", \"10\", \"11\"))\n\tassert.Equal(t, 0, Clamp[int64](0, math.MinInt64, math.MaxInt64))\n\tassert.Equal(t, math.MinInt64, Clamp[int64](math.MinInt64, math.MinInt64, math.MaxInt64))\n\tassert.Equal(t, math.MaxInt64, Clamp[int64](math.MaxInt64, math.MinInt64, math.MaxInt64))\n\tassert.Equal(t, -1.0, Clamp[float64](-1e9, -1.0, 1.0))\n\tassert.Equal(t, \"   \", Clamp[string](\"\", \"   \", \"     \"))\n}\n\nfunc TestIsNil(t *testing.T) {\n\tassert.False(t, IsNil(1))\n\tii := 1\n\tassert.False(t, IsNil(&ii))\n\tassert.False(t, &ii == nil)\n\tassert.True(t, IsNil(nil))\n\t// assert.True(t, nil == nil)\n\n\t// Nil\n\tvar i *int\n\tassert.True(t, IsNil(i))\n\tassert.True(t, i == nil)\n\tassert.True(t, IsNil(Zero[*int]()))\n\tassert.True(t, IsNil((*int)(nil)))\n\tassert.True(t, (*int)(nil) == nil)\n\n\t// Interface\n\tvar ip *net.IP\n\tassert.True(t, IsNil(fmt.Stringer(ip)))\n\tassert.True(t, ip == nil)\n\tassert.True(t, IsNil(fmt.Stringer((*net.IP)(nil))))\n\tassert.False(t, fmt.Stringer((*net.IP)(nil)) == nil)\n\tvar s fmt.Stringer\n\tassert.True(t, IsNil(s))\n\tassert.True(t, s == nil)\n\ts = ip\n\tassert.True(t, IsNil(s))\n\tassert.False(t, s == nil)\n\ts = &net.IP{}\n\tassert.False(t, IsNil(s))\n\tassert.False(t, s == nil)\n}\n\nfunc TestIsNotNil(t *testing.T) {\n\tassert.True(t, IsNotNil(1))\n\tvar i *int\n\tassert.False(t, IsNotNil(i))\n}\n\nfunc TestIsZero(t *testing.T) {\n\tassert.True(t, IsZero(0))\n\tassert.False(t, IsZero(1))\n\n\tassert.True(t, IsZero(\"\"))\n\tassert.False(t, IsZero(\"0\"))\n\n\tassert.True(t, IsZero[*int](nil))\n\ti := 0\n\tassert.False(t, IsZero(&i))\n}\n\nfunc TestIsNotZero(t *testing.T) {\n\tassert.False(t, IsNotZero(0))\n\tassert.True(t, IsNotZero(1))\n}\n\nfunc TestEqual(t *testing.T) {\n\tassert.True(t, Equal(1, 1))\n\tassert.False(t, Equal(1, 0))\n\n\tassert.True(t, Equal(\"a\", \"a\"))\n\tassert.False(t, Equal(\"a\", \"A\"))\n}\n\nfunc TestAdd(t *testing.T) {\n\tassert.Equal(t, 2, Add(1, 1))\n\tassert.Equal(t, \"Alice\", Add(\"Ali\", \"ce\"))\n}\n\nfunc TestLess(t *testing.T) {\n\tassert.True(t, Less(1, 2))\n\tassert.False(t, Less(2, 1))\n\tassert.False(t, Less(1, 1))\n\n\tassert.True(t, Less(\"1\", \"2\"))\n\tassert.False(t, Less(\"2\", \"1\"))\n\tassert.False(t, Less(\"1\", \"1\"))\n}\n\nfunc TestLessEqual(t *testing.T) {\n\tassert.True(t, LessEqual(1, 2))\n\tassert.False(t, LessEqual(2, 1))\n\tassert.True(t, LessEqual(1, 1))\n\n\tassert.True(t, LessEqual(\"1\", \"2\"))\n\tassert.False(t, LessEqual(\"2\", \"1\"))\n\tassert.True(t, LessEqual(\"1\", \"1\"))\n}\n\nfunc TestGreater(t *testing.T) {\n\tassert.True(t, Greater(2, 1))\n\tassert.False(t, Greater(1, 2))\n\tassert.False(t, Greater(1, 1))\n\n\tassert.True(t, Greater(\"2\", \"1\"))\n\tassert.False(t, Greater(\"1\", \"2\"))\n\tassert.False(t, Greater(\"1\", \"1\"))\n}\n\nfunc TestGreaterEqual(t *testing.T) {\n\tassert.True(t, GreaterEqual(2, 1))\n\tassert.False(t, GreaterEqual(1, 2))\n\tassert.True(t, GreaterEqual(1, 1))\n\n\tassert.True(t, GreaterEqual(\"2\", \"1\"))\n\tassert.False(t, GreaterEqual(\"1\", \"2\"))\n\tassert.True(t, GreaterEqual(\"1\", \"1\"))\n}\n\nfunc TestBetween(t *testing.T) {\n\tassert.True(t, Between(2, 1, 2))\n\tassert.False(t, Between(1, 2, 3))\n\tassert.True(t, Between(1, 1, 1))\n\n\tassert.True(t, Between(\"2\", \"1\", \"2\"))\n\tassert.False(t, Between(\"1\", \"2\", \"3\"))\n\tassert.True(t, Between(\"1\", \"1\", \"1\"))\n}\n\nfunc TestTypeAssert(t *testing.T) {\n\tassert.Equal(t, any(1), TypeAssert[any, int](1))\n\tassert.Equal(t, 1, TypeAssert[int, any](any(1)))\n\n\t// Omit original type.\n\tassert.Equal(t, any(1), TypeAssert[any](1))\n\tassert.Equal(t, 1, TypeAssert[int](any(1)))\n\n\tassert.Panic(t, func() {\n\t\tTypeAssert[float64](any(1))\n\t})\n}\n\nfunc TestTryAssert(t *testing.T) {\n\tassert.Equal(t, MakePair(any(1), true), MakePair(TryAssert[any, int](1)))\n\tassert.Equal(t, MakePair(1, true), MakePair(TryAssert[int, any](any(1))))\n\n\t// Omit original type.\n\tassert.Equal(t, MakePair(any(1), true), MakePair(TryAssert[any](1)))\n\tassert.Equal(t, MakePair(1, true), MakePair(TryAssert[int](any(1))))\n\n\t// Assert failed.\n\tassert.Equal(t, MakePair(float64(0), false), MakePair(TryAssert[float64](any(1))))\n\n\tassert.NotPanic(t, func() {\n\t\tTryAssert[float64](any(1))\n\t})\n}\n\nfunc TestOnce(t *testing.T) {\n\t{\n\t\ti := 2\n\t\tf := func() int {\n\t\t\ti++\n\t\t\treturn i\n\t\t}\n\t\tassert.Equal(t, i, 2)\n\t\tonce := Once(f)\n\t\tassert.Equal(t, i, 2)\n\t\tassert.Equal(t, 3, once())\n\t\tassert.Equal(t, 3, once())\n\t\tassert.Equal(t, 3, once())\n\t\tassert.Equal(t, i, 3)\n\t}\n\n\t{ // Test concurrency.\n\t\ti := 2\n\t\tf := func() int {\n\t\t\ti++\n\t\t\treturn i\n\t\t}\n\t\tassert.Equal(t, i, 2)\n\t\tonce := Once(f)\n\t\tassert.Equal(t, i, 2)\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(100)\n\t\tfor j := 0; j < 100; j++ {\n\t\t\tgo func() {\n\t\t\t\tassert.Equal(t, 3, once())\n\t\t\t\tassert.Equal(t, i, 3)\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\tassert.Equal(t, i, 3)\n\t}\n}"
