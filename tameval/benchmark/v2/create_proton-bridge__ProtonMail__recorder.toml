[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.24"

[repo_info]
repository = "ProtonMail/proton-bridge"
sha = "42605c1923d73f0989027dce4a36c3681206f436"

[run_info]
docker_image = "golang:1.24"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/avito-tech/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/services/sendrecorder/recorder.go internal/services/sendrecorder/recorder_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/services/sendrecorder/recorder.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 90.0
original_coverage = 90.0
mutation_kill_rate = 72.0
original_mutation_kill_rate = 72.0
covered_lines = [ 44, 45, 46, 47, 48, 49, 60, 61, 62, 63, 64, 75, 76, 77, 78, 79, 80, 83, 84, 85, 86, 89, 90, 91, 93, 103, 104, 105, 106, 107, 109, 110, 111, 116, 117, 118, 120, 123, 124, 125, 126, 127, 129, 130, 131, 132, 133, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 179, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 201, 202, 203, 204, 205, 210, 211, 212, 213, 214, 217, 218, 219, 230, 231, 232, 233, 234, 235, 236, 238, 242, 243, 244, 245, 246, 247, 248, 249, 253, 256, 257, 258, 259, 268, 269, 270, 272, 273, 274, 275, 277, 283, 289,]
missed_lines = [ 112, 113, 114, 198, 206, 207, 208, 215, 216, 278, 279, 280, 284, 285, 286,]

[input_info]
test_file_path = "internal/services/sendrecorder/recorder_test.go"
focal_file_path = "internal/services/sendrecorder/recorder.go"
test_file_url = "https://github.com/ProtonMail/proton-bridge/blob/42605c1923d73f0989027dce4a36c3681206f436/internal/services/sendrecorder/recorder_test.go"
focal_file_url = "https://github.com/ProtonMail/proton-bridge/blob/42605c1923d73f0989027dce4a36c3681206f436/internal/services/sendrecorder/recorder.go"
first_commit_date = "2023-07-18"
last_commit_date = "2025-01-02"
test_file_content = "// Copyright (c) 2025 Proton AG\n//\n// This file is part of Proton Mail Bridge.\n//\n// Proton Mail Bridge is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Proton Mail Bridge is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Proton Mail Bridge.  If not, see <https://www.gnu.org/licenses/>.\n\npackage sendrecorder\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestSendHasher_Insert(t *testing.T) {\n\th := NewSendRecorder(SendEntryExpiry)\n\n\t// Insert a message into the hasher.\n\tsrdID1, hash1, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash1)\n\n\t// Simulate successfully sending the message.\n\th.SignalMessageSent(hash1, srdID1, \"abc\")\n\n\t// Inserting a message with the same hash should return false.\n\tsrdID2, _, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.False(t, ok)\n\trequire.Equal(t, srdID1, srdID2)\n\n\t// Inserting a message with a different hash should return true.\n\tsrdID3, hash2, ok, err := testTryInsert(h, literal2, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash2)\n\trequire.NotEqual(t, srdID3, srdID1)\n}\n\nfunc TestSendHasher_Insert_Expired(t *testing.T) {\n\th := NewSendRecorder(time.Second)\n\n\t// Insert a message into the hasher.\n\tsrID1, hash1, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash1)\n\n\t// Simulate successfully sending the message.\n\th.SignalMessageSent(hash1, srID1, \"abc\")\n\n\t// Wait for the entry to expire.\n\ttime.Sleep(time.Second)\n\n\t// Inserting a message with the same hash should return true because the previous entry has since expired.\n\tsrID2, hash2, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\n\t// The hashes should be the same.\n\trequire.Equal(t, hash1, hash2)\n\n\t// Send IDs should differ\n\trequire.NotEqual(t, srID2, srID1)\n}\n\nfunc TestSendHasher_Insert_DifferentToList(t *testing.T) {\n\th := NewSendRecorder(time.Second)\n\n\t// Insert a message into the hasher.\n\tsrID1, hash1, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second), []string{\"abc\", \"def\"}...)\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash1)\n\n\t// Insert the same message into the hasher but with a different to list.\n\tsrID2, hash2, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second), []string{\"abc\", \"def\", \"ghi\"}...)\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash2)\n\trequire.NotEqual(t, srID1, srID2)\n\n\t// Insert the same message into the hasher but with the same to list.\n\t_, _, ok, err = testTryInsert(h, literal1, time.Now().Add(time.Second), []string{\"abc\", \"def\", \"ghi\"}...)\n\trequire.Error(t, err)\n\trequire.False(t, ok)\n}\n\nfunc TestSendHasher_Wait_SendSuccess(t *testing.T) {\n\th := NewSendRecorder(SendEntryExpiry)\n\n\t// Insert a message into the hasher.\n\tsrID1, hash, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash)\n\n\t// Simulate successfully sending the message after half a second.\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 500)\n\t\th.SignalMessageSent(hash, srID1, \"abc\")\n\t}()\n\n\t// Inserting a message with the same hash should fail.\n\tsrID2, _, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.False(t, ok)\n\trequire.Equal(t, srID1, srID2)\n}\n\nfunc TestSendHasher_Wait_SendFail(t *testing.T) {\n\th := NewSendRecorder(SendEntryExpiry)\n\n\t// Insert a message into the hasher.\n\tsrID1, hash, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash)\n\n\t// Simulate failing to send the message after half a second.\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 500)\n\t\th.RemoveOnFail(hash, srID1)\n\t}()\n\n\t// Inserting a message with the same hash should succeed because the first message failed to send.\n\tsrID2, hash2, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEqual(t, srID2, srID1)\n\n\t// The hashes should be the same.\n\trequire.Equal(t, hash, hash2)\n}\n\nfunc TestSendHasher_Wait_Timeout(t *testing.T) {\n\th := NewSendRecorder(SendEntryExpiry)\n\n\t// Insert a message into the hasher.\n\t_, hash, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash)\n\n\t// We should fail to insert because the message is not sent within the timeout period.\n\t_, _, _, err = testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.Error(t, err)\n}\n\nfunc TestSendHasher_HasEntry(t *testing.T) {\n\th := NewSendRecorder(SendEntryExpiry)\n\n\t// Insert a message into the hasher.\n\tsrID1, hash, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash)\n\n\t// Simulate successfully sending the message.\n\th.SignalMessageSent(hash, srID1, \"abc\")\n\n\t// The message was already sent; we should find it in the hasher.\n\tmessageID, ok, err := testHasEntry(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.Equal(t, \"abc\", messageID)\n}\n\nfunc TestSendHasher_HasEntry_SendSuccess(t *testing.T) {\n\th := NewSendRecorder(SendEntryExpiry)\n\n\t// Insert a message into the hasher.\n\tsrID1, hash, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash)\n\n\t// Simulate successfully sending the message after half a second.\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 500)\n\t\th.SignalMessageSent(hash, srID1, \"abc\")\n\t}()\n\n\t// The message was already sent; we should find it in the hasher.\n\tmessageID, ok, err := testHasEntry(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.Equal(t, \"abc\", messageID)\n}\n\nfunc TestSendHasher_DualAddDoesNotCauseCrash(t *testing.T) {\n\t// There may be a rare case where one 2 smtp connections attempt to send the same message, but if the first message\n\t// is stuck long enough for it to expire, the second connection will remove it from the list and cause it to be\n\t// inserted as a new entry. The two clients end up sending the message twice and calling the `SignalMessageSent` x2,\n\t// resulting in a crash.\n\th := NewSendRecorder(SendEntryExpiry)\n\n\t// Insert a message into the hasher.\n\tsrID1, hash, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash)\n\n\t// Simulate successfully sending the message. We call this method twice as it possible for multiple SMTP connections\n\t// to attempt to send the same message.\n\th.SignalMessageSent(hash, srID1, \"abc\")\n\th.SignalMessageSent(hash, srID1, \"abc\")\n\n\t// The message was already sent; we should find it in the hasher.\n\tmessageID, ok, err := testHasEntry(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.Equal(t, \"abc\", messageID)\n}\n\nfunc TestSendHashed_MessageWithSameHasButDifferentRecipientsIsInserted(t *testing.T) {\n\th := NewSendRecorder(SendEntryExpiry)\n\n\t// Insert a message into the hasher.\n\tsrID1, hash, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second), \"Receiver <receiver@pm.me>\")\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash)\n\n\tsrID2, hash2, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second), \"Receiver <receiver@pm.me>\", \"Receiver2 <receiver2@pm.me>\")\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash2)\n\trequire.Equal(t, hash, hash2)\n\n\t// Should map to different requests\n\trequire.NotEqual(t, srID2, srID1)\n}\n\nfunc TestSendHashed_SameMessageWIthDifferentToListShouldWaitSuccessfullyAfterSend(t *testing.T) {\n\t// Check that if we send the same message twice with different recipients and the second message is somehow\n\t// sent before the first, ensure that we check if the message was sent we wait on the correct object.\n\th := NewSendRecorder(SendEntryExpiry)\n\n\t// Insert a message into the hasher.\n\t_, hash, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Minute), \"Receiver <receiver@pm.me>\")\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash)\n\n\tsrID2, hash2, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Microsecond), \"Receiver <receiver@pm.me>\", \"Receiver2 <receiver2@pm.me>\")\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash2)\n\trequire.Equal(t, hash, hash2)\n\n\t// simulate message sent\n\th.SignalMessageSent(hash2, srID2, \"newID\")\n\n\t// Simulate Wait on message 2\n\t_, ok, err = h.HasEntryWait(context.Background(), hash2, time.Now().Add(time.Second), []string{\"Receiver <receiver@pm.me>\", \"Receiver2 <receiver2@pm.me>\"})\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n}\n\nfunc TestSendHasher_HasEntry_SendFail(t *testing.T) {\n\th := NewSendRecorder(SendEntryExpiry)\n\n\t// Insert a message into the hasher.\n\tsrID1, hash, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash)\n\n\t// Simulate failing to send the message after half a second.\n\tgo func() {\n\t\ttime.Sleep(time.Millisecond * 500)\n\t\th.RemoveOnFail(hash, srID1)\n\t}()\n\n\t// The message failed to send; we should not find it in the hasher.\n\t_, ok, err = testHasEntry(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.False(t, ok)\n}\n\nfunc TestSendHasher_HasEntry_Timeout(t *testing.T) {\n\th := NewSendRecorder(SendEntryExpiry)\n\n\t// Insert a message into the hasher.\n\t_, hash, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash)\n\n\t// The message is never sent; we should not find it in the hasher.\n\t_, ok, err = testHasEntry(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.False(t, ok)\n}\n\nfunc TestSendHasher_HasEntry_Expired(t *testing.T) {\n\th := NewSendRecorder(time.Second)\n\n\t// Insert a message into the hasher.\n\tsrID1, hash, ok, err := testTryInsert(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.True(t, ok)\n\trequire.NotEmpty(t, hash)\n\n\t// Simulate successfully sending the message.\n\th.SignalMessageSent(hash, srID1, \"abc\")\n\n\t// Wait for the entry to expire.\n\ttime.Sleep(time.Second)\n\n\t// The entry has expired; we should not find it in the hasher.\n\t_, ok, err = testHasEntry(h, literal1, time.Now().Add(time.Second))\n\trequire.NoError(t, err)\n\trequire.False(t, ok)\n}\n\nconst literal1 = `From: Sender <sender@pm.me>\nTo: Receiver <receiver@pm.me>\nContent-Type: multipart/mixed; boundary=longrandomstring\n\n--longrandomstring\n\nbody\n--longrandomstring\nContent-Disposition: attachment; filename=\"attname.txt\"\n\nattachment\n--longrandomstring--\n`\nconst literal2 = `From: Sender <sender@pm.me>\nTo: Receiver <receiver@pm.me>\nContent-Type: multipart/mixed; boundary=longrandomstring\n\n--longrandomstring\n\nbody\n--longrandomstring\nContent-Disposition: attachment; filename=\"attname2.txt\"\n\nattachment\n--longrandomstring--\n`\n\nfunc TestGetMessageHash(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tlit1, lit2 []byte\n\t\twantEqual  bool\n\t}{\n\t\t{\n\t\t\tname:      \"empty\",\n\t\t\tlit1:      []byte{},\n\t\t\tlit2:      []byte{},\n\t\t\twantEqual: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"same to\",\n\t\t\tlit1:      []byte(\"To: someone@pm.me\\r\\n\\r\\nHello world!\"),\n\t\t\tlit2:      []byte(\"To: someone@pm.me\\r\\n\\r\\nHello world!\"),\n\t\t\twantEqual: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"different to\",\n\t\t\tlit1:      []byte(\"To: someone@pm.me\\r\\n\\r\\nHello world!\"),\n\t\t\tlit2:      []byte(\"To: another@pm.me\\r\\n\\r\\nHello world!\"),\n\t\t\twantEqual: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"same from\",\n\t\t\tlit1:      []byte(\"From: someone@pm.me\\r\\n\\r\\nHello world!\"),\n\t\t\tlit2:      []byte(\"From: someone@pm.me\\r\\n\\r\\nHello world!\"),\n\t\t\twantEqual: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"different from\",\n\t\t\tlit1:      []byte(\"From: someone@pm.me\\r\\n\\r\\nHello world!\"),\n\t\t\tlit2:      []byte(\"From: another@pm.me\\r\\n\\r\\nHello world!\"),\n\t\t\twantEqual: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"same subject\",\n\t\t\tlit1:      []byte(\"Subject: Hello world!\\r\\n\\r\\nHello world!\"),\n\t\t\tlit2:      []byte(\"Subject: Hello world!\\r\\n\\r\\nHello world!\"),\n\t\t\twantEqual: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"different subject\",\n\t\t\tlit1:      []byte(\"Subject: Hello world!\\r\\n\\r\\nHello world!\"),\n\t\t\tlit2:      []byte(\"Subject: Goodbye world!\\r\\n\\r\\nHello world!\"),\n\t\t\twantEqual: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"same plaintext body\",\n\t\t\tlit1:      []byte(\"To: someone@pm.me\\r\\nContent-Type: text/plain\\r\\n\\r\\nHello world!\"),\n\t\t\tlit2:      []byte(\"To: someone@pm.me\\r\\nContent-Type: text/plain\\r\\n\\r\\nHello world!\"),\n\t\t\twantEqual: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"different plaintext body\",\n\t\t\tlit1:      []byte(\"To: someone@pm.me\\r\\nContent-Type: text/plain\\r\\n\\r\\nHello world!\"),\n\t\t\tlit2:      []byte(\"To: someone@pm.me\\r\\nContent-Type: text/plain\\r\\n\\r\\nGoodbye world!\"),\n\t\t\twantEqual: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"different attachment filenames\",\n\t\t\tlit1:      []byte(literal1),\n\t\t\tlit2:      []byte(literal2),\n\t\t\twantEqual: false,\n\t\t},\n\t\t{\n\t\t\tname:      \"different date and message ID should still match\",\n\t\t\tlit1:      []byte(\"To: a@b.c\\r\\nDate: Fri, 13 Aug 1982\\r\\nMessage-Id: 1@b.c\\r\\n\\r\\nHello\"),\n\t\t\tlit2:      []byte(\"To: a@b.c\\r\\nDate: Sat, 14 Aug 1982\\r\\nMessage-Id: 2@b.c\\r\\n\\r\\nHello\"),\n\t\t\twantEqual: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\thash1, err := GetMessageHash(tt.lit1)\n\t\t\trequire.NoError(t, err)\n\n\t\t\thash2, err := GetMessageHash(tt.lit2)\n\t\t\trequire.NoError(t, err)\n\n\t\t\tif tt.wantEqual {\n\t\t\t\trequire.Equal(t, hash1, hash2)\n\t\t\t} else {\n\t\t\t\trequire.NotEqual(t, hash1, hash2)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc testTryInsert(h *SendRecorder, literal string, deadline time.Time, toList ...string) (ID, string, bool, error) { //nolint:unparam\n\thash, err := GetMessageHash([]byte(literal))\n\tif err != nil {\n\t\treturn 0, \"\", false, err\n\t}\n\n\tsrID, ok, err := h.TryInsertWait(context.Background(), hash, toList, deadline)\n\tif err != nil {\n\t\treturn 0, \"\", false, err\n\t}\n\n\treturn srID, hash, ok, nil\n}\n\nfunc testHasEntry(h *SendRecorder, literal string, deadline time.Time, toList ...string) (string, bool, error) { //nolint:unparam\n\thash, err := GetMessageHash([]byte(literal))\n\tif err != nil {\n\t\treturn \"\", false, err\n\t}\n\n\treturn h.HasEntryWait(context.Background(), hash, deadline, toList)\n}\n"
