[meta]
task = "repair"
scenario = "repair_missed_asserts"

[lang_info]
lang = "Python"
python_version = "3.12"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "flyteorg/flytekit"
sha = "5503ee5e232fdbc633af39c7f4539a04906102fc"

[run_info]
docker_image = "python:3.12"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r dev-requirements.txt && (pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=flytekit/interaction/click_types.py -m pytest -q --junit-xml=test_output.xml tests/flytekit/unit/interaction/test_click_types.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target flytekit.interaction.click_types --unit-test tests.flytekit.unit.interaction.test_click_types --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target flytekit/interaction/click_types.py --unit-test tests/flytekit/unit/interaction/test_click_types.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 71.0
original_coverage = 79.0
mutation_kill_rate = 100.0
original_mutation_kill_rate = 100.0
covered_lines = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 36, 37, 38, 39, 52, 56, 58, 59, 60, 61, 62, 63, 67, 83, 84, 86, 89, 94, 95, 96, 97, 99, 102, 107, 109, 121, 122, 124, 127, 131, 132, 133, 134, 136, 139, 140, 142, 145, 148, 149, 150, 151, 152, 154, 155, 156, 157, 158, 159, 160, 161, 162, 165, 166, 168, 174, 175, 176, 177, 178, 179, 180, 182, 183, 184, 186, 189, 190, 191, 192, 193, 194, 195, 197, 200, 203, 204, 206, 207, 208, 209, 211, 212, 213, 214, 215, 218, 219, 220, 222, 224, 227, 228, 230, 233, 235, 236, 240, 241, 242, 243, 245, 255, 260, 261, 262, 264, 265, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 279, 280, 282, 299, 300, 302, 303, 304, 306, 307, 308, 309, 310, 311, 312, 314, 316, 319, 320, 321, 322, 323, 325, 328, 330, 331, 333, 335, 355, 357, 359, 361, 365, 368, 370, 371, 372, 373, 374, 375, 379, 400, 401, 403, 406, 431, 441, 445, 446, 447, 448, 449, 450, 451, 454, 455, 457, 460, 461, 462, 463, 465, 466, 468, 477, 478, 479, 480, 481, 482, 483, 484, 486, 489, 490, 492, 499, 500, 501, 502, 503, 505, 506, 509, 512, 518, 520, 522, 526, 530, 531,]
missed_lines = [ 41, 42, 43, 45, 46, 47, 49, 57, 64, 71, 72, 73, 74, 75, 76, 78, 79, 80, 90, 98, 112, 113, 114, 115, 116, 117, 118, 128, 135, 143, 153, 171, 201, 210, 234, 237, 248, 249, 250, 251, 252, 266, 289, 290, 291, 292, 293, 294, 295, 296, 317, 318, 329, 369, 377, 380, 385, 386, 387, 389, 390, 393, 394, 397, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 426, 458, 469, 470, 471, 472, 473, 474, 475, 507, 510, 519, 524, 527, 533, 534, 535, 536, 537, 538,]

[input_info]
test_file_path = "tests/flytekit/unit/interaction/test_click_types.py"
focal_file_path = "flytekit/interaction/click_types.py"
test_file_url = "https://github.com/flyteorg/flytekit/blob/5503ee5e232fdbc633af39c7f4539a04906102fc/tests/flytekit/unit/interaction/test_click_types.py"
focal_file_url = "https://github.com/flyteorg/flytekit/blob/5503ee5e232fdbc633af39c7f4539a04906102fc/flytekit/interaction/click_types.py"
first_commit_date = "2023-09-12"
last_commit_date = "2025-02-14"
test_file_content = "import os\nfrom dataclasses import field\nimport json\nimport sys\nimport tempfile\nimport typing\nfrom datetime import datetime, timedelta\nfrom enum import Enum\nfrom typing import Optional\n\nimport click\nimport mock\nimport pytest\nimport yaml\n\nfrom flytekit import FlyteContextManager\nfrom flytekit.core.artifact import Artifact\nfrom flytekit.core.type_engine import TypeEngine\nfrom flytekit.interaction.click_types import (\n    DateTimeType,\n    DirParamType,\n    DurationParamType,\n    EnumParamType,\n    FileParamType,\n    FlyteLiteralConverter,\n    JsonParamType,\n    PickleParamType,\n    StructuredDatasetParamType,\n    UnionParamType,\n    key_value_callback,\n)\n\ndummy_param = click.Option([\"--dummy\"], type=click.STRING, default=\"dummy\")\n\ndef test_dir_param():\n    import os\n    m = mock.MagicMock()\n    current_file_directory = os.path.dirname(os.path.abspath(__file__))\n    l = DirParamType().convert(current_file_directory, m, m)\n    r = DirParamType().convert(\"https://tmp/dir\", m, m)\n\ndef test_file_param():\n    m = mock.MagicMock()\n    l = FileParamType().convert(__file__, m, m)\n    r = FileParamType().convert(\"https://tmp/file\", m, m)\n\n\nclass Color(Enum):\n    RED = \"red\"\n    GREEN = \"green\"\n    BLUE = \"blue\"\n\n\n@pytest.mark.parametrize(\n    \"python_type, python_value\",\n    [\n        (typing.Union[typing.List[int], str, Color], \"flyte\"),\n        (typing.Union[typing.List[int], str, Color], \"red\"),\n        (typing.Union[typing.List[int], str, Color], [1, 2, 3]),\n        (typing.List[int], [1, 2, 3]),\n        (typing.Dict[str, int], {\"flyte\": 2}),\n    ],\n)\ndef test_literal_converter(python_type, python_value):\n    ctx = FlyteContextManager.current_context()\n    lt = TypeEngine.to_literal_type(python_type)\n\n    lc = FlyteLiteralConverter(\n        ctx,\n        literal_type=lt,\n        python_type=python_type,\n        is_remote=True,\n    )\n\n    click_ctx = click.Context(click.Command(\"test_command\"), obj={\"remote\": True})\n\n\ndef test_literal_converter_query():\n    ctx = FlyteContextManager.current_context()\n    lt = TypeEngine.to_literal_type(int)\n\n    lc = FlyteLiteralConverter(\n        ctx,\n        literal_type=lt,\n        python_type=int,\n        is_remote=True,\n    )\n\n    a = Artifact(name=\"test-artifact\")\n    query = a.query()\n    click_ctx = click.Context(click.Command(\"test_command\"), obj={\"remote\": True})\n\n\n@pytest.mark.parametrize(\n    \"python_type, python_str_value, python_value\",\n    [\n        (Color, \"red\", Color.RED),\n        (int, \"1\", 1),\n        (float, \"1.0\", 1.0),\n        (bool, \"True\", True),\n        (bool, \"False\", False),\n        (str, \"flyte\", \"flyte\"),\n        (typing.List[int], \"[1, 2, 3]\", [1, 2, 3]),\n        (typing.Dict[str, int], '{\"a\": 1}', {\"a\": 1}),\n        (bool, \"true\", True),\n        (bool, \"false\", False),\n        (bool, \"TRUE\", True),\n        (bool, \"FALSE\", False),\n        (bool, \"t\", True),\n        (bool, \"f\", False),\n        (typing.Optional[int], \"1\", 1),\n        (typing.Union[int, str, Color], \"1\", 1),\n        (typing.Union[Color, str], \"hello\", \"hello\"),\n        (typing.Union[Color, str], \"red\", Color.RED),\n        (typing.Union[int, str, Color], \"Hello\", \"Hello\"),\n        (typing.Union[int, str, Color], \"red\", Color.RED),\n        (typing.Union[int, str, Color, float], \"1.1\", 1.1),\n    ],\n)\ndef test_enum_converter(python_type: typing.Type, python_str_value: str, python_value: typing.Any):\n    p = dummy_param\n    pt = python_type\n    click_ctx = click.Context(click.Command(\"test_command\"), obj={\"remote\": True})\n    ctx = FlyteContextManager.current_context()\n    lt = TypeEngine.to_literal_type(pt)\n    lc = FlyteLiteralConverter(ctx, literal_type=lt, python_type=pt, is_remote=True)\n\n\ndef test_duration_type():\n    t = DurationParamType()\n\n    with pytest.raises(click.BadParameter):\n        t.convert(None, None, None)\n\n\n# write a helper function that calls convert and checks the result\ndef _datetime_helper(t: click.ParamType, value: str, expected: datetime):\n    v = t.convert(value, None, None)\n\n\ndef test_datetime_type():\n    t = DateTimeType()\n\n\n    now = datetime.now()\n    _datetime_helper(t, \"now\", now)\n\n    today = datetime.today()\n    _datetime_helper(t, \"today\", today)\n\n    add = datetime.now() + timedelta(days=1)\n    _datetime_helper(t, \"now + 1d\", add)\n\n    sub = datetime.now() - timedelta(days=1)\n    _datetime_helper(t, \"now - 1d\", sub)\n\n    fmt_v = \"2020-01-01T10:10:00\"\n    d = t.convert(fmt_v, None, None)\n    _datetime_helper(t, fmt_v, d)\n\n    _datetime_helper(t, f\"{fmt_v} + 1d\", d + timedelta(days=1))\n\n    with pytest.raises(click.BadParameter):\n        t.convert(\"now-1d\", None, None)\n\n    with pytest.raises(click.BadParameter):\n        t.convert(\"now + 1\", None, None)\n\n    with pytest.raises(click.BadParameter):\n        t.convert(\"now + 1abc\", None, None)\n\n    with pytest.raises(click.BadParameter):\n        t.convert(\"aaa + 1d\", None, None)\n\n    fmt_v = \"2024-07-29 13:47:07.643004+00:00\"\n    d = t.convert(fmt_v, None, None)\n    _datetime_helper(t, fmt_v, d)\n\n\ndef test_json_type():\n    t = JsonParamType(typing.Dict[str, str])\n\n    with pytest.raises(click.BadParameter):\n        t.convert(None, None, None)\n\n    # test that it loads a json file\n    with tempfile.NamedTemporaryFile(\"w\", delete=False) as f:\n        json.dump({\"a\": \"b\"}, f)\n        f.flush()\n\n    # test that if the file is not a valid json, it raises an error\n    with tempfile.NamedTemporaryFile(\"w\", delete=False) as f:\n        f.write(\"asdf\")\n        f.flush()\n        with pytest.raises(click.BadParameter):\n            t.convert(value=f.name, param=dummy_param, ctx=None)\n\n    # test if the file does not exist\n    with pytest.raises(click.BadParameter):\n        t.convert(value=\"asdf\", param=None, ctx=None)\n\n    # test if the file is yaml and ends with .yaml it works correctly\n    with tempfile.NamedTemporaryFile(\"w\", suffix=\".yaml\", delete=False) as f:\n        yaml.dump({\"a\": \"b\"}, f)\n        f.flush()\n\n\ndef test_key_value_callback():\n    \"\"\"Write a test that verifies that the callback works correctly.\"\"\"\n    ctx = click.Context(click.Command(\"test_command\"), obj={\"remote\": True})\n    with pytest.raises(click.BadParameter):\n        key_value_callback(ctx, \"a\", [\"a=b\", \"c\"])\n    with pytest.raises(click.BadParameter):\n        key_value_callback(ctx, \"a\", [\"a=b\", \"c=d\", \"e\"])\n    with pytest.raises(click.BadParameter):\n        key_value_callback(ctx, \"a\", [\"a=b\", \"c=d\", \"e=f\", \"g\"])\n\n\n@pytest.mark.parametrize(\n    \"param_type\",\n    [\n        (DateTimeType()),\n        (DurationParamType()),\n        (JsonParamType(typing.Dict[str, str])),\n        (UnionParamType([click.FLOAT, click.INT])),\n        (EnumParamType(Color)),\n        (PickleParamType()),\n        (StructuredDatasetParamType()),\n        (DirParamType()),\n    ],\n)\ndef test_query_passing(param_type: click.ParamType):\n    a = Artifact(name=\"test-artifact\")\n    query = a.query()\n\n\n\ndef test_dataclass_type():\n    from dataclasses import dataclass\n\n    @dataclass\n    class Datum:\n        x: int\n        y: str\n        z: typing.Dict[int, str]\n        w: typing.List[int]\n\n    t = JsonParamType(Datum)\n    value = '{ \"x\": 1, \"y\": \"2\", \"z\": { \"1\": \"one\", \"2\": \"two\" }, \"w\": [1, 2, 3] }'\n    v = t.convert(value=value, param=None, ctx=None)\n\n\n\ndef test_nested_dataclass_type():\n    from dataclasses import dataclass\n\n    @dataclass\n    class Datum:\n        w: int\n        x: str = \"default\"\n        y: typing.Dict[str, str] = field(default_factory=lambda: {\"key\": \"value\"})\n        z: typing.List[int] = field(default_factory=lambda: [1, 2, 3])\n\n    @dataclass\n    class NestedDatum:\n        w: Datum\n        x: typing.List[Datum]\n        y: typing.Dict[str, Datum] = field(default_factory=lambda: {\"key\": Datum(1)})\n\n\n    # typing.List[Datum]\n    value = '[{ \"w\": 1 }]'\n    t = JsonParamType(typing.List[Datum])\n    v = t.convert(value=value, param=None, ctx=None)\n\n    ctx = FlyteContextManager.current_context()\n    lt = TypeEngine.to_literal_type(typing.List[Datum])\n    literal_converter = FlyteLiteralConverter(\n        ctx, literal_type=lt, python_type=typing.List[Datum], is_remote=False\n    )\n    v = literal_converter.convert(ctx, None, v)\n\n\n    # typing.Dict[str, Datum]\n    value = '{ \"x\": { \"w\": 1 } }'\n    t = JsonParamType(typing.Dict[str, Datum])\n    v = t.convert(value=value, param=None, ctx=None)\n    ctx = FlyteContextManager.current_context()\n    lt = TypeEngine.to_literal_type(typing.Dict[str, Datum])\n    literal_converter = FlyteLiteralConverter(\n        ctx, literal_type=lt, python_type=typing.Dict[str, Datum], is_remote=False\n    )\n    v = literal_converter.convert(ctx, None, v)\n\n\n    # typing.List[NestedDatum]\n    value = '[{\"w\":{ \"w\" : 1 },\"x\":[{ \"w\" : 1 }]}]'\n    t = JsonParamType(typing.List[NestedDatum])\n    v = t.convert(value=value, param=None, ctx=None)\n    ctx = FlyteContextManager.current_context()\n    lt = TypeEngine.to_literal_type(typing.List[NestedDatum])\n    literal_converter = FlyteLiteralConverter(\n        ctx, literal_type=lt, python_type=typing.List[NestedDatum], is_remote=False\n    )\n    v = literal_converter.convert(ctx, None, v)\n\n\n    # typing.List[typing.List[Datum]]\n    value = '[[{ \"w\": 1 }]]'\n    t = JsonParamType(typing.List[typing.List[Datum]])\n    v = t.convert(value=value, param=None, ctx=None)\n    ctx = FlyteContextManager.current_context()\n    lt = TypeEngine.to_literal_type(typing.List[typing.List[Datum]])\n    literal_converter = FlyteLiteralConverter(\n        ctx, literal_type=lt, python_type=typing.List[typing.List[Datum]], is_remote=False\n    )\n    v = literal_converter.convert(ctx, None, v)\n\n\ndef test_dataclass_with_default_none():\n    from dataclasses import dataclass\n\n    @dataclass\n    class Datum:\n        x: int\n        y: Optional[str] = None\n        z: Optional[typing.Dict[int, str]] = None\n        w: Optional[typing.List[int]] = None\n\n    t = JsonParamType(Datum)\n    value = '{ \"x\": 1 }'\n    v = t.convert(value=value, param=None, ctx=None)\n    lt = TypeEngine.to_literal_type(Datum)\n    ctx = FlyteContextManager.current_context()\n    literal_converter = FlyteLiteralConverter(\n        ctx, literal_type=lt, python_type=Datum, is_remote=False\n    )\n    v = literal_converter.convert(ctx=ctx, param=None, value=v)\n\n\n\ndef test_dataclass_with_flyte_type_exception():\n    from dataclasses import dataclass\n    from flytekit import StructuredDataset\n    from flytekit.types.directory import FlyteDirectory\n    from flytekit.types.file import FlyteFile\n    import os\n\n    DIR_NAME = os.path.dirname(os.path.realpath(__file__))\n    parquet_file = os.path.join(DIR_NAME, \"testdata/df.parquet\")\n\n    @dataclass\n    class Datum:\n        x: FlyteFile\n        y: FlyteDirectory\n        z: StructuredDataset\n\n    t = JsonParamType(Datum)\n    value = { \"x\": parquet_file, \"y\": DIR_NAME, \"z\": os.path.join(DIR_NAME, \"testdata\")}\n\n    with pytest.raises(AttributeError):\n        t.convert(value=value, param=None, ctx=None)\n\ndef test_dataclass_with_optional_fields():\n    from dataclasses import dataclass\n    from typing import Optional\n\n    @dataclass\n    class Datum:\n        x: int\n        y: Optional[str] = None\n        z: Optional[typing.Dict[int, str]] = None\n        w: Optional[typing.List[int]] = None\n\n    t = JsonParamType(Datum)\n    value = '{ \"x\": 1 }'\n    v = t.convert(value=value, param=None, ctx=None)\n    lt = TypeEngine.to_literal_type(Datum)\n    ctx = FlyteContextManager.current_context()\n    literal_converter = FlyteLiteralConverter(\n        ctx, literal_type=lt, python_type=Datum, is_remote=False\n    )\n    v = literal_converter.convert(ctx=ctx, param=None, value=v)\n\n    # Assertions to check the Optional fields\n\n    # Test with all fields provided\n    value = '{ \"x\": 2, \"y\": \"test\", \"z\": {\"1\": \"value\"}, \"w\": [1, 2, 3] }'\n    v = t.convert(value=value, param=None, ctx=None)\n    v = literal_converter.convert(ctx=ctx, param=None, value=v)\n\n\ndef test_nested_dataclass_with_optional_fields():\n    from dataclasses import dataclass\n    from typing import Optional, List, Dict\n\n    @dataclass\n    class InnerDatum:\n        a: int\n        b: Optional[str] = None\n\n    @dataclass\n    class Datum:\n        x: int\n        y: Optional[InnerDatum] = None\n        z: Optional[Dict[str, InnerDatum]] = None\n        w: Optional[List[InnerDatum]] = None\n\n    t = JsonParamType(Datum)\n\n    # Case 1: Only required field provided\n    value = '{ \"x\": 1 }'\n    v = t.convert(value=value, param=None, ctx=None)\n    lt = TypeEngine.to_literal_type(Datum)\n    ctx = FlyteContextManager.current_context()\n    literal_converter = FlyteLiteralConverter(\n        ctx, literal_type=lt, python_type=Datum, is_remote=False\n    )\n    v = literal_converter.convert(ctx=ctx, param=None, value=v)\n\n    # Assertions to check the Optional fields\n\n    # Case 2: All fields provided with nested structures\n    value = '''\n    {\n        \"x\": 2,\n        \"y\": {\"a\": 10, \"b\": \"inner\"},\n        \"z\": {\"key\": {\"a\": 20, \"b\": \"nested\"}},\n        \"w\": [{\"a\": 30, \"b\": \"list_item\"}]\n    }\n    '''\n    v = t.convert(value=value, param=None, ctx=None)\n    v = literal_converter.convert(ctx=ctx, param=None, value=v)\n\n    # Assertions for nested structure\n\n\n@pytest.mark.skipif(\n    sys.version_info < (3, 12), reason=\"handling for windows is nicer with delete_on_close, which doesn't exist before 3.12\"\n)\ndef test_pickle_type():\n    t = PickleParamType()\n    value = {\"a\": \"b\"}\n    v = t.convert(value=value, param=None, ctx=None)\n\n    t.convert(\"\", None, None)\n\n    t.convert(\"module.x\", None, None)\n\n    with pytest.raises(click.BadParameter):\n        t.convert(\"module:var\", None, None)\n\n    with pytest.raises(click.BadParameter):\n        t.convert(\"typing:not_exists\", None, None)\n\n    # test that it can load a variable from a module\n    with tempfile.NamedTemporaryFile(\"w\", dir=\".\", suffix=\".py\", delete=True, delete_on_close=False) as f:\n        f.write(\"a = 1\")\n        f.flush()\n        f.close()\n        # find the base name of the file\n        basename = os.path.basename(f.name).split(\".\")[0]\n"
