[meta]
task = "repair"
scenario = "repair_missed_dependencies"

[lang_info]
lang = "Go"
go_version = "1.23.0"

[repo_info]
repository = "redpanda-data/benthos"
sha = "7da18c5fb096a3607f9f70c06614742b24ae938e"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/impl/pure/processor_mutation.go internal/impl/pure/processor_mutation_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/impl/pure/processor_mutation.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 92.0
mutation_kill_rate = 0.0
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "internal/impl/pure/processor_mutation_test.go"
focal_file_path = "internal/impl/pure/processor_mutation.go"
test_file_url = "https://github.com/redpanda-data/benthos/blob/7da18c5fb096a3607f9f70c06614742b24ae938e/internal/impl/pure/processor_mutation_test.go"
focal_file_url = "https://github.com/redpanda-data/benthos/blob/7da18c5fb096a3607f9f70c06614742b24ae938e/internal/impl/pure/processor_mutation.go"
first_commit_date = "2022-07-29"
last_commit_date = "2025-01-09"
test_file_content = "// Copyright 2025 Redpanda Data, Inc.\n\npackage pure\n\n\nfunc TestMutationCreateCrossfire(t *testing.T) {\n\ttCtx := context.Background()\n\n\tinMsg := message.NewPart(nil)\n\tinMsg.SetStructuredMut(map[string]any{\n\t\t\"foo\": map[string]any{\n\t\t\t\"bar\": map[string]any{\n\t\t\t\t\"baz\": \"original value\",\n\t\t\t\t\"qux\": \"dont change\",\n\t\t\t},\n\t\t},\n\t})\n\tinMsg.MetaSetMut(\"foo\", \"orig1\")\n\tinMsg.MetaSetMut(\"bar\", \"orig2\")\n\n\tinMsg2 := message.NewPart([]byte(`{}`))\n\n\texec, err := bloblang.Parse(`\na = batch_index()\nfoo = json(\"foo\").from(0)\nfoo.bar_new = \"this is swapped now\"\nfoo.bar.baz = \"and this changed\"\nmeta foo = meta(\"foo\").from(0)\nmeta bar = meta(\"bar\").from(0)\nmeta baz = \"new meta\"\n`)\n\trequire.NoError(t, err)\n\n\tproc := newMutation(exec, nil)\n\n\tinBatch := message.Batch{inMsg, inMsg2}\n\toutBatches, err := proc.ProcessBatch(processor.TestBatchProcContext(tCtx, nil, inBatch), inBatch)\n\trequire.NoError(t, err)\n\trequire.Len(t, outBatches, 1)\n\trequire.Len(t, outBatches[0], 2)\n\n\tmsgBytes := inMsg.AsBytes()\n\tassert.Equal(t, `{\"a\":0,\"foo\":{\"bar\":{\"baz\":\"and this changed\",\"qux\":\"dont change\"},\"bar_new\":\"this is swapped now\"}}`, string(msgBytes))\n\tv, _ := inMsg.MetaGetMut(\"foo\")\n\tassert.Equal(t, \"orig1\", v)\n\tv, _ = inMsg.MetaGetMut(\"bar\")\n\tassert.Equal(t, \"orig2\", v)\n\tv, _ = inMsg.MetaGetMut(\"baz\")\n\tassert.Equal(t, \"new meta\", v)\n\n\tmsgBytes = inMsg2.AsBytes()\n\tassert.Equal(t, `{\"a\":1,\"foo\":{\"bar\":{\"baz\":\"and this changed\",\"qux\":\"dont change\"},\"bar_new\":\"this is swapped now\"}}`, string(msgBytes))\n\tv, _ = inMsg2.MetaGetMut(\"foo\")\n\tassert.Equal(t, \"orig1\", v)\n\tv, _ = inMsg2.MetaGetMut(\"bar\")\n\tassert.Equal(t, \"orig2\", v)\n\tv, _ = inMsg2.MetaGetMut(\"baz\")\n\tassert.Equal(t, \"new meta\", v)\n\n\tmsgBytes = outBatches[0][0].AsBytes()\n\tassert.Equal(t, `{\"a\":0,\"foo\":{\"bar\":{\"baz\":\"and this changed\",\"qux\":\"dont change\"},\"bar_new\":\"this is swapped now\"}}`, string(msgBytes))\n\tv, _ = outBatches[0][0].MetaGetMut(\"foo\")\n\tassert.Equal(t, \"orig1\", v)\n\tv, _ = outBatches[0][0].MetaGetMut(\"bar\")\n\tassert.Equal(t, \"orig2\", v)\n\tv, _ = outBatches[0][0].MetaGetMut(\"baz\")\n\tassert.Equal(t, \"new meta\", v)\n\n\tmsgBytes = outBatches[0][1].AsBytes()\n\tassert.Equal(t, `{\"a\":1,\"foo\":{\"bar\":{\"baz\":\"and this changed\",\"qux\":\"dont change\"},\"bar_new\":\"this is swapped now\"}}`, string(msgBytes))\n\tv, _ = outBatches[0][1].MetaGetMut(\"foo\")\n\tassert.Equal(t, \"orig1\", v)\n\tv, _ = outBatches[0][1].MetaGetMut(\"bar\")\n\tassert.Equal(t, \"orig2\", v)\n\tv, _ = outBatches[0][1].MetaGetMut(\"baz\")\n\tassert.Equal(t, \"new meta\", v)\n}\n\nfunc TestMutationCreateCustomObject(t *testing.T) {\n\ttCtx := context.Background()\n\n\tpart := message.NewPart(nil)\n\n\tgObj := gabs.New()\n\t_, _ = gObj.ArrayOfSize(3, \"foos\")\n\n\tgObjEle := gabs.New()\n\t_, _ = gObjEle.Set(\"FROM NEW OBJECT\", \"foo\")\n\n\t_, _ = gObj.S(\"foos\").SetIndex(gObjEle.Data(), 0)\n\t_, _ = gObj.S(\"foos\").SetIndex(5, 1)\n\n\tpart.SetStructuredMut(gObj.Data())\n\n\texec, err := bloblang.Parse(`root.foos = this.foos`)\n\trequire.NoError(t, err)\n\n\tproc := newMutation(exec, nil)\n\n\tinBatch := message.Batch{part}\n\toutBatches, err := proc.ProcessBatch(processor.TestBatchProcContext(tCtx, nil, inBatch), inBatch)\n\trequire.NoError(t, err)\n\trequire.Len(t, outBatches, 1)\n\trequire.Len(t, outBatches[0], 1)\n\n\tresPartBytes := outBatches[0][0].AsBytes()\n\tassert.Equal(t, `{\"foos\":[{\"foo\":\"FROM NEW OBJECT\"},5,null]}`, string(resPartBytes))\n}\n\nfunc TestMutationCreateFiltering(t *testing.T) {\n\ttCtx := context.Background()\n\n\tinBatch := message.Batch{\n\t\tmessage.NewPart([]byte(`{\"foo\":{\"delete\":true}}`)),\n\t\tmessage.NewPart([]byte(`{\"foo\":{\"dont\":\"delete me\"}}`)),\n\t\tmessage.NewPart([]byte(`{\"bar\":{\"delete\":true}}`)),\n\t\tmessage.NewPart([]byte(`{\"bar\":{\"dont\":\"delete me\"}}`)),\n\t}\n\n\texec, err := bloblang.Parse(`\nroot = match {\n  (foo | bar).delete.or(false) => deleted(),\n}\n`)\n\trequire.NoError(t, err)\n\n\tproc := newMutation(exec, nil)\n\n\toutBatches, err := proc.ProcessBatch(processor.TestBatchProcContext(tCtx, nil, inBatch), inBatch)\n\trequire.NoError(t, err)\n\trequire.Len(t, outBatches, 1)\n\trequire.Len(t, outBatches[0], 2)\n\n\tassert.NoError(t, outBatches[0][0].ErrorGet())\n\tassert.NoError(t, outBatches[0][1].ErrorGet())\n\n\tmsgBytes := outBatches[0][0].AsBytes()\n\tassert.Equal(t, `{\"foo\":{\"dont\":\"delete me\"}}`, string(msgBytes))\n\n\tmsgBytes = outBatches[0][1].AsBytes()\n\tassert.Equal(t, `{\"bar\":{\"dont\":\"delete me\"}}`, string(msgBytes))\n}\n\nfunc TestMutationCreateFilterAll(t *testing.T) {\n\ttCtx := context.Background()\n\n\tinBatch := message.Batch{\n\t\tmessage.NewPart([]byte(`{\"foo\":{\"delete\":true}}`)),\n\t\tmessage.NewPart([]byte(`{\"foo\":{\"dont\":\"delete me\"}}`)),\n\t\tmessage.NewPart([]byte(`{\"bar\":{\"delete\":true}}`)),\n\t\tmessage.NewPart([]byte(`{\"bar\":{\"dont\":\"delete me\"}}`)),\n\t}\n\n\texec, err := bloblang.Parse(`root = deleted()`)\n\trequire.NoError(t, err)\n\n\tproc := newMutation(exec, nil)\n\n\toutBatches, err := proc.ProcessBatch(processor.TestBatchProcContext(tCtx, nil, inBatch), inBatch)\n\tassert.NoError(t, err)\n\tassert.Empty(t, outBatches)\n}\n\nfunc TestMutationCreateJSONError(t *testing.T) {\n\ttCtx := context.Background()\n\n\tmsg := message.Batch{\n\t\tmessage.NewPart([]byte(`this is not valid json`)),\n\t}\n\n\texec, err := bloblang.Parse(`foo = json().bar`)\n\trequire.NoError(t, err)\n\n\tproc := newMutation(exec, nil)\n\n\toutBatches, err := proc.ProcessBatch(processor.TestBatchProcContext(tCtx, nil, msg), msg)\n\trequire.NoError(t, err)\n\trequire.Len(t, outBatches, 1)\n\trequire.Len(t, outBatches[0], 1)\n\n\tmsgBytes := outBatches[0][0].AsBytes()\n\tassert.Equal(t, `this is not valid json`, string(msgBytes))\n\n\terr = outBatches[0][0].ErrorGet()\n\trequire.Error(t, err)\n\tassert.Equal(t, `failed assignment (line 1): invalid character 'h' in literal true (expecting 'r')`, err.Error())\n}\n\nfunc BenchmarkMutationBasic(b *testing.B) {\n\tblobl, err := bloblang.Parse(`\nroot = this\nroot.sum = this.a + this.b\n`)\n\trequire.NoError(b, err)\n\n\tproc := newMutation(blobl, nil)\n\n\ttCtx, done := context.WithTimeout(context.Background(), time.Second*30)\n\tdefer done()\n\n\ttmpMsg := message.NewPart(nil)\n\ttmpMsg.SetStructured(map[string]any{\n\t\t\"a\": 5,\n\t\t\"b\": 7,\n\t})\n\n\tb.ResetTimer()\n\tb.ReportAllocs()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tresBatches, err := proc.ProcessBatch(processor.TestBatchProcContext(tCtx, nil, nil), message.Batch{tmpMsg.ShallowCopy()})\n\t\trequire.NoError(b, err)\n\t\trequire.Len(b, resBatches, 1)\n\t\trequire.Len(b, resBatches[0], 1)\n\n\t\tv, err := resBatches[0][0].AsStructured()\n\t\trequire.NoError(b, err)\n\t\tassert.Equal(b, int64(12), v.(map[string]any)[\"sum\"])\n\t}\n\n\trequire.NoError(b, proc.Close(tCtx))\n}\n"
