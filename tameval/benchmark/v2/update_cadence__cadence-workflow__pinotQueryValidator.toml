[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.22"

[repo_info]
repository = "cadence-workflow/cadence"
sha = "6d4ff3b9586899afadea49387fa6cfe75b0d00aa"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out common/pinot/pinotQueryValidator.go common/pinot/pinotQueryValidator_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting common/pinot/pinotQueryValidator.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 87.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "common/pinot/pinotQueryValidator_test.go"
focal_file_path = "common/pinot/pinotQueryValidator.go"
test_file_url = "https://github.com/cadence-workflow/cadence/blob/6d4ff3b9586899afadea49387fa6cfe75b0d00aa/common/pinot/pinotQueryValidator_test.go"
focal_file_url = "https://github.com/cadence-workflow/cadence/blob/6d4ff3b9586899afadea49387fa6cfe75b0d00aa/common/pinot/pinotQueryValidator.go"
first_commit_date = "2023-10-19"
last_commit_date = "2025-03-10"
test_file_content = "// The MIT License (MIT)\n\n// Copyright (c) 2017-2020 Uber Technologies Inc.\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage pinot\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/xwb1989/sqlparser\"\n\n\t\"github.com/uber/cadence/common/definition\"\n\t\"github.com/uber/cadence/common/dynamicconfig\"\n)\n\nfunc TestValidateQuery(t *testing.T) {\n\ttests := map[string]struct {\n\t\tquery     string\n\t\tvalidated string\n\t\terr       string\n\t}{\n\t\t\"Case1: empty query\": {\n\t\t\tquery:     \"\",\n\t\t\tvalidated: \"\",\n\t\t},\n\t\t\"Case2-1: simple query\": {\n\t\t\tquery:     \"WorkflowID = 'wid'\",\n\t\t\tvalidated: \"WorkflowID = 'wid'\",\n\t\t},\n\t\t\"Case2-2: simple query with partial match\": {\n\t\t\tquery:     \"WorkflowID like 'wid'\",\n\t\t\tvalidated: \"TEXT_MATCH(WorkflowID, '/.*wid.*/')\",\n\t\t},\n\t\t\"Case2-3: invalid simple query with partial match\": {\n\t\t\tquery: \"WorkflowID like wid\",\n\t\t\terr:   \"right comparison is invalid: &{<nil> wid { }}\"},\n\t\t\"Case3-1: query with custom field\": {\n\t\t\tquery:     \"CustomStringField = 'custom'\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*custom.*'')')`,\n\t\t},\n\t\t\"Case3-2: query with custom field not equal\": {\n\t\t\tquery:     \"CustomStringField != 'custom'\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*custom.*'')')`,\n\t\t},\n\t\t\"Case3-3: query with custom field value is empty\": {\n\t\t\tquery:     \"CustomStringField = ''\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''^$'')')`,\n\t\t},\n\t\t\"Case3-4: query with custom field not equal to empty\": {\n\t\t\tquery:     \"CustomStringField != ''\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''^$'')')`,\n\t\t},\n\t\t\"Case4: custom field query with or in string\": {\n\t\t\tquery:     \"CustomStringField='Or'\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*Or.*'')')`,\n\t\t},\n\t\t\"Case5: custom keyword field query\": {\n\t\t\tquery:     \"CustomKeywordField = 'custom'\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomKeywordField\"=''custom''') or JSON_MATCH(Attr, '\"$.CustomKeywordField[*]\"=''custom'''))`,\n\t\t},\n\t\t\"Case6-1: complex query I: with parenthesis\": {\n\t\t\tquery:     \"(CustomStringField = 'custom and custom2 or custom3 order by') or CustomIntField between 1 and 10\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*custom and custom2 or custom3 order by.*'')') or (JSON_MATCH(Attr, '\"$.CustomIntField\" is not null') AND CAST(JSON_EXTRACT_SCALAR(Attr, '$.CustomIntField') AS INT) >= 1 AND CAST(JSON_EXTRACT_SCALAR(Attr, '$.CustomIntField') AS INT) <= 10))`,\n\t\t},\n\t\t\"Case6-2: complex query II: with only system keys\": {\n\t\t\tquery:     \"DomainID = 'd-id' and (RunID = 'run-id' or WorkflowID = 'wid')\",\n\t\t\tvalidated: \"DomainID = 'd-id' and (RunID = 'run-id' or WorkflowID = 'wid')\",\n\t\t},\n\t\t\"Case6-3: complex query III: operation priorities\": {\n\t\t\tquery:     \"DomainID = 'd-id' or RunID = 'run-id' and WorkflowID = 'wid'\",\n\t\t\tvalidated: \"(DomainID = 'd-id' or RunID = 'run-id' and WorkflowID = 'wid')\",\n\t\t},\n\t\t\"Case6-4: complex query IV\": {\n\t\t\tquery:     \"WorkflowID = 'wid' and (CustomStringField = 'custom and custom2 or custom3 order by' or CustomIntField between 1 and 10)\",\n\t\t\tvalidated: `WorkflowID = 'wid' and (JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*custom and custom2 or custom3 order by.*'')') or (JSON_MATCH(Attr, '\"$.CustomIntField\" is not null') AND CAST(JSON_EXTRACT_SCALAR(Attr, '$.CustomIntField') AS INT) >= 1 AND CAST(JSON_EXTRACT_SCALAR(Attr, '$.CustomIntField') AS INT) <= 10))`,\n\t\t},\n\t\t\"Case6-5: complex query with partial match\": {\n\t\t\tquery:     \"RunID like '123' or WorkflowID like '123'\",\n\t\t\tvalidated: \"(TEXT_MATCH(RunID, '/.*123.*/') or TEXT_MATCH(WorkflowID, '/.*123.*/'))\",\n\t\t},\n\t\t\"Case7: invalid sql query\": {\n\t\t\tquery: \"Invalid SQL\",\n\t\t\terr:   \"Invalid query: syntax error at position 38 near 'sql'\",\n\t\t},\n\t\t\"Case8-1: query with missing val\": {\n\t\t\tquery:     \"CloseTime = missing\",\n\t\t\tvalidated: \"CloseTime = -1\",\n\t\t},\n\t\t\"Case8-2: query with not missing case\": {\n\t\t\tquery:     \"CloseTime != missing\",\n\t\t\tvalidated: \"CloseTime != -1\",\n\t\t},\n\t\t\"Case8-3: query with custom attr\": {\n\t\t\tquery: \"CustomKeywordField = missing\",\n\t\t\terr:   \"invalid comparison expression, right\",\n\t\t},\n\t\t\"Case8-4: query with custom keyword field not equal\": {\n\t\t\tquery:     \"CustomKeywordField != 0\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomKeywordField\"!=''0''') and JSON_MATCH(Attr, '\"$.CustomKeywordField[*]\"!=''0'''))`,\n\t\t},\n\t\t\"Case9: invalid where expression\": {\n\t\t\tquery: \"InvalidWhereExpr\",\n\t\t\terr:   \"invalid where clause\",\n\t\t},\n\t\t\"Case10: invalid search attribute\": {\n\t\t\tquery: \"Invalid = 'a' and 1 < 2\",\n\t\t\terr:   `invalid search attribute \"Invalid\"`,\n\t\t},\n\t\t\"Case11-1: order by clause\": {\n\t\t\tquery:     \"order by CloseTime desc\",\n\t\t\tvalidated: \" order by CloseTime desc\",\n\t\t},\n\t\t\"Case11-2: only order by clause with custom field\": {\n\t\t\tquery:     \"order by CustomIntField desc\",\n\t\t\tvalidated: \" order by CustomIntField desc\",\n\t\t},\n\t\t\"Case11-3: order by clause with custom field\": {\n\t\t\tquery:     \"WorkflowID = 'wid' order by CloseTime desc\",\n\t\t\tvalidated: \"WorkflowID = 'wid' order by CloseTime desc\",\n\t\t},\n\t\t\"Case12-1: security SQL injection - with another statement\": {\n\t\t\tquery: \"WorkflowID = 'wid'; SELECT * FROM important_table;\",\n\t\t\terr:   \"Invalid query: syntax error at position 53 near 'select'\",\n\t\t},\n\t\t\"Case12-2: security SQL injection - with union\": {\n\t\t\tquery: \"WorkflowID = 'wid' union select * from dummy\",\n\t\t\terr:   \"Invalid select query.\",\n\t\t},\n\t\t\"Case13: or clause\": {\n\t\t\tquery:     \"CustomIntField = 1 or CustomIntField = 2\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomIntField\"=''1''') or JSON_MATCH(Attr, '\"$.CustomIntField\"=''2'''))`,\n\t\t},\n\t\t\"Case14-1: range query: custom filed\": {\n\t\t\tquery:     \"CustomIntField BETWEEN 1 AND 2\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomIntField\" is not null') AND CAST(JSON_EXTRACT_SCALAR(Attr, '$.CustomIntField') AS INT) >= 1 AND CAST(JSON_EXTRACT_SCALAR(Attr, '$.CustomIntField') AS INT) <= 2)`,\n\t\t},\n\t\t\"Case14-2: range query: system filed\": {\n\t\t\tquery:     \"NumClusters BETWEEN 1 AND 2\",\n\t\t\tvalidated: \"NumClusters between 1 and 2\",\n\t\t},\n\t\t\"Case15-1: custom date attribute less than\": {\n\t\t\tquery:     \"CustomDatetimeField < 1697754674\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomDatetimeField\" is not null') AND CAST(JSON_EXTRACT_SCALAR(Attr, '$.CustomDatetimeField') AS BIGINT) < 1697754674)`,\n\t\t},\n\t\t\"Case15-2: custom date attribute greater than or equal to\": {\n\t\t\tquery:     \"CustomDatetimeField >= 1697754674\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomDatetimeField\" is not null') AND CAST(JSON_EXTRACT_SCALAR(Attr, '$.CustomDatetimeField') AS BIGINT) >= 1697754674)`,\n\t\t},\n\t\t\"Case15-3: system date attribute greater than or equal to\": {\n\t\t\tquery:     \"StartTime >= 1697754674\",\n\t\t\tvalidated: \"StartTime >= 1697754674\",\n\t\t},\n\t\t\"Case15-4: unix nano converts to milli seconds for equal statements\": {\n\t\t\tquery:     \"StartTime = 1707319950934000128\",\n\t\t\tvalidated: \"StartTime = 1707319950934\",\n\t\t},\n\t\t\"Case15-5: unix nano converts to milli seconds for unequal statements query\": {\n\t\t\tquery:     \"StartTime > 1707319950934000128\",\n\t\t\tvalidated: \"StartTime > 1707319950934\",\n\t\t},\n\t\t\"Case15-6: open workflows\": {\n\t\t\tquery:     \"CloseTime = -1\",\n\t\t\tvalidated: \"CloseTime = -1\",\n\t\t},\n\t\t\"Case15-7: startTime for range query\": {\n\t\t\tquery:     \"StartTime BETWEEN 1707319950934000128 AND 1707319950935000128\",\n\t\t\tvalidated: \"StartTime between 1707319950934 and 1707319950935\",\n\t\t},\n\t\t\"Case15-8: invalid string for trim\": {\n\t\t\tquery:     \"CloseTime = abc\",\n\t\t\tvalidated: \"\",\n\t\t\terr:       \"right comparison is invalid string value: abc\",\n\t\t},\n\t\t\"Case15-9: invalid value for trim\": {\n\t\t\tquery:     \"CloseTime = 123.45\",\n\t\t\tvalidated: \"\",\n\t\t\terr:       \"trim time field CloseTime got error: error: failed to parse int from SQLVal 123.45\",\n\t\t},\n\t\t\"Case15-10: invalid from time for range query\": {\n\t\t\tquery:     \"StartTime BETWEEN 17.50 AND 1707319950935000128\",\n\t\t\tvalidated: \"\",\n\t\t\terr:       \"trim time field StartTime got error: error: failed to parse int from SQLVal 17.50\",\n\t\t},\n\t\t\"Case15-11: invalid to time for range query\": {\n\t\t\tquery:     \"StartTime BETWEEN 1707319950934000128 AND 1707319950935000128.1\",\n\t\t\tvalidated: \"\",\n\t\t\terr:       \"trim time field StartTime got error: error: failed to parse int from SQLVal 1707319950935000128.1\",\n\t\t},\n\t\t\"Case15-12: value already in milliseconds\": {\n\t\t\tquery:     \"StartTime = 170731995093\",\n\t\t\tvalidated: \"StartTime = 170731995093\",\n\t\t},\n\t\t\"Case15-13: value in raw string for equal statement\": {\n\t\t\tquery:     \"StartTime = '2024-02-07T15:32:30Z'\",\n\t\t\tvalidated: \"StartTime = 1707319950000\",\n\t\t},\n\t\t\"Case15-14: value in raw string for not equal statement\": {\n\t\t\tquery:     \"StartTime > '2024-02-07T15:32:30Z'\",\n\t\t\tvalidated: \"StartTime > 1707319950000\",\n\t\t},\n\t\t\"Case15-15: value in raw string for range statement\": {\n\t\t\tquery:     \"StartTime between '2024-02-07T15:32:30Z' and '2024-02-07T15:33:30Z'\",\n\t\t\tvalidated: \"StartTime between 1707319950000 and 1707320010000\",\n\t\t},\n\t\t\"Case15-16: combined time and missing case\": {\n\t\t\tquery:     \"CloseTime != missing and StartTime >= 1707662555754408145\",\n\t\t\tvalidated: \"CloseTime != -1 and StartTime >= 1707662555754\",\n\t\t},\n\t\t\"Case15-17: CustomDatetimeField with big int type case\": {\n\t\t\tquery:     \"CustomDatetimeField = 1707319950000\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomDatetimeField\"=''1707319950000''')`,\n\t\t},\n\t\t\"Case15-18: CustomDatetimeField with time.Time() type case\": {\n\t\t\tquery:     \"CustomDatetimeField = '2024-02-07T15:32:30Z'\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomDatetimeField\"=''1707319950000''')`,\n\t\t},\n\t\t\"Case15-19: CustomDatetimeField with error case\": {\n\t\t\tquery:     \"CustomDatetimeField = 'test'\",\n\t\t\tvalidated: \"\",\n\t\t\terr:       \"trim time field CustomDatetimeField got error: error: failed to parse int from SQLVal test\",\n\t\t},\n\t\t\"Case16-1: custom int attribute greater than or equal to\": {\n\t\t\tquery:     \"CustomIntField >= 0\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomIntField\" is not null') AND CAST(JSON_EXTRACT_SCALAR(Attr, '$.CustomIntField') AS INT) >= 0)`,\n\t\t},\n\t\t\"Case16-2: custom double attribute greater than or equal to\": {\n\t\t\tquery:     \"CustomDoubleField >= 0\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomDoubleField\" is not null') AND CAST(JSON_EXTRACT_SCALAR(Attr, '$.CustomDoubleField') AS DOUBLE) >= 0)`,\n\t\t},\n\t\t\"Case17: custom keyword attribute greater than or equal to. Will return error run time\": {\n\t\t\tquery:     \"CustomKeywordField < 0\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomKeywordField\"<''0''') or JSON_MATCH(Attr, '\"$.CustomKeywordField[*]\"<''0'''))`,\n\t\t},\n\t\t\"Case18: custom int order by. Will have errors at run time. Doesn't support for now\": {\n\t\t\tquery:     \"CustomIntField = 0 order by CustomIntField desc\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomIntField\"=''0''') order by CustomIntField desc`,\n\t\t},\n\t\t\"case19-1: close status parse string\": {\n\t\t\tquery:     \"CloseStatus = 'CONTINUED_AS_NEW'\",\n\t\t\tvalidated: \"CloseStatus = 4\",\n\t\t},\n\t\t\"case19-2: close status parse number\": {\n\t\t\tquery:     \"CloseStatus = '1'\",\n\t\t\tvalidated: \"CloseStatus = 1\",\n\t\t},\n\t\t\"case19-3: close status parse normal case\": {\n\t\t\tquery:     \"CloseStatus = 1\",\n\t\t\tvalidated: \"CloseStatus = 1\",\n\t\t},\n\t\t\"case20-1: in clause in Attr\": {\n\t\t\tquery:     \"CustomKeywordField in (123)\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomKeywordField\" IN (''123'')') or JSON_MATCH(Attr, '\"$.CustomKeywordField[*]\" IN (''123'')')`,\n\t\t},\n\t\t\"case20-2: in clause in Attr with multiple values\": {\n\t\t\tquery:     \"CustomKeywordField in (123, 456)\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomKeywordField\" IN (''123'',''456'')') or JSON_MATCH(Attr, '\"$.CustomKeywordField[*]\" IN (''123'',''456'')')`,\n\t\t},\n\t\t\"case20-3-1: in clause in Attr with a string value, double quote\": {\n\t\t\tquery:     `CustomKeywordField in (\"abc\")`,\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomKeywordField\" IN (''abc'')') or JSON_MATCH(Attr, '\"$.CustomKeywordField[*]\" IN (''abc'')')`,\n\t\t},\n\t\t\"case20-3-2: in clause in Attr with a string value, single quote\": {\n\t\t\tquery:     \"CustomKeywordField in ('abc')\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomKeywordField\" IN (''abc'')') or JSON_MATCH(Attr, '\"$.CustomKeywordField[*]\" IN (''abc'')')`,\n\t\t},\n\t\t\"case20-4: in clause in Attr with invalid IN expression, value\": {\n\t\t\tquery:     \"CustomKeywordField in (abc)\",\n\t\t\tvalidated: \"\",\n\t\t\terr:       \"invalid IN expression, value\",\n\t\t},\n\t\t\"case21-1: test bool value- system key- no quotes\": {\n\t\t\tquery:     \"IsCron = true\",\n\t\t\tvalidated: \"IsCron = true\",\n\t\t},\n\t\t\"case21-2: test bool value- system key- single quotes\": {\n\t\t\tquery:     \"IsCron = 'true'\",\n\t\t\tvalidated: \"IsCron = true\",\n\t\t},\n\t\t\"case21-3: test bool value- system key- double quotes\": {\n\t\t\tquery:     `IsCron = \"true\"`,\n\t\t\tvalidated: \"IsCron = true\",\n\t\t},\n\t\t\"case21-4: test bool value- system key- invalid value\": {\n\t\t\tquery:     \"IsCron = 1\",\n\t\t\tvalidated: \"\",\n\t\t\terr:       \"invalid bool value in pinot_query_validator: 1\",\n\t\t},\n\t\t\"case21-5: test bool value- when it is not SQLBool and SQLVAl\": {\n\t\t\tquery:     \"IsCron = abc\",\n\t\t\tvalidated: \"\",\n\t\t\terr:       \"failed to process a bool key to SQLVal: &{<nil> abc { }}\",\n\t\t},\n\t\t\"case22-1: test not equal to a string field\": {\n\t\t\tquery:     \"CustomStringField != 'abc'\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*abc.*'')')`,\n\t\t},\n\t\t\"case22-2: test not equal to an empty string\": {\n\t\t\tquery:     \"CustomStringField != ''\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''^$'')')`,\n\t\t},\n\t\t// ES also doesn't support this kind of query\n\t\t\"case22-3: custom string is missing\": {\n\t\t\tquery: \"CustomStringField is missing\",\n\t\t\terr:   \"Invalid query: syntax error at position 55 near 'missing'\",\n\t\t},\n\t\t// ES also doesn't support this kind of query\n\t\t\"case22-4: custom string is not missing\": {\n\t\t\tquery: \"CustomStringField is not missing\",\n\t\t\terr:   \"Invalid query: syntax error at position 59 near 'missing'\",\n\t\t},\n\t\t\"case22-5: 2 custom string not equal with and clause\": {\n\t\t\tquery:     \"CustomStringField != 'abc' AND CustomStringField != 'def'\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*abc.*'')') and JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*def.*'')')`,\n\t\t},\n\t\t\"case22-6: 2 custom string, equal and not equal with and clause\": {\n\t\t\tquery:     \"CustomStringField = 'abc' AND CustomStringField != 'def'\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*abc.*'')') and JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*def.*'')')`,\n\t\t},\n\t\t\"case22-7: 2 custom string, not equal and equal with and clause\": {\n\t\t\tquery:     \"CustomStringField != 'abc' AND CustomStringField = 'def'\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*abc.*'')') and JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*def.*'')')`,\n\t\t},\n\t\t\"case22-8: 2 custom string equal with and clause\": {\n\t\t\tquery:     \"CustomStringField = 'abc' AND CustomStringField = 'def'\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*abc.*'')') and JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*def.*'')')`,\n\t\t},\n\t\t\"case22-9: 2 custom string not equal with or clause\": {\n\t\t\tquery:     \"CustomStringField != 'abc' OR CustomStringField != 'def'\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*abc.*'')') or JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*def.*'')'))`,\n\t\t},\n\t\t\"case22-10: 2 custom string, equal and not equal with or clause\": {\n\t\t\tquery:     \"CustomStringField = 'abc' OR CustomStringField != 'def'\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*abc.*'')') or JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*def.*'')'))`,\n\t\t},\n\t\t\"case22-11: 2 custom string, not equal and equal with or clause\": {\n\t\t\tquery:     \"CustomStringField != 'abc' OR CustomStringField = 'def'\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*abc.*'')') or JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*def.*'')'))`,\n\t\t},\n\t\t\"case22-12: 2 custom string equal with or clause\": {\n\t\t\tquery:     \"CustomStringField = 'abc' OR CustomStringField = 'def'\",\n\t\t\tvalidated: `(JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*abc.*'')') or JSON_MATCH(Attr, '\"$.CustomStringField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomStringField\", ''.*def.*'')'))`,\n\t\t},\n\t\t\"case23-1: custom keyword field is empty case\": {\n\t\t\tquery:     \"CustomKeywordField = ''\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomKeywordField\" is not null') AND JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomKeywordField\", ''^$'')')`,\n\t\t},\n\t\t\"case23-2: custom keyword field is not empty case\": {\n\t\t\tquery:     \"CustomKeywordField != ''\",\n\t\t\tvalidated: `JSON_MATCH(Attr, '\"$.CustomKeywordField\" is not null') AND NOT JSON_MATCH(Attr, 'REGEXP_LIKE(\"$.CustomKeywordField\", ''^$'')')`,\n\t\t},\n\t}\n\n\tfor name, test := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tvalidSearchAttr := dynamicconfig.GetMapPropertyFn(definition.GetDefaultIndexedKeys())\n\t\t\tqv := NewPinotQueryValidator(validSearchAttr)\n\t\t\tvalidated, err := qv.ValidateQuery(test.query)\n\t\t\tif err != nil {\n\t\t\t\tassert.Equal(t, test.err, err.Error())\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, test.validated, validated)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProcessInClause_FailedInputExprCases(t *testing.T) {\n\t// Define test cases\n\ttests := map[string]struct {\n\t\tinputExpr     sqlparser.Expr\n\t\texpectedError string\n\t}{\n\t\t\"case1: 'In' clause in Attr with invalid expr\": {\n\t\t\tinputExpr:     &sqlparser.SQLVal{Type: sqlparser.StrVal, Val: []byte(\"invalid\")},\n\t\t\texpectedError: \"invalid IN expression\",\n\t\t},\n\t\t\"case2: 'In' clause in Attr with invalid expr, left\": {\n\t\t\tinputExpr:     &sqlparser.ComparisonExpr{Operator: sqlparser.InStr},\n\t\t\texpectedError: \"invalid IN expression, left\",\n\t\t},\n\t\t\"case3: 'In' clause in Attr with invalid expr, right\": {\n\t\t\tinputExpr:     &sqlparser.ComparisonExpr{Operator: sqlparser.InStr, Left: &sqlparser.ColName{Name: sqlparser.NewColIdent(\"CustomKeywordField\")}},\n\t\t\texpectedError: \"invalid IN expression, right\",\n\t\t},\n\t}\n\n\t// Create a new VisibilityQueryValidator\n\tvalidSearchAttr := dynamicconfig.GetMapPropertyFn(definition.GetDefaultIndexedKeys())\n\tqv := NewPinotQueryValidator(validSearchAttr)\n\n\tfor name, test := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\t// Call processInClause with the input expression\n\t\t\t_, err := qv.processInClause(test.inputExpr)\n\n\t\t\t// Check that an error was returned and that the error message matches the expected error message\n\t\t\tif assert.Error(t, err) {\n\t\t\t\tassert.Contains(t, err.Error(), test.expectedError)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseTime(t *testing.T) {\n\tvar tests = []struct {\n\t\tname     string\n\t\ttimeStr  string\n\t\texpected int64\n\t\thasErr   bool\n\t}{\n\t\t{\"empty string\", \"\", 0, true},\n\t\t{\"valid RFC3339\", \"2024-02-07T15:32:30Z\", 1707319950000, false},\n\t\t{\"valid unix milli string\", \"1707319950000\", 1707319950000, false},\n\t\t{\"valid unix nano string\", \"1707319950000000000\", 1707319950000, false},\n\t\t{\"invalid string\", \"invalid\", 0, true},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tparsed, err := parseTime(tt.timeStr)\n\t\t\tassert.Equal(t, parsed, tt.expected)\n\t\t\tif tt.hasErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseCloseStatus(t *testing.T) {\n\ttests := []struct {\n\t\tinput       string\n\t\texpected    *sqlparser.SQLVal\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\tinput:       \"4\",\n\t\t\texpected:    &sqlparser.SQLVal{Type: sqlparser.IntVal, Val: []byte(\"4\")},\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"CANCELED\",\n\t\t\texpected:    &sqlparser.SQLVal{Type: sqlparser.IntVal, Val: []byte(\"2\")},\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\tinput:       \"invalid\",\n\t\t\texpected:    nil,\n\t\t\texpectedErr: true, // expected error,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.input, func(t *testing.T) {\n\t\t\toriginal := &sqlparser.SQLVal{Type: sqlparser.IntVal, Val: []byte(test.input)}\n\t\t\tresult, err := parseCloseStatus(original)\n\n\t\t\tassert.Equal(t, test.expected, result)\n\t\t\tif test.expectedErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}"
