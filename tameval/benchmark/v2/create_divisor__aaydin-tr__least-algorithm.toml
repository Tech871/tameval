[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.22"

[repo_info]
repository = "aaydin-tr/divisor"
sha = "be1010bf44bd1fcf47537b6a7423b664e5016985"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out core/least-algorithm/least-algorithm.go core/least-algorithm/least-algorithm_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting core/least-algorithm/least-algorithm.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 96.0
original_coverage = 96.0
mutation_kill_rate = 65.0
original_mutation_kill_rate = 65.0
covered_lines = [ 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 48, 49, 50, 51, 52, 55, 56, 57, 59, 60, 61, 62, 63, 64, 65, 66, 68, 69, 70, 73, 74, 75, 76, 79, 80, 81, 82, 83, 84, 85, 88, 91, 92, 93, 94, 95, 96, 97, 100, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 130, 131, 132, 134, 135, 136, 137, 138, 139, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 157, 160, 161, 162, 163, 164, 167, 168, 172, 178, 179,]
missed_lines = [ 165, 166, 173, 174, 175,]

[input_info]
test_file_path = "core/least-algorithm/least-algorithm_test.go"
focal_file_path = "core/least-algorithm/least-algorithm.go"
test_file_url = "https://github.com/aaydin-tr/divisor/blob/be1010bf44bd1fcf47537b6a7423b664e5016985/core/least-algorithm/least-algorithm_test.go"
focal_file_url = "https://github.com/aaydin-tr/divisor/blob/be1010bf44bd1fcf47537b6a7423b664e5016985/core/least-algorithm/least-algorithm.go"
first_commit_date = "2024-07-21"
last_commit_date = "2025-06-08"
test_file_content = "package least_algorithm\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aaydin-tr/divisor/mocks\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/valyala/fasthttp\"\n)\n\nfunc TestNewLeastAlgorithm(t *testing.T) {\n\tfor i, l := range mocks.TestCases {\n\t\tif l.ExpectedServerCount == 0 {\n\t\t\ttestConfig := l.Config\n\t\t\ttestConfig.Type = \"least-connection\"\n\t\t\tif i%2 == 0 {\n\t\t\t\ttestConfig.Type = \"least-response-time\"\n\t\t\t}\n\n\t\t\tleastAlgorithm := NewLeastAlgorithm(&testConfig, l.ProxyFunc)\n\t\t\tassert.Nil(t, leastAlgorithm)\n\t\t} else {\n\t\t\ttestConfig := l.Config\n\t\t\ttestConfig.Type = \"least-connection\"\n\t\t\tif i%2 == 0 {\n\t\t\t\ttestConfig.Type = \"least-response-time\"\n\t\t\t}\n\n\t\t\tleastAlgorithm := NewLeastAlgorithm(&testConfig, l.ProxyFunc).(*LeastAlgorithm)\n\t\t\tassert.Equal(t, l.ExpectedServerCount, len(leastAlgorithm.serversMap))\n\t\t\tassert.Equal(t, l.ExpectedServerCount, leastAlgorithm.len)\n\t\t}\n\t}\n}\n\nfunc TestNewLeastAlgorithmWithoutAlgorithmType(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tcaseOne.Config.Type = \"\"\n\tleastAlgorithm := NewLeastAlgorithm(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.Nil(t, leastAlgorithm)\n}\n\nfunc TestNext(t *testing.T) {\n\tt.Run(\"least-connection\", func(t *testing.T) {\n\t\tt.Run(\"with zero pending requests\", func(t *testing.T) {\n\t\t\tcaseFour := mocks.TestCases[4]\n\t\t\tcaseFour.Config.Type = \"least-connection\"\n\t\t\tbalancer := NewLeastAlgorithm(&caseFour.Config, caseFour.ProxyFunc)\n\t\t\tassert.NotNil(t, balancer)\n\n\t\t\tleastConnection := balancer.(*LeastAlgorithm)\n\t\t\tproxy := leastConnection.nextFunc()\n\n\t\t\tassert.IsType(t, &mocks.MockProxy{}, proxy)\n\t\t\tmProxy := proxy.(*mocks.MockProxy)\n\t\t\tassert.Equal(t, caseFour.Config.Backends[0].Url, mProxy.Addr)\n\t\t})\n\n\t\tt.Run(\"with non zero pending requests\", func(t *testing.T) {\n\t\t\tcaseOne := mocks.TestCases[0]\n\t\t\tcaseOne.Config.Type = \"least-connection\"\n\t\t\tbalancer := NewLeastAlgorithm(&caseOne.Config, caseOne.ProxyFunc)\n\t\t\tassert.NotNil(t, balancer)\n\n\t\t\tleastConnection := balancer.(*LeastAlgorithm)\n\t\t\tproxy := leastConnection.nextFunc()\n\n\t\t\tassert.IsType(t, &mocks.MockProxy{}, proxy)\n\t\t\tmProxy := proxy.(*mocks.MockProxy)\n\t\t\tassert.Equal(t, caseOne.Config.Backends[1].Url, mProxy.Addr)\n\t\t})\n\t})\n\n\tt.Run(\"least-response-time\", func(t *testing.T) {\n\t\tt.Run(\"with zero avg response time\", func(t *testing.T) {\n\t\t\tcaseFive := mocks.TestCases[4]\n\t\t\tcaseFive.Config.Type = \"least-response-time\"\n\t\t\tbalancer := NewLeastAlgorithm(&caseFive.Config, caseFive.ProxyFunc)\n\t\t\tassert.NotNil(t, balancer)\n\n\t\t\tleastResponseTime := balancer.(*LeastAlgorithm)\n\t\t\tproxy := leastResponseTime.nextFunc()\n\n\t\t\tassert.IsType(t, &mocks.MockProxy{}, proxy)\n\t\t\tmProxy := proxy.(*mocks.MockProxy)\n\t\t\tassert.Equal(t, caseFive.Config.Backends[1].Url, mProxy.Addr)\n\t\t})\n\n\t\tt.Run(\"with non zero avg response time\", func(t *testing.T) {\n\t\t\tcaseOne := mocks.TestCases[0]\n\t\t\tcaseOne.Config.Type = \"least-response-time\"\n\t\t\tbalancer := NewLeastAlgorithm(&caseOne.Config, caseOne.ProxyFunc)\n\t\t\tassert.NotNil(t, balancer)\n\n\t\t\tleastResponseTime := balancer.(*LeastAlgorithm)\n\t\t\tproxy := leastResponseTime.nextFunc()\n\n\t\t\tassert.IsType(t, &mocks.MockProxy{}, proxy)\n\t\t\tmProxy := proxy.(*mocks.MockProxy)\n\t\t\tassert.Equal(t, caseOne.Config.Backends[0].Url, mProxy.Addr)\n\n\t\t})\n\t})\n}\n\nfunc TestServe(t *testing.T) {\n\tcaseOne := mocks.TestCases[1]\n\tcaseOne.Config.Type = \"least-connection\"\n\tbalancer := NewLeastAlgorithm(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\tleastAlgorithm := balancer.(*LeastAlgorithm)\n\thandlerFunc := leastAlgorithm.Serve()\n\n\tctx := fasthttp.RequestCtx{\n\t\tRequest: *fasthttp.AcquireRequest(),\n\t}\n\n\tproxy := leastAlgorithm.nextFunc().(*mocks.MockProxy)\n\tassert.False(t, proxy.IsCalled, \"expected Server func not be called, but it was called\")\n\thandlerFunc(&ctx)\n\tassert.True(t, proxy.IsCalled, \"expected Server func to be called, but it wasn't\")\n}\n\nfunc TestHealthChecker(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tleastAlgorithm := &LeastAlgorithm{stopHealthChecker: make(chan bool)}\n\n\tleastAlgorithm.isHostAlive = func(s string) bool {\n\t\tgo func() {\n\t\t\tleastAlgorithm.stopHealthChecker <- true\n\t\t}()\n\t\treturn false\n\t}\n\tleastAlgorithm.hashFunc = func(b []byte) uint32 {\n\t\treturn 0\n\t}\n\n\tcaseOne.Config.HealthCheckerTime = 1\n\tleastAlgorithm.healthChecker(caseOne.Config.Backends)\n}\n\nfunc TestStats(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tcaseOne.Config.Type = \"least-connection\"\n\tbalancer := NewLeastAlgorithm(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\tleastAlgorithm := balancer.(*LeastAlgorithm)\n\tstats := leastAlgorithm.Stats()\n\n\tfor i, backend := range caseOne.Config.Backends {\n\t\thash := leastAlgorithm.hashFunc([]byte(backend.Url + strconv.Itoa(i)))\n\t\ts := leastAlgorithm.serversMap[hash]\n\t\tp := s.proxy.(*mocks.MockProxy)\n\n\t\tassert.Equal(t, s.isHostAlive, stats[i].IsHostAlive)\n\t\tassert.Equal(t, hash, stats[i].BackendHash)\n\t\tassert.Equal(t, backend.Url, p.Addr)\n\t}\n}\n\nfunc TestRemoveOneServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tcaseOne.Config.Type = \"least-connection\"\n\tleastAlgorithm := NewLeastAlgorithm(&caseOne.Config, caseOne.ProxyFunc).(*LeastAlgorithm)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(leastAlgorithm.serversMap))\n\n\t// Remove one server\n\tbackend := caseOne.Config.Backends[0]\n\tif b, ok := leastAlgorithm.serversMap[leastAlgorithm.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\tleastAlgorithm.isHostAlive = func(s string) bool {\n\t\t\treturn false\n\t\t}\n\t\toldServerCount := leastAlgorithm.len\n\t\tleastAlgorithm.healthCheck(backend, 0)\n\n\t\tassert.False(t, b.isHostAlive, \"expected isHostAlive equal to false, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, oldServerCount, leastAlgorithm.len, \"expected server to be removed after health check, but it did not.\")\n\t}\n}\n\nfunc TestRemoveAndAddServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tcaseOne.Config.Type = \"least-connection\"\n\tleastAlgorithm := NewLeastAlgorithm(&caseOne.Config, caseOne.ProxyFunc).(*LeastAlgorithm)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(leastAlgorithm.serversMap))\n\n\t// Remove one server\n\tbackend := caseOne.Config.Backends[0]\n\tif b, ok := leastAlgorithm.serversMap[leastAlgorithm.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\tleastAlgorithm.isHostAlive = func(s string) bool {\n\t\t\treturn false\n\t\t}\n\t\toldServerCount := leastAlgorithm.len\n\t\tleastAlgorithm.healthCheck(backend, 0)\n\n\t\tassert.False(t, b.isHostAlive, \"expected isHostAlive equal to false, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, oldServerCount, leastAlgorithm.len, \"expected server to be removed after health check, but it did not.\")\n\t}\n\n\t// Add one server\n\tif b, ok := leastAlgorithm.serversMap[leastAlgorithm.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\tb.isHostAlive = false\n\t\tleastAlgorithm.isHostAlive = func(s string) bool {\n\t\t\treturn true\n\t\t}\n\n\t\toldServerCount := leastAlgorithm.len\n\t\tleastAlgorithm.healthCheck(backend, 0)\n\n\t\tassert.True(t, b.isHostAlive, \"expected isHostAlive equal to true, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, leastAlgorithm.len, oldServerCount, \"expected server to be added after health check, but it did not.\")\n\n\t}\n}\n\nfunc TestRemmoveAllServers(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tcaseOne.Config.Type = \"least-connection\"\n\tleastAlgorithm := NewLeastAlgorithm(&caseOne.Config, caseOne.ProxyFunc).(*LeastAlgorithm)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(leastAlgorithm.serversMap))\n\n\t// Remove All\n\tfor i, backend := range caseOne.Config.Backends {\n\t\tif _, ok := leastAlgorithm.serversMap[leastAlgorithm.hashFunc([]byte(backend.Url+strconv.Itoa(i)))]; ok {\n\t\t\tleastAlgorithm.isHostAlive = func(s string) bool {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\toldServerCount := leastAlgorithm.len\n\t\t\tif oldServerCount == 1 {\n\t\t\t\tassert.Panics(t, func() {\n\t\t\t\t\tleastAlgorithm.healthCheck(backend, i)\n\t\t\t\t}, \"expected panic after remove all servers\")\n\t\t\t} else {\n\t\t\t\tleastAlgorithm.healthCheck(backend, i)\n\t\t\t\tassert.GreaterOrEqual(t, oldServerCount, leastAlgorithm.len, \"expected server to be removed after health check, but it did not.\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShutdown(t *testing.T) {\n\tt.Run(\"shutdown least-connection calls close on all proxies\", func(t *testing.T) {\n\t\tcaseOne := mocks.TestCases[0]\n\t\tcaseOne.Config.Type = \"least-connection\"\n\t\tleastAlgorithm := NewLeastAlgorithm(&caseOne.Config, caseOne.ProxyFunc).(*LeastAlgorithm)\n\t\tassert.NotNil(t, leastAlgorithm)\n\n\t\t// Verify proxy Close() methods are not called yet\n\t\tfor _, sm := range leastAlgorithm.serversMap {\n\t\t\tmockProxy := sm.proxy.(*mocks.MockProxy)\n\t\t\tassert.False(t, mockProxy.CloseCalled, \"Proxy Close() should not be called before shutdown\")\n\t\t}\n\n\t\t// Call shutdown\n\t\terr := leastAlgorithm.Shutdown()\n\t\tassert.NoError(t, err, \"Shutdown() should not return an error\")\n\n\t\t// Verify that Close() was called on all proxy clients\n\t\tfor _, sm := range leastAlgorithm.serversMap {\n\t\t\tmockProxy := sm.proxy.(*mocks.MockProxy)\n\t\t\tassert.True(t, mockProxy.CloseCalled, \"Proxy Close() should be called during shutdown\")\n\t\t}\n\t})\n\n\tt.Run(\"shutdown least-response-time calls close on all proxies\", func(t *testing.T) {\n\t\tcaseOne := mocks.TestCases[0]\n\t\tcaseOne.Config.Type = \"least-response-time\"\n\t\tleastResponseTime := NewLeastAlgorithm(&caseOne.Config, caseOne.ProxyFunc).(*LeastAlgorithm)\n\t\tassert.NotNil(t, leastResponseTime)\n\n\t\t// Verify proxy Close() methods are not called yet\n\t\tfor _, sm := range leastResponseTime.serversMap {\n\t\t\tmockProxy := sm.proxy.(*mocks.MockProxy)\n\t\t\tassert.False(t, mockProxy.CloseCalled, \"Proxy Close() should not be called before shutdown\")\n\t\t}\n\n\t\t// Call shutdown\n\t\terr := leastResponseTime.Shutdown()\n\t\tassert.NoError(t, err, \"Shutdown() should not return an error for least-response-time algorithm\")\n\n\t\t// Verify that Close() was called on all proxy clients\n\t\tfor _, sm := range leastResponseTime.serversMap {\n\t\t\tmockProxy := sm.proxy.(*mocks.MockProxy)\n\t\t\tassert.True(t, mockProxy.CloseCalled, \"Proxy Close() should be called during shutdown\")\n\t\t}\n\t})\n\n\tt.Run(\"shutdown with no servers\", func(t *testing.T) {\n\t\temptyCase := mocks.TestCases[3] // Case with 0 servers\n\t\temptyCase.Config.Type = \"least-connection\"\n\t\temptyLeastAlgorithm := NewLeastAlgorithm(&emptyCase.Config, emptyCase.ProxyFunc)\n\t\tif emptyLeastAlgorithm != nil {\n\t\t\terr := emptyLeastAlgorithm.Shutdown()\n\t\t\tassert.NoError(t, err, \"Shutdown() should not return an error even with no servers\")\n\t\t}\n\t})\n\n\tt.Run(\"shutdown with actual health checker goroutine\", func(t *testing.T) {\n\t\tcaseOne := mocks.TestCases[0]\n\t\tcaseOne.Config.Type = \"least-connection\"\n\t\tcaseOne.Config.HealthCheckerTime = 100 * time.Millisecond // Fast health check for testing\n\t\tleastAlgorithm := NewLeastAlgorithm(&caseOne.Config, caseOne.ProxyFunc).(*LeastAlgorithm)\n\t\tassert.NotNil(t, leastAlgorithm)\n\n\t\t// Give health checker time to start\n\t\ttime.Sleep(50 * time.Millisecond)\n\n\t\t// Call shutdown - this should stop the health checker goroutine\n\t\terr := leastAlgorithm.Shutdown()\n\t\tassert.NoError(t, err, \"Shutdown() should not return an error\")\n\n\t\t// Verify that Close() was called on all proxy clients\n\t\tfor _, sm := range leastAlgorithm.serversMap {\n\t\t\tmockProxy := sm.proxy.(*mocks.MockProxy)\n\t\t\tassert.True(t, mockProxy.CloseCalled, \"Proxy Close() should be called during shutdown\")\n\t\t}\n\n\t\t// Give some time for health checker to actually stop\n\t\ttime.Sleep(150 * time.Millisecond)\n\t})\n}\n"
