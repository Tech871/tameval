[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "quantumlib/OpenFermion"
sha = "39667a6f66a4a87ed80b7d255198a39c826f17cb"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "(pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=src/openfermion/transforms/opconversions/jordan_wigner.py -m pytest -q --junit-xml=test_output.xml src/openfermion/transforms/opconversions/jordan_wigner_test.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target src.openfermion.transforms.opconversions.jordan_wigner --unit-test src.openfermion.transforms.opconversions.jordan_wigner_test --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target src/openfermion/transforms/opconversions/jordan_wigner.py --unit-test src/openfermion/transforms/opconversions/jordan_wigner_test.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 7.0
original_coverage = 100.0
mutation_kill_rate = nan
original_mutation_kill_rate = 1.0
covered_lines = [ 12, 14, 16, 17, 18, 21, 60, 86, 99, 130, 186, 216,]
missed_lines = [ 44, 45, 46, 47, 48, 49, 50, 51, 52, 61, 63, 64, 66, 68, 69, 70, 71, 72, 73, 77, 80, 81, 82, 83, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 100, 101, 104, 105, 106, 107, 110, 112, 113, 114, 115, 116, 117, 118, 121, 122, 123, 124, 125, 127, 141, 142, 143, 144, 147, 150, 151, 152, 155, 157, 158, 161, 167, 170, 171, 181, 183, 193, 194, 195, 196, 197, 198, 199, 205, 206, 210, 211, 213, 223, 226, 227, 230, 231, 232, 234, 236, 237, 238, 239, 241, 242, 243, 244, 245, 248, 253, 254, 255, 256, 257, 258, 261, 264, 266, 267, 268, 269, 271, 272, 273, 274, 275, 276, 277, 279, 280, 281, 282, 283, 284, 286, 287, 288, 289, 290, 291, 293, 294, 295, 298, 299, 300, 306, 307, 308, 311, 312, 313, 316, 318, 319, 321, 324, 325, 326, 327, 329,]

[input_info]
test_file_path = "src/openfermion/transforms/opconversions/jordan_wigner_test.py"
focal_file_path = "src/openfermion/transforms/opconversions/jordan_wigner.py"
test_file_url = "https://github.com/quantumlib/OpenFermion/blob/39667a6f66a4a87ed80b7d255198a39c826f17cb/src/openfermion/transforms/opconversions/jordan_wigner_test.py"
focal_file_url = "https://github.com/quantumlib/OpenFermion/blob/39667a6f66a4a87ed80b7d255198a39c826f17cb/src/openfermion/transforms/opconversions/jordan_wigner.py"
first_commit_date = "2020-07-23"
last_commit_date = "2025-04-24"
test_file_content = "#   Licensed under the Apache License, Version 2.0 (the \"License\");\n#   you may not use this file except in compliance with the License.\n#   You may obtain a copy of the License at\n#\n#       http://www.apache.org/licenses/LICENSE-2.0\n#\n#   Unless required by applicable law or agreed to in writing, software\n#   distributed under the License is distributed on an \"AS IS\" BASIS,\n#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n#   See the License for the specific language governing permissions and\n#   limitations under the License.\n\"\"\"Tests  jordan_wigner.py.\"\"\"\nimport itertools\nimport os\nimport unittest\n\nimport numpy\nimport sympy\n\nfrom openfermion.config import DATA_DIRECTORY\nfrom openfermion.hamiltonians import fermi_hubbard, number_operator\nfrom openfermion.chem import MolecularData\nfrom openfermion.ops.operators import (FermionOperator, MajoranaOperator,\n                                       QubitOperator)\nfrom openfermion.ops.representations import InteractionOperator\nfrom openfermion.transforms.opconversions import (get_fermion_operator,\n                                                  reverse_jordan_wigner)\nfrom openfermion.transforms.repconversions import (\n    get_diagonal_coulomb_hamiltonian, get_interaction_operator)\nfrom openfermion.utils import hermitian_conjugated\nfrom openfermion.transforms.opconversions import normal_ordered\nfrom openfermion.testing.testing_utils import (random_interaction_operator,\n                                               random_quadratic_hamiltonian)\n\nfrom openfermion.transforms.opconversions.jordan_wigner import (\n    jordan_wigner, jordan_wigner_one_body, jordan_wigner_two_body,\n    jordan_wigner_interaction_op)\n\n\nclass JordanWignerTransformTest(unittest.TestCase):\n\n    def setUp(self):\n        self.n_qubits = 5\n\n    def test_bad_input(self):\n        with self.assertRaises(TypeError):\n            jordan_wigner(3)\n\n    def test_transm_raise3(self):\n        raising = jordan_wigner(FermionOperator(((3, 1),)))\n        self.assertEqual(len(raising.terms), 2)\n\n        correct_operators_x = ((0, 'Z'), (1, 'Z'), (2, 'Z'), (3, 'X'))\n        correct_operators_y = ((0, 'Z'), (1, 'Z'), (2, 'Z'), (3, 'Y'))\n        qtermx = QubitOperator(correct_operators_x, 0.5)\n        qtermy = QubitOperator(correct_operators_y, -0.5j)\n\n        self.assertEqual(raising.terms[correct_operators_x], 0.5)\n        self.assertEqual(raising.terms[correct_operators_y], -0.5j)\n        self.assertTrue(raising == qtermx + qtermy)\n\n    def test_transm_hopping_sympy(self):\n        coeff = sympy.Symbol('x')\n        hopping = FermionOperator(((3, 1), (2, 0))) * coeff\n        hopping += FermionOperator(((2, 1), (3, 0))) * coeff\n\n        jw_hopping = jordan_wigner(hopping)\n        print(jw_hopping)\n        correct_operators_xx = ((2, 'X'), (3, 'X'))\n        correct_operators_yy = ((2, 'Y'), (3, 'Y'))\n        qtermxx = QubitOperator(correct_operators_xx, 0.5 * coeff)\n        qtermyy = QubitOperator(correct_operators_yy, 0.5 * coeff)\n\n        self.assertEqual(jw_hopping.terms[correct_operators_xx], 0.5 * coeff)\n        self.assertEqual(jw_hopping.terms[correct_operators_yy], 0.5 * coeff)\n        self.assertTrue(jw_hopping == qtermxx + qtermyy)\n\n    def test_transm_raise3_sympy(self):\n        coeff = sympy.Symbol('x')\n        raising = jordan_wigner(coeff * FermionOperator(((3, 1),)))\n        self.assertEqual(len(raising.terms), 2)\n\n        correct_operators_x = ((0, 'Z'), (1, 'Z'), (2, 'Z'), (3, 'X'))\n        correct_operators_y = ((0, 'Z'), (1, 'Z'), (2, 'Z'), (3, 'Y'))\n        qtermx = QubitOperator(correct_operators_x, 0.5 * coeff)\n        qtermy = QubitOperator(correct_operators_y, -0.5j * coeff)\n\n        self.assertEqual(raising.terms[correct_operators_x], 0.5 * coeff)\n        self.assertEqual(raising.terms[correct_operators_y], -0.5j * coeff)\n        self.assertTrue(raising == qtermx + qtermy)\n\n    def test_transm_raise1(self):\n        raising = jordan_wigner(FermionOperator(((1, 1),)))\n\n        correct_operators_x = ((0, 'Z'), (1, 'X'))\n        correct_operators_y = ((0, 'Z'), (1, 'Y'))\n        qtermx = QubitOperator(correct_operators_x, 0.5)\n        qtermy = QubitOperator(correct_operators_y, -0.5j)\n\n        self.assertEqual(raising.terms[correct_operators_x], 0.5)\n        self.assertEqual(raising.terms[correct_operators_y], -0.5j)\n        self.assertTrue(raising == qtermx + qtermy)\n\n    def test_transm_lower3(self):\n        lowering = jordan_wigner(FermionOperator(((3, 0),)))\n\n        correct_operators_x = ((0, 'Z'), (1, 'Z'), (2, 'Z'), (3, 'X'))\n        correct_operators_y = ((0, 'Z'), (1, 'Z'), (2, 'Z'), (3, 'Y'))\n        qtermx = QubitOperator(correct_operators_x, 0.5)\n        qtermy = QubitOperator(correct_operators_y, 0.5j)\n\n        self.assertEqual(lowering.terms[correct_operators_x], 0.5)\n        self.assertEqual(lowering.terms[correct_operators_y], 0.5j)\n        self.assertTrue(lowering == qtermx + qtermy)\n\n    def test_transm_lower2(self):\n        lowering = jordan_wigner(FermionOperator(((2, 0),)))\n\n        correct_operators_x = ((0, 'Z'), (1, 'Z'), (2, 'X'))\n        correct_operators_y = ((0, 'Z'), (1, 'Z'), (2, 'Y'))\n        qtermx = QubitOperator(correct_operators_x, 0.5)\n        qtermy = QubitOperator(correct_operators_y, 0.5j)\n\n        self.assertEqual(lowering.terms[correct_operators_x], 0.5)\n        self.assertEqual(lowering.terms[correct_operators_y], 0.5j)\n        self.assertTrue(lowering == qtermx + qtermy)\n\n    def test_transm_lower1(self):\n        lowering = jordan_wigner(FermionOperator(((1, 0),)))\n\n        correct_operators_x = ((0, 'Z'), (1, 'X'))\n        correct_operators_y = ((0, 'Z'), (1, 'Y'))\n        qtermx = QubitOperator(correct_operators_x, 0.5)\n        qtermy = QubitOperator(correct_operators_y, 0.5j)\n\n        self.assertEqual(lowering.terms[correct_operators_x], 0.5)\n        self.assertEqual(lowering.terms[correct_operators_y], 0.5j)\n        self.assertTrue(lowering == qtermx + qtermy)\n\n    def test_transm_lower0(self):\n        lowering = jordan_wigner(FermionOperator(((0, 0),)))\n\n        correct_operators_x = ((0, 'X'),)\n        correct_operators_y = ((0, 'Y'),)\n        qtermx = QubitOperator(correct_operators_x, 0.5)\n        qtermy = QubitOperator(correct_operators_y, 0.5j)\n\n        self.assertEqual(lowering.terms[correct_operators_x], 0.5)\n        self.assertEqual(lowering.terms[correct_operators_y], 0.5j)\n        self.assertTrue(lowering == qtermx + qtermy)\n\n    def test_transm_raise3lower0(self):\n        # recall that creation gets -1j on Y and annihilation gets +1j on Y.\n        term = jordan_wigner(FermionOperator(((3, 1), (0, 0))))\n        self.assertEqual(term.terms[((0, 'X'), (1, 'Z'), (2, 'Z'), (3, 'Y'))],\n                         0.25 * 1 * -1j)\n        self.assertEqual(term.terms[((0, 'Y'), (1, 'Z'), (2, 'Z'), (3, 'Y'))],\n                         0.25 * 1j * -1j)\n        self.assertEqual(term.terms[((0, 'Y'), (1, 'Z'), (2, 'Z'), (3, 'X'))],\n                         0.25 * 1j * 1)\n        self.assertEqual(term.terms[((0, 'X'), (1, 'Z'), (2, 'Z'), (3, 'X'))],\n                         0.25 * 1 * 1)\n\n    def test_transm_number(self):\n        n = number_operator(self.n_qubits, 3)\n        n_jw = jordan_wigner(n)\n        self.assertEqual(n_jw.terms[((3, 'Z'),)], -0.5)\n        self.assertEqual(n_jw.terms[()], 0.5)\n        self.assertEqual(len(n_jw.terms), 2)\n\n    def test_ccr_offsite_even_ca(self):\n        c2 = FermionOperator(((2, 1),))\n        a4 = FermionOperator(((4, 0),))\n\n        self.assertTrue(normal_ordered(c2 * a4) == normal_ordered(-a4 * c2))\n        self.assertTrue(jordan_wigner(c2 * a4) == jordan_wigner(-a4 * c2))\n\n    def test_ccr_offsite_odd_ca(self):\n        c1 = FermionOperator(((1, 1),))\n        a4 = FermionOperator(((4, 0),))\n        self.assertTrue(normal_ordered(c1 * a4) == normal_ordered(-a4 * c1))\n\n        self.assertTrue(jordan_wigner(c1 * a4) == jordan_wigner(-a4 * c1))\n\n    def test_ccr_offsite_even_cc(self):\n        c2 = FermionOperator(((2, 1),))\n        c4 = FermionOperator(((4, 1),))\n        self.assertTrue(normal_ordered(c2 * c4) == normal_ordered(-c4 * c2))\n\n        self.assertTrue(jordan_wigner(c2 * c4) == jordan_wigner(-c4 * c2))\n\n    def test_ccr_offsite_odd_cc(self):\n        c1 = FermionOperator(((1, 1),))\n        c4 = FermionOperator(((4, 1),))\n        self.assertTrue(normal_ordered(c1 * c4) == normal_ordered(-c4 * c1))\n\n        self.assertTrue(jordan_wigner(c1 * c4) == jordan_wigner(-c4 * c1))\n\n    def test_ccr_offsite_even_aa(self):\n        a2 = FermionOperator(((2, 0),))\n        a4 = FermionOperator(((4, 0),))\n        self.assertTrue(normal_ordered(a2 * a4) == normal_ordered(-a4 * a2))\n\n        self.assertTrue(jordan_wigner(a2 * a4) == jordan_wigner(-a4 * a2))\n\n    def test_ccr_offsite_odd_aa(self):\n        a1 = FermionOperator(((1, 0),))\n        a4 = FermionOperator(((4, 0),))\n        self.assertTrue(normal_ordered(a1 * a4) == normal_ordered(-a4 * a1))\n\n        self.assertTrue(jordan_wigner(a1 * a4) == jordan_wigner(-a4 * a1))\n\n    def test_ccr_onsite(self):\n        c1 = FermionOperator(((1, 1),))\n        a1 = hermitian_conjugated(c1)\n        self.assertTrue(\n            normal_ordered(c1 * a1) == FermionOperator(()) -\n            normal_ordered(a1 * c1))\n        self.assertTrue(\n            jordan_wigner(c1 * a1) == QubitOperator(()) -\n            jordan_wigner(a1 * c1))\n\n    def test_jordan_wigner_transm_op(self):\n        n = number_operator(self.n_qubits)\n        n_jw = jordan_wigner(n)\n        self.assertEqual(self.n_qubits + 1, len(n_jw.terms))\n        self.assertEqual(self.n_qubits / 2., n_jw.terms[()])\n        for qubit in range(self.n_qubits):\n            operators = ((qubit, 'Z'),)\n            self.assertEqual(n_jw.terms[operators], -0.5)\n\n\nclass InteractionOperatorsJWTest(unittest.TestCase):\n\n    def setUp(self):\n        self.n_qubits = 5\n        self.constant = 0.\n        self.one_body = numpy.zeros((self.n_qubits, self.n_qubits), float)\n        self.two_body = numpy.zeros(\n            (self.n_qubits, self.n_qubits, self.n_qubits, self.n_qubits), float)\n        self.interaction_operator = InteractionOperator(self.constant,\n                                                        self.one_body,\n                                                        self.two_body)\n\n    def test_consistency(self):\n        \"\"\"Test consistency with JW for FermionOperators.\"\"\"\n        # Random interaction operator\n        n_qubits = 5\n        iop = random_interaction_operator(n_qubits, real=False)\n        op1 = jordan_wigner(iop)\n        op2 = jordan_wigner(get_fermion_operator(iop))\n\n        self.assertEqual(op1, op2)\n\n        # Interaction operator from molecule\n        geometry = [('Li', (0., 0., 0.)), ('H', (0., 0., 1.45))]\n        basis = 'sto-3g'\n        multiplicity = 1\n\n        filename = os.path.join(DATA_DIRECTORY, 'H1-Li1_sto-3g_singlet_1.45')\n        molecule = MolecularData(geometry,\n                                 basis,\n                                 multiplicity,\n                                 filename=filename)\n        molecule.load()\n\n        iop = molecule.get_molecular_hamiltonian()\n        op1 = jordan_wigner(iop)\n        op2 = jordan_wigner(get_fermion_operator(iop))\n\n        self.assertEqual(op1, op2)\n\n    def test_jordan_wigner_one_body(self):\n        # Make sure it agrees with jordan_wigner(FermionTerm).\n        for p in range(self.n_qubits):\n            for q in range(self.n_qubits):\n                coefficient = numpy.random.randn()\n                if p != q:\n                    coefficient += 1j * numpy.random.randn()\n                # Get test qubit operator.\n                test_operator = jordan_wigner_one_body(p, q, coefficient)\n\n                # Get correct qubit operator.\n                fermion_term = FermionOperator(((p, 1), (q, 0)), coefficient)\n                if p != q:\n                    fermion_term += FermionOperator(((q, 1), (p, 0)),\n                                                    coefficient.conjugate())\n                correct_op = jordan_wigner(fermion_term)\n\n                self.assertTrue(test_operator == correct_op)\n\n    def test_jordan_wigner_two_body(self):\n        # Make sure it agrees with jordan_wigner(FermionTerm).\n        for p, q, r, s in itertools.product(range(self.n_qubits), repeat=4):\n            coefficient = numpy.random.randn()\n            if set([p, q]) != set([r, s]):\n                coefficient += 1j * numpy.random.randn()\n\n            # Get test qubit operator.\n            test_operator = jordan_wigner_two_body(p, q, r, s, coefficient)\n\n            # Get correct qubit operator.\n            fermion_term = FermionOperator(((p, 1), (q, 1), (r, 0), (s, 0)),\n                                           coefficient)\n            if set([p, q]) != set([r, s]):\n                fermion_term += FermionOperator(\n                    ((s, 1), (r, 1), (q, 0), (p, 0)), coefficient.conjugate())\n            correct_op = jordan_wigner(fermion_term)\n\n            self.assertTrue(test_operator == correct_op,\n                            str(test_operator - correct_op))\n\n    def test_jordan_wigner_twobody_interaction_op_allunique(self):\n        test_op = FermionOperator('1^ 2^ 3 4')\n        test_op += hermitian_conjugated(test_op)\n\n        retransformed_test_op = reverse_jordan_wigner(\n            jordan_wigner(get_interaction_operator(test_op)))\n\n        self.assertTrue(\n            normal_ordered(retransformed_test_op) == normal_ordered(test_op))\n\n    def test_jordan_wigner_twobody_interaction_op_reversal_symmetric(self):\n        test_op = FermionOperator('1^ 2^ 2 1')\n        test_op += hermitian_conjugated(test_op)\n        self.assertTrue(\n            jordan_wigner(test_op) == jordan_wigner(\n                get_interaction_operator(test_op)))\n\n    def test_jordan_wigner_interaction_op_too_few_n_qubits(self):\n        with self.assertRaises(ValueError):\n            jordan_wigner_interaction_op(self.interaction_operator,\n                                         self.n_qubits - 2)\n\n    def test_jordan_wigner_interaction_op_with_zero_term(self):\n        test_op = FermionOperator('1^ 2^ 3 4')\n        test_op += hermitian_conjugated(test_op)\n\n        interaction_op = get_interaction_operator(test_op)\n        interaction_op.constant = 0.0\n\n        retransformed_test_op = reverse_jordan_wigner(\n            jordan_wigner(interaction_op))\n\n        self.assertEqual(normal_ordered(retransformed_test_op),\n                         normal_ordered(test_op))\n\n\nclass GetInteractionOperatorTest(unittest.TestCase):\n\n    def setUp(self):\n        self.n_qubits = 5\n        self.constant = 0.\n        self.one_body = numpy.zeros((self.n_qubits, self.n_qubits), float)\n        self.two_body = numpy.zeros(\n            (self.n_qubits, self.n_qubits, self.n_qubits, self.n_qubits), float)\n\n    def test_get_interaction_operator_identity(self):\n        interaction_operator = InteractionOperator(-2j, self.one_body,\n                                                   self.two_body)\n        qubit_operator = jordan_wigner(interaction_operator)\n        self.assertTrue(qubit_operator == -2j * QubitOperator(()))\n        self.assertEqual(\n            interaction_operator,\n            get_interaction_operator(reverse_jordan_wigner(qubit_operator),\n                                     self.n_qubits))\n\n    def test_get_interaction_operator_one_body(self):\n        interaction_operator = get_interaction_operator(FermionOperator('2^ 2'),\n                                                        self.n_qubits)\n        one_body = numpy.zeros((self.n_qubits, self.n_qubits), float)\n        one_body[2, 2] = 1.\n        self.assertEqual(interaction_operator,\n                         InteractionOperator(0.0, one_body, self.two_body))\n\n    def test_get_interaction_operator_one_body_twoterm(self):\n        interaction_operator = get_interaction_operator(\n            FermionOperator('2^ 3', -2j) + FermionOperator('3^ 2', 3j),\n            self.n_qubits)\n        one_body = numpy.zeros((self.n_qubits, self.n_qubits), complex)\n        one_body[2, 3] = -2j\n        one_body[3, 2] = 3j\n        self.assertEqual(interaction_operator,\n                         InteractionOperator(0.0, one_body, self.two_body))\n\n    def test_get_interaction_operator_two_body(self):\n        interaction_operator = get_interaction_operator(\n            FermionOperator('2^ 2 3^ 4'), self.n_qubits)\n        two_body = numpy.zeros(\n            (self.n_qubits, self.n_qubits, self.n_qubits, self.n_qubits), float)\n        two_body[3, 2, 4, 2] = -1.\n        self.assertEqual(interaction_operator,\n                         InteractionOperator(0.0, self.one_body, two_body))\n\n    def test_get_interaction_operator_two_body_distinct(self):\n        interaction_operator = get_interaction_operator(\n            FermionOperator('0^ 1^ 2 3'), self.n_qubits)\n        two_body = numpy.zeros(\n            (self.n_qubits, self.n_qubits, self.n_qubits, self.n_qubits), float)\n        two_body[1, 0, 3, 2] = 1.\n        self.assertEqual(interaction_operator,\n                         InteractionOperator(0.0, self.one_body, two_body))\n\n\nclass JordanWignerDiagonalCoulombHamiltonianTest(unittest.TestCase):\n\n    def test_hubbard(self):\n        x_dim = 4\n        y_dim = 5\n        tunneling = 2.\n        coulomb = 3.\n        chemical_potential = 7.\n        magnetic_field = 11.\n        periodic = False\n\n        hubbard_model = fermi_hubbard(x_dim, y_dim, tunneling, coulomb,\n                                      chemical_potential, magnetic_field,\n                                      periodic)\n\n        self.assertTrue(\n            jordan_wigner(hubbard_model) == jordan_wigner(\n                get_diagonal_coulomb_hamiltonian(hubbard_model)))\n\n    def test_random_quadratic(self):\n        n_qubits = 5\n        quad_ham = random_quadratic_hamiltonian(n_qubits, True)\n        ferm_op = get_fermion_operator(quad_ham)\n        self.assertTrue(\n            jordan_wigner(ferm_op) == jordan_wigner(\n                get_diagonal_coulomb_hamiltonian(ferm_op)))\n\n\ndef test_jordan_wigner_majorana_op_consistent():\n    op = (MajoranaOperator((1, 3, 4), 0.5) + MajoranaOperator(\n        (3, 7, 8, 9, 10, 12), 1.8) + MajoranaOperator((0, 4)))\n    assert jordan_wigner(op) == jordan_wigner(get_fermion_operator(op))"
