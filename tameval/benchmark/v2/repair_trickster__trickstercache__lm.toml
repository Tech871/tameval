[meta]
task = "repair"
scenario = "repair_invalid_constructor"

[lang_info]
lang = "Go"
go_version = "1.24"

[repo_info]
repository = "trickstercache/trickster"
sha = "99ac2462add00d5014794ec929eec27c7f1ceaa7"

[run_info]
docker_image = "golang:1.24"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/proxy/router/lm/lm.go pkg/proxy/router/lm/lm_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/proxy/router/lm/lm.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 100.0
mutation_kill_rate = nan
original_mutation_kill_rate = 65.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "pkg/proxy/router/lm/lm_test.go"
focal_file_path = "pkg/proxy/router/lm/lm.go"
test_file_url = "https://github.com/trickstercache/trickster/blob/99ac2462add00d5014794ec929eec27c7f1ceaa7/pkg/proxy/router/lm/lm_test.go"
focal_file_url = "https://github.com/trickstercache/trickster/blob/99ac2462add00d5014794ec929eec27c7f1ceaa7/pkg/proxy/router/lm/lm.go"
first_commit_date = "2025-05-27"
last_commit_date = "2025-05-27"
test_file_content = "package lm\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/trickstercache/trickster/v2/pkg/errors\"\n\t\"github.com/trickstercache/trickster/v2/pkg/proxy/router/route\"\n\t\"github.com/trickstercache/trickster/v2/pkg/testutil/writer\"\n)\n\nconst testPathExact1 = \"/path1/exact\"\n\nfunc TestRegisterRoute(t *testing.T) {\n\n\tconst testPathExact1 = \"/path1/exact\"\n\n\tr := NewRouter().(*lmRouter)\n\tr.RegisterRoute(testPathExact1, nil, nil, false, notFoundHandler)\n\n\thrs, ok := r.routes[\"\"]\n\tif !ok || hrs == nil {\n\t\tt.Fatal(\"expected non-nil route set\")\n\t}\n\trll, ok := hrs.ExactMatchRoutes[testPathExact1]\n\tif !ok || rll == nil {\n\t\tt.Fatal(\"expected non-nil route lookup\")\n\t}\n\n\terr := r.RegisterRoute(\"\", nil, nil, false, notFoundHandler)\n\tif err != errors.ErrInvalidPath {\n\t\tt.Fatal(\"expected error for invalid path\")\n\t}\n\n\terr = r.RegisterRoute(testPathPrefix1, nil, []string{\"invalidMethod\"},\n\t\tfalse, notFoundHandler)\n\tif err != errors.ErrInvalidMethod {\n\t\tt.Fatal(\"expected error for invalid method\")\n\t}\n\n\terr = r.RegisterRoute(testPathPrefix1, nil, []string{http.MethodGet},\n\t\ttrue, notFoundHandler)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestHandler(t *testing.T) {\n\tr := NewRouter().(*lmRouter)\n\tr.RegisterRoute(testPathExact1, nil, nil, false, testResponse1Handler)\n\tr.RegisterRoute(testPathPrefix2, []string{\"example.com\"}, nil, true,\n\t\ttestResponse2Handler)\n\tr.RegisterRoute(testPathPrefix1, []string{\"example.com\"}, nil, true,\n\t\ttestResponse1Handler)\n\n\treq, _ := http.NewRequest(http.MethodGet, testPathExact1, nil)\n\treq.Host = \"example.com:8080\"\n\th := r.Handler(req)\n\tw := writer.NewWriter(1, 2, 3).(*writer.TestResponseWriter)\n\tif h == nil {\n\t\tt.Fatal(\"expected non-nil handler\")\n\t}\n\tok := serveAndVerifyTestResponse1(h, w, req)\n\tif !ok {\n\t\tt.Fatal(\"expected test response 1 handler\")\n\t}\n\treq, _ = http.NewRequest(http.MethodPost, testPathExact1, nil)\n\treq.Host = \"example.com:8080\"\n\th = r.Handler(req)\n\tw.Reset()\n\tif h == nil {\n\t\tt.Fatal(\"expected non-nil handler\")\n\t}\n\tok = verifyMethodNotAllowed(h, w, req)\n\tif !ok {\n\t\tt.Fatal(\"expected method not allowed handler\")\n\t}\n\treq, _ = http.NewRequest(http.MethodPost, testPathExact2, nil)\n\th = r.Handler(req)\n\tw.Reset()\n\tif h == nil {\n\t\tt.Fatal(\"expected non-nil handler\")\n\t}\n\tok = verifyNotFound(h, w, req)\n\tif !ok {\n\t\tt.Fatal(\"expected 404 not found handler\")\n\t}\n\treq, _ = http.NewRequest(http.MethodGet, testPathPrefix1+\"/more/path\", nil)\n\treq.Host = \"example.com:8080\"\n\th = r.Handler(req)\n\tw.Reset()\n\tif h == nil {\n\t\tt.Fatal(\"expected non-nil handler\")\n\t}\n\tok = serveAndVerifyTestResponse1(h, w, req)\n\tif !ok {\n\t\tt.Fatal(\"expected test response 1 handler\")\n\t}\n\treq, _ = http.NewRequest(http.MethodPost, testPathPrefix1+\"/more/path\", nil)\n\treq.Host = \"example.com:8080\"\n\th = r.Handler(req)\n\tw.Reset()\n\tif h == nil {\n\t\tt.Fatal(\"expected non-nil handler\")\n\t}\n\tok = verifyMethodNotAllowed(h, w, req)\n\tif !ok {\n\t\tt.Fatal(\"expected method not allowed handler\")\n\t}\n\n\tr.RegisterRoute(testPathExact2, []string{\"example.com\"}, nil, false,\n\t\ttestResponse2Handler)\n\treq, _ = http.NewRequest(http.MethodGet, testPathExact2, nil)\n\treq.Host = \"example.com:8080\"\n\th = r.Handler(req)\n\tw.Reset()\n\tif h == nil {\n\t\tt.Fatal(\"expected non-nil handler\")\n\t}\n\tok = verifyTestResponse2(h, w, req)\n\tif !ok {\n\t\tt.Fatal(\"expected test response 2 handler\")\n\t}\n\n\tr.SetMatchingScheme(0)\n\treq, _ = http.NewRequest(http.MethodConnect, testPathPrefix1, nil)\n\treq.Host = \"example.com:8080\"\n\th = r.Handler(req)\n\tw.Reset()\n\tif h == nil {\n\t\tt.Fatal(\"expected non-nil handler\")\n\t}\n\tok = verifyNotFound(h, w, req)\n\tif !ok {\n\t\tt.Fatal(\"expected 404 not found handler\")\n\t}\n\n}\n\nfunc TestServeHTTP(t *testing.T) {\n\tr := NewRouter().(*lmRouter)\n\tr.RegisterRoute(\"/\", nil, nil, true, testResponse1Handler)\n\tw := writer.NewWriter().(*writer.TestResponseWriter)\n\treq, _ := http.NewRequest(http.MethodGet, testPathPrefix1, nil)\n\treq.RequestURI = \"*\"\n\tr.ServeHTTP(w, req)\n\tok := verifyBadRequest(w)\n\tif !ok {\n\t\tt.Fatal(\"expected 400 bad request handler\")\n\t}\n\treq, _ = http.NewRequest(http.MethodGet, testPathPrefix1, nil)\n\tw.Reset()\n\tr.ServeHTTP(w, req)\n\tok = verifyTestResponse1(w)\n\tif !ok {\n\t\tt.Fatal(\"expected test response 1 handler\")\n\t}\n}\n\nfunc verifyNotFound(h http.Handler, w *writer.TestResponseWriter,\n\tr *http.Request) bool {\n\th.ServeHTTP(w, r)\n\treturn w.StatusCode == http.StatusNotFound\n}\n\nfunc verifyMethodNotAllowed(h http.Handler, w *writer.TestResponseWriter,\n\tr *http.Request) bool {\n\th.ServeHTTP(w, r)\n\treturn w.StatusCode == http.StatusMethodNotAllowed\n}\n\nconst testResponse1Text = \"test response 1\"\nconst testResponse2Text = \"test response 2\"\n\nfunc testResponse1(w http.ResponseWriter, r *http.Request) {\n\thttp.Error(w, testResponse1Text, http.StatusOK)\n}\n\nvar testResponse1Handler = http.HandlerFunc(testResponse1)\n\nfunc serveAndVerifyTestResponse1(h http.Handler, w *writer.TestResponseWriter,\n\tr *http.Request) bool {\n\th.ServeHTTP(w, r)\n\treturn verifyTestResponse1(w)\n}\n\nfunc verifyTestResponse1(w *writer.TestResponseWriter) bool {\n\treturn w.StatusCode == http.StatusOK &&\n\t\tstrings.TrimSpace(string(w.Bytes)) == testResponse1Text\n}\n\nfunc testResponse2(w http.ResponseWriter, r *http.Request) {\n\thttp.Error(w, testResponse2Text, http.StatusOK)\n}\n\nvar testResponse2Handler = http.HandlerFunc(testResponse2)\n\nfunc verifyTestResponse2(h http.Handler, w *writer.TestResponseWriter,\n\tr *http.Request) bool {\n\th.ServeHTTP(w, r)\n\treturn w.StatusCode == http.StatusOK &&\n\t\tstrings.TrimSpace(string(w.Bytes)) == testResponse2Text\n}\n\nfunc verifyBadRequest(w *writer.TestResponseWriter) bool {\n\treturn w.StatusCode == http.StatusBadRequest\n}\n\nfunc Test_lmRouter(t *testing.T) {\n\tl := lmRouter{\n\t\troutes: map[string]*route.HostRouteSet{\n\t\t\t\"foo\": {\n\t\t\t\tPrefixMatchRoutes: []*route.PrefixRouteSet{\n\t\t\t\t\t{Path: \"/baz\", PathLen: 3},\n\t\t\t\t\t{Path: \"/quxx\", PathLen: 4},\n\t\t\t\t\t{Path: \"/ab\", PathLen: 2},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tl.sort()\n\troute := l.routes[\"foo\"]\n\trequire.Equal(t, 3, len(route.PrefixMatchRoutes))\n\tprefixes := route.PrefixMatchRoutes\n\trequire.Equal(t, \"/quxx\", prefixes[0].Path)\n\trequire.Equal(t, 4, prefixes[0].PathLen)\n\trequire.Equal(t, \"/baz\", prefixes[1].Path)\n\trequire.Equal(t, 3, prefixes[1].PathLen)\n\trequire.Equal(t, \"/ab\", prefixes[2].Path)\n\trequire.Equal(t, 2, prefixes[2].PathLen)\n\n}"
