[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "antrea-io/antrea"
sha = "0cd2eed3cc54448553096bf4e6ee74836c9c1d11"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/agent/controller/networkpolicy/l7engine/reconciler.go pkg/agent/controller/networkpolicy/l7engine/reconciler_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/agent/controller/networkpolicy/l7engine/reconciler.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 63.0
original_coverage = 63.0
mutation_kill_rate = 38.0
original_mutation_kill_rate = 38.0
covered_lines = [ 131, 132, 133, 134, 135, 137, 138, 139, 140, 141, 143, 144, 145, 146, 147, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 203, 206, 207, 208, 210, 211, 212, 214, 215, 219, 223, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 260, 261, 262, 263, 264, 265, 268, 269, 270, 272, 273, 274, 275, 276, 279, 280, 281, 282, 283, 293, 294, 295, 296, 297, 298, 299, 300, 311, 312, 313, 314, 323, 326, 327, 328, 329, 330, 338, 343, 346, 347, 348, 355, 356, 363, 364, 367, 368, 369, 370, 371, 372, 373, 374, 375, 379, 387, 388, 395, 396, 400, 401, 408, 409, 412, 413, 414, 417, 418, 419, 420, 427, 428, 432, 433, 440, 441, 445, 451, 454, 455, 456, 457, 459, 460, 461, 462, 464, 465, 466, 467, 469, 470, 471, 472, 474, 475, 476, 477, 479, 480, 484, 490, 494, 495, 500, 501, 502, 503, 507, 512, 513,]
missed_lines = [ 216, 217, 218, 220, 221, 222, 285, 286, 287, 288, 289, 290, 302, 303, 304, 305, 306, 307, 315, 316, 317, 320, 321, 322, 333, 334, 335, 339, 340, 341, 349, 350, 351, 357, 358, 359, 360, 361, 362, 376, 377, 378, 380, 381, 382, 383, 389, 390, 391, 392, 393, 394, 402, 403, 404, 405, 406, 407, 421, 422, 423, 424, 425, 426, 434, 435, 436, 437, 438, 439, 446, 447, 448, 449, 481, 482, 483, 485, 486, 487, 491, 492, 493, 496, 497, 498, 504, 505, 506, 509, 510, 511, 516, 517, 518, 519, 520, 522, 523, 524, 525, 527, 528, 529, 530, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543,]

[input_info]
test_file_path = "pkg/agent/controller/networkpolicy/l7engine/reconciler_test.go"
focal_file_path = "pkg/agent/controller/networkpolicy/l7engine/reconciler.go"
test_file_url = "https://github.com/antrea-io/antrea/blob/0cd2eed3cc54448553096bf4e6ee74836c9c1d11/pkg/agent/controller/networkpolicy/l7engine/reconciler_test.go"
focal_file_url = "https://github.com/antrea-io/antrea/blob/0cd2eed3cc54448553096bf4e6ee74836c9c1d11/pkg/agent/controller/networkpolicy/l7engine/reconciler.go"
first_commit_date = "2022-12-22"
last_commit_date = "2025-02-21"
test_file_content = "// Copyright 2022 Antrea Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage l7engine\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\n\t\"github.com/spf13/afero\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n\t\"k8s.io/apimachinery/pkg/util/sets\"\n\n\toftesting \"antrea.io/antrea/pkg/agent/openflow/testing\"\n\tv1beta \"antrea.io/antrea/pkg/apis/controlplane/v1beta2\"\n)\n\ntype fakeSuricata struct {\n\tcalledScCommands      sets.Set[string]\n\tstartSuricataFnCalled bool\n}\n\nfunc newFakeSuricata() *fakeSuricata {\n\treturn &fakeSuricata{\n\t\tcalledScCommands:      sets.New[string](),\n\t\tstartSuricataFnCalled: false,\n\t}\n}\n\nfunc (f *fakeSuricata) suricataScFunc(scCmd string) (*scCmdRet, error) {\n\tf.calledScCommands.Insert(scCmd)\n\treturn &scCmdRet{Return: scCmdOK}, nil\n}\n\nfunc (f *fakeSuricata) startSuricataFn() {\n\tf.startSuricataFnCalled = true\n\tdefaultFS.Create(suricataCommandSocket)\n}\n\nfunc TestConvertProtocolHTTP(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\thttp     *v1beta.HTTPProtocol\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"without host,method,path\",\n\t\t\thttp:     &v1beta.HTTPProtocol{},\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"with host,method,exact path\",\n\t\t\thttp: &v1beta.HTTPProtocol{\n\t\t\t\tHost:   \"www.google.com\",\n\t\t\t\tMethod: \"GET\",\n\t\t\t\tPath:   \"/index.html\",\n\t\t\t},\n\t\t\texpected: `http.uri; content:\"/index.html\"; startswith; endswith; http.method; content:\"GET\"; http.host; content:\"www.google.com\"; startswith; endswith;`,\n\t\t},\n\t\t{\n\t\t\tname: \"with host suffix, path prefix\",\n\t\t\thttp: &v1beta.HTTPProtocol{\n\t\t\t\tHost: \"*.foo.com\",\n\t\t\t\tPath: \"/api/v2/*\",\n\t\t\t},\n\t\t\texpected: `http.uri; content:\"/api/v2/\"; startswith; http.host; content:\".foo.com\"; endswith;`,\n\t\t},\n\t\t{\n\t\t\tname: \"with host pattern\",\n\t\t\thttp: &v1beta.HTTPProtocol{\n\t\t\t\tHost: \"*.foo.*\",\n\t\t\t},\n\t\t\texpected: `http.host; content:\".foo.\";`,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tassert.Equal(t, tc.expected, convertProtocolHTTP(tc.http))\n\t\t})\n\t}\n}\n\nfunc TestConvertProtocolTLS(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\ttls      *v1beta.TLSProtocol\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"without SNI\",\n\t\t\ttls:      &v1beta.TLSProtocol{},\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"with SNI\",\n\t\t\ttls: &v1beta.TLSProtocol{\n\t\t\t\tSNI: \"google.com\",\n\t\t\t},\n\t\t\texpected: `tls.sni; content:\"google.com\"; startswith; endswith;`,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tassert.Equal(t, tc.expected, convertProtocolTLS(tc.tls))\n\t\t})\n\t}\n}\n\nfunc TestStartSuricata(t *testing.T) {\n\tdefaultFS = afero.NewMemMapFs()\n\tdefer func() {\n\t\tdefaultFS = afero.NewOsFs()\n\t}()\n\n\t_, err := defaultFS.Create(defaultSuricataConfigPath)\n\tassert.NoError(t, err)\n\n\tfe := NewReconciler(nil)\n\tfs := newFakeSuricata()\n\tfe.suricataScFn = fs.suricataScFunc\n\tfe.startSuricataFn = fs.startSuricataFn\n\n\tfe.startSuricata()\n\n\tok, err := afero.FileContainsBytes(defaultFS, antreaSuricataConfigPath, []byte(suricataAntreaConfigData))\n\tassert.NoError(t, err)\n\tassert.True(t, ok)\n\n\tok, err = afero.FileContainsBytes(defaultFS, defaultSuricataConfigPath, []byte(\"include: /etc/suricata/antrea.yaml\"))\n\tassert.NoError(t, err)\n\tassert.True(t, ok)\n}\n\nfunc TestRuleLifecycle(t *testing.T) {\n\truleID := \"123456\"\n\tvlanID := uint32(1)\n\tpolicyName := \"AntreaNetworkPolicy:test-l7\"\n\n\ttestCases := []struct {\n\t\tname                 string\n\t\tl7Protocols          []v1beta.L7Protocol\n\t\tupdatedL7Protocols   []v1beta.L7Protocol\n\t\texpectedRules        string\n\t\texpectedUpdatedRules string\n\t}{\n\t\t{\n\t\t\tname: \"protocol HTTP\",\n\t\t\tl7Protocols: []v1beta.L7Protocol{\n\t\t\t\t{\n\t\t\t\t\tHTTP: &v1beta.HTTPProtocol{\n\t\t\t\t\t\tHost:   \"www.google.com\",\n\t\t\t\t\t\tMethod: \"GET\",\n\t\t\t\t\t\tPath:   \"/index.html\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tupdatedL7Protocols: []v1beta.L7Protocol{\n\t\t\t\t{\n\t\t\t\t\tHTTP: &v1beta.HTTPProtocol{},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedRules:        `pass http any any -> any any (msg: \"Allow http by AntreaNetworkPolicy:test-l7\"; http.uri; content:\"/index.html\"; startswith; endswith; http.method; content:\"GET\"; http.host; content:\"www.google.com\"; startswith; endswith; sid: 2;)`,\n\t\t\texpectedUpdatedRules: `pass http any any -> any any (msg: \"Allow http by AntreaNetworkPolicy:test-l7\"; sid: 2;)`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tdefaultFS = afero.NewMemMapFs()\n\t\t\tdefer func() {\n\t\t\t\tdefaultFS = afero.NewOsFs()\n\t\t\t}()\n\n\t\t\t_, err := defaultFS.Create(defaultSuricataConfigPath)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockOfClient := oftesting.NewMockClient(ctrl)\n\t\t\tfe := NewReconciler(mockOfClient)\n\t\t\tfs := newFakeSuricata()\n\t\t\tfe.suricataScFn = fs.suricataScFunc\n\t\t\tfe.startSuricataFn = fs.startSuricataFn\n\n\t\t\tmockOfClient.EXPECT().InstallL7NetworkPolicyFlows().Times(1)\n\n\t\t\t// Test add a L7 NetworkPolicy.\n\t\t\tassert.NoError(t, fe.AddRule(ruleID, policyName, vlanID, tc.l7Protocols))\n\n\t\t\trulesPath := generateTenantRulesPath(vlanID)\n\t\t\tok, err := afero.FileContainsBytes(defaultFS, rulesPath, []byte(tc.expectedRules))\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.True(t, ok)\n\n\t\t\tconfigPath := generateTenantConfigPath(vlanID)\n\t\t\tok, err = afero.FileContainsBytes(defaultFS, configPath, []byte(rulesPath))\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.True(t, ok)\n\n\t\t\texpectedScCommands := sets.New[string](\"register-tenant 1 /etc/suricata/antrea-tenant-1.yaml\", \"register-tenant-handler 1 vlan 1\")\n\t\t\tassert.True(t, fs.startSuricataFnCalled)\n\t\t\tassert.Equal(t, expectedScCommands, fs.calledScCommands)\n\n\t\t\t// Update the added L7 NetworkPolicy.\n\t\t\tassert.NoError(t, fe.AddRule(ruleID, policyName, vlanID, tc.updatedL7Protocols))\n\t\t\texpectedScCommands.Insert(\"reload-tenant 1 /etc/suricata/antrea-tenant-1.yaml\")\n\t\t\tassert.Equal(t, expectedScCommands, fs.calledScCommands)\n\n\t\t\t// Delete the L7 NetworkPolicy.\n\t\t\tassert.NoError(t, fe.DeleteRule(ruleID, vlanID))\n\t\t\texpectedScCommands.Insert(\"unregister-tenant-handler 1 vlan 1\", \"unregister-tenant 1\")\n\t\t\tassert.Equal(t, expectedScCommands, fs.calledScCommands)\n\n\t\t\texists, err := afero.Exists(defaultFS, rulesPath)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.False(t, exists)\n\n\t\t\texists, err = afero.Exists(defaultFS, configPath)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.False(t, exists)\n\t\t})\n\t}\n}\n\nfunc TestInitializeL7FlowsOnce(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tmockOfClient := oftesting.NewMockClient(ctrl)\n\tfe := NewReconciler(mockOfClient)\n\n\tmockOfClient.EXPECT().InstallL7NetworkPolicyFlows().Return(fmt.Errorf(\"error\"))\n\tmockOfClient.EXPECT().InstallL7NetworkPolicyFlows().Return(nil)\n\n\tvar wg sync.WaitGroup\n\tvar errOccurred int32\n\tfor i := 0; i < 3; i++ {\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\terr := fe.initializeL7FlowsOnce.Do(fe.initializeL7Flows)\n\t\t\tif err != nil {\n\t\t\t\tatomic.AddInt32(&errOccurred, 1)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\trequire.Equal(t, int32(1), errOccurred)\n}\n"
