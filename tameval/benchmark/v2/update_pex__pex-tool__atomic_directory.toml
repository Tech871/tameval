[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Python"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "pex-tool/pex"
sha = "17bd416647eaca978e538408f1ec21813ab26335"

[run_info]
docker_image = "python:3"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r docs-requirements.txt && (pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=pex/atomic_directory.py -m pytest -q --junit-xml=test_output.xml tests/test_atomic_directory.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target pex.atomic_directory --unit-test tests.test_atomic_directory --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target pex/atomic_directory.py --unit-test tests/test_atomic_directory.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 39.0
original_coverage = 83.0
mutation_kill_rate = nan
original_mutation_kill_rate = 78.0
covered_lines = [ 3, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 19, 24, 27, 64, 107, 108, 112, 113, 117, 121, 122, 126, 130, 131, 139, 171, 176, 191, 192, 193, 194, 195, 197, 212, 213, 214, 215, 217, 237, 240, 241,]
missed_lines = [ 20, 22, 71, 72, 75, 78, 80, 81, 99, 100, 110, 115, 119, 124, 128, 133, 134, 135, 137, 149, 150, 152, 153, 164, 165, 166, 167, 169, 173, 186, 199, 200, 202, 204, 205, 207, 209, 228, 229, 230, 231, 232, 234, 265, 266, 268, 269, 271, 272, 275, 276, 278, 279, 284, 285, 286, 287, 290, 299, 300, 301, 307, 309, 310, 311, 312, 313, 315, 317,]

[input_info]
test_file_path = "tests/test_atomic_directory.py"
focal_file_path = "pex/atomic_directory.py"
test_file_url = "https://github.com/pex-tool/pex/blob/17bd416647eaca978e538408f1ec21813ab26335/tests/test_atomic_directory.py"
focal_file_url = "https://github.com/pex-tool/pex/blob/17bd416647eaca978e538408f1ec21813ab26335/pex/atomic_directory.py"
first_commit_date = "2022-10-21"
last_commit_date = "2025-02-06"
test_file_content = "# Copyright 2022 Pex project contributors.\n# Licensed under the Apache License, Version 2.0 (see LICENSE).\n\nimport errno\nimport os\nimport re\nfrom contextlib import contextmanager\n\nimport pytest\n\nfrom pex.atomic_directory import AtomicDirectory, FileLockStyle, _is_bsd_lock, atomic_directory\nfrom pex.common import temporary_dir, touch\nfrom pex.typing import TYPE_CHECKING\nfrom testing import environment_as\n\ntry:\n    from unittest import mock\nexcept ImportError:\n    import mock  # type: ignore[no-redef,import]\n\nif TYPE_CHECKING:\n    from typing import Iterator, Optional, Type\n\n\ndef test_is_bsd_lock():\n    # type: () -> None\n\n    assert not _is_bsd_lock(\n        lock_style=None\n    ), \"Expected the default lock style to be POSIX for maximum compatibility.\"\n    assert not _is_bsd_lock(lock_style=FileLockStyle.POSIX)\n    assert _is_bsd_lock(lock_style=FileLockStyle.BSD)\n\n    # The hard-coded default is already POSIX, so setting the env var default changes nothing.\n    with environment_as(_PEX_FILE_LOCK_STYLE=\"posix\"):\n        assert not _is_bsd_lock(lock_style=None)\n        assert not _is_bsd_lock(lock_style=FileLockStyle.POSIX)\n        assert _is_bsd_lock(lock_style=FileLockStyle.BSD)\n\n    with environment_as(_PEX_FILE_LOCK_STYLE=\"bsd\"):\n        assert _is_bsd_lock(\n            lock_style=None\n        ), \"Expected the default lock style to be taken from the environment when defined.\"\n        assert not _is_bsd_lock(lock_style=FileLockStyle.POSIX)\n        assert _is_bsd_lock(lock_style=FileLockStyle.BSD)\n\n\n@contextmanager\ndef maybe_raises(exception=None):\n    # type: (Optional[Type[Exception]]) -> Iterator[None]\n    @contextmanager\n    def noop():\n        yield\n\n    context = noop() if exception is None else pytest.raises(exception)\n    with context:\n        yield\n\n\ndef atomic_directory_finalize_test(errno, expect_raises=None):\n    # type: (int, Optional[Type[Exception]]) -> None\n    with mock.patch(\"os.rename\", spec_set=True, autospec=True) as mock_rename:\n        mock_rename.side_effect = OSError(errno, os.strerror(errno))\n        with maybe_raises(expect_raises):\n            AtomicDirectory(\"to.dir\").finalize()\n\n\ndef test_atomic_directory_finalize_eexist():\n    # type: () -> None\n    atomic_directory_finalize_test(errno.EEXIST)\n\n\ndef test_atomic_directory_finalize_enotempty():\n    # type: () -> None\n    atomic_directory_finalize_test(errno.ENOTEMPTY)\n\n\ndef test_atomic_directory_finalize_eperm():\n    # type: () -> None\n    atomic_directory_finalize_test(errno.EPERM, expect_raises=OSError)\n\n\ndef test_atomic_directory_empty_workdir_finalize():\n    # type: () -> None\n    with temporary_dir() as sandbox:\n        target_dir = os.path.join(sandbox, \"target_dir\")\n        assert not os.path.exists(target_dir)\n\n        with atomic_directory(target_dir) as atomic_dir:\n            assert not atomic_dir.is_finalized()\n            assert target_dir == atomic_dir.target_dir\n            assert os.path.exists(atomic_dir.work_dir)\n            assert os.path.isdir(atomic_dir.work_dir)\n            assert [] == os.listdir(atomic_dir.work_dir)\n\n            touch(os.path.join(atomic_dir.work_dir, \"created\"))\n\n            assert not os.path.exists(target_dir)\n\n        assert not os.path.exists(atomic_dir.work_dir), \"The work_dir should always be cleaned up.\"\n        assert os.path.exists(os.path.join(target_dir, \"created\"))\n\n\ndef test_atomic_directory_empty_workdir_failure():\n    # type: () -> None\n    class SimulatedRuntimeError(RuntimeError):\n        pass\n\n    with temporary_dir() as sandbox:\n        target_dir = os.path.join(sandbox, \"target_dir\")\n        with pytest.raises(SimulatedRuntimeError):\n            with atomic_directory(target_dir) as atomic_dir:\n                assert not atomic_dir.is_finalized()\n                touch(os.path.join(atomic_dir.work_dir, \"created\"))\n                raise SimulatedRuntimeError()\n\n        assert not os.path.exists(  # type: ignore[unreachable]\n            atomic_dir.work_dir\n        ), \"The work_dir should always be cleaned up.\"\n        assert not os.path.exists(target_dir), (\n            \"When the context raises the work_dir it was given should not be moved to the \"\n            \"target_dir.\"\n        )\n\n\ndef test_atomic_directory_empty_workdir_finalized():\n    # type: () -> None\n    with temporary_dir() as target_dir:\n        with atomic_directory(target_dir) as work_dir:\n            assert (\n                work_dir.is_finalized()\n            ), \"When the target_dir exists no work_dir should be created.\"\n\n\ndef test_atomic_directory_locked_mode():\n    # type: () -> None\n\n    assert AtomicDirectory(\"unlocked\").work_dir != AtomicDirectory(\"unlocked\").work_dir\n    assert (\n        AtomicDirectory(\"locked\", locked=True).work_dir\n        == AtomicDirectory(\"locked\", locked=True).work_dir\n    )\n\n\ndef test_long_file_name_issue_2087():\n    # type: () -> None\n\n    atomic_directory = AtomicDirectory(\n        \"/tmp/pycryptodome-3.16.0-cp35-abi3-manylinux_2_5_x86_64.manylinux1_x86_64.\"\n        \"manylinux_2_12_x86_64\",\n        locked=False,\n    )\n    assert re.match(\n        r\"pycryptodome-3\\.16\\.0-cp35-abi3-manylinux_2_5_x86_64\\.manylinux1_x86_64\\.\"\n        r\"manylinux_2_12_x86_64\\.[a-f0-9]+.work\",\n        os.path.basename(atomic_directory.work_dir),\n    ), \"Expected shorter directory names to use a workdir with the target dir as a prefix.\"\n\n    atomic_directory = AtomicDirectory(\n        \"/tmp/pycryptodome-3.16.0-cp35-abi3-manylinux_2_5_x86_64.manylinux1_x86_64.\"\n        \"manylinux_2_12_x86_64.manylinux2010_x86_64.whl\",\n        locked=False,\n    )\n    assert \"/tmp\" == os.path.dirname(\n        atomic_directory.work_dir\n    ), \"Expected the workdir to be co-located with the target dir to ensure atomic rename works.\"\n    assert 143 == len(\n        os.path.basename(atomic_directory.work_dir)\n    ), \"Expected longer directory names to use a workdir that is 143 characters in length.\"\n    assert re.match(\n        r\"^pycryptodome-3\\.16\\.0-cp35-abi3-manylinux_2_5_x86_64\\.manylinux1_x86_64\\.manylin\"\n        r\"\\.\\.\\.[a-f0-9]{64}$\",\n        os.path.basename(atomic_directory.work_dir),\n    ), \"Expected longer directory names to retain their prefix with a `...<hash>` suffix.\""
