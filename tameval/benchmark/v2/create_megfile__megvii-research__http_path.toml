[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "megvii-research/megfile"
sha = "0dd2329354b37b41cb8ec31cfd5c15c5e0b1af35"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r requirements.txt && pip install -r requirements-cli.txt && pip install -r requirements-hdfs.txt && pip install -r requirements-dev.txt && (pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=megfile/http_path.py -m pytest -q --junit-xml=test_output.xml tests/test_http_path.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target megfile.http_path --unit-test tests.test_http_path --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target megfile/http_path.py --unit-test tests/test_http_path.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 84.0
original_coverage = 84.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = [ 0, 1, 2, 3, 4, 5, 6, 8, 9, 11, 16, 17, 18, 19, 20, 21, 22, 24, 31, 33, 38, 47, 48, 49, 50, 51, 53, 54, 55, 56, 58, 59, 63, 71, 72, 73, 74, 75, 76, 78, 79, 80, 81, 82, 83, 84, 85, 86, 88, 92, 94, 95, 96, 97, 98, 99, 100, 102, 110, 113, 120, 121, 124, 126, 127, 130, 131, 132, 134, 135, 137, 138, 139, 141, 142, 143, 145, 146, 177, 180, 181, 182, 183, 189, 190, 191, 212, 218, 220, 258, 270, 282, 298, 301, 302, 303, 306, 307, 308, 310, 311, 312, 313, 314, 315, 317, 318, 319, 321, 322, 323, 325, 326, 328, 329, 330, 332, 333, 334, 335, 336, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 353, 354, 355, 356, 357, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392, 394, 396, 397, 398, 399, 400, 401, 402, 403, 404, 406, 407,]
missed_lines = [ 178, 184, 185, 186, 187, 196, 198, 208, 209, 210, 229, 230, 231, 232, 233, 234, 236, 237, 238, 240, 242, 243, 244, 248, 250, 268, 280, 290, 291, 292, 293, 294, 295, 296,]

[input_info]
test_file_path = "tests/test_http_path.py"
focal_file_path = "megfile/http_path.py"
test_file_url = "https://github.com/megvii-research/megfile/blob/0dd2329354b37b41cb8ec31cfd5c15c5e0b1af35/tests/test_http_path.py"
focal_file_url = "https://github.com/megvii-research/megfile/blob/0dd2329354b37b41cb8ec31cfd5c15c5e0b1af35/megfile/http_path.py"
first_commit_date = "2021-08-23"
last_commit_date = "2025-06-27"
test_file_content = "import io\nimport logging\nfrom copy import deepcopy\n\nimport pytest\nimport requests\nimport requests_mock  # noqa: F401\n\nfrom megfile.http_path import HttpPath, Response, get_http_session, is_http\n\n\ndef test_absolute():\n    assert HttpPath(\"http://foo/bar\").is_absolute()\n    assert HttpPath(\"foo/bar\").is_absolute()\n\n\ndef test_reserved():\n    assert not HttpPath(\"http://foo/bar\").is_reserved()\n    assert not HttpPath(\"foo/bar\").is_reserved()\n\n\ndef test_joinpath():\n    assert HttpPath(\"http://foo\").joinpath(\"bar\") == HttpPath(\"http://foo/bar\")\n    assert HttpPath(\"http://foo\").joinpath(HttpPath(\"bar\")) == HttpPath(\n        \"http://foo/bar\"\n    )\n    assert HttpPath(\"http://foo\").joinpath(\"bar\", \"baz\") == HttpPath(\n        \"http://foo/bar/baz\"\n    )\n\n    assert HttpPath(\"foo\").joinpath(\"bar\") == HttpPath(\"foo/bar\")\n    assert HttpPath(\"foo\").joinpath(HttpPath(\"bar\")) == HttpPath(\"foo/bar\")\n    assert HttpPath(\"foo\").joinpath(\"bar\", \"baz\") == HttpPath(\"foo/bar/baz\")\n\n\ndef test_match():\n    assert HttpPath(\"a/b.py\").match(\"*.py\")\n    assert HttpPath(\"http://a/b/c.py\").match(\"b/*.py\")\n    assert not HttpPath(\"http://a/b/c.py\").match(\"http://a/*.py\")\n    assert HttpPath(\"http://a.py\").match(\"http://*.py\")\n    assert HttpPath(\"a/b.py\").match(\"http://a/b.py\")\n    assert not HttpPath(\"a/b.py\").match(\"https://a/b.py\")\n    assert not HttpPath(\"a/b.py\").match(\"http://*.py\")\n    assert not HttpPath(\"a/b.py\").match(\"*.Py\")\n\n\ndef test_relative_to():\n    path = HttpPath(\"http://foo/bar\")\n    assert path.relative_to(\"http://\") == HttpPath(\"foo/bar\")\n    assert path.relative_to(\"http://foo\") == HttpPath(\"bar\")\n    with pytest.raises(ValueError):\n        path.relative_to(\"http://baz\")\n\n\ndef test_relative_to_relative():\n    path = HttpPath(\"foo/bar/baz\")\n    assert path.relative_to(\"foo/bar\") == HttpPath(\"baz\")\n    assert path.relative_to(\"foo\") == HttpPath(\"bar/baz\")\n    with pytest.raises(ValueError):\n        path.relative_to(\"baz\")\n\n\ndef test_with_name():\n    path = HttpPath(\"http://foo/bar.tar.gz\")\n    assert path.with_name(\"baz.py\") == HttpPath(\"http://foo/baz.py\")\n    path = HttpPath(\"http://\")\n\n    # with pytest.raises(ValueError):\n    #     path.with_name('baz.py')\n\n    path = HttpPath(\"foo/bar.tar.gz\")\n    assert path.with_name(\"baz.py\") == HttpPath(\"foo/baz.py\")\n\n\ndef test_with_suffix():\n    path = HttpPath(\"http://foo/bar.tar.gz\")\n    assert path.with_suffix(\".bz2\") == HttpPath(\"http://foo/bar.tar.bz2\")\n    path = HttpPath(\"baz\")\n    assert path.with_suffix(\".txt\") == HttpPath(\"baz.txt\")\n    path = HttpPath(\"baz.txt\")\n    assert path.with_suffix(\"\") == HttpPath(\"baz\")\n\n\ndef test_http_retry(requests_mock, mocker):\n    max_retries = 2\n    mocker.patch(\"megfile.http_path.HTTP_MAX_RETRY_TIMES\", max_retries)\n    requests_mock.post(\"http://foo\", status_code=500)\n    session = get_http_session()\n    history_index = 0\n\n    with pytest.raises(requests.exceptions.HTTPError):\n        session.post(\"http://foo\", files={\"foo\": \"bar\"})\n    for _ in range(max_retries):\n        assert b'name=\"foo\"' in requests_mock.request_history[history_index].body\n        assert b\"bar\" in requests_mock.request_history[history_index].body\n        history_index += 1\n\n    with pytest.raises(requests.exceptions.HTTPError):\n        session.post(\"http://foo\", files={\"foo\": io.BytesIO(b\"bar\")})\n    for _ in range(max_retries):\n        assert b\"bar\" in requests_mock.request_history[history_index].body\n        history_index += 1\n\n    with pytest.raises(requests.exceptions.HTTPError):\n        session.post(\"http://foo\", files={\"foo\": io.BytesIO(b\"bar\")})\n    for _ in range(max_retries):\n        assert b\"bar\" in requests_mock.request_history[history_index].body\n        history_index += 1\n\n    with pytest.raises(requests.exceptions.HTTPError):\n        session.post(\"http://foo\", files={\"foo\": (\"filename\", io.BytesIO(b\"bar\"))})\n    for _ in range(max_retries):\n        assert b'name=\"filename\"' in requests_mock.request_history[history_index].body\n        assert b\"bar\" in requests_mock.request_history[history_index].body\n        history_index += 1\n\n    with pytest.raises(requests.exceptions.HTTPError):\n        session.post(\n            \"http://foo\",\n            files={\"foo\": (\"filename\", io.BytesIO(b\"bar\"), \"application/vnd.ms-excel\")},\n        )\n    for _ in range(max_retries):\n        assert b'name=\"filename\"' in requests_mock.request_history[history_index].body\n        assert b\"bar\" in requests_mock.request_history[history_index].body\n        history_index += 1\n\n    with pytest.raises(requests.exceptions.HTTPError):\n        session.post(\n            \"http://foo\",\n            files={\"foo\": (\"filename\", b\"bar\", \"application/vnd.ms-excel\")},\n        )\n    for _ in range(max_retries):\n        assert b'name=\"filename\"' in requests_mock.request_history[history_index].body\n        assert b\"bar\" in requests_mock.request_history[history_index].body\n        history_index += 1\n\n    with pytest.raises(requests.exceptions.HTTPError):\n        session.post(\n            \"http://foo\",\n            files={\n                \"foo\": (\n                    \"filename\",\n                    io.BytesIO(b\"bar\"),\n                    \"application/vnd.ms-excel\",\n                    {\"Expires\": \"0\"},\n                )\n            },\n        )\n    for _ in range(max_retries):\n        assert b'name=\"filename\"' in requests_mock.request_history[history_index].body\n        assert b\"bar\" in requests_mock.request_history[history_index].body\n        history_index += 1\n\n    with pytest.raises(requests.exceptions.HTTPError):\n        session.post(\"http://foo\", data=io.BytesIO(b\"bar\"))\n    for _ in range(max_retries):\n        assert (\n            b\"bar\" == deepcopy(requests_mock.request_history[history_index].body).read()\n        )\n        history_index += 1\n\n    with pytest.raises(requests.exceptions.HTTPError):\n        session.post(\"http://foo\", data=(s for s in [\"a\"]))\n    assert history_index + 1 == len(requests_mock.request_history)\n\n\ndef test_http_retry_fileobj_without_seek(requests_mock, mocker, fs):\n    max_retries = 2\n    mocker.patch(\"megfile.http_path.HTTP_MAX_RETRY_TIMES\", max_retries)\n    requests_mock.post(\"http://foo\", status_code=500)\n    session = get_http_session()\n    history_index = 0\n\n    with open(\"foo.txt\", \"wb\") as f:\n        f.write(b\"bar\")\n\n    class FakeFile:\n        def __init__(self):\n            self.name = \"foo.txt\"\n\n        def read(self, size=-1, **kwargs):\n            return b\"bar\"\n\n    with pytest.raises(requests.exceptions.HTTPError):\n        session.post(\n            \"http://foo\",\n            files={\"foo\": (\"filename\", FakeFile(), \"application/vnd.ms-excel\")},\n        )\n    for _ in range(max_retries):\n        assert b'name=\"filename\"' in requests_mock.request_history[history_index].body\n        assert b\"bar\" in requests_mock.request_history[history_index].body\n        history_index += 1\n\n\ndef test_http_retry_fileobj_without_name(requests_mock, mocker, fs, caplog):\n    with caplog.at_level(logging.INFO, logger=\"megfile\"):\n        max_retries = 2\n        mocker.patch(\"megfile.http_path.HTTP_MAX_RETRY_TIMES\", max_retries)\n        requests_mock.post(\"http://foo\", status_code=500)\n        session = get_http_session()\n\n        class FakeFileWithoutName:\n            def __init__(self):\n                pass\n\n            def read(self, size=-1, **kwargs):\n                return b\"bar\"\n\n        with pytest.raises(requests.exceptions.HTTPError):\n            session.post(\n                \"http://foo\",\n                files={\n                    \"foo\": (\n                        \"filename\",\n                        FakeFileWithoutName(),\n                        \"application/vnd.ms-excel\",\n                    )\n                },\n            )\n        assert len(requests_mock.request_history) == 1\n        assert (\n            \"Can not retry http request, because the file object \"\n            'is not seekable and not support \"name\"'\n        ) in caplog.text\n\n\ndef test_response():\n    fp = io.BytesIO(b\"test\")\n    fp.name = \"foo\"\n    real_read = fp.read\n    fp.read = lambda size, **kwargs: real_read(size)\n\n    resp = Response(fp)\n    assert resp.mode == \"rb\"\n    assert resp.name == \"foo\"\n    assert resp.read(0) == b\"\"\n    assert resp.read(1) == b\"t\"\n    assert resp.read(-1) == b\"est\"\n    assert resp.tell() == 4\n\n    fp = io.BytesIO(b\"1\\n2\\n3\\n4\\n\")\n    fp.name = \"foo\"\n    real_read = fp.read\n    fp.read = lambda size, **kwargs: real_read(size)\n\n    resp = Response(fp)\n    assert resp.name == \"foo\"\n    assert resp.readlines() == [b\"1\\n\", b\"2\\n\", b\"3\\n\", b\"4\\n\"]\n\n    fp = io.BytesIO(b\"1\\n2\\n3\\n4\\n\")\n    fp.name = \"foo\"\n    real_read = fp.read\n    fp.read = lambda size, **kwargs: real_read(size)\n\n    resp = Response(fp)\n    assert resp.name == \"foo\"\n    lines = []\n    for i in range(4):\n        line = resp.readline(-1)\n        assert resp.tell() == (i + 1) * 2\n        if not line:\n            break\n        lines.append(line)\n    assert lines == [b\"1\\n\", b\"2\\n\", b\"3\\n\", b\"4\\n\"]\n\n    fp = io.BytesIO(b\"11\\n2\\n3\\n4\\n\")\n    fp.name = \"foo\"\n    real_read = fp.read\n    fp.read = lambda size, **kwargs: real_read(size)\n\n    resp = Response(fp)\n    resp._block_size = 4\n    assert resp.name == \"foo\"\n    assert resp.readline(0) == b\"\"\n    assert resp.readline(1) == b\"1\"\n    assert resp.readline(2) == b\"1\\n\"\n    assert resp.readline(1) == b\"2\"\n    assert resp.readline(1) == b\"\\n\"\n\n    fp = io.BytesIO(b\"123\")\n    fp.name = \"foo\"\n    real_read = fp.read\n    fp.read = lambda size, **kwargs: real_read(size)\n\n    resp = Response(fp)\n    resp._block_size = 2\n    assert resp.readline(1) == b\"1\"\n    assert resp.readline() == b\"23\"\n    assert resp.readline() == b\"\"\n\n\ndef test_is_http():\n    assert is_http(\"http://foo\") is True\n    assert is_http(\"s3://foo\") is False\n\n\ndef test_open_with_headers(requests_mock):\n    requests_mock.get(\n        \"http://test\", text=\"test\", status_code=200, headers={\"Content-Length\": \"4\"}\n    )\n    headers = {\"A\": \"a\", \"B\": \"b\"}\n\n    path = HttpPath(\"http://test\")\n    path.request_kwargs = {\"headers\": headers}\n    with path.open(\"rb\") as f:\n        assert f.read() == b\"test\"\n\n    for key, value in headers.items():\n        assert requests_mock.request_history[0].headers[key] == value\n\n\ndef test_https_path():\n    assert HttpPath(\"https://foo\").protocol == \"https\"\n"
