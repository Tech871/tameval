[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.24.2"

[repo_info]
repository = "KevoDB/kevo"
sha = "a0bcddabc1700e19208bd8adb99211654de65bc8"

[run_info]
docker_image = "golang:1.24.2"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/common/iterator/bounded/bounded.go pkg/common/iterator/bounded/bounded_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/common/iterator/bounded/bounded.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 75.0
original_coverage = 75.0
mutation_kill_rate = 69.0
original_mutation_kill_rate = 69.0
covered_lines = [ 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 27, 28, 29, 30, 32, 36, 37, 38, 39, 40, 45, 46, 47, 53, 54, 55, 59, 60, 61, 62, 63, 64, 65, 66, 67, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 92, 99, 100, 101, 102, 105, 109, 110, 111, 112, 113, 116, 117, 118, 120, 121, 122, 127, 128, 134, 135, 136, 139, 143, 144, 145, 148, 152, 173, 179, 180, 181, 184, 185, 186, 188,]
missed_lines = [ 41, 42, 43, 48, 49, 50, 93, 94, 95, 96, 97, 123, 129, 130, 131, 149, 150, 151, 156, 157, 158, 159, 160, 164, 165, 166, 167, 168, 174, 175, 176,]

[input_info]
test_file_path = "pkg/common/iterator/bounded/bounded_test.go"
focal_file_path = "pkg/common/iterator/bounded/bounded.go"
test_file_url = "https://github.com/KevoDB/kevo/blob/a0bcddabc1700e19208bd8adb99211654de65bc8/pkg/common/iterator/bounded/bounded_test.go"
focal_file_url = "https://github.com/KevoDB/kevo/blob/a0bcddabc1700e19208bd8adb99211654de65bc8/pkg/common/iterator/bounded/bounded.go"
first_commit_date = "2025-04-20"
last_commit_date = "2025-04-22"
test_file_content = "package bounded\n\nimport (\n\t\"testing\"\n)\n\n// mockIterator is a simple in-memory iterator for testing\ntype mockIterator struct {\n\tdata  map[string]string\n\tkeys  []string\n\tindex int\n}\n\nfunc newMockIterator(data map[string]string) *mockIterator {\n\tkeys := make([]string, 0, len(data))\n\tfor k := range data {\n\t\tkeys = append(keys, k)\n\t}\n\n\t// Sort keys\n\tfor i := 0; i < len(keys)-1; i++ {\n\t\tfor j := i + 1; j < len(keys); j++ {\n\t\t\tif keys[i] > keys[j] {\n\t\t\t\tkeys[i], keys[j] = keys[j], keys[i]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &mockIterator{\n\t\tdata:  data,\n\t\tkeys:  keys,\n\t\tindex: -1,\n\t}\n}\n\nfunc (m *mockIterator) SeekToFirst() {\n\tif len(m.keys) > 0 {\n\t\tm.index = 0\n\t} else {\n\t\tm.index = -1\n\t}\n}\n\nfunc (m *mockIterator) SeekToLast() {\n\tif len(m.keys) > 0 {\n\t\tm.index = len(m.keys) - 1\n\t} else {\n\t\tm.index = -1\n\t}\n}\n\nfunc (m *mockIterator) Seek(target []byte) bool {\n\ttargetStr := string(target)\n\tfor i, key := range m.keys {\n\t\tif key >= targetStr {\n\t\t\tm.index = i\n\t\t\treturn true\n\t\t}\n\t}\n\tm.index = -1\n\treturn false\n}\n\nfunc (m *mockIterator) Next() bool {\n\tif m.index >= 0 && m.index < len(m.keys)-1 {\n\t\tm.index++\n\t\treturn true\n\t}\n\tm.index = -1\n\treturn false\n}\n\nfunc (m *mockIterator) Key() []byte {\n\tif m.index >= 0 && m.index < len(m.keys) {\n\t\treturn []byte(m.keys[m.index])\n\t}\n\treturn nil\n}\n\nfunc (m *mockIterator) Value() []byte {\n\tif m.index >= 0 && m.index < len(m.keys) {\n\t\tkey := m.keys[m.index]\n\t\treturn []byte(m.data[key])\n\t}\n\treturn nil\n}\n\nfunc (m *mockIterator) Valid() bool {\n\treturn m.index >= 0 && m.index < len(m.keys)\n}\n\nfunc (m *mockIterator) IsTombstone() bool {\n\treturn false\n}\n\nfunc TestBoundedIterator_NoBounds(t *testing.T) {\n\t// Create a mock iterator with some data\n\tmockIter := newMockIterator(map[string]string{\n\t\t\"a\": \"1\",\n\t\t\"b\": \"2\",\n\t\t\"c\": \"3\",\n\t\t\"d\": \"4\",\n\t\t\"e\": \"5\",\n\t})\n\n\t// Create bounded iterator with no bounds\n\tboundedIter := NewBoundedIterator(mockIter, nil, nil)\n\n\t// Test SeekToFirst\n\tboundedIter.SeekToFirst()\n\tif !boundedIter.Valid() {\n\t\tt.Fatal(\"Expected iterator to be valid after SeekToFirst\")\n\t}\n\n\t// Should be at \"a\"\n\tif string(boundedIter.Key()) != \"a\" {\n\t\tt.Errorf(\"Expected key 'a', got '%s'\", string(boundedIter.Key()))\n\t}\n\n\t// Test iterating through all keys\n\texpected := []string{\"a\", \"b\", \"c\", \"d\", \"e\"}\n\tfor i, exp := range expected {\n\t\tif !boundedIter.Valid() {\n\t\t\tt.Fatalf(\"Iterator should be valid at position %d\", i)\n\t\t}\n\n\t\tif string(boundedIter.Key()) != exp {\n\t\t\tt.Errorf(\"Position %d: Expected key '%s', got '%s'\", i, exp, string(boundedIter.Key()))\n\t\t}\n\n\t\tif i < len(expected)-1 {\n\t\t\tif !boundedIter.Next() {\n\t\t\t\tt.Fatalf(\"Next() should return true at position %d\", i)\n\t\t\t}\n\t\t}\n\t}\n\n\t// After all elements, Next should return false\n\tif boundedIter.Next() {\n\t\tt.Error(\"Expected Next() to return false after all elements\")\n\t}\n\n\t// Test SeekToLast\n\tboundedIter.SeekToLast()\n\tif !boundedIter.Valid() {\n\t\tt.Fatal(\"Expected iterator to be valid after SeekToLast\")\n\t}\n\n\t// Should be at \"e\"\n\tif string(boundedIter.Key()) != \"e\" {\n\t\tt.Errorf(\"Expected key 'e', got '%s'\", string(boundedIter.Key()))\n\t}\n}\n\nfunc TestBoundedIterator_WithBounds(t *testing.T) {\n\t// Create a mock iterator with some data\n\tmockIter := newMockIterator(map[string]string{\n\t\t\"a\": \"1\",\n\t\t\"b\": \"2\",\n\t\t\"c\": \"3\",\n\t\t\"d\": \"4\",\n\t\t\"e\": \"5\",\n\t})\n\n\t// Create bounded iterator with bounds b to d (inclusive b, exclusive d)\n\tboundedIter := NewBoundedIterator(mockIter, []byte(\"b\"), []byte(\"d\"))\n\n\t// Test SeekToFirst\n\tboundedIter.SeekToFirst()\n\tif !boundedIter.Valid() {\n\t\tt.Fatal(\"Expected iterator to be valid after SeekToFirst\")\n\t}\n\n\t// Should be at \"b\" (start of range)\n\tif string(boundedIter.Key()) != \"b\" {\n\t\tt.Errorf(\"Expected key 'b', got '%s'\", string(boundedIter.Key()))\n\t}\n\n\t// Test iterating through the range\n\texpected := []string{\"b\", \"c\"}\n\tfor i, exp := range expected {\n\t\tif !boundedIter.Valid() {\n\t\t\tt.Fatalf(\"Iterator should be valid at position %d\", i)\n\t\t}\n\n\t\tif string(boundedIter.Key()) != exp {\n\t\t\tt.Errorf(\"Position %d: Expected key '%s', got '%s'\", i, exp, string(boundedIter.Key()))\n\t\t}\n\n\t\tif i < len(expected)-1 {\n\t\t\tif !boundedIter.Next() {\n\t\t\t\tt.Fatalf(\"Next() should return true at position %d\", i)\n\t\t\t}\n\t\t}\n\t}\n\n\t// After last element in range, Next should return false\n\tif boundedIter.Next() {\n\t\tt.Error(\"Expected Next() to return false after last element in range\")\n\t}\n\n\t// Test SeekToLast\n\tboundedIter.SeekToLast()\n\tif !boundedIter.Valid() {\n\t\tt.Fatal(\"Expected iterator to be valid after SeekToLast\")\n\t}\n\n\t// Should be at \"c\" (last element in range)\n\tif string(boundedIter.Key()) != \"c\" {\n\t\tt.Errorf(\"Expected key 'c', got '%s'\", string(boundedIter.Key()))\n\t}\n}\n\nfunc TestBoundedIterator_Seek(t *testing.T) {\n\t// Create a mock iterator with some data\n\tmockIter := newMockIterator(map[string]string{\n\t\t\"a\": \"1\",\n\t\t\"b\": \"2\",\n\t\t\"c\": \"3\",\n\t\t\"d\": \"4\",\n\t\t\"e\": \"5\",\n\t})\n\n\t// Create bounded iterator with bounds b to d (inclusive b, exclusive d)\n\tboundedIter := NewBoundedIterator(mockIter, []byte(\"b\"), []byte(\"d\"))\n\n\t// Test seeking within bounds\n\ttests := []struct {\n\t\ttarget      string\n\t\texpectValid bool\n\t\texpectKey   string\n\t}{\n\t\t{\"a\", true, \"b\"},  // Before range, should go to start bound\n\t\t{\"b\", true, \"b\"},  // At range start\n\t\t{\"bc\", true, \"c\"}, // Between b and c\n\t\t{\"c\", true, \"c\"},  // Within range\n\t\t{\"d\", false, \"\"},  // At range end (exclusive)\n\t\t{\"e\", false, \"\"},  // After range\n\t}\n\n\tfor i, test := range tests {\n\t\tfound := boundedIter.Seek([]byte(test.target))\n\t\tif found != test.expectValid {\n\t\t\tt.Errorf(\"Test %d: Seek(%s) returned %v, expected %v\",\n\t\t\t\ti, test.target, found, test.expectValid)\n\t\t}\n\n\t\tif test.expectValid {\n\t\t\tif string(boundedIter.Key()) != test.expectKey {\n\t\t\t\tt.Errorf(\"Test %d: Seek(%s) key is '%s', expected '%s'\",\n\t\t\t\t\ti, test.target, string(boundedIter.Key()), test.expectKey)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBoundedIterator_SetBounds(t *testing.T) {\n\t// Create a mock iterator with some data\n\tmockIter := newMockIterator(map[string]string{\n\t\t\"a\": \"1\",\n\t\t\"b\": \"2\",\n\t\t\"c\": \"3\",\n\t\t\"d\": \"4\",\n\t\t\"e\": \"5\",\n\t})\n\n\t// Create bounded iterator with no initial bounds\n\tboundedIter := NewBoundedIterator(mockIter, nil, nil)\n\n\t// Position at 'c'\n\tboundedIter.Seek([]byte(\"c\"))\n\n\t// Set bounds that include 'c'\n\tboundedIter.SetBounds([]byte(\"b\"), []byte(\"e\"))\n\n\t// Iterator should still be valid at 'c'\n\tif !boundedIter.Valid() {\n\t\tt.Fatal(\"Iterator should remain valid after setting bounds that include current position\")\n\t}\n\n\tif string(boundedIter.Key()) != \"c\" {\n\t\tt.Errorf(\"Expected key to remain 'c', got '%s'\", string(boundedIter.Key()))\n\t}\n\n\t// Set bounds that exclude 'c'\n\tboundedIter.SetBounds([]byte(\"d\"), []byte(\"f\"))\n\n\t// Iterator should no longer be valid\n\tif boundedIter.Valid() {\n\t\tt.Fatal(\"Iterator should be invalid after setting bounds that exclude current position\")\n\t}\n\n\t// SeekToFirst should position at 'd'\n\tboundedIter.SeekToFirst()\n\tif !boundedIter.Valid() {\n\t\tt.Fatal(\"Iterator should be valid after SeekToFirst\")\n\t}\n\n\tif string(boundedIter.Key()) != \"d\" {\n\t\tt.Errorf(\"Expected key 'd', got '%s'\", string(boundedIter.Key()))\n\t}\n}\n"
