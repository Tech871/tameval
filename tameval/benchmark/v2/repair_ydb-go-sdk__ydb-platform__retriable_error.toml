[meta]
task = "repair"
scenario = "repair_no_new_covered_logic"

[lang_info]
lang = "Go"
go_version = "1.22.5"

[repo_info]
repository = "ydb-platform/ydb-go-sdk"
sha = "6ecec32a4ff86f5a4f92e3d35aa1c1a4cf1b63d3"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/topic/retriable_error.go internal/topic/retriable_error_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/topic/retriable_error.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 96.0
original_coverage = 96.0
mutation_kill_rate = 65.0
original_mutation_kill_rate = 65.0
covered_lines = [ 32, 33, 34, 35, 36, 48, 49, 50, 51, 52, 54, 64, 65, 66, 67, 68, 71, 72, 73, 75, 76, 77, 79, 80, 81, 82, 83, 84, 86, 87, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 105, 106, 107, 108, 109,]
missed_lines = [ 99, 100,]

[input_info]
test_file_path = "internal/topic/retriable_error_test.go"
focal_file_path = "internal/topic/retriable_error.go"
test_file_url = "https://github.com/ydb-platform/ydb-go-sdk/blob/6ecec32a4ff86f5a4f92e3d35aa1c1a4cf1b63d3/internal/topic/retriable_error_test.go"
focal_file_url = "https://github.com/ydb-platform/ydb-go-sdk/blob/6ecec32a4ff86f5a4f92e3d35aa1c1a4cf1b63d3/internal/topic/retriable_error.go"
first_commit_date = "2022-08-01"
last_commit_date = "2025-06-26"
test_file_content = "package topic\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/ydb-platform/ydb-go-genproto/protos/Ydb\"\n\tgrpcCodes \"google.golang.org/grpc/codes\"\n\tgrpcStatus \"google.golang.org/grpc/status\"\n\n\t\"github.com/ydb-platform/ydb-go-sdk/v3/internal/backoff\"\n\t\"github.com/ydb-platform/ydb-go-sdk/v3/internal/value\"\n\t\"github.com/ydb-platform/ydb-go-sdk/v3/internal/xerrors\"\n)\n\nfunc TestCheckRetryMode(t *testing.T) {\n\tfastError := xerrors.Transport(grpcStatus.Error(grpcCodes.Unavailable, \"\"))\n\tslowError := xerrors.Operation(xerrors.WithStatusCode(Ydb.StatusIds_OVERLOADED))\n\tunretriable := xerrors.Operation(xerrors.WithStatusCode(Ydb.StatusIds_UNAUTHORIZED))\n\n\ttable := []struct {\n\t\tname         string\n\t\terr          error\n\t\tsettings     RetrySettings\n\t\tduration     time.Duration\n\t\tresBackoff   backoff.Backoff\n\t\tresRetriable bool\n\t}{\n\t\t{\n\t\t\tname:         \"OK\",\n\t\t\terr:          nil,\n\t\t\tsettings:     RetrySettings{},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   nil,\n\t\t\tresRetriable: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"RetryRetriableErrorFast\",\n\t\t\terr:          fastError,\n\t\t\tsettings:     RetrySettings{},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   backoff.Fast,\n\t\t\tresRetriable: true,\n\t\t},\n\t\t{\n\t\t\tname: \"RetryRetriableErrorFastWithTimeout\",\n\t\t\terr:  fastError,\n\t\t\tsettings: RetrySettings{\n\t\t\t\tStartTimeout: time.Second,\n\t\t\t},\n\t\t\tduration:     time.Second * 2,\n\t\t\tresBackoff:   nil,\n\t\t\tresRetriable: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"RetryRetriableErrorSlow\",\n\t\t\terr:          slowError,\n\t\t\tsettings:     RetrySettings{},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   backoff.Slow,\n\t\t\tresRetriable: true,\n\t\t},\n\t\t{\n\t\t\tname: \"RetryRetriableErrorSlowWithTimeout\",\n\t\t\terr:  slowError,\n\t\t\tsettings: RetrySettings{\n\t\t\t\tStartTimeout: time.Second,\n\t\t\t},\n\t\t\tduration:     time.Second * 2,\n\t\t\tresBackoff:   nil,\n\t\t\tresRetriable: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"UnretriableError\",\n\t\t\terr:          unretriable,\n\t\t\tsettings:     RetrySettings{},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   nil,\n\t\t\tresRetriable: false,\n\t\t},\n\t\t{\n\t\t\tname: \"UserOverrideFastErrorDefault\",\n\t\t\terr:  fastError,\n\t\t\tsettings: RetrySettings{\n\t\t\t\tCheckError: func(errInfo PublicCheckErrorRetryArgs) PublicCheckRetryResult {\n\t\t\t\t\treturn PublicRetryDecisionDefault\n\t\t\t\t},\n\t\t\t},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   backoff.Fast,\n\t\t\tresRetriable: true,\n\t\t},\n\t\t{\n\t\t\tname: \"UserOverrideFastErrorRetry\",\n\t\t\terr:  fastError,\n\t\t\tsettings: RetrySettings{\n\t\t\t\tCheckError: func(errInfo PublicCheckErrorRetryArgs) PublicCheckRetryResult {\n\t\t\t\t\treturn PublicRetryDecisionRetry\n\t\t\t\t},\n\t\t\t},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   backoff.Fast,\n\t\t\tresRetriable: true,\n\t\t},\n\t\t{\n\t\t\tname: \"UserOverrideFastErrorStop\",\n\t\t\terr:  fastError,\n\t\t\tsettings: RetrySettings{\n\t\t\t\tCheckError: func(errInfo PublicCheckErrorRetryArgs) PublicCheckRetryResult {\n\t\t\t\t\treturn PublicRetryDecisionStop\n\t\t\t\t},\n\t\t\t},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   nil,\n\t\t\tresRetriable: false,\n\t\t},\n\t\t{\n\t\t\tname: \"UserOverrideSlowErrorDefault\",\n\t\t\terr:  slowError,\n\t\t\tsettings: RetrySettings{\n\t\t\t\tCheckError: func(errInfo PublicCheckErrorRetryArgs) PublicCheckRetryResult {\n\t\t\t\t\treturn PublicRetryDecisionDefault\n\t\t\t\t},\n\t\t\t},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   backoff.Slow,\n\t\t\tresRetriable: true,\n\t\t},\n\t\t{\n\t\t\tname: \"UserOverrideSlowErrorRetry\",\n\t\t\terr:  slowError,\n\t\t\tsettings: RetrySettings{\n\t\t\t\tCheckError: func(errInfo PublicCheckErrorRetryArgs) PublicCheckRetryResult {\n\t\t\t\t\treturn PublicRetryDecisionRetry\n\t\t\t\t},\n\t\t\t},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   backoff.Slow,\n\t\t\tresRetriable: true,\n\t\t},\n\t\t{\n\t\t\tname: \"UserOverrideSlowErrorStop\",\n\t\t\terr:  slowError,\n\t\t\tsettings: RetrySettings{\n\t\t\t\tCheckError: func(errInfo PublicCheckErrorRetryArgs) PublicCheckRetryResult {\n\t\t\t\t\treturn PublicRetryDecisionStop\n\t\t\t\t},\n\t\t\t},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   nil,\n\t\t\tresRetriable: false,\n\t\t},\n\t\t{\n\t\t\tname: \"UserOverrideUnretriableErrorDefault\",\n\t\t\terr:  xerrors.Operation(xerrors.WithStatusCode(Ydb.StatusIds_UNAUTHORIZED)),\n\t\t\tsettings: RetrySettings{\n\t\t\t\tCheckError: func(errInfo PublicCheckErrorRetryArgs) PublicCheckRetryResult {\n\t\t\t\t\treturn PublicRetryDecisionDefault\n\t\t\t\t},\n\t\t\t},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   nil,\n\t\t\tresRetriable: false,\n\t\t},\n\t\t{\n\t\t\tname: \"UserOverrideUnretriableErrorRetry\",\n\t\t\terr:  xerrors.Operation(xerrors.WithStatusCode(Ydb.StatusIds_UNAUTHORIZED)),\n\t\t\tsettings: RetrySettings{\n\t\t\t\tCheckError: func(errInfo PublicCheckErrorRetryArgs) PublicCheckRetryResult {\n\t\t\t\t\treturn PublicRetryDecisionRetry\n\t\t\t\t},\n\t\t\t},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   backoff.Slow,\n\t\t\tresRetriable: true,\n\t\t},\n\t\t{\n\t\t\tname: \"UserOverrideUnretriableErrorStop\",\n\t\t\terr:  xerrors.Operation(xerrors.WithStatusCode(Ydb.StatusIds_UNAUTHORIZED)),\n\t\t\tsettings: RetrySettings{\n\t\t\t\tCheckError: func(errInfo PublicCheckErrorRetryArgs) PublicCheckRetryResult {\n\t\t\t\t\treturn PublicRetryDecisionStop\n\t\t\t\t},\n\t\t\t},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   nil,\n\t\t\tresRetriable: false,\n\t\t},\n\t\t{\n\t\t\tname: \"UserOverrideFastErrorRetryWithTimeout\",\n\t\t\terr:  xerrors.Operation(xerrors.WithStatusCode(Ydb.StatusIds_UNAUTHORIZED)),\n\t\t\tsettings: RetrySettings{\n\t\t\t\tStartTimeout: time.Second,\n\t\t\t\tCheckError: func(errInfo PublicCheckErrorRetryArgs) PublicCheckRetryResult {\n\t\t\t\t\treturn PublicRetryDecisionRetry\n\t\t\t\t},\n\t\t\t},\n\t\t\tduration:     time.Second * 2,\n\t\t\tresBackoff:   nil,\n\t\t\tresRetriable: false,\n\t\t},\n\t\t{\n\t\t\tname: \"NotCallForNil\",\n\t\t\terr:  nil,\n\t\t\tsettings: RetrySettings{\n\t\t\t\tStartTimeout: time.Second,\n\t\t\t\tCheckError: func(errInfo PublicCheckErrorRetryArgs) PublicCheckRetryResult {\n\t\t\t\t\tpanic(\"must not call for nil err\")\n\t\t\t\t},\n\t\t\t},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   nil,\n\t\t\tresRetriable: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"EOF\",\n\t\t\terr:          fmt.Errorf(\"test wrap: %w\", io.EOF),\n\t\t\tsettings:     RetrySettings{},\n\t\t\tduration:     0,\n\t\t\tresBackoff:   backoff.Slow,\n\t\t\tresRetriable: true,\n\t\t},\n\t}\n\n\tfor _, test := range table {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tresBackoff, stopReason := RetryDecision(test.err, test.settings, test.duration)\n\t\t\trequire.Equal(t, test.resBackoff, resBackoff)\n\t\t\trequire.Equal(t, test.resRetriable, stopReason == nil)\n\t\t})\n\t}\n}\n\nfunc TestCheckRetryModeAlternative(t *testing.T) {\n\tfastError := xerrors.Transport(grpcStatus.Error(grpcCodes.Unavailable, \"\"))\n\tslowError := xerrors.Operation(xerrors.WithStatusCode(Ydb.StatusIds_OVERLOADED))\n\tunretriable := xerrors.Operation(xerrors.WithStatusCode(Ydb.StatusIds_UNAUTHORIZED))\n\n\ttests := []struct {\n\t\tscenario     string\n\t\tinputErr     error\n\t\tretryConfig  RetrySettings\n\t\ttimeElapsed  time.Duration\n\t\texpectedBack backoff.Backoff\n\t\texpectRetry  bool\n\t}{\n\t\t{\n\t\t\tscenario:     \"NoError\",\n\t\t\tinputErr:     nil,\n\t\t\tretryConfig:  RetrySettings{},\n\t\t\ttimeElapsed:  0,\n\t\t\texpectedBack: nil,\n\t\t\texpectRetry:  false,\n\t\t},\n\t\t{\n\t\t\tscenario:     \"FastRetryable\",\n\t\t\tinputErr:     fastError,\n\t\t\tretryConfig:  RetrySettings{},\n\t\t\ttimeElapsed:  0,\n\t\t\texpectedBack: backoff.Fast,\n\t\t\texpectRetry:  true,\n\t\t},\n\t\t{\n\t\t\tscenario: \"FastRetryableWithTimeout\",\n\t\t\tinputErr: fastError,\n\t\t\tretryConfig: RetrySettings{\n\t\t\t\tStartTimeout: time.Second,\n\t\t\t},\n\t\t\ttimeElapsed:  time.Second * 2,\n\t\t\texpectedBack: nil,\n\t\t\texpectRetry:  false,\n\t\t},\n\t\t{\n\t\t\tscenario:     \"SlowRetryable\",\n\t\t\tinputErr:     slowError,\n\t\t\tretryConfig:  RetrySettings{},\n\t\t\ttimeElapsed:  0,\n\t\t\texpectedBack: backoff.Slow,\n\t\t\texpectRetry:  true,\n\t\t},\n\t\t{\n\t\t\tscenario: \"SlowRetryableWithTimeout\",\n\t\t\tinputErr: slowError,\n\t\t\tretryConfig: RetrySettings{\n\t\t\t\tStartTimeout: time.Second,\n\t\t\t},\n\t\t\ttimeElapsed:  time.Second * 2,\n\t\t\texpectedBack: nil,\n\t\t\texpectRetry:  false,\n\t\t},\n\t\t{\n\t\t\tscenario:     \"NotRetryable\",\n\t\t\tinputErr:     unretriable,\n\t\t\tretryConfig:  RetrySettings{},\n\t\t\ttimeElapsed:  0,\n\t\t\texpectedBack: nil,\n\t\t\texpectRetry:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.scenario, func(t *testing.T) {\n\t\t\tactualBackoff, actualStopReason := RetryDecision(tc.inputErr, tc.retryConfig, tc.timeElapsed)\n\t\t\trequire.Equal(t, tc.expectedBack, actualBackoff)\n\t\t\trequire.Equal(t, tc.expectRetry, actualStopReason == nil)\n\t\t})\n\t}\n}\n\nfunc TestRetryDecisionVariation(t *testing.T) {\n\tfastError := xerrors.Transport(grpcStatus.Error(grpcCodes.Unavailable, \"\"))\n\tslowError := xerrors.Operation(xerrors.WithStatusCode(Ydb.StatusIds_OVERLOADED))\n\tunretriable := xerrors.Operation(xerrors.WithStatusCode(Ydb.StatusIds_UNAUTHORIZED))\n\n\tcases := []struct {\n\t\ttestName      string\n\t\terrorToCheck  error\n\t\tretrySettings RetrySettings\n\t\ttimePassed    time.Duration\n\t\twantBackoff   backoff.Backoff\n\t\twantRetry     bool\n\t}{\n\t\t{\n\t\t\ttestName:      \"SuccessfulNoError\",\n\t\t\terrorToCheck:  nil,\n\t\t\tretrySettings: RetrySettings{},\n\t\t\ttimePassed:    0,\n\t\t\twantBackoff:   nil,\n\t\t\twantRetry:     false,\n\t\t},\n\t\t{\n\t\t\ttestName:      \"FastErrorShouldRetry\",\n\t\t\terrorToCheck:  fastError,\n\t\t\tretrySettings: RetrySettings{},\n\t\t\ttimePassed:    0,\n\t\t\twantBackoff:   backoff.Fast,\n\t\t\twantRetry:     true,\n\t\t},\n\t\t{\n\t\t\ttestName: \"FastErrorExceedsTimeout\",\n\t\t\terrorToCheck: fastError,\n\t\t\tretrySettings: RetrySettings{\n\t\t\t\tStartTimeout: time.Second,\n\t\t\t},\n\t\t\ttimePassed:    time.Second * 2,\n\t\t\twantBackoff:   nil,\n\t\t\twantRetry:     false,\n\t\t},\n\t\t{\n\t\t\ttestName:      \"SlowErrorShouldRetry\",\n\t\t\terrorToCheck:  slowError,\n\t\t\tretrySettings: RetrySettings{},\n\t\t\ttimePassed:    0,\n\t\t\twantBackoff:   backoff.Slow,\n\t\t\twantRetry:     true,\n\t\t},\n\t\t{\n\t\t\ttestName: \"SlowErrorExceedsTimeout\",\n\t\t\terrorToCheck: slowError,\n\t\t\tretrySettings: RetrySettings{\n\t\t\t\tStartTimeout: time.Second,\n\t\t\t},\n\t\t\ttimePassed:    time.Second * 2,\n\t\t\twantBackoff:   nil,\n\t\t\twantRetry:     false,\n\t\t},\n\t\t{\n\t\t\ttestName:      \"UnretryableError\",\n\t\t\terrorToCheck:  unretriable,\n\t\t\tretrySettings: RetrySettings{},\n\t\t\ttimePassed:    0,\n\t\t\twantBackoff:   nil,\n\t\t\twantRetry:     false,\n\t\t},\n\t}\n\n\tfor _, c := range cases {\n\t\tt.Run(c.testName, func(t *testing.T) {\n\t\t\tback, reason := RetryDecision(c.errorToCheck, c.retrySettings, c.timePassed)\n\t\t\trequire.Equal(t, c.wantBackoff, back)\n\t\t\trequire.Equal(t, c.wantRetry, reason == nil)\n\t\t})\n\t}\n}\n\nfunc TestCheckResetReconnectionCounters(t *testing.T) {\n\tnow := time.Now()\n\ttable := []struct {\n\t\tname              string\n\t\tlastTry           time.Time\n\t\tconnectionTimeout time.Duration\n\t\tshouldReset       bool\n\t}{\n\t\t{\n\t\t\tname:              \"RecentLastTryWithInfiniteConnectionTimeout\",\n\t\t\tlastTry:           now.Add(-30 * time.Second),\n\t\t\tconnectionTimeout: value.InfiniteDuration,\n\t\t\tshouldReset:       false,\n\t\t},\n\t\t{\n\t\t\tname:              \"OldLastTryWithInfiniteConnectionTimeout\",\n\t\t\tlastTry:           now.Add(-30 * time.Minute),\n\t\t\tconnectionTimeout: value.InfiniteDuration,\n\t\t\tshouldReset:       true,\n\t\t},\n\t\t{\n\t\t\tname:              \"LastTryLessThanConnectionTimeout\",\n\t\t\tlastTry:           now.Add(-30 * time.Second),\n\t\t\tconnectionTimeout: time.Minute,\n\t\t\tshouldReset:       false,\n\t\t},\n\t\t{\n\t\t\tname:              \"LastTryGreaterThanConnectionTimeout\",\n\t\t\tlastTry:           now.Add(-time.Hour),\n\t\t\tconnectionTimeout: time.Minute,\n\t\t\tshouldReset:       true,\n\t\t},\n\t}\n\n\tfor _, test := range table {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tshouldReset := CheckResetReconnectionCounters(test.lastTry, now, test.connectionTimeout)\n\t\t\trequire.Equal(t, test.shouldReset, shouldReset)\n\t\t})\n\t}\n}"
