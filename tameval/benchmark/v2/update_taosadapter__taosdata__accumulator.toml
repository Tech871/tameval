[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "taosdata/taosadapter"
sha = "2e4a8bb5b4d61bb7a6f5b5a722fc038f8c8d1270"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out plugin/statsd/accumulator.go plugin/statsd/accumulator_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting plugin/statsd/accumulator.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 87.0
mutation_kill_rate = nan
original_mutation_kill_rate = 100.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "plugin/statsd/accumulator_test.go"
focal_file_path = "plugin/statsd/accumulator.go"
test_file_url = "https://github.com/taosdata/taosadapter/blob/2e4a8bb5b4d61bb7a6f5b5a722fc038f8c8d1270/plugin/statsd/accumulator_test.go"
focal_file_url = "https://github.com/taosdata/taosadapter/blob/2e4a8bb5b4d61bb7a6f5b5a722fc038f8c8d1270/plugin/statsd/accumulator.go"
first_commit_date = "2025-04-11"
last_commit_date = "2025-04-11"
test_file_content = "package statsd\n\n// copied from github.com/influxdata/telegraf@v1.23.4/accumulator_test.go\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/influxdata/telegraf\"\n\t\"github.com/influxdata/telegraf/models\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestAddFields(t *testing.T) {\n\tmetrics := make(chan telegraf.Metric, 10)\n\tdefer close(metrics)\n\ta := NewAccumulator(&TestMetricMaker{}, metrics)\n\n\ttags := map[string]string{\"foo\": \"bar\"}\n\tfields := map[string]interface{}{\n\t\t\"usage\": float64(99),\n\t}\n\tnow := time.Now()\n\ta.AddCounter(\"acctest\", fields, tags, now)\n\n\ttestm := <-metrics\n\n\trequire.Equal(t, \"acctest\", testm.Name())\n\tactual, ok := testm.GetField(\"usage\")\n\n\trequire.True(t, ok)\n\trequire.Equal(t, float64(99), actual)\n\n\tactual, ok = testm.GetTag(\"foo\")\n\trequire.True(t, ok)\n\trequire.Equal(t, \"bar\", actual)\n\n\ttm := testm.Time()\n\t// okay if monotonic clock differs\n\trequire.True(t, now.Equal(tm))\n\n\ttp := testm.Type()\n\trequire.Equal(t, telegraf.Counter, tp)\n}\n\nfunc TestAccAddError(t *testing.T) {\n\terrBuf := bytes.NewBuffer(nil)\n\tlog.SetOutput(errBuf)\n\tdefer log.SetOutput(os.Stderr)\n\n\tmetrics := make(chan telegraf.Metric, 10)\n\tdefer close(metrics)\n\ta := NewAccumulator(&TestMetricMaker{}, metrics)\n\t// test that we can add a nil error\n\ta.AddError(nil)\n\n\ta.AddError(fmt.Errorf(\"foo\"))\n\ta.AddError(fmt.Errorf(\"bar\"))\n\ta.AddError(fmt.Errorf(\"baz\"))\n\n\terrs := bytes.Split(errBuf.Bytes(), []byte{'\\n'})\n\trequire.Len(t, errs, 4) // 4 because of trailing newline\n\tassert.Contains(t, string(errs[0]), \"TestPlugin\")\n\tassert.Contains(t, string(errs[0]), \"foo\")\n\tassert.Contains(t, string(errs[1]), \"TestPlugin\")\n\tassert.Contains(t, string(errs[1]), \"bar\")\n\tassert.Contains(t, string(errs[2]), \"TestPlugin\")\n\tassert.Contains(t, string(errs[2]), \"baz\")\n}\n\nfunc TestSetPrecision(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tunset     bool\n\t\tprecision time.Duration\n\t\ttimestamp time.Time\n\t\texpected  time.Time\n\t}{\n\t\t{\n\t\t\tname:      \"default precision is nanosecond\",\n\t\t\tunset:     true,\n\t\t\ttimestamp: time.Date(2006, time.February, 10, 12, 0, 0, 82912748, time.UTC),\n\t\t\texpected:  time.Date(2006, time.February, 10, 12, 0, 0, 82912748, time.UTC),\n\t\t},\n\t\t{\n\t\t\tname:      \"second interval\",\n\t\t\tprecision: time.Second,\n\t\t\ttimestamp: time.Date(2006, time.February, 10, 12, 0, 0, 82912748, time.UTC),\n\t\t\texpected:  time.Date(2006, time.February, 10, 12, 0, 0, 0, time.UTC),\n\t\t},\n\t\t{\n\t\t\tname:      \"microsecond interval\",\n\t\t\tprecision: time.Microsecond,\n\t\t\ttimestamp: time.Date(2006, time.February, 10, 12, 0, 0, 82912748, time.UTC),\n\t\t\texpected:  time.Date(2006, time.February, 10, 12, 0, 0, 82913000, time.UTC),\n\t\t},\n\t\t{\n\t\t\tname:      \"2 second precision\",\n\t\t\tprecision: 2 * time.Second,\n\t\t\ttimestamp: time.Date(2006, time.February, 10, 12, 0, 2, 4, time.UTC),\n\t\t\texpected:  time.Date(2006, time.February, 10, 12, 0, 2, 0, time.UTC),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tmetrics := make(chan telegraf.Metric, 10)\n\n\t\t\ta := NewAccumulator(&TestMetricMaker{}, metrics)\n\t\t\tif !tt.unset {\n\t\t\t\ta.SetPrecision(tt.precision)\n\t\t\t}\n\n\t\t\ta.AddFields(\"acctest\",\n\t\t\t\tmap[string]interface{}{\"value\": float64(101)},\n\t\t\t\tmap[string]string{},\n\t\t\t\ttt.timestamp,\n\t\t\t)\n\n\t\t\ttestm := <-metrics\n\t\t\trequire.Equal(t, tt.expected, testm.Time())\n\n\t\t\tclose(metrics)\n\t\t})\n\t}\n}\n\nfunc TestAddTrackingMetricGroupEmpty(t *testing.T) {\n\tch := make(chan telegraf.Metric, 10)\n\tmetrics := []telegraf.Metric{}\n\tacc := NewAccumulator(&TestMetricMaker{}, ch).WithTracking(1)\n\n\tid := acc.AddTrackingMetricGroup(metrics)\n\n\tselect {\n\tcase tracking := <-acc.Delivered():\n\t\trequire.Equal(t, tracking.ID(), id)\n\tdefault:\n\t\tt.Fatal(\"empty group should be delivered immediately\")\n\t}\n}\n\ntype TestMetricMaker struct {\n}\n\nfunc (tm *TestMetricMaker) Name() string {\n\treturn \"TestPlugin\"\n}\n\nfunc (tm *TestMetricMaker) LogName() string {\n\treturn tm.Name()\n}\n\nfunc (tm *TestMetricMaker) MakeMetric(metric telegraf.Metric) telegraf.Metric {\n\treturn metric\n}\n\nfunc (tm *TestMetricMaker) Log() telegraf.Logger {\n\treturn models.NewLogger(\"TestPlugin\", \"test\", \"\")\n}\n\nfunc TestAddGauge(t *testing.T) {\n\tmetrics := make(chan telegraf.Metric, 10)\n\tdefer close(metrics)\n\ta := NewAccumulator(&TestMetricMaker{}, metrics)\n\n\ttags := map[string]string{\"foo\": \"bar\"}\n\tfields := map[string]interface{}{\n\t\t\"usage\": float64(99),\n\t}\n\tnow := time.Now()\n\ta.AddGauge(\"acctest\", fields, tags, now)\n\n\ttestm := <-metrics\n\n\trequire.Equal(t, \"acctest\", testm.Name())\n\tactual, ok := testm.GetField(\"usage\")\n\n\trequire.True(t, ok)\n\trequire.Equal(t, float64(99), actual)\n\n\tactual, ok = testm.GetTag(\"foo\")\n\trequire.True(t, ok)\n\trequire.Equal(t, \"bar\", actual)\n\n\ttm := testm.Time()\n\t// okay if monotonic clock differs\n\trequire.True(t, now.Equal(tm))\n\n\ttp := testm.Type()\n\trequire.Equal(t, telegraf.Gauge, tp)\n}\n\nfunc TestAddSummary(t *testing.T) {\n\tmetrics := make(chan telegraf.Metric, 10)\n\tdefer close(metrics)\n\ta := NewAccumulator(&TestMetricMaker{}, metrics)\n\n\ttags := map[string]string{\"foo\": \"bar\"}\n\tfields := map[string]interface{}{\n\t\t\"usage\": float64(99),\n\t}\n\tnow := time.Now()\n\ta.AddSummary(\"acctest\", fields, tags, now)\n\n\ttestm := <-metrics\n\n\trequire.Equal(t, \"acctest\", testm.Name())\n\tactual, ok := testm.GetField(\"usage\")\n\n\trequire.True(t, ok)\n\trequire.Equal(t, float64(99), actual)\n\n\tactual, ok = testm.GetTag(\"foo\")\n\trequire.True(t, ok)\n\trequire.Equal(t, \"bar\", actual)\n\n\ttm := testm.Time()\n\t// okay if monotonic clock differs\n\trequire.True(t, now.Equal(tm))\n\n\ttp := testm.Type()\n\trequire.Equal(t, telegraf.Summary, tp)\n}\n\nfunc TestAddHistogram(t *testing.T) {\n\tmetrics := make(chan telegraf.Metric, 10)\n\tdefer close(metrics)\n\ta := NewAccumulator(&TestMetricMaker{}, metrics)\n\n\ttags := map[string]string{\"foo\": \"bar\"}\n\tfields := map[string]interface{}{\n\t\t\"usage\": float64(99),\n\t}\n\tnow := time.Now()\n\ta.AddHistogram(\"acctest\", fields, tags, now)\n\n\ttestm := <-metrics\n\n\trequire.Equal(t, \"acctest\", testm.Name())\n\tactual, ok := testm.GetField(\"usage\")\n\n\trequire.True(t, ok)\n\trequire.Equal(t, float64(99), actual)\n\n\tactual, ok = testm.GetTag(\"foo\")\n\trequire.True(t, ok)\n\trequire.Equal(t, \"bar\", actual)\n\n\ttm := testm.Time()\n\t// okay if monotonic clock differs\n\trequire.True(t, now.Equal(tm))\n\n\ttp := testm.Type()\n\trequire.Equal(t, telegraf.Histogram, tp)\n}\n\nfunc TestAddTrackingMetric(t *testing.T) {\n\tch := make(chan telegraf.Metric, 10)\n\tacc := NewAccumulator(&TestMetricMaker{}, ch).WithTracking(1)\n\tmetrics := make(chan telegraf.Metric, 10)\n\tdefer close(metrics)\n\ta := NewAccumulator(&TestMetricMaker{}, metrics)\n\n\ttags := map[string]string{\"foo\": \"bar\"}\n\tfields := map[string]interface{}{\n\t\t\"usage\": float64(99),\n\t}\n\tnow := time.Now()\n\ta.AddHistogram(\"acctest\", fields, tags, now)\n\n\ttestm := <-metrics\n\trequire.Equal(t, \"acctest\", testm.Name())\n\tactual, ok := testm.GetField(\"usage\")\n\trequire.True(t, ok)\n\trequire.Equal(t, float64(99), actual)\n\tid := acc.AddTrackingMetricGroup([]telegraf.Metric{testm})\n\tm := <-ch\n\tm.Accept()\n\tselect {\n\tcase tracking := <-acc.Delivered():\n\t\trequire.Equal(t, tracking.ID(), id)\n\tcase <-time.Tick(time.Second * 10):\n\t\tt.Fatal(\"timeout\")\n\t}\n\n\tid2 := acc.AddTrackingMetric(testm)\n\tm = <-ch\n\tm.Accept()\n\tselect {\n\tcase tracking := <-acc.Delivered():\n\t\trequire.Equal(t, tracking.ID(), id2)\n\tcase <-time.Tick(time.Second * 10):\n\t\tt.Fatal(\"timeout\")\n\t}\n}"
