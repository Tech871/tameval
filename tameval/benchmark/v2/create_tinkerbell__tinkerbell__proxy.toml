[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.24.1"

[repo_info]
repository = "tinkerbell/tinkerbell"
sha = "702865f012a2ed3cafbe215976ebdfc7b5c3d072"

[run_info]
docker_image = "golang:1.24.1"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out smee/internal/dhcp/handler/proxy/proxy.go smee/internal/dhcp/handler/proxy/proxy_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting smee/internal/dhcp/handler/proxy/proxy.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 75.0
original_coverage = 75.0
mutation_kill_rate = 34.0
original_mutation_kill_rate = 34.0
covered_lines = [ 103, 104, 105, 106, 107, 108, 109, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 160, 161, 162, 163, 170, 171, 172, 173, 174, 175, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 213, 214, 215, 218, 219, 220, 221, 222, 223, 224, 225, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 253, 254, 255, 259, 260, 261, 262, 263, 265, 266, 267, 268, 269, 270, 271, 272, 274, 284, 285, 286, 296, 297, 298, 299, 301,]
missed_lines = [ 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 145, 146, 147, 148, 149, 150, 152, 153, 154, 155, 156, 157, 164, 165, 166, 167, 168, 169, 176, 177, 178, 179, 180, 181, 247, 248, 249, 250, 251, 252,]

[input_info]
test_file_path = "smee/internal/dhcp/handler/proxy/proxy_test.go"
focal_file_path = "smee/internal/dhcp/handler/proxy/proxy.go"
test_file_url = "https://github.com/tinkerbell/tinkerbell/blob/702865f012a2ed3cafbe215976ebdfc7b5c3d072/smee/internal/dhcp/handler/proxy/proxy_test.go"
focal_file_url = "https://github.com/tinkerbell/tinkerbell/blob/702865f012a2ed3cafbe215976ebdfc7b5c3d072/smee/internal/dhcp/handler/proxy/proxy.go"
first_commit_date = "2024-01-15"
last_commit_date = "2025-08-07"
test_file_content = "package proxy\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/netip\"\n\t\"net/url\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-logr/logr\"\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\t\"github.com/insomniacslk/dhcp/dhcpv4\"\n\t\"github.com/tinkerbell/tinkerbell/pkg/data\"\n\t\"github.com/tinkerbell/tinkerbell/smee/internal/dhcp\"\n\t\"golang.org/x/net/ipv4\"\n\t\"golang.org/x/net/nettest\"\n)\n\nvar errBackend = errors.New(\"backend error\")\n\n// mockBackend implements BackendReader for testing.\ntype mockBackend struct {\n\tallowNetboot bool\n\tiPXEBinary   string\n\terr          error\n}\n\nfunc (m *mockBackend) GetByMac(_ context.Context, _ net.HardwareAddr) (*data.DHCP, *data.Netboot, error) {\n\tif m.err != nil {\n\t\treturn nil, nil, m.err\n\t}\n\treturn &data.DHCP{}, &data.Netboot{AllowNetboot: m.allowNetboot, IPXEBinary: m.iPXEBinary}, nil\n}\n\nfunc (m *mockBackend) GetByIP(_ context.Context, _ net.IP) (*data.DHCP, *data.Netboot, error) {\n\treturn nil, nil, errors.New(\"not implemented\")\n}\n\nfunc TestHandle(t *testing.T) {\n\tlo, _ := net.InterfaceByName(\"lo\")\n\tip := netip.MustParseAddr(\"127.0.0.1\")\n\tbinServerTFTP := netip.AddrPortFrom(ip, 69)\n\tbinServerHTTP, _ := url.Parse(\"http://localhost:8080\")\n\tipxeScript := func(*dhcpv4.DHCPv4) *url.URL { u, _ := url.Parse(\"http://localhost/script.ipxe\"); return u }\n\n\ttests := map[string]struct {\n\t\thandler Handler\n\t\tpkt     *dhcpv4.DHCPv4\n\t\tpeer    net.Addr\n\t\tmd      *dhcp.Metadata\n\t\twant    *dhcpv4.DHCPv4\n\t\twantErr bool\n\t}{\n\t\t\"nil packet\": {\n\t\t\thandler: Handler{Log: logr.Discard(), Backend: &mockBackend{}},\n\t\t\tpkt:     nil,\n\t\t\tpeer:    &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 68},\n\t\t\tmd:      &dhcp.Metadata{IfName: lo.Name, IfIndex: lo.Index},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t\"not netboot client\": {\n\t\t\thandler: Handler{\n\t\t\t\tLog:     logr.Discard(),\n\t\t\t\tBackend: &mockBackend{},\n\t\t\t\tNetboot: Netboot{Enabled: true},\n\t\t\t},\n\t\t\tpkt: &dhcpv4.DHCPv4{\n\t\t\t\tOpCode:       dhcpv4.OpcodeBootRequest,\n\t\t\t\tClientHWAddr: []byte{1, 2, 3, 4, 5, 6},\n\t\t\t\tOptions:      dhcpv4.OptionsFromList(dhcpv4.OptMessageType(dhcpv4.MessageTypeDiscover)),\n\t\t\t},\n\t\t\tpeer:    &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 68},\n\t\t\tmd:      &dhcp.Metadata{IfName: lo.Name, IfIndex: lo.Index},\n\t\t\twant:    nil,\n\t\t\twantErr: false,\n\t\t},\n\t\t\"backend error\": {\n\t\t\thandler: Handler{\n\t\t\t\tLog:     logr.Discard(),\n\t\t\t\tBackend: &mockBackend{err: errBackend},\n\t\t\t\tNetboot: Netboot{Enabled: true, IPXEBinServerTFTP: binServerTFTP, IPXEBinServerHTTP: binServerHTTP, IPXEScriptURL: ipxeScript},\n\t\t\t\tIPAddr:  ip,\n\t\t\t},\n\t\t\tpkt: &dhcpv4.DHCPv4{\n\t\t\t\tOpCode:       dhcpv4.OpcodeBootRequest,\n\t\t\t\tClientHWAddr: []byte{1, 2, 3, 4, 5, 6},\n\t\t\t\tOptions: dhcpv4.OptionsFromList(\n\t\t\t\t\tdhcpv4.OptMessageType(dhcpv4.MessageTypeDiscover),\n\t\t\t\t\tdhcpv4.OptClassIdentifier(\"PXEClient:Arch:00000:UNDI:002001\"),\n\t\t\t\t\tdhcpv4.OptClientArch(9), // EFI_X86_64\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientNetworkInterfaceIdentifier, []byte{1, 2, 3, 4}),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientMachineIdentifier, []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}),\n\t\t\t\t),\n\t\t\t},\n\t\t\tpeer:    &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 68},\n\t\t\tmd:      &dhcp.Metadata{IfName: lo.Name, IfIndex: lo.Index},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t\"netboot not allowed\": {\n\t\t\thandler: Handler{\n\t\t\t\tLog:     logr.Discard(),\n\t\t\t\tBackend: &mockBackend{allowNetboot: false},\n\t\t\t\tNetboot: Netboot{Enabled: true, IPXEBinServerTFTP: binServerTFTP, IPXEBinServerHTTP: binServerHTTP, IPXEScriptURL: ipxeScript},\n\t\t\t\tIPAddr:  ip,\n\t\t\t},\n\t\t\tpkt: &dhcpv4.DHCPv4{\n\t\t\t\tOpCode:       dhcpv4.OpcodeBootRequest,\n\t\t\t\tClientHWAddr: []byte{1, 2, 3, 4, 5, 6},\n\t\t\t\tOptions: dhcpv4.OptionsFromList(\n\t\t\t\t\tdhcpv4.OptMessageType(dhcpv4.MessageTypeDiscover),\n\t\t\t\t\tdhcpv4.OptClassIdentifier(\"PXEClient:Arch:00000:UNDI:002001\"),\n\t\t\t\t\tdhcpv4.OptClientArch(9), // EFI_X86_64\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientNetworkInterfaceIdentifier, []byte{1, 2, 3, 4}),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientMachineIdentifier, []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}),\n\t\t\t\t),\n\t\t\t},\n\t\t\tpeer: &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 68},\n\t\t\tmd:   &dhcp.Metadata{IfName: lo.Name, IfIndex: lo.Index},\n\t\t\twant: &dhcpv4.DHCPv4{\n\t\t\t\tOpCode:         dhcpv4.OpcodeBootReply,\n\t\t\t\tClientHWAddr:   []byte{1, 2, 3, 4, 5, 6},\n\t\t\t\tClientIPAddr:   []byte{0, 0, 0, 0},\n\t\t\t\tYourIPAddr:     []byte{0, 0, 0, 0},\n\t\t\t\tServerIPAddr:   []byte{127, 0, 0, 1},\n\t\t\t\tGatewayIPAddr:  []byte{0, 0, 0, 0},\n\t\t\t\tServerHostName: \"127.0.0.1\",\n\t\t\t\tBootFileName:   fmt.Sprintf(\"/%s/netboot-not-allowed\", net.HardwareAddr([]byte{1, 2, 3, 4, 5, 6})),\n\t\t\t\tOptions: dhcpv4.OptionsFromList(\n\t\t\t\t\tdhcpv4.OptMessageType(dhcpv4.MessageTypeOffer),\n\t\t\t\t\tdhcpv4.OptServerIdentifier(net.IP{127, 0, 0, 1}),\n\t\t\t\t\tdhcpv4.OptClassIdentifier(\"PXEClient\"),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientMachineIdentifier, []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionVendorSpecificInformation, dhcpv4.Options{6: []byte{8}}.ToBytes()),\n\t\t\t\t),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t\"valid netboot client discover\": {\n\t\t\thandler: Handler{\n\t\t\t\tLog:     logr.Discard(),\n\t\t\t\tBackend: &mockBackend{allowNetboot: true},\n\t\t\t\tNetboot: Netboot{Enabled: true, IPXEBinServerTFTP: binServerTFTP, IPXEBinServerHTTP: binServerHTTP, IPXEScriptURL: ipxeScript},\n\t\t\t\tIPAddr:  ip,\n\t\t\t},\n\t\t\tpkt: &dhcpv4.DHCPv4{\n\t\t\t\tOpCode:       dhcpv4.OpcodeBootRequest,\n\t\t\t\tClientHWAddr: []byte{1, 2, 3, 4, 5, 6},\n\t\t\t\tOptions: dhcpv4.OptionsFromList(\n\t\t\t\t\tdhcpv4.OptMessageType(dhcpv4.MessageTypeDiscover),\n\t\t\t\t\tdhcpv4.OptClassIdentifier(\"PXEClient:Arch:00000:UNDI:002001\"),\n\t\t\t\t\tdhcpv4.OptClientArch(9), // EFI_X86_64\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientNetworkInterfaceIdentifier, []byte{1, 2, 3, 4}),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientMachineIdentifier, []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}),\n\t\t\t\t\tdhcpv4.OptUserClass(\"Tinkerbell\"),\n\t\t\t\t),\n\t\t\t},\n\t\t\tpeer: &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 68},\n\t\t\tmd:   &dhcp.Metadata{IfName: lo.Name, IfIndex: lo.Index},\n\t\t\twant: &dhcpv4.DHCPv4{\n\t\t\t\tOpCode:         dhcpv4.OpcodeBootReply,\n\t\t\t\tClientHWAddr:   []byte{1, 2, 3, 4, 5, 6},\n\t\t\t\tClientIPAddr:   []byte{0, 0, 0, 0},\n\t\t\t\tYourIPAddr:     []byte{0, 0, 0, 0},\n\t\t\t\tServerIPAddr:   []byte{127, 0, 0, 1},\n\t\t\t\tGatewayIPAddr:  []byte{0, 0, 0, 0},\n\t\t\t\tServerHostName: \"127.0.0.1\",\n\t\t\t\tBootFileName:   \"http://localhost/script.ipxe\",\n\t\t\t\tOptions: dhcpv4.OptionsFromList(\n\t\t\t\t\tdhcpv4.OptMessageType(dhcpv4.MessageTypeOffer),\n\t\t\t\t\tdhcpv4.OptServerIdentifier(net.IP{127, 0, 0, 1}),\n\t\t\t\t\tdhcpv4.OptClassIdentifier(\"PXEClient\"),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientMachineIdentifier, []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionVendorSpecificInformation, dhcpv4.Options{6: []byte{8}}.ToBytes()),\n\t\t\t\t),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t\"valid netboot client request\": {\n\t\t\thandler: Handler{\n\t\t\t\tLog:     logr.Discard(),\n\t\t\t\tBackend: &mockBackend{allowNetboot: true},\n\t\t\t\tNetboot: Netboot{Enabled: true, IPXEBinServerTFTP: binServerTFTP, IPXEBinServerHTTP: binServerHTTP, IPXEScriptURL: ipxeScript},\n\t\t\t\tIPAddr:  ip,\n\t\t\t},\n\t\t\tpkt: &dhcpv4.DHCPv4{\n\t\t\t\tOpCode:       dhcpv4.OpcodeBootRequest,\n\t\t\t\tClientHWAddr: []byte{1, 2, 3, 4, 5, 6},\n\t\t\t\tOptions: dhcpv4.OptionsFromList(\n\t\t\t\t\tdhcpv4.OptMessageType(dhcpv4.MessageTypeRequest),\n\t\t\t\t\tdhcpv4.OptClassIdentifier(\"PXEClient:Arch:00000:UNDI:002001\"),\n\t\t\t\t\tdhcpv4.OptClientArch(9), // EFI_X86_64\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientNetworkInterfaceIdentifier, []byte{1, 2, 3, 4}),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientMachineIdentifier, []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}),\n\t\t\t\t),\n\t\t\t},\n\t\t\tpeer: &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 68},\n\t\t\tmd:   &dhcp.Metadata{IfName: lo.Name, IfIndex: lo.Index},\n\t\t\twant: &dhcpv4.DHCPv4{\n\t\t\t\tOpCode:         dhcpv4.OpcodeBootReply,\n\t\t\t\tClientHWAddr:   []byte{1, 2, 3, 4, 5, 6},\n\t\t\t\tClientIPAddr:   []byte{0, 0, 0, 0},\n\t\t\t\tYourIPAddr:     []byte{0, 0, 0, 0},\n\t\t\t\tServerIPAddr:   []byte{127, 0, 0, 1},\n\t\t\t\tGatewayIPAddr:  []byte{0, 0, 0, 0},\n\t\t\t\tServerHostName: \"127.0.0.1\",\n\t\t\t\tBootFileName:   \"ipxe.efi\",\n\t\t\t\tOptions: dhcpv4.OptionsFromList(\n\t\t\t\t\tdhcpv4.OptMessageType(dhcpv4.MessageTypeAck),\n\t\t\t\t\tdhcpv4.OptServerIdentifier(net.IP{127, 0, 0, 1}),\n\t\t\t\t\tdhcpv4.OptClassIdentifier(\"PXEClient\"),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientMachineIdentifier, []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionVendorSpecificInformation, dhcpv4.Options{6: []byte{8}}.ToBytes()),\n\t\t\t\t),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t\"valid netboot client request custom ipxe binary\": {\n\t\t\thandler: Handler{\n\t\t\t\tLog:     logr.Discard(),\n\t\t\t\tBackend: &mockBackend{allowNetboot: true, iPXEBinary: \"snp-x86_64.efi\"},\n\t\t\t\tNetboot: Netboot{Enabled: true, IPXEBinServerTFTP: binServerTFTP, IPXEBinServerHTTP: binServerHTTP, IPXEScriptURL: ipxeScript},\n\t\t\t\tIPAddr:  ip,\n\t\t\t},\n\t\t\tpkt: &dhcpv4.DHCPv4{\n\t\t\t\tOpCode:       dhcpv4.OpcodeBootRequest,\n\t\t\t\tClientHWAddr: []byte{1, 2, 3, 4, 5, 6},\n\t\t\t\tOptions: dhcpv4.OptionsFromList(\n\t\t\t\t\tdhcpv4.OptMessageType(dhcpv4.MessageTypeRequest),\n\t\t\t\t\tdhcpv4.OptClassIdentifier(\"PXEClient:Arch:00000:UNDI:002001\"),\n\t\t\t\t\tdhcpv4.OptClientArch(9), // EFI_X86_64\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientNetworkInterfaceIdentifier, []byte{1, 2, 3, 4}),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientMachineIdentifier, []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}),\n\t\t\t\t),\n\t\t\t},\n\t\t\tpeer: &net.UDPAddr{IP: net.IPv4(127, 0, 0, 1), Port: 68},\n\t\t\tmd:   &dhcp.Metadata{IfName: lo.Name, IfIndex: lo.Index},\n\t\t\twant: &dhcpv4.DHCPv4{\n\t\t\t\tOpCode:         dhcpv4.OpcodeBootReply,\n\t\t\t\tClientHWAddr:   []byte{1, 2, 3, 4, 5, 6},\n\t\t\t\tClientIPAddr:   []byte{0, 0, 0, 0},\n\t\t\t\tYourIPAddr:     []byte{0, 0, 0, 0},\n\t\t\t\tServerIPAddr:   []byte{127, 0, 0, 1},\n\t\t\t\tGatewayIPAddr:  []byte{0, 0, 0, 0},\n\t\t\t\tServerHostName: \"127.0.0.1\",\n\t\t\t\tBootFileName:   \"snp-x86_64.efi\",\n\t\t\t\tOptions: dhcpv4.OptionsFromList(\n\t\t\t\t\tdhcpv4.OptMessageType(dhcpv4.MessageTypeAck),\n\t\t\t\t\tdhcpv4.OptServerIdentifier(net.IP{127, 0, 0, 1}),\n\t\t\t\t\tdhcpv4.OptClassIdentifier(\"PXEClient\"),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionClientMachineIdentifier, []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}),\n\t\t\t\t\tdhcpv4.OptGeneric(dhcpv4.OptionVendorSpecificInformation, dhcpv4.Options{6: []byte{8}}.ToBytes()),\n\t\t\t\t),\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor name, tt := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\t// Create the test server\n\t\t\tconn, err := nettest.NewLocalPacketListener(\"udp\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"failed to create test server\", err)\n\t\t\t}\n\t\t\tdefer conn.Close()\n\n\t\t\t// Create a client to listen for responses\n\t\t\tpc, err := net.ListenPacket(\"udp4\", \":0\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"failed to create test client\", err)\n\t\t\t}\n\t\t\tdefer pc.Close()\n\n\t\t\t// Set up the peer based on the test client\n\t\t\tpeer := tt.peer\n\t\t\tif p, ok := peer.(*net.UDPAddr); ok && p != nil {\n\t\t\t\t// Update the port to match our test client\n\t\t\t\tpeer = &net.UDPAddr{IP: p.IP, Port: pc.LocalAddr().(*net.UDPAddr).Port}\n\t\t\t}\n\n\t\t\t// Set up the connection\n\t\t\tcon := ipv4.NewPacketConn(conn)\n\t\t\tif err := con.SetControlMessage(ipv4.FlagInterface, true); err != nil {\n\t\t\t\tt.Fatal(\"failed to set control message\", err)\n\t\t\t}\n\n\t\t\t// Send the packet to the handler\n\t\t\tpkt := dhcp.Packet{Peer: peer, Pkt: tt.pkt, Md: tt.md}\n\t\t\ttt.handler.Handle(context.Background(), con, pkt)\n\n\t\t\t// Get the response (or timeout if none is expected)\n\t\t\tmsg, err := clientResponse(pc)\n\n\t\t\t// Validate the error\n\t\t\tif tt.wantErr && err == nil {\n\t\t\t\tt.Fatal(\"expected error, got nil\")\n\t\t\t}\n\t\t\tif !tt.wantErr && err != nil && tt.want != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\t// If we expect a response, compare it with what we got\n\t\t\tif tt.want != nil {\n\t\t\t\tif msg == nil {\n\t\t\t\t\tt.Fatal(\"expected a response, got nil\")\n\t\t\t\t}\n\n\t\t\t\t// Compare the DHCP packets\n\t\t\t\tif diff := cmp.Diff(msg, tt.want, cmpopts.IgnoreUnexported(dhcpv4.DHCPv4{})); diff != \"\" {\n\t\t\t\t\tt.Fatalf(\"DHCP response doesn't match expected:\\n%s\", diff)\n\t\t\t\t}\n\t\t\t} else if msg != nil {\n\t\t\t\tt.Fatal(\"expected no response, but got one\")\n\t\t\t}\n\t\t})\n\t}\n}\n\n// clientResponse attempts to read a DHCP response from the given connection.\nfunc clientResponse(pc net.PacketConn) (*dhcpv4.DHCPv4, error) {\n\tbuf := make([]byte, 1024)\n\tif err := pc.SetReadDeadline(time.Now().Add(time.Millisecond * 100)); err != nil {\n\t\treturn nil, err\n\t}\n\tn, _, err := pc.ReadFrom(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmsg, err := dhcpv4.FromBytes(buf[:n])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn msg, nil\n}\n\nfunc TestSetMessageType(t *testing.T) {\n\ttests := map[string]struct {\n\t\tmsgType dhcpv4.MessageType\n\t\twant    dhcpv4.MessageType\n\t\twantErr bool\n\t}{\n\t\t\"discover\": {msgType: dhcpv4.MessageTypeDiscover, want: dhcpv4.MessageTypeOffer},\n\t\t\"request\":  {msgType: dhcpv4.MessageTypeRequest, want: dhcpv4.MessageTypeAck},\n\t\t\"other\":    {msgType: dhcpv4.MessageTypeRelease, wantErr: true},\n\t}\n\tfor name, tt := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\treply := &dhcpv4.DHCPv4{}\n\t\t\terr := setMessageType(reply, tt.msgType)\n\t\t\tif tt.wantErr && err == nil {\n\t\t\t\tt.Fatal(\"expected error, got nil\")\n\t\t\t}\n\t\t\tif !tt.wantErr && err != nil {\n\t\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t\t}\n\t\t\tif !tt.wantErr && reply.MessageType() != tt.want {\n\t\t\t\tt.Fatalf(\"got %v, want %v\", reply.MessageType(), tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReplyDestination(t *testing.T) {\n\tpeer := &net.UDPAddr{IP: net.IPv4(1, 2, 3, 4), Port: 68}\n\tgiaddr := net.IPv4(5, 6, 7, 8)\n\ttests := map[string]struct {\n\t\tgiaddr net.IP\n\t\twant   net.Addr\n\t}{\n\t\t\"giaddr set\":   {giaddr: giaddr, want: &net.UDPAddr{IP: giaddr, Port: dhcpv4.ServerPort}},\n\t\t\"giaddr unset\": {giaddr: net.IPv4zero, want: peer},\n\t}\n\tfor name, tt := range tests {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := replyDestination(peer, tt.giaddr)\n\t\t\tif udp, ok := got.(*net.UDPAddr); ok {\n\t\t\t\tif !udp.IP.Equal(tt.want.(*net.UDPAddr).IP) || udp.Port != tt.want.(*net.UDPAddr).Port {\n\t\t\t\t\tt.Fatalf(\"got %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t} else if got != tt.want {\n\t\t\t\tt.Fatalf(\"got %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestEncodeToAttributes(t *testing.T) {\n\th := &Handler{Log: logr.Discard()}\n\tpkt := &dhcpv4.DHCPv4{BootFileName: \"test.efi\"}\n\tkvs := h.encodeToAttributes(pkt, \"test\")\n\tif len(kvs) == 0 {\n\t\tt.Fatal(\"expected attributes, got none\")\n\t}\n}\n\nfunc TestIgnorePacketError(t *testing.T) {\n\terr := IgnorePacketError{\n\t\tPacketType: dhcpv4.MessageTypeRelease,\n\t\tDetails:    \"test details\",\n\t}\n\n\texpected := \"Ignoring packet: message type RELEASE: details test details\"\n\tif err.Error() != expected {\n\t\tt.Errorf(\"expected error string %q, got %q\", expected, err.Error())\n\t}\n}\n"
