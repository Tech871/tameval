[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.24.5"

[repo_info]
repository = "creativeprojects/resticprofile"
sha = "f74803217ccdcda44570871757d168817c0a95f6"

[run_info]
docker_image = "golang:1.24.5"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out schedule_jobs.go schedule_jobs_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting schedule_jobs.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 77.0
mutation_kill_rate = nan
original_mutation_kill_rate = 39.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "schedule_jobs_test.go"
focal_file_path = "schedule_jobs.go"
test_file_url = "https://github.com/creativeprojects/resticprofile/blob/f74803217ccdcda44570871757d168817c0a95f6/schedule_jobs_test.go"
focal_file_url = "https://github.com/creativeprojects/resticprofile/blob/f74803217ccdcda44570871757d168817c0a95f6/schedule_jobs.go"
first_commit_date = "2020-07-16"
last_commit_date = "2025-06-12"
test_file_content = "package main\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/creativeprojects/resticprofile/calendar\"\n\t\"github.com/creativeprojects/resticprofile/config\"\n\t\"github.com/creativeprojects/resticprofile/schedule\"\n\t\"github.com/creativeprojects/resticprofile/schedule/mocks\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/mock\"\n)\n\n//nolint:unparam\nfunc configForJob(command string, at ...string) *config.Schedule {\n\torigin := config.ScheduleOrigin(\"profile\", command)\n\treturn config.NewDefaultSchedule(nil, origin, at...)\n}\n\nfunc TestScheduleNilJobs(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\n\terr := scheduleJobs(handler, nil)\n\tassert.NoError(t, err)\n}\n\nfunc TestSimpleScheduleJob(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\thandler.EXPECT().ParseSchedules([]string{\"sched\"}).Return([]*calendar.Event{{}}, nil)\n\thandler.EXPECT().DisplaySchedules(\"profile\", \"backup\", []string{\"sched\"}).Return(nil)\n\thandler.EXPECT().CreateJob(\n\t\tmock.AnythingOfType(\"*schedule.Config\"),\n\t\tmock.AnythingOfType(\"[]*calendar.Event\"),\n\t\tmock.AnythingOfType(\"string\")).\n\t\tRunAndReturn(func(scheduleConfig *schedule.Config, events []*calendar.Event, permission string) error {\n\t\t\tassert.Equal(t, []string{\"--no-ansi\", \"--config\", `config file`, \"run-schedule\", \"backup@profile\"}, scheduleConfig.Arguments.RawArgs())\n\t\t\tassert.Equal(t, `--no-ansi --config \"config file\" run-schedule backup@profile`, scheduleConfig.Arguments.String())\n\t\t\treturn nil\n\t\t})\n\n\tscheduleConfig := configForJob(\"backup\", \"sched\")\n\tscheduleConfig.ConfigFile = \"config file\"\n\terr := scheduleJobs(handler, []*config.Schedule{scheduleConfig})\n\tassert.NoError(t, err)\n}\n\nfunc TestFailScheduleJob(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\thandler.EXPECT().ParseSchedules([]string{\"sched\"}).Return([]*calendar.Event{{}}, nil)\n\thandler.EXPECT().DisplaySchedules(\"profile\", \"backup\", []string{\"sched\"}).Return(nil)\n\thandler.EXPECT().CreateJob(\n\t\tmock.AnythingOfType(\"*schedule.Config\"),\n\t\tmock.AnythingOfType(\"[]*calendar.Event\"),\n\t\tmock.AnythingOfType(\"string\")).\n\t\tReturn(errors.New(\"error creating job\"))\n\n\tscheduleConfig := configForJob(\"backup\", \"sched\")\n\terr := scheduleJobs(handler, []*config.Schedule{scheduleConfig})\n\tassert.Error(t, err)\n}\n\nfunc TestRemoveNilJobs(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\n\terr := removeJobs(handler, nil)\n\tassert.NoError(t, err)\n}\n\nfunc TestRemoveJob(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\thandler.EXPECT().RemoveJob(mock.AnythingOfType(\"*schedule.Config\"), mock.AnythingOfType(\"string\")).\n\t\tRunAndReturn(func(scheduleConfig *schedule.Config, user string) error {\n\t\t\tassert.Equal(t, \"profile\", scheduleConfig.ProfileName)\n\t\t\tassert.Equal(t, \"backup\", scheduleConfig.CommandName)\n\t\t\treturn nil\n\t\t})\n\n\tscheduleConfig := configForJob(\"backup\", \"sched\")\n\terr := removeJobs(handler, []*config.Schedule{scheduleConfig})\n\tassert.NoError(t, err)\n}\n\nfunc TestRemoveJobNoConfig(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\thandler.EXPECT().RemoveJob(mock.AnythingOfType(\"*schedule.Config\"), mock.AnythingOfType(\"string\")).\n\t\tRunAndReturn(func(scheduleConfig *schedule.Config, user string) error {\n\t\t\tassert.Equal(t, \"profile\", scheduleConfig.ProfileName)\n\t\t\tassert.Equal(t, \"backup\", scheduleConfig.CommandName)\n\t\t\treturn nil\n\t\t})\n\n\tscheduleConfig := configForJob(\"backup\")\n\terr := removeJobs(handler, []*config.Schedule{scheduleConfig})\n\tassert.NoError(t, err)\n}\n\nfunc TestFailRemoveJob(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\thandler.EXPECT().RemoveJob(mock.AnythingOfType(\"*schedule.Config\"), mock.AnythingOfType(\"string\")).\n\t\tReturn(errors.New(\"error removing job\"))\n\n\tscheduleConfig := configForJob(\"backup\", \"sched\")\n\terr := removeJobs(handler, []*config.Schedule{scheduleConfig})\n\tassert.Error(t, err)\n}\n\nfunc TestNoFailRemoveUnknownJob(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\thandler.EXPECT().RemoveJob(mock.AnythingOfType(\"*schedule.Config\"), mock.AnythingOfType(\"string\")).\n\t\tReturn(schedule.ErrScheduledJobNotFound)\n\n\tscheduleConfig := configForJob(\"backup\", \"sched\")\n\terr := removeJobs(handler, []*config.Schedule{scheduleConfig})\n\tassert.NoError(t, err)\n}\n\nfunc TestNoFailRemoveUnknownRemoveOnlyJob(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\thandler.EXPECT().RemoveJob(mock.AnythingOfType(\"*schedule.Config\"), mock.AnythingOfType(\"string\")).\n\t\tReturn(schedule.ErrScheduledJobNotFound)\n\n\tscheduleConfig := configForJob(\"backup\")\n\terr := removeJobs(handler, []*config.Schedule{scheduleConfig})\n\tassert.NoError(t, err)\n}\n\nfunc TestStatusNilJobs(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\thandler.EXPECT().DisplayStatus(\"profile\").Return(nil)\n\n\terr := statusJobs(handler, \"profile\", nil)\n\tassert.NoError(t, err)\n}\n\nfunc TestStatusJob(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\thandler.EXPECT().DisplaySchedules(\"profile\", \"backup\", []string{\"sched\"}).Return(nil)\n\thandler.EXPECT().DisplayJobStatus(mock.AnythingOfType(\"*schedule.Config\")).Return(nil)\n\thandler.EXPECT().DisplayStatus(\"profile\").Return(nil)\n\n\tscheduleConfig := configForJob(\"backup\", \"sched\")\n\terr := statusJobs(handler, \"profile\", []*config.Schedule{scheduleConfig})\n\tassert.NoError(t, err)\n}\n\nfunc TestStatusRemoveOnlyJob(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\n\tscheduleConfig := configForJob(\"backup\")\n\terr := statusJobs(handler, \"profile\", []*config.Schedule{scheduleConfig})\n\tassert.Error(t, err)\n}\n\nfunc TestRemoveScheduledJobs(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tremoveProfileName string\n\t\tfromConfigFile    string\n\t\tscheduledConfigs  []schedule.Config\n\t\tremovedConfigs    []schedule.Config\n\t\tpermission        string\n\t}{\n\t\t{\n\t\t\tremoveProfileName: \"profile_no_config\",\n\t\t\tfromConfigFile:    \"configFile\",\n\t\t\tscheduledConfigs:  []schedule.Config{},\n\t\t\tremovedConfigs:    []schedule.Config{},\n\t\t\tpermission:        \"user\",\n\t\t},\n\t\t{\n\t\t\tremoveProfileName: \"profile_one_config_to_remove\",\n\t\t\tfromConfigFile:    \"configFile\",\n\t\t\tscheduledConfigs: []schedule.Config{\n\t\t\t\t{\n\t\t\t\t\tProfileName: \"profile_one_config_to_remove\",\n\t\t\t\t\tCommandName: \"backup\",\n\t\t\t\t\tConfigFile:  \"configFile\",\n\t\t\t\t\tPermission:  \"user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tremovedConfigs: []schedule.Config{\n\t\t\t\t{\n\t\t\t\t\tProfileName: \"profile_one_config_to_remove\",\n\t\t\t\t\tCommandName: \"backup\",\n\t\t\t\t\tConfigFile:  \"configFile\",\n\t\t\t\t\tPermission:  \"user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tpermission: \"user\",\n\t\t},\n\t\t{\n\t\t\tremoveProfileName: \"profile_different_config_file\",\n\t\t\tfromConfigFile:    \"configFile\",\n\t\t\tscheduledConfigs: []schedule.Config{\n\t\t\t\t{\n\t\t\t\t\tProfileName: \"profile_different_config_file\",\n\t\t\t\t\tCommandName: \"backup\",\n\t\t\t\t\tConfigFile:  \"other_configFile\",\n\t\t\t\t\tPermission:  \"user\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tremovedConfigs: []schedule.Config{},\n\t\t\tpermission:     \"user\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.removeProfileName, func(t *testing.T) {\n\t\t\thandler := mocks.NewHandler(t)\n\t\t\thandler.EXPECT().Init().Return(nil)\n\t\t\thandler.EXPECT().Close()\n\n\t\t\thandler.EXPECT().Scheduled(tc.removeProfileName).Return(tc.scheduledConfigs, nil)\n\t\t\tfor _, cfg := range tc.removedConfigs {\n\t\t\t\thandler.EXPECT().RemoveJob(&cfg, tc.permission).Return(nil)\n\t\t\t}\n\n\t\t\terr := removeScheduledJobs(handler, tc.fromConfigFile, tc.removeProfileName)\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t}\n}\n\nfunc TestFailRemoveScheduledJobs(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\n\thandler.EXPECT().Scheduled(\"profile_to_remove\").Return([]schedule.Config{\n\t\t{\n\t\t\tProfileName: \"profile_to_remove\",\n\t\t\tCommandName: \"backup\",\n\t\t\tConfigFile:  \"configFile\",\n\t\t\tPermission:  \"user\",\n\t\t},\n\t}, nil)\n\thandler.EXPECT().RemoveJob(&schedule.Config{\n\t\tProfileName: \"profile_to_remove\",\n\t\tCommandName: \"backup\",\n\t\tConfigFile:  \"configFile\",\n\t\tPermission:  \"user\",\n\t}, \"user\").Return(errors.New(\"impossible\"))\n\n\terr := removeScheduledJobs(handler, \"configFile\", \"profile_to_remove\")\n\tassert.Error(t, err)\n\tt.Log(err)\n}\n\nfunc TestStatusScheduledJobs(t *testing.T) {\n\tt.Parallel()\n\n\ttestCases := []struct {\n\t\tstatusProfileName string\n\t\tfromConfigFile    string\n\t\tscheduledConfigs  []schedule.Config\n\t\tstatusConfigs     []schedule.Config\n\t}{\n\t\t{\n\t\t\tstatusProfileName: \"profile_no_config\",\n\t\t\tfromConfigFile:    \"configFile\",\n\t\t\tscheduledConfigs:  []schedule.Config{},\n\t\t\tstatusConfigs:     []schedule.Config{},\n\t\t},\n\t\t{\n\t\t\tstatusProfileName: \"profile_one_config_to_remove\",\n\t\t\tfromConfigFile:    \"configFile\",\n\t\t\tscheduledConfigs: []schedule.Config{\n\t\t\t\t{\n\t\t\t\t\tProfileName: \"profile_one_config_to_remove\",\n\t\t\t\t\tCommandName: \"backup\",\n\t\t\t\t\tConfigFile:  \"configFile\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tstatusConfigs: []schedule.Config{\n\t\t\t\t{\n\t\t\t\t\tProfileName: \"profile_one_config_to_remove\",\n\t\t\t\t\tCommandName: \"backup\",\n\t\t\t\t\tConfigFile:  \"configFile\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tstatusProfileName: \"profile_different_config_file\",\n\t\t\tfromConfigFile:    \"configFile\",\n\t\t\tscheduledConfigs: []schedule.Config{\n\t\t\t\t{\n\t\t\t\t\tProfileName: \"profile_different_config_file\",\n\t\t\t\t\tCommandName: \"backup\",\n\t\t\t\t\tConfigFile:  \"other_configFile\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tstatusConfigs: []schedule.Config{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.statusProfileName, func(t *testing.T) {\n\t\t\thandler := mocks.NewHandler(t)\n\t\t\thandler.EXPECT().Init().Return(nil)\n\t\t\thandler.EXPECT().Close()\n\n\t\t\thandler.EXPECT().Scheduled(tc.statusProfileName).Return(tc.scheduledConfigs, nil)\n\t\t\tfor _, cfg := range tc.statusConfigs {\n\t\t\t\thandler.EXPECT().DisplaySchedules(cfg.ProfileName, cfg.CommandName, []string(nil)).Return(nil)\n\t\t\t\thandler.EXPECT().DisplayJobStatus(&cfg).Return(nil)\n\t\t\t}\n\t\t\tif len(tc.scheduledConfigs) > 0 {\n\t\t\t\thandler.EXPECT().DisplayStatus(tc.statusProfileName).Return(nil)\n\t\t\t}\n\n\t\t\terr := statusScheduledJobs(handler, tc.fromConfigFile, tc.statusProfileName)\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t}\n}\n\nfunc TestFailStatusScheduledJobs(t *testing.T) {\n\tt.Parallel()\n\n\thandler := mocks.NewHandler(t)\n\thandler.EXPECT().Init().Return(nil)\n\thandler.EXPECT().Close()\n\n\thandler.EXPECT().Scheduled(\"profile_name\").Return([]schedule.Config{\n\t\t{\n\t\t\tProfileName: \"profile_name\",\n\t\t\tCommandName: \"backup\",\n\t\t\tConfigFile:  \"configFile\",\n\t\t\tPermission:  \"user\",\n\t\t},\n\t}, nil)\n\thandler.EXPECT().DisplaySchedules(\"profile_name\", \"backup\", []string(nil)).Return(errors.New(\"impossible\"))\n\thandler.EXPECT().DisplayStatus(\"profile_name\").Return(errors.New(\"impossible\"))\n\n\terr := statusScheduledJobs(handler, \"configFile\", \"profile_name\")\n\tassert.Error(t, err)\n\tt.Log(err)\n}"
