[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.24"

[repo_info]
repository = "UiPath/uipathcli"
sha = "f599d0fbb2bbbb5d055d76ba5f1f68f727e97612"

[run_info]
docker_image = "golang:1.24"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out commandline/type_converter.go commandline/type_converter_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting commandline/type_converter.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 62.0
original_coverage = 62.0
mutation_kill_rate = 57.0
original_mutation_kill_rate = 57.0
covered_lines = [ 17, 18, 19, 20, 21, 22, 25, 26, 27, 29, 30, 34, 37, 38, 42, 45, 46, 47, 48, 52, 55, 56, 57, 59, 60, 61, 62, 63, 64, 65, 66, 68, 71, 72, 73, 74, 75, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 95, 96, 97, 98, 99, 100, 105, 106, 107, 111, 112, 113, 116, 117, 118, 119, 120, 121, 125, 126, 128, 129, 130, 131, 132, 134, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 152, 155, 156, 157, 158, 159, 163, 166, 167, 168, 169, 170, 171, 175, 176, 181, 182, 183, 184, 188, 189, 190, 191, 192, 193, 195, 198, 199, 200, 202, 203, 204, 205, 206, 207, 211, 213, 244, 245, 246, 248, 249, 250, 251, 252, 253, 254, 255, 259, 260, 261, 262, 263, 264, 265, 266, 267, 269, 270, 271, 272, 273, 274, 275, 276, 278, 279, 280, 281, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 306, 307, 335, 336, 337, 338, 342, 344, 371, 372, 377, 378, 388, 389, 390,]
missed_lines = [ 31, 32, 33, 39, 40, 41, 49, 50, 51, 101, 102, 103, 108, 109, 110, 122, 123, 124, 149, 150, 151, 160, 161, 162, 172, 177, 178, 179, 185, 186, 187, 208, 209, 210, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 227, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 241, 256, 257, 258, 300, 301, 302, 303, 304, 305, 311, 312, 313, 314, 315, 316, 317, 318, 320, 323, 324, 325, 326, 327, 328, 329, 330, 332, 339, 340, 341, 347, 348, 349, 350, 351, 352, 353, 354, 356, 359, 360, 361, 362, 363, 364, 365, 366, 368, 373, 374, 375, 376, 379, 380, 381, 382, 383, 384,]

[input_info]
test_file_path = "commandline/type_converter_test.go"
focal_file_path = "commandline/type_converter.go"
test_file_url = "https://github.com/UiPath/uipathcli/blob/f599d0fbb2bbbb5d055d76ba5f1f68f727e97612/commandline/type_converter_test.go"
focal_file_url = "https://github.com/UiPath/uipathcli/blob/f599d0fbb2bbbb5d055d76ba5f1f68f727e97612/commandline/type_converter.go"
first_commit_date = "2022-09-03"
last_commit_date = "2025-04-17"
test_file_content = "package commandline\n\nimport (\n\t\"testing\"\n\n\t\"github.com/UiPath/uipathcli/parser\"\n\t\"github.com/UiPath/uipathcli/utils/stream\"\n)\n\nfunc TestConvertReturnsErrorForInvalidBoolean(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"enabled\", parser.ParameterTypeBoolean, []parser.Parameter{})\n\t_, err := converter.Convert(\"invalid\", parameter)\n\n\tif err.Error() != \"Cannot convert 'enabled' value 'invalid' to boolean\" {\n\t\tt.Errorf(\"Should return error, but got: %v\", err)\n\t}\n}\n\nfunc TestConvertStringToBoolean(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"enabled\", parser.ParameterTypeBoolean, []parser.Parameter{})\n\tresult, err := converter.Convert(\"true\", parameter)\n\n\tif err != nil {\n\t\tt.Errorf(\"Should not return error, but got: %v\", err)\n\t}\n\tif result != true {\n\t\tt.Errorf(\"Result should be boolean, but got: %v\", result)\n\t}\n}\n\nfunc TestConvertStringToFileStream(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"file\", parser.ParameterTypeBinary, []parser.Parameter{})\n\tresult, err := converter.Convert(\"test.txt\", parameter)\n\n\tif err != nil {\n\t\tt.Errorf(\"Should not return error, but got: %v\", err)\n\t}\n\tfileStream := result.(*stream.FileStream)\n\tif fileStream.Name() != \"test.txt\" {\n\t\tt.Errorf(\"Result should be file stream, but got: %v\", result)\n\t}\n}\n\nfunc TestConvertCommaSeparatedStringToIntegerArray(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"metrics\", parser.ParameterTypeIntegerArray, []parser.Parameter{})\n\tresult, err := converter.Convert(\"5,2\", parameter)\n\n\tif err != nil {\n\t\tt.Errorf(\"Should not return error, but got: %v\", err)\n\t}\n\tarray := result.([]int)\n\tif len(array) != 2 || array[0] != 5 || array[1] != 2 {\n\t\tt.Errorf(\"Result should be integer array, but got: %v\", result)\n\t}\n}\n\nfunc TestConvertStringToIntegerArray(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"metrics\", parser.ParameterTypeIntegerArray, []parser.Parameter{})\n\tresult, err := converter.ConvertArray([]string{\"5,2\", \"3\"}, parameter)\n\n\tif err != nil {\n\t\tt.Errorf(\"Should not return error, but got: %v\", err)\n\t}\n\tarray := result.([]int)\n\tif len(array) != 3 || array[0] != 5 || array[1] != 2 || array[2] != 3 {\n\t\tt.Errorf(\"Result should be integer array, but got: %v\", result)\n\t}\n}\n\nfunc TestConvertExpressionToObject(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"tag\", parser.ParameterTypeObject,\n\t\t[]parser.Parameter{\n\t\t\tnewParameter(\"name\", parser.ParameterTypeString, []parser.Parameter{}),\n\t\t\tnewParameter(\"value\", parser.ParameterTypeNumber, []parser.Parameter{}),\n\t\t})\n\tresult, _ := converter.Convert(\"name=hello;value=1.5\", parameter)\n\n\tname := getValue(result, \"name\")\n\tif name != \"hello\" {\n\t\tt.Errorf(\"Result should be string, but got: %v\", name)\n\t}\n\tvalue := getValue(result, \"value\")\n\tif value != 1.5 {\n\t\tt.Errorf(\"Result should be float, but got: %v\", value)\n\t}\n}\n\nfunc TestConvertNestedExpressionToObject(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"user\", parser.ParameterTypeObject,\n\t\t[]parser.Parameter{\n\t\t\tnewParameter(\"profile\", parser.ParameterTypeObject,\n\t\t\t\t[]parser.Parameter{\n\t\t\t\t\tnewParameter(\"status\", parser.ParameterTypeInteger, []parser.Parameter{}),\n\t\t\t\t},\n\t\t\t),\n\t\t})\n\tresult, _ := converter.Convert(\"profile.status=1\", parameter)\n\n\tprofile := getValue(result, \"profile\")\n\tstatus := getValue(profile, \"status\")\n\tif status != 1 {\n\t\tt.Errorf(\"Result should be integer, but got: %v\", status)\n\t}\n}\n\nfunc TestCustomParameterAddedToObject(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"request\", parser.ParameterTypeObject, []parser.Parameter{})\n\tresult, _ := converter.Convert(\"firstName=Thomas\", parameter)\n\n\tfirstName := getValue(result, \"firstName\")\n\tif firstName != \"Thomas\" {\n\t\tt.Errorf(\"Custom property not found, got: %v\", firstName)\n\t}\n}\n\nfunc TestConvertObjectArray(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"root\", parser.ParameterTypeObject, []parser.Parameter{})\n\tresult, _ := converter.Convert(\"nodes[0].id = 1; nodes[0].value = my-value;\", parameter)\n\n\tfirstNode := getArrayValue(result, \"nodes\", 0)\n\tid := getValue(firstNode, \"id\")\n\tif id != \"1\" {\n\t\tt.Errorf(\"Could not find first node id, got: %v\", id)\n\t}\n\tvalue := getValue(firstNode, \"value\")\n\tif value != \"my-value\" {\n\t\tt.Errorf(\"Could not find first node value, got: %v\", value)\n\t}\n}\n\nfunc TestMixingObjectAndArrayReturnsError(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"root\", parser.ParameterTypeObject, []parser.Parameter{})\n\t_, err := converter.Convert(\"nodes[0].id = 1; nodes.value = my-value;\", parameter)\n\n\tif err.Error() != \"Cannot convert 'root' value because there is a type mismatch for the object key 'nodes'\" {\n\t\tt.Errorf(\"Should return error, but got: %v\", err)\n\t}\n}\n\nfunc TestInvalidIndexIsIgnored(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"root\", parser.ParameterTypeObject, []parser.Parameter{})\n\tresult, _ := converter.Convert(\"nodes[invalid].id = 1\", parameter)\n\n\tvalue := getValue(result, \"nodes[invalid]\")\n\tid := getValue(value, \"id\")\n\tif id != \"1\" {\n\t\tt.Errorf(\"Could not find id value, got: %v\", id)\n\t}\n}\n\nfunc TestNegativeIndexIsIgnored(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"root\", parser.ParameterTypeObject, []parser.Parameter{})\n\tresult, _ := converter.Convert(\"nodes[-1].id = 1\", parameter)\n\n\tvalue := getValue(result, \"nodes[-1]\")\n\tid := getValue(value, \"id\")\n\tif id != \"1\" {\n\t\tt.Errorf(\"Could not find id value, got: %v\", id)\n\t}\n}\n\nfunc TestConvertStringAvoidEscapeEqualSign(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"tag\", parser.ParameterTypeObject,\n\t\t[]parser.Parameter{\n\t\t\tnewParameter(\"name\", parser.ParameterTypeString, []parser.Parameter{}),\n\t\t})\n\tresult, _ := converter.Convert(\"name=hello=\", parameter)\n\n\tname := getValue(result, \"name\")\n\tif name != \"hello=\" {\n\t\tt.Errorf(\"Result should contain equal sign, but got: %v\", name)\n\t}\n}\n\nfunc TestConvertPreserveEscapeCharacter(t *testing.T) {\n\tconverter := newTypeConverter()\n\n\tparameter := newParameter(\"values\", parser.ParameterTypeStringArray, []parser.Parameter{})\n\tresult, _ := converter.Convert(\"..\\\\path\\\\myfile.txt,..\\\\path\\\\myfile2.txt\", parameter)\n\n\tvalues := result.([]string)\n\tif len(values) != 2 {\n\t\tt.Errorf(\"values array should contain two entries, but got: %v\", len(values))\n\t}\n\tif values[0] != \"..\\\\path\\\\myfile.txt\" {\n\t\tt.Errorf(\"values array should contain first path, but got: %v\", values[0])\n\t}\n\tif values[1] != \"..\\\\path\\\\myfile2.txt\" {\n\t\tt.Errorf(\"values array should contain second path, but got: %v\", values[1])\n\t}\n}\n\nfunc getValue(result interface{}, key string) interface{} {\n\treturn result.(map[string]interface{})[key]\n}\n\nfunc getArrayValue(result interface{}, key string, index int) interface{} {\n\treturn getValue(result, key).([]interface{})[index]\n}\n\nfunc newParameter(name string, t string, parameters []parser.Parameter) parser.Parameter {\n\treturn *parser.NewParameter(name, t, \"\", \"\", name, false, nil, []interface{}{}, false, parameters)\n}\n"
