[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Python"
python_version = "3.11"
python_cfg_file = "setup.py"

[repo_info]
repository = "facebookresearch/balance"
sha = "80a89cf6f5d7de64f55f2bebe7d666e51d6f9bb9"

[run_info]
docker_image = "python:3.11"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "(pip install . && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=balance/weighting_methods/rake.py -m pytest -q --junit-xml=test_output.xml tests/test_rake.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target balance.weighting_methods.rake --unit-test tests.test_rake --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target balance/weighting_methods/rake.py --unit-test tests/test_rake.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 97.0
original_coverage = 97.0
mutation_kill_rate = 82.0
original_mutation_kill_rate = 82.0
covered_lines = [ 7, 9, 11, 12, 14, 15, 17, 18, 20, 21, 23, 27, 75, 78, 83, 84, 85, 88, 91, 95, 100, 102, 104, 105, 107, 112, 117, 118, 121, 124, 125, 126, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 147, 148, 153, 155, 159, 160, 162, 163, 167, 168, 170, 175, 185, 189, 195, 205, 207, 212, 215, 223, 237, 241, 244, 256, 285, 288, 315, 318, 319, 323, 328, 329, 330, 333, 335, 336, 338, 340, 342, 345, 372, 373, 374, 377, 428, 431, 434, 435, 436, 437, 438, 440, 443, 478, 479, 481, 483,]
missed_lines = [ 128, 213, 320,]

[input_info]
test_file_path = "tests/test_rake.py"
focal_file_path = "balance/weighting_methods/rake.py"
test_file_url = "https://github.com/facebookresearch/balance/blob/80a89cf6f5d7de64f55f2bebe7d666e51d6f9bb9/tests/test_rake.py"
focal_file_url = "https://github.com/facebookresearch/balance/blob/80a89cf6f5d7de64f55f2bebe7d666e51d6f9bb9/balance/weighting_methods/rake.py"
first_commit_date = "2023-04-23"
last_commit_date = "2025-01-06"
test_file_content = "# Copyright (c) Meta Platforms, Inc. and affiliates.\n#\n# This source code is licensed under the MIT license found in the\n# LICENSE file in the root directory of this source tree.\n\n# pyre-unsafe\n\nfrom __future__ import absolute_import, division, print_function, unicode_literals\n\nimport balance.testutil\n\nimport numpy as np\nimport pandas as pd\n\nfrom balance.sample_class import Sample\nfrom balance.weighting_methods.rake import (\n    _proportional_array_from_dict,\n    _realize_dicts_of_proportions,\n    prepare_marginal_dist_for_raking,\n    rake,\n)\n\n\nclass Testrake(\n    balance.testutil.BalanceTestCase,\n):\n    def test_rake_input_assertions(self):\n        N = 20\n        sample = pd.DataFrame(\n            {\n                \"a\": np.random.normal(size=N),\n                \"b\": np.random.normal(size=N),\n                \"weight\": [1.0] * N,\n            }\n        )\n        target = pd.DataFrame(\n            {\n                \"a\": np.random.normal(size=N),\n                \"b\": np.random.normal(size=N),\n            }\n        )\n\n        # Cannot have weight in df that is not the weight column\n        self.assertRaisesRegex(\n            AssertionError,\n            \"weight shouldn't be a name for covariate in the sample data\",\n            rake,\n            sample,\n            pd.Series((1,) * N),\n            target,\n            pd.Series((1,) * N),\n        )\n\n        target[\"weight\"] = [2.0] * N\n        self.assertRaisesRegex(\n            AssertionError,\n            \"weight shouldn't be a name for covariate in the target data\",\n            rake,\n            sample[[\"a\", \"b\"]],\n            pd.Series((1,) * N),\n            target,\n            pd.Series((1,) * N),\n        )\n\n        # Must pass more than one varaible\n        self.assertRaisesRegex(\n            AssertionError,\n            \"Must weight on at least two variables\",\n            rake,\n            sample[[\"a\"]],\n            pd.Series((1,) * N),\n            target[[\"a\"]],\n            pd.Series((1,) * N),\n        )\n\n        # Must pass weights for sample\n        self.assertRaisesRegex(\n            AssertionError,\n            \"sample_weights must be a pandas Series\",\n            rake,\n            sample[[\"a\", \"b\"]],\n            None,\n            target[[\"a\", \"b\"]],\n            pd.Series((1,) * N),\n        )\n\n        # Must pass weights for sample\n        self.assertRaisesRegex(\n            AssertionError,\n            \"target_weights must be a pandas Series\",\n            rake,\n            sample[[\"a\", \"b\"]],\n            pd.Series((1,) * N),\n            target[[\"a\", \"b\"]],\n            None,\n        )\n\n        # Must pass weights of same length as sample\n        self.assertRaisesRegex(\n            AssertionError,\n            \"sample_weights must be the same length as sample_df\",\n            rake,\n            sample[[\"a\", \"b\"]],\n            pd.Series((1,) * (N - 1)),\n            target[[\"a\", \"b\"]],\n            pd.Series((1,) * N),\n        )\n\n        # Must pass weights for sample\n        self.assertRaisesRegex(\n            AssertionError,\n            \"target_weights must be the same length as target_df\",\n            rake,\n            sample[[\"a\", \"b\"]],\n            pd.Series((1,) * N),\n            target[[\"a\", \"b\"]],\n            pd.Series((1,) * (N - 1)),\n        )\n\n    def test_rake_fails_when_all_na(self):\n        df_sample_nas = pd.DataFrame(\n            {\n                \"a\": np.array([np.nan] * 12),\n                \"b\": [\"a\"] * 6 + [\"b\"] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n        df_target = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\"] * 10 + [\"2\"] * 2),\n                \"b\": [\"a\"] * 6 + [\"b\"] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n        df_sample = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\", \"2\"] * 6),\n                \"b\": [\"a\"] * 6 + [\"b\"] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n        df_target_nas = pd.DataFrame(\n            {\n                \"a\": pd.Series([np.nan] * 6 + [\"2\"] * 6, dtype=object),\n                \"b\": pd.Series([\"a\"] * 6 + [np.nan] * 6, dtype=object),\n                \"id\": range(0, 12),\n            }\n        )\n\n        self.assertRaisesRegex(\n            ValueError,\n            \"Dropping rows led to empty\",\n            rake,\n            df_sample_nas,\n            pd.Series((1,) * 12),\n            df_target,\n            pd.Series((1,) * 12),\n            na_action=\"drop\",\n            transformations=None,\n        )\n\n        self.assertRaisesRegex(\n            ValueError,\n            \"Dropping rows led to empty\",\n            rake,\n            df_sample,\n            pd.Series((1,) * 12),\n            df_target_nas,\n            pd.Series((1,) * 12),\n            na_action=\"drop\",\n            transformations=None,\n        )\n\n    def test_rake_weights(self):\n        df_sample = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\", \"2\"] * 6),\n                \"b\": [\"a\"] * 6 + [\"b\"] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n        df_target = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\"] * 10 + [\"2\"] * 2),\n                \"b\": [\"a\"] * 6 + [\"b\"] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n\n        sample = Sample.from_frame(df_sample)\n        target = Sample.from_frame(df_target)\n        sample = sample.set_target(target)\n\n        adjusted = rake(\n            sample.covars().df,\n            sample.weight_column,\n            target.covars().df,\n            target.weight_column,\n        )\n\n        self.assertEqual(\n            adjusted[\"weight\"].round(2),\n            pd.Series([1.67, 0.33] * 6, name=\"rake_weight\").rename_axis(\"index\"),\n        )\n\n    def test_rake_weights_with_weighted_input(self):\n        df_sample = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\", \"2\"] * 6),\n                \"b\": [\"a\"] * 6 + [\"b\"] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n        df_target = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\"] * 10 + [\"2\"] * 2),\n                \"b\": [\"a\"] * 6 + [\"b\"] * 6,\n                \"weight\": [0.5, 1.0] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n\n        sample = Sample.from_frame(df_sample)\n        target = Sample.from_frame(df_target)\n        sample = sample.set_target(target)\n\n        adjusted = rake(\n            sample.covars().df,\n            sample.weight_column,\n            target.covars().df,\n            target.weight_column,\n        )\n\n        self.assertEqual(\n            adjusted[\"weight\"].round(2),\n            pd.Series([1.25, 0.25] * 6, name=\"rake_weight\").rename_axis(\"index\"),\n        )\n\n    def test_rake_weights_scale_to_pop(self):\n        df_sample = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\", \"2\"] * 6),\n                \"b\": [\"a\"] * 6 + [\"b\"] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n        df_target = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\"] * 10 + [\"2\"] * 5),\n                \"b\": [\"a\"] * 6 + [\"b\"] * 9,\n                \"id\": range(0, 15),\n            }\n        )\n\n        sample = Sample.from_frame(df_sample)\n        target = Sample.from_frame(df_target)\n        sample = sample.set_target(target)\n\n        adjusted = rake(\n            sample.covars().df,\n            sample.weight_column,\n            target.covars().df,\n            target.weight_column,\n        )\n\n        self.assertEqual(round(sum(adjusted[\"weight\"]), 2), 15.0)\n\n    def test_rake_expected_weights_with_na(self):\n        dfsamp = pd.DataFrame(\n            {\n                \"a\": np.array([1.0, 2.0, np.nan] * 6),\n                \"b\": [\"a\", \"b\"] * 9,\n                \"id\": range(0, 18),\n            }\n        )\n        dfpop = pd.DataFrame(\n            {\n                \"a\": np.array([1.0] * 10 + [2.0] * 6 + [np.nan] * 2),\n                \"b\": [\"a\", \"b\"] * 9,\n                \"id\": range(18, 36),\n            }\n        )\n\n        sample = Sample.from_frame(dfsamp)\n        target = Sample.from_frame(dfpop)\n        sample = sample.set_target(target)\n\n        # Dropping NAs (example calculation for test values):\n        # Note, 'b' does not matter here, always balanced\n        # In sample, a=1.0 is 6/12=0.5\n        # In target, a=1.0 is 10/16=0.625\n        # So a=1.0 in sample needs 1.25 weight (when weights sum to sample size)\n        # Now that weights sum to target size, we need to scale 1.25 by relative population sizes\n        # 1.25 * (16/12) = 1.6666667, final weight\n\n        adjusted = sample.adjust(method=\"rake\", transformations=None, na_action=\"drop\")\n        self.assertEqual(\n            adjusted.weight_column.round(2),\n            pd.Series([1.67, 1.0, np.nan] * 6, name=\"weight\"),\n        )\n\n        # Dropping NAs (example calculation for test values):\n        # Note, 'b' does not matter here, always balanced\n        # In sample, a=1.0 is 6/18=0.333333\n        # In target, a=1.0 is 10/18=0.5555556\n        # So a=1.0 in sample needs 1.6667 weight (when weights sum to sample size)\n        # sample size = target size, so no need to rescale\n        adjusted = sample.adjust(\n            method=\"rake\", transformations=None, na_action=\"add_indicator\"\n        )\n\n        self.assertEqual(\n            adjusted.weight_column.round(2),\n            pd.Series([1.67, 1.0, 0.33] * 6, name=\"weight\"),\n        )\n\n    # Test consistency result of rake\n    def test_rake_consistency_with_default_arguments(self):\n        # This test is meant to check the consistency of the rake function with the default arguments\n        np.random.seed(2021)\n        n_sample = 1000\n        n_target = 2000\n\n        sample_df = pd.concat(\n            [\n                pd.DataFrame(np.random.uniform(0, 10, size=n_sample), columns=[0]),\n                pd.DataFrame(\n                    np.random.uniform(0, 1, size=(n_sample, 4)), columns=range(1, 5)\n                ),\n                pd.DataFrame(\n                    np.random.choice(\n                        [\"level1\", \"level2\", \"level3\"], size=(n_sample, 5)\n                    ),\n                    columns=range(5, 10),\n                ),\n            ],\n            axis=1,\n        )\n        sample_df = sample_df.rename(columns={i: \"abcdefghij\"[i] for i in range(0, 10)})\n\n        target_df = pd.concat(\n            [\n                pd.DataFrame(np.random.uniform(0, 18, size=n_target), columns=[0]),\n                pd.DataFrame(\n                    np.random.uniform(0, 1, size=(n_target, 4)), columns=range(1, 5)\n                ),\n                pd.DataFrame(\n                    np.random.choice(\n                        [\"level1\", \"level2\", \"level3\"], size=(n_target, 5)\n                    ),\n                    columns=range(5, 10),\n                ),\n            ],\n            axis=1,\n        )\n        target_df = target_df.rename(columns={i: \"abcdefghij\"[i] for i in range(0, 10)})\n\n        # Add some NAN values\n        sample_df.loc[[0, 1], \"a\"] = np.nan\n        target_df.loc[[100, 101], \"a\"] = np.nan\n\n        sample_weights = pd.Series(np.random.uniform(0, 1, size=n_sample))\n        target_weights = pd.Series(np.random.uniform(0, 1, size=n_target))\n\n        res = rake(sample_df, sample_weights, target_df, target_weights)\n\n        # Compare output weights (examples and distribution)\n        self.assertEqual(round(res[\"weight\"][4], 4), 1.3221)\n        self.assertEqual(round(res[\"weight\"][997], 4), 0.8985)\n        self.assertEqual(\n            np.around(res[\"weight\"].describe().values, 4),\n            np.array(\n                [\n                    1.0000e03,\n                    1.0167e00,\n                    3.5000e-01,\n                    3.4260e-01,\n                    7.4790e-01,\n                    9.7610e-01,\n                    1.2026e00,\n                    2.8854e00,\n                ]\n            ),\n        )\n\n    def test_variable_order_alphabetized(self):\n        # Note: 'a' is always preferred, and due to perfect collinearity\n        # with 'b', 'b' never gets weighted to, even if we reverse the\n        # order. This is not a perfect test, but it broke pre-alphabetization!\n        df_sample = pd.DataFrame(\n            {\n                \"a\": [\"1\"] * 6 + [\"2\"] * 6,\n                \"b\": [\"a\"] * 6 + [\"b\"] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n        df_target = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\"] * 10 + [\"2\"] * 2),\n                \"b\": [\"a\"] * 3 + [\"b\"] * 9,\n                \"id\": range(0, 12),\n            }\n        )\n\n        sample = Sample.from_frame(df_sample)\n        target = Sample.from_frame(df_target)\n\n        adjusted = rake(\n            sample.covars().df,\n            sample.weight_column,\n            target.covars().df,\n            target.weight_column,\n            variables=[\"a\", \"b\"],\n        )\n\n        adjusted_two = rake(\n            sample.covars().df,\n            sample.weight_column,\n            target.covars().df,\n            target.weight_column,\n            variables=[\"b\", \"a\"],\n        )\n\n        self.assertEqual(\n            adjusted[\"weight\"],\n            adjusted_two[\"weight\"],\n        )\n\n    def test_rake_levels_warnings(self):\n        df_sample = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\", \"2\"] * 6),\n                \"b\": [\"a\"] * 6 + [\"b\"] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n        df_target = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\"] * 10 + [\"2\"] * 2),\n                \"b\": [\"a\"] * 6 + [\"b\"] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n        df_sample_excess_levels = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\", \"2\"] * 6),\n                \"b\": [\"alpha\"] * 2 + [\"a\"] * 4 + [\"b\"] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n        df_target_excess_levels = pd.DataFrame(\n            {\n                \"a\": np.array([\"1\"] * 10 + [\"2\"] * 2),\n                \"b\": [\"omega\"] * 2 + [\"a\"] * 4 + [\"b\"] * 6,\n                \"id\": range(0, 12),\n            }\n        )\n\n        sample = Sample.from_frame(df_sample)\n        sample_excess_levels = Sample.from_frame(df_sample_excess_levels)\n        target = Sample.from_frame(df_target)\n        target_excess_levels = Sample.from_frame(df_target_excess_levels)\n\n        self.assertRaisesRegex(\n            ValueError,\n            \"'b' in target is missing.*alpha\",\n            rake,\n            sample_excess_levels.covars().df,\n            sample_excess_levels.weight_column,\n            target.covars().df,\n            target.weight_column,\n        )\n        self.assertWarnsRegexp(\n            \"'b' in sample is missing.*omega\",\n            rake,\n            sample.covars().df,\n            sample.weight_column,\n            target_excess_levels.covars().df,\n            target_excess_levels.weight_column,\n        )\n\n    def test__proportional_array_from_dict(self):\n        self.assertEqual(\n            _proportional_array_from_dict({\"a\": 0.2, \"b\": 0.8}),\n            [\"a\", \"b\", \"b\", \"b\", \"b\"],\n        )\n        self.assertEqual(\n            _proportional_array_from_dict({\"a\": 0.5, \"b\": 0.5}), [\"a\", \"b\"]\n        )\n        self.assertEqual(\n            _proportional_array_from_dict({\"a\": 1 / 3, \"b\": 1 / 3, \"c\": 1 / 3}),\n            [\"a\", \"b\", \"c\"],\n        )\n        self.assertEqual(\n            _proportional_array_from_dict({\"a\": 3 / 8, \"b\": 5 / 8}),\n            [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"b\", \"b\"],\n        )\n        self.assertEqual(\n            _proportional_array_from_dict({\"a\": 3 / 5, \"b\": 1 / 5, \"c\": 2 / 10}),\n            [\"a\", \"a\", \"a\", \"b\", \"c\"],\n        )\n        self.assertEqual(\n            _proportional_array_from_dict({\"a\": 3 / 8, \"b\": 5 / 8}, max_length=5),\n            [\"a\", \"a\", \"b\", \"b\", \"b\"],\n        )\n        self.assertEqual(\n            _proportional_array_from_dict({\"a\": 3 / 8, \"b\": 5 / 8}, max_length=50),\n            [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\", \"b\", \"b\"],\n        )\n\n    def test__realize_dicts_of_proportions(self):\n        dict_of_dicts = {\n            \"v1\": {\"a\": 0.2, \"b\": 0.6, \"c\": 0.2},\n            \"v2\": {\"aa\": 0.5, \"bb\": 0.5},\n        }\n\n        self.assertEqual(\n            _realize_dicts_of_proportions(dict_of_dicts),\n            {\n                \"v1\": [\"a\", \"b\", \"b\", \"b\", \"c\", \"a\", \"b\", \"b\", \"b\", \"c\"],\n                \"v2\": [\"aa\", \"bb\", \"aa\", \"bb\", \"aa\", \"bb\", \"aa\", \"bb\", \"aa\", \"bb\"],\n            },\n        )\n\n        dict_of_dicts = {\n            \"v1\": {\"a\": 0.2, \"b\": 0.6, \"c\": 0.2},\n            \"v2\": {\"aa\": 0.5, \"bb\": 0.5},\n            \"v3\": {\"A\": 0.2, \"B\": 0.8},\n        }\n        self.assertEqual(\n            _realize_dicts_of_proportions(dict_of_dicts),\n            {\n                \"v1\": [\"a\", \"b\", \"b\", \"b\", \"c\", \"a\", \"b\", \"b\", \"b\", \"c\"],\n                \"v2\": [\"aa\", \"bb\", \"aa\", \"bb\", \"aa\", \"bb\", \"aa\", \"bb\", \"aa\", \"bb\"],\n                \"v3\": [\"A\", \"B\", \"B\", \"B\", \"B\", \"A\", \"B\", \"B\", \"B\", \"B\"],\n            },\n        )\n\n        dict_of_dicts = {\n            \"v1\": {\"a\": 0.2, \"b\": 0.6, \"c\": 0.2},\n            \"v2\": {\"aa\": 0.5, \"bb\": 0.5},\n            \"v3\": {\"A\": 0.2, \"B\": 0.8},\n            \"v4\": {\"A\": 0.1, \"B\": 0.9},\n        }\n        self.assertEqual(\n            _realize_dicts_of_proportions(dict_of_dicts),\n            {\n                \"v1\": [\"a\", \"b\", \"b\", \"b\", \"c\", \"a\", \"b\", \"b\", \"b\", \"c\"],\n                \"v2\": [\"aa\", \"bb\", \"aa\", \"bb\", \"aa\", \"bb\", \"aa\", \"bb\", \"aa\", \"bb\"],\n                \"v3\": [\"A\", \"B\", \"B\", \"B\", \"B\", \"A\", \"B\", \"B\", \"B\", \"B\"],\n                \"v4\": [\"A\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\", \"B\"],\n            },\n        )\n\n    def test_prepare_marginal_dist_for_raking(self):\n        self.assertEqual(\n            prepare_marginal_dist_for_raking(\n                {\"A\": {\"a\": 0.5, \"b\": 0.5}, \"B\": {\"x\": 0.2, \"y\": 0.8}}\n            ).to_dict(),\n            {\n                \"A\": {\n                    0: \"a\",\n                    1: \"b\",\n                    2: \"a\",\n                    3: \"b\",\n                    4: \"a\",\n                    5: \"b\",\n                    6: \"a\",\n                    7: \"b\",\n                    8: \"a\",\n                    9: \"b\",\n                },\n                \"B\": {\n                    0: \"x\",\n                    1: \"y\",\n                    2: \"y\",\n                    3: \"y\",\n                    4: \"y\",\n                    5: \"x\",\n                    6: \"y\",\n                    7: \"y\",\n                    8: \"y\",\n                    9: \"y\",\n                },\n                \"id\": {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9},\n            },\n        )\n\n    # TODO: test convergence rate\n    # TODO: test max iteration\n    # TODO: test logging\n"
