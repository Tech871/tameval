[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "reflex-dev/reflex"
sha = "7acc7d9bb472d6e3a0e9df64bcbc5019d66fc788"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "(pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=reflex/vars/dep_tracking.py -m pytest -q --junit-xml=test_output.xml tests/units/vars/test_dep_tracking.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target reflex.vars.dep_tracking --unit-test tests.units.vars.test_dep_tracking --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target reflex/vars/dep_tracking.py --unit-test tests/units/vars/test_dep_tracking.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 84.0
original_coverage = 84.0
mutation_kill_rate = 100.0
original_mutation_kill_rate = 100.0
covered_lines = [ 2, 4, 5, 6, 7, 8, 9, 10, 11, 13, 21, 24, 33, 34, 39, 42, 43, 44, 45, 48, 49, 52, 53, 55, 57, 58, 60, 62, 63, 65, 67, 69, 71, 72, 74, 76, 77, 79, 81, 83, 89, 90, 92, 104, 106, 107, 108, 109, 111, 112, 113, 115, 116, 117, 118, 121, 122, 124, 125, 126, 131, 134, 136, 139, 144, 148, 154, 155, 156, 158, 164, 165, 166, 176, 192, 194, 195, 196, 197, 200, 202, 203, 207, 209, 210, 214, 216, 221, 222, 223, 225, 238, 239, 242, 243, 244, 245, 246, 254, 256, 257, 261, 263, 265, 279, 280, 283, 284, 285, 288, 291, 293, 301, 302, 303, 304, 305, 306, 312, 313, 314, 318, 319, 320, 325,]
missed_lines = [ 35, 36, 123, 127, 129, 133, 198, 199, 204, 205, 206, 211, 212, 213, 219, 220, 240, 241, 252, 253, 281, 282, 286, 287,]

[input_info]
test_file_path = "tests/units/vars/test_dep_tracking.py"
focal_file_path = "reflex/vars/dep_tracking.py"
test_file_url = "https://github.com/reflex-dev/reflex/blob/7acc7d9bb472d6e3a0e9df64bcbc5019d66fc788/tests/units/vars/test_dep_tracking.py"
focal_file_url = "https://github.com/reflex-dev/reflex/blob/7acc7d9bb472d6e3a0e9df64bcbc5019d66fc788/reflex/vars/dep_tracking.py"
first_commit_date = "2025-02-01"
last_commit_date = "2025-07-24"
test_file_content = "\"\"\"Tests for dependency tracking functionality.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\n\nimport pytest\n\nimport reflex as rx\nfrom reflex.state import State\nfrom reflex.utils.exceptions import VarValueError\nfrom reflex.vars.dep_tracking import DependencyTracker, get_cell_value\n\n\nclass DependencyTestState(State):\n    \"\"\"Test state for dependency tracking tests.\"\"\"\n\n    count: rx.Field[int] = rx.field(default=0)\n    name: rx.Field[str] = rx.field(default=\"test\")\n    items: rx.Field[list[str]] = rx.field(default_factory=list)\n\n\nclass AnotherTestState(State):\n    \"\"\"Another test state for cross-state dependencies.\"\"\"\n\n    value: rx.Field[int] = rx.field(default=42)\n    text: rx.Field[str] = rx.field(default=\"hello\")\n\n\ndef test_simple_attribute_access():\n    \"\"\"Test tracking simple attribute access on self.\"\"\"\n\n    def simple_func(self: DependencyTestState):\n        return self.count\n\n    tracker = DependencyTracker(simple_func, DependencyTestState)\n\n    expected_deps = {DependencyTestState.get_full_name(): {\"count\"}}\n    assert tracker.dependencies == expected_deps\n\n\ndef test_multiple_attribute_access():\n    \"\"\"Test tracking multiple attribute access on self.\"\"\"\n\n    def multi_attr_func(self: DependencyTestState):\n        return self.count + len(self.name) + len(self.items)\n\n    tracker = DependencyTracker(multi_attr_func, DependencyTestState)\n\n    expected_deps = {DependencyTestState.get_full_name(): {\"count\", \"name\", \"items\"}}\n    assert tracker.dependencies == expected_deps\n\n\ndef test_method_call_dependencies():\n    \"\"\"Test tracking dependencies from method calls.\"\"\"\n\n    class StateWithMethod(State):\n        value: int = 0\n\n        def helper_method(self):\n            return self.value * 2\n\n        def func_with_method_call(self):\n            return self.helper_method()\n\n    tracker = DependencyTracker(StateWithMethod.func_with_method_call, StateWithMethod)\n\n    # Should track dependencies from both the method call and the method itself\n    expected_deps = {StateWithMethod.get_full_name(): {\"value\"}}\n    assert tracker.dependencies == expected_deps\n\n\ndef test_nested_function_dependencies():\n    \"\"\"Test tracking dependencies in nested functions.\"\"\"\n\n    def func_with_nested(self: DependencyTestState):\n        def inner():\n            return self.count\n\n        return inner()\n\n    tracker = DependencyTracker(func_with_nested, DependencyTestState)\n\n    expected_deps = {DependencyTestState.get_full_name(): {\"count\"}}\n    assert tracker.dependencies == expected_deps\n\n\ndef test_list_comprehension_dependencies():\n    \"\"\"Test tracking dependencies in list comprehensions.\"\"\"\n\n    def func_with_comprehension(self: DependencyTestState):\n        return [x for x in self.items if len(x) > self.count]\n\n    tracker = DependencyTracker(func_with_comprehension, DependencyTestState)\n\n    expected_deps = {DependencyTestState.get_full_name(): {\"items\", \"count\"}}\n    assert tracker.dependencies == expected_deps\n\n\ndef test_invalid_attribute_access():\n    \"\"\"Test that accessing invalid attributes raises VarValueError.\"\"\"\n\n    def invalid_func(self: DependencyTestState):\n        return self.parent_state\n\n    with pytest.raises(\n        VarValueError, match=\"cannot access arbitrary state via `parent_state`\"\n    ):\n        DependencyTracker(invalid_func, DependencyTestState)\n\n\ndef test_get_state_functionality():\n    \"\"\"Test tracking dependencies when using get_state.\"\"\"\n\n    async def func_with_get_state(self: DependencyTestState):\n        other_state = await self.get_state(AnotherTestState)\n        return other_state.value\n\n    tracker = DependencyTracker(func_with_get_state, DependencyTestState)\n\n    expected_deps = {AnotherTestState.get_full_name(): {\"value\"}}\n    assert tracker.dependencies == expected_deps\n\n\ndef test_get_state_with_local_var_error():\n    \"\"\"Test that get_state with local variables raises appropriate error.\"\"\"\n\n    async def invalid_get_state_func(self: DependencyTestState):\n        state_cls = AnotherTestState\n        return (await self.get_state(state_cls)).value\n\n    with pytest.raises(\n        VarValueError, match=\"cannot identify get_state class from local var\"\n    ):\n        DependencyTracker(invalid_get_state_func, DependencyTestState)\n\n\n@pytest.mark.skipif(\n    sys.version_info < (3, 11), reason=\"Requires Python 3.11+ for positions\"\n)\ndef test_get_var_value_functionality():\n    \"\"\"Test tracking dependencies when using get_var_value.\"\"\"\n\n    async def func_with_get_var_value(self: DependencyTestState):\n        return await self.get_var_value(DependencyTestState.count)\n\n    tracker = DependencyTracker(func_with_get_var_value, DependencyTestState)\n    expected_deps = {DependencyTestState.get_full_name(): {\"count\"}}\n    assert tracker.dependencies == expected_deps\n\n\n@pytest.mark.skipif(\n    sys.version_info < (3, 11), reason=\"Requires Python 3.11+ for positions\"\n)\ndef test_get_var_value_multiple_lines_functionality():\n    \"\"\"Test tracking dependencies when using get_var_value spread out on multiple lines.\"\"\"\n\n    async def func_with_get_var_value(self: DependencyTestState):\n        return await self.get_var_value(\n            DependencyTestState.\n            # annoying comment\n            count\n        )\n\n    tracker = DependencyTracker(func_with_get_var_value, DependencyTestState)\n    expected_deps = {DependencyTestState.get_full_name(): {\"count\"}}\n    assert tracker.dependencies == expected_deps\n\n\ndef test_merge_deps():\n    \"\"\"Test merging dependencies from multiple trackers.\"\"\"\n\n    def func1(self: DependencyTestState):\n        return self.count\n\n    def func2(self: DependencyTestState):\n        return self.name\n\n    tracker1 = DependencyTracker(func1, DependencyTestState)\n    tracker2 = DependencyTracker(func2, DependencyTestState)\n\n    tracker1._merge_deps(tracker2)\n\n    expected_deps = {DependencyTestState.get_full_name(): {\"count\", \"name\"}}\n    assert tracker1.dependencies == expected_deps\n\n\ndef test_get_globals_with_function():\n    \"\"\"Test _get_globals method with a function.\"\"\"\n\n    def test_func(self: DependencyTestState):\n        return self.count\n\n    tracker = DependencyTracker(test_func, DependencyTestState)\n    globals_dict = tracker._get_globals()\n\n    assert isinstance(globals_dict, dict)\n    assert \"DependencyTestState\" in globals_dict\n    assert \"State\" in globals_dict\n\n\ndef test_get_globals_with_code_object():\n    \"\"\"Test _get_globals method with a code object.\"\"\"\n\n    def test_func(self: DependencyTestState):\n        return self.count\n\n    code_obj = test_func.__code__\n    tracker = DependencyTracker(code_obj, DependencyTestState)\n    globals_dict = tracker._get_globals()\n\n    assert not globals_dict\n\n\ndef test_get_closure_with_function():\n    \"\"\"Test _get_closure method with a function that has closure.\"\"\"\n    outer_var = \"test\"\n\n    def func_with_closure(self: DependencyTestState):\n        return self.count + len(outer_var)\n\n    tracker = DependencyTracker(func_with_closure, DependencyTestState)\n    closure_dict = tracker._get_closure()\n\n    assert isinstance(closure_dict, dict)\n    assert \"outer_var\" in closure_dict\n    assert closure_dict[\"outer_var\"] == \"test\"\n\n\ndef test_get_closure_with_code_object():\n    \"\"\"Test _get_closure method with a code object.\"\"\"\n\n    def test_func(self: DependencyTestState):\n        return self.count\n\n    code_obj = test_func.__code__\n    tracker = DependencyTracker(code_obj, DependencyTestState)\n    closure_dict = tracker._get_closure()\n\n    assert not closure_dict\n\n\ndef test_property_dependencies():\n    \"\"\"Test tracking dependencies through property access.\"\"\"\n\n    class StateWithProperty(State):\n        _value: int = 0\n\n        def computed_value(self) -> int:\n            return self._value * 2\n\n        def func_with_property(self):\n            return self.computed_value\n\n    tracker = DependencyTracker(StateWithProperty.func_with_property, StateWithProperty)\n\n    # Should track dependencies from the property getter\n    expected_deps = {StateWithProperty.get_full_name(): {\"_value\"}}\n    assert tracker.dependencies == expected_deps\n\n\ndef test_no_dependencies():\n    \"\"\"Test functions with no state dependencies.\"\"\"\n\n    def func_no_deps(self: DependencyTestState):\n        return 42\n\n    tracker = DependencyTracker(func_no_deps, DependencyTestState)\n\n    assert not tracker.dependencies\n\n\ndef test_complex_expression_dependencies():\n    \"\"\"Test tracking dependencies in complex expressions.\"\"\"\n\n    def complex_func(self: DependencyTestState):\n        return (self.count * 2 + len(self.name)) if self.items else 0\n\n    tracker = DependencyTracker(complex_func, DependencyTestState)\n\n    expected_deps = {DependencyTestState.get_full_name(): {\"count\", \"name\", \"items\"}}\n    assert tracker.dependencies == expected_deps\n\n\ndef test_get_cell_value_with_valid_cell():\n    \"\"\"Test get_cell_value with a valid cell containing a value.\"\"\"\n    # Create a closure to get a cell object\n    value = \"test_value\"\n\n    def outer():\n        def inner():\n            return value\n\n        return inner\n\n    inner_func = outer()\n\n    assert inner_func.__closure__ is not None\n\n    cell = inner_func.__closure__[0]\n    result = get_cell_value(cell)\n    assert result == \"test_value\"\n\n\ndef test_cross_state_dependencies_complex():\n    \"\"\"Test complex cross-state dependency scenarios.\"\"\"\n\n    class StateA(State):\n        value_a: int = 1\n\n    class StateB(State):\n        value_b: int = 2\n\n    async def complex_cross_state_func(self: DependencyTestState):\n        state_a = await self.get_state(StateA)\n        state_b = await self.get_state(StateB)\n        return state_a.value_a + state_b.value_b\n\n    tracker = DependencyTracker(complex_cross_state_func, DependencyTestState)\n\n    expected_deps = {\n        StateA.get_full_name(): {\"value_a\"},\n        StateB.get_full_name(): {\"value_b\"},\n    }\n    assert tracker.dependencies == expected_deps\n\n\ndef test_dependencies_with_computed_var():\n    \"\"\"Test that computed vars are handled correctly in dependency tracking.\"\"\"\n\n    class StateWithComputedVar(State):\n        base_value: int = 0\n\n        @rx.var\n        def computed_value(self) -> int:\n            return self.base_value * 2\n\n    def func_using_computed_var(self: StateWithComputedVar):\n        return self.computed_value\n\n    tracker = DependencyTracker(func_using_computed_var, StateWithComputedVar)\n\n    # Should track the computed var, not its dependencies\n    expected_deps = {StateWithComputedVar.get_full_name(): {\"computed_value\"}}\n    assert tracker.dependencies == expected_deps\n"
