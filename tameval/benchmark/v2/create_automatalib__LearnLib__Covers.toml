[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Java"
java_builder = "Maven"
is_multi_module = true

[repo_info]
repository = "LearnLib/automatalib"
sha = "125bd7267571158b87da3e5dbe92f505ce1729a5"

[run_info]
docker_image = "maven:3.8.3-openjdk-17"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "mvn -Dmaven.repo.local=/.m2 -T 4 clean install"
test_run_command = "mvn clean -Dmaven.repo.local=/.m2 test -q -pl util -Dtest=CoversTest && mvn jacoco:report -Djacoco.append=false"
mutation_run_command = "mvn -Dmaven.repo.local=/.m2 org.pitest:pitest-maven:mutationCoverage -pl util -DtargetClasses=**.Covers  -DtargetTests=**.CoversTest  -DoutputFormats=XML"
coverage_report_path = "util/target/site/jacoco/jacoco.xml"
coverage_report_type = "jacoco"
mutation_report_path = "util/target/pit-reports/mutations.xml"
mutation_report_type = "pitest"

[coverage]
coverage = 22.0
original_coverage = 67.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = [ 31, 307, 360, 471, 473, 474, 475, 476, 482, 483, 484, 485, 487, 497, 499, 500, 501, 503, 504, 506, 507, 508, 509, 510, 513, 514, 517, 518,]
missed_lines = [ 56, 57, 76, 101, 102, 121, 144, 145, 168, 169, 176, 178, 179, 182, 183, 185, 186, 188, 192, 193, 194, 196, 197, 198, 199, 202, 204, 205, 206, 207, 209, 210, 211, 212, 239, 241, 242, 245, 247, 249, 251, 253, 255, 256, 257, 258, 259, 263, 264, 265, 267, 268, 269, 270, 273, 274, 275, 276, 277, 278, 279, 281, 282, 284, 333, 335, 337, 392, 393, 395, 397, 407, 409, 410, 413, 415, 417, 421, 423, 425, 426, 427, 428, 432, 436, 440, 441, 442, 444, 445, 446, 448, 450, 451, 452, 454, 457, 458, 461, 463, 477,]

[input_info]
test_file_path = "util/src/test/java/net/automatalib/util/automaton/cover/CoversTest.java"
focal_file_path = "util/src/main/java/net/automatalib/util/automaton/cover/Covers.java"
test_file_url = "https://github.com/LearnLib/automatalib/blob/125bd7267571158b87da3e5dbe92f505ce1729a5/util/src/test/java/net/automatalib/util/automaton/cover/CoversTest.java"
focal_file_url = "https://github.com/LearnLib/automatalib/blob/125bd7267571158b87da3e5dbe92f505ce1729a5/util/src/main/java/net/automatalib/util/automaton/cover/Covers.java"
first_commit_date = "2023-10-10"
last_commit_date = "2025-01-16"
test_file_content = "/* Copyright (C) 2013-2025 TU Dortmund University\n * This file is part of AutomataLib <https://automatalib.net>.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.automatalib.util.automaton.cover;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.Set;\n\nimport net.automatalib.alphabet.Alphabet;\nimport net.automatalib.alphabet.impl.Alphabets;\nimport net.automatalib.automaton.UniversalDeterministicAutomaton;\nimport net.automatalib.automaton.fsa.DFA;\nimport net.automatalib.automaton.fsa.impl.CompactDFA;\nimport net.automatalib.common.util.collection.IteratorUtil;\nimport net.automatalib.common.util.mapping.Mapping;\nimport net.automatalib.util.automaton.Automata;\nimport net.automatalib.util.automaton.random.RandomAutomata;\nimport net.automatalib.util.graph.Graphs;\nimport net.automatalib.word.Word;\nimport org.testng.Assert;\nimport org.testng.annotations.Test;\n\n@Test\npublic class CoversTest {\n\n    private final Alphabet<Integer> alphabet = Alphabets.integers(0, 2);\n    final CompactDFA<Integer> dfa = new CompactDFA<>(alphabet);\n\n    private final List<Word<Integer>> stateCover = new ArrayList<>();\n    private final List<Word<Integer>> transCover = new ArrayList<>();\n\n    private final List<Word<Integer>> newStates = new ArrayList<>();\n    private final List<Word<Integer>> newTransitions = new ArrayList<>();\n    private final List<Word<Integer>> newStructural = new ArrayList<>();\n\n    private final List<Word<Integer>> expectedNewStateCover = new ArrayList<>();\n    private final List<Word<Integer>> expectedNewTransCover = new ArrayList<>();\n    private final List<Word<Integer>> expectedNewStructuralCover = new ArrayList<>();\n\n\n    private void checkCovers() {\n        Assert.assertEquals(newStates, expectedNewStateCover);\n        Assert.assertEquals(newTransitions, expectedNewTransCover);\n    }\n\n    private void updateAndClearCovers() {\n        stateCover.addAll(newStates);\n        transCover.addAll(newTransitions);\n\n        newStates.clear();\n        newTransitions.clear();\n\n        expectedNewStateCover.clear();\n        expectedNewTransCover.clear();\n    }\n\n\n\n\n    @Test\n    public void testIncrementalIteratorWithUnreachableOldCovers() {\n        final CompactDFA<Integer> dfa = new CompactDFA<>(alphabet);\n        final int q0 = dfa.addInitialState();\n        final int q1 = dfa.addState();\n        dfa.setTransition(q0, 0, q1);\n\n        final Collection<Word<Integer>> oldStateCover = Arrays.asList(Word.epsilon(), Word.fromLetter(1));\n        final Collection<Word<Integer>> oldTransCover = Collections.singleton(Word.fromSymbols(0, 0));\n        final List<Word<Integer>> newStateCover =\n                IteratorUtil.list(Covers.incrementalStateCoverIterator(dfa, alphabet, oldStateCover));\n        final List<Word<Integer>> newTransCover =\n                IteratorUtil.list(Covers.incrementalTransitionCoverIterator(dfa, alphabet, oldTransCover));\n\n        Assert.assertEquals(newStateCover, Collections.singleton(Word.fromLetter(0)));\n        Assert.assertEquals(newTransCover, Collections.singleton(Word.fromLetter(0)));\n    }\n\n    private static <S, I> void testStateCover(UniversalDeterministicAutomaton<S, I, ?, ?, ?> automaton,\n                                              Alphabet<I> alphabet,\n                                              Collection<Word<I>> cover) {\n\n        final Set<S> states = new HashSet<>(automaton.getStates());\n\n        for (Word<I> w : cover) {\n            Assert.assertTrue(states.remove(automaton.getState(w)));\n        }\n\n        final Mapping<S, ? extends Collection<?>> mapping =\n                Graphs.incomingEdges(automaton.transitionGraphView(alphabet));\n\n        for (S s : states) {\n            final Collection<?> incoming = mapping.get(s);\n            Assert.assertTrue(incoming == null || incoming.isEmpty());\n        }\n    }\n\n    private static <S, I, T> void testTransitionCover(UniversalDeterministicAutomaton<S, I, T, ?, ?> automaton,\n                                                      Alphabet<I> alphabet,\n                                                      Collection<Word<I>> cover) {\n\n        final List<T> transitions = new ArrayList<>(automaton.size() * alphabet.size());\n\n        for (S s : automaton.getStates()) {\n            for (I i : alphabet) {\n                T t = automaton.getTransition(s, i);\n                if (t != null) {\n                    transitions.add(t);\n                }\n            }\n        }\n\n        Assert.assertEquals(cover.size(), transitions.size()); // make sure we only cover defined transitions\n\n        for (Word<I> w : cover) {\n            final S s = automaton.getState(w.prefix(-1));\n            Assert.assertTrue(transitions.remove(automaton.getTransition(s, w.lastSymbol())));\n        }\n\n        Assert.assertTrue(transitions.isEmpty()); // make sure we cover all defined transitions\n    }\n}\n"
