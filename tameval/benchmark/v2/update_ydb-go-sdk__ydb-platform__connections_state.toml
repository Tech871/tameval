[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.22.5"

[repo_info]
repository = "ydb-platform/ydb-go-sdk"
sha = "6ecec32a4ff86f5a4f92e3d35aa1c1a4cf1b63d3"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/balancer/connections_state.go internal/balancer/connections_state_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/balancer/connections_state.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 86.0
mutation_kill_rate = nan
original_mutation_kill_rate = 70.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "internal/balancer/connections_state_test.go"
focal_file_path = "internal/balancer/connections_state.go"
test_file_url = "https://github.com/ydb-platform/ydb-go-sdk/blob/6ecec32a4ff86f5a4f92e3d35aa1c1a4cf1b63d3/internal/balancer/connections_state_test.go"
focal_file_url = "https://github.com/ydb-platform/ydb-go-sdk/blob/6ecec32a4ff86f5a4f92e3d35aa1c1a4cf1b63d3/internal/balancer/connections_state.go"
first_commit_date = "2022-05-20"
last_commit_date = "2025-03-12"
test_file_content = "package balancer\n\nimport (\n\t\"context\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\n\tbalancerConfig \"github.com/ydb-platform/ydb-go-sdk/v3/internal/balancer/config\"\n\t\"github.com/ydb-platform/ydb-go-sdk/v3/internal/conn\"\n\t\"github.com/ydb-platform/ydb-go-sdk/v3/internal/endpoint\"\n\t\"github.com/ydb-platform/ydb-go-sdk/v3/internal/mock\"\n)\n\nfunc TestConnsToNodeIDMap(t *testing.T) {\n\ttable := []struct {\n\t\tname   string\n\t\tsource []conn.Conn\n\t\tres    map[uint32]conn.Conn\n\t}{\n\t\t{\n\t\t\tname:   \"Empty\",\n\t\t\tsource: nil,\n\t\t\tres:    nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Zero\",\n\t\t\tsource: []conn.Conn{\n\t\t\t\t&mock.Conn{NodeIDField: 0},\n\t\t\t},\n\t\t\tres: map[uint32]conn.Conn{\n\t\t\t\t0: &mock.Conn{NodeIDField: 0},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NonZero\",\n\t\t\tsource: []conn.Conn{\n\t\t\t\t&mock.Conn{NodeIDField: 1},\n\t\t\t\t&mock.Conn{NodeIDField: 10},\n\t\t\t},\n\t\t\tres: map[uint32]conn.Conn{\n\t\t\t\t1:  &mock.Conn{NodeIDField: 1},\n\t\t\t\t10: &mock.Conn{NodeIDField: 10},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Combined\",\n\t\t\tsource: []conn.Conn{\n\t\t\t\t&mock.Conn{NodeIDField: 1},\n\t\t\t\t&mock.Conn{NodeIDField: 0},\n\t\t\t\t&mock.Conn{NodeIDField: 10},\n\t\t\t},\n\t\t\tres: map[uint32]conn.Conn{\n\t\t\t\t0:  &mock.Conn{NodeIDField: 0},\n\t\t\t\t1:  &mock.Conn{NodeIDField: 1},\n\t\t\t\t10: &mock.Conn{NodeIDField: 10},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range table {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\trequire.Equal(t, test.res, connsToNodeIDMap(test.source))\n\t\t})\n\t}\n}\n\ntype filterFunc func(info balancerConfig.Info, c conn.Conn) bool\n\nfunc (f filterFunc) Allow(info balancerConfig.Info, c conn.Conn) bool {\n\treturn f(info, c)\n}\n\nfunc (f filterFunc) String() string {\n\treturn \"Custom\"\n}\n\nfunc TestSortPreferConnections(t *testing.T) {\n\ttable := []struct {\n\t\tname          string\n\t\tsource        []conn.Conn\n\t\tallowFallback bool\n\t\tfilter        balancerConfig.Filter\n\t\tprefer        []conn.Conn\n\t\tfallback      []conn.Conn\n\t}{\n\t\t{\n\t\t\tname:          \"Empty\",\n\t\t\tsource:        nil,\n\t\t\tallowFallback: false,\n\t\t\tfilter:        nil,\n\t\t\tprefer:        nil,\n\t\t\tfallback:      nil,\n\t\t},\n\t\t{\n\t\t\tname: \"NilFilter\",\n\t\t\tsource: []conn.Conn{\n\t\t\t\t&mock.Conn{AddrField: \"1\"},\n\t\t\t\t&mock.Conn{AddrField: \"2\"},\n\t\t\t},\n\t\t\tallowFallback: false,\n\t\t\tfilter:        nil,\n\t\t\tprefer: []conn.Conn{\n\t\t\t\t&mock.Conn{AddrField: \"1\"},\n\t\t\t\t&mock.Conn{AddrField: \"2\"},\n\t\t\t},\n\t\t\tfallback: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"FilterNoFallback\",\n\t\t\tsource: []conn.Conn{\n\t\t\t\t&mock.Conn{AddrField: \"t1\"},\n\t\t\t\t&mock.Conn{AddrField: \"f1\"},\n\t\t\t\t&mock.Conn{AddrField: \"t2\"},\n\t\t\t\t&mock.Conn{AddrField: \"f2\"},\n\t\t\t},\n\t\t\tallowFallback: false,\n\t\t\tfilter: filterFunc(func(_ balancerConfig.Info, c conn.Conn) bool {\n\t\t\t\treturn strings.HasPrefix(c.Endpoint().Address(), \"t\")\n\t\t\t}),\n\t\t\tprefer: []conn.Conn{\n\t\t\t\t&mock.Conn{AddrField: \"t1\"},\n\t\t\t\t&mock.Conn{AddrField: \"t2\"},\n\t\t\t},\n\t\t\tfallback: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"FilterWithFallback\",\n\t\t\tsource: []conn.Conn{\n\t\t\t\t&mock.Conn{AddrField: \"t1\"},\n\t\t\t\t&mock.Conn{AddrField: \"f1\"},\n\t\t\t\t&mock.Conn{AddrField: \"t2\"},\n\t\t\t\t&mock.Conn{AddrField: \"f2\"},\n\t\t\t},\n\t\t\tallowFallback: true,\n\t\t\tfilter: filterFunc(func(_ balancerConfig.Info, c conn.Conn) bool {\n\t\t\t\treturn strings.HasPrefix(c.Endpoint().Address(), \"t\")\n\t\t\t}),\n\t\t\tprefer: []conn.Conn{\n\t\t\t\t&mock.Conn{AddrField: \"t1\"},\n\t\t\t\t&mock.Conn{AddrField: \"t2\"},\n\t\t\t},\n\t\t\tfallback: []conn.Conn{\n\t\t\t\t&mock.Conn{AddrField: \"f1\"},\n\t\t\t\t&mock.Conn{AddrField: \"f2\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range table {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tprefer, fallback := sortPreferConnections(test.source, test.filter, balancerConfig.Info{}, test.allowFallback)\n\t\t\trequire.Equal(t, test.prefer, prefer)\n\t\t\trequire.Equal(t, test.fallback, fallback)\n\t\t})\n\t}\n}\n\nfunc TestSelectRandomConnection(t *testing.T) {\n\ts := newConnectionsState(nil, nil, balancerConfig.Info{}, false)\n\n\tt.Run(\"Empty\", func(t *testing.T) {\n\t\tc, failedCount := s.selectRandomConnection(nil, false)\n\t\trequire.Nil(t, c)\n\t\trequire.Equal(t, 0, failedCount)\n\t})\n\n\tt.Run(\"One\", func(t *testing.T) {\n\t\tfor _, goodState := range []conn.State{conn.Online, conn.Offline, conn.Created} {\n\t\t\tc, failedCount := s.selectRandomConnection([]conn.Conn{&mock.Conn{AddrField: \"asd\", State: goodState}}, false)\n\t\t\trequire.Equal(t, &mock.Conn{AddrField: \"asd\", State: goodState}, c)\n\t\t\trequire.Equal(t, 0, failedCount)\n\t\t}\n\t})\n\tt.Run(\"OneBanned\", func(t *testing.T) {\n\t\tc, failedCount := s.selectRandomConnection([]conn.Conn{&mock.Conn{AddrField: \"asd\", State: conn.Banned}}, false)\n\t\trequire.Nil(t, c)\n\t\trequire.Equal(t, 1, failedCount)\n\n\t\tc, failedCount = s.selectRandomConnection([]conn.Conn{&mock.Conn{AddrField: \"asd\", State: conn.Banned}}, true)\n\t\trequire.Equal(t, &mock.Conn{AddrField: \"asd\", State: conn.Banned}, c)\n\t\trequire.Equal(t, 0, failedCount)\n\t})\n\tt.Run(\"Two\", func(t *testing.T) {\n\t\tconns := []conn.Conn{\n\t\t\t&mock.Conn{AddrField: \"1\", State: conn.Online},\n\t\t\t&mock.Conn{AddrField: \"2\", State: conn.Online},\n\t\t}\n\t\tfirst := 0\n\t\tsecond := 0\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tc, _ := s.selectRandomConnection(conns, false)\n\t\t\tif c.Endpoint().Address() == \"1\" {\n\t\t\t\tfirst++\n\t\t\t} else {\n\t\t\t\tsecond++\n\t\t\t}\n\t\t}\n\t\trequire.Equal(t, 100, first+second)\n\t\trequire.InDelta(t, 50, first, 21)\n\t\trequire.InDelta(t, 50, second, 21)\n\t})\n\tt.Run(\"TwoBanned\", func(t *testing.T) {\n\t\tconns := []conn.Conn{\n\t\t\t&mock.Conn{AddrField: \"1\", State: conn.Banned},\n\t\t\t&mock.Conn{AddrField: \"2\", State: conn.Banned},\n\t\t}\n\t\ttotalFailed := 0\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tc, failed := s.selectRandomConnection(conns, false)\n\t\t\trequire.Nil(t, c)\n\t\t\ttotalFailed += failed\n\t\t}\n\t\trequire.Equal(t, 200, totalFailed)\n\t})\n\tt.Run(\"ThreeWithBanned\", func(t *testing.T) {\n\t\tconns := []conn.Conn{\n\t\t\t&mock.Conn{AddrField: \"1\", State: conn.Online},\n\t\t\t&mock.Conn{AddrField: \"2\", State: conn.Online},\n\t\t\t&mock.Conn{AddrField: \"3\", State: conn.Banned},\n\t\t}\n\t\tfirst := 0\n\t\tsecond := 0\n\t\tfailed := 0\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tc, checkFailed := s.selectRandomConnection(conns, false)\n\t\t\tfailed += checkFailed\n\t\t\tswitch c.Endpoint().Address() {\n\t\t\tcase \"1\":\n\t\t\t\tfirst++\n\t\t\tcase \"2\":\n\t\t\t\tsecond++\n\t\t\tdefault:\n\t\t\t\tt.Errorf(c.Endpoint().Address())\n\t\t\t}\n\t\t}\n\t\trequire.Equal(t, 100, first+second)\n\t\trequire.InDelta(t, 50, first, 21)\n\t\trequire.InDelta(t, 50, second, 21)\n\t\trequire.Greater(t, 10, failed)\n\t})\n}\n\nfunc TestNewState(t *testing.T) {\n\ttable := []struct {\n\t\tname  string\n\t\tstate *connectionsState\n\t\tres   *connectionsState\n\t}{\n\t\t{\n\t\t\tname:  \"Empty\",\n\t\t\tstate: newConnectionsState(nil, nil, balancerConfig.Info{}, false),\n\t\t\tres: &connectionsState{\n\t\t\t\tconnByNodeID: nil,\n\t\t\t\tprefer:       nil,\n\t\t\t\tfallback:     nil,\n\t\t\t\tall:          nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"NoFilter\",\n\t\t\tstate: newConnectionsState([]conn.Conn{\n\t\t\t\t&mock.Conn{AddrField: \"1\", NodeIDField: 1},\n\t\t\t\t&mock.Conn{AddrField: \"2\", NodeIDField: 2},\n\t\t\t}, nil, balancerConfig.Info{}, false),\n\t\t\tres: &connectionsState{\n\t\t\t\tconnByNodeID: map[uint32]conn.Conn{\n\t\t\t\t\t1: &mock.Conn{AddrField: \"1\", NodeIDField: 1},\n\t\t\t\t\t2: &mock.Conn{AddrField: \"2\", NodeIDField: 2},\n\t\t\t\t},\n\t\t\t\tprefer: []conn.Conn{\n\t\t\t\t\t&mock.Conn{AddrField: \"1\", NodeIDField: 1},\n\t\t\t\t\t&mock.Conn{AddrField: \"2\", NodeIDField: 2},\n\t\t\t\t},\n\t\t\t\tfallback: nil,\n\t\t\t\tall: []conn.Conn{\n\t\t\t\t\t&mock.Conn{AddrField: \"1\", NodeIDField: 1},\n\t\t\t\t\t&mock.Conn{AddrField: \"2\", NodeIDField: 2},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"FilterDenyFallback\",\n\t\t\tstate: newConnectionsState([]conn.Conn{\n\t\t\t\t&mock.Conn{AddrField: \"t1\", NodeIDField: 1, LocationField: \"t\"},\n\t\t\t\t&mock.Conn{AddrField: \"f1\", NodeIDField: 2, LocationField: \"f\"},\n\t\t\t\t&mock.Conn{AddrField: \"t2\", NodeIDField: 3, LocationField: \"t\"},\n\t\t\t\t&mock.Conn{AddrField: \"f2\", NodeIDField: 4, LocationField: \"f\"},\n\t\t\t}, filterFunc(func(info balancerConfig.Info, c conn.Conn) bool {\n\t\t\t\treturn info.SelfLocation == c.Endpoint().Location()\n\t\t\t}), balancerConfig.Info{SelfLocation: \"t\"}, false),\n\t\t\tres: &connectionsState{\n\t\t\t\tconnByNodeID: map[uint32]conn.Conn{\n\t\t\t\t\t1: &mock.Conn{AddrField: \"t1\", NodeIDField: 1, LocationField: \"t\"},\n\t\t\t\t\t2: &mock.Conn{AddrField: \"f1\", NodeIDField: 2, LocationField: \"f\"},\n\t\t\t\t\t3: &mock.Conn{AddrField: \"t2\", NodeIDField: 3, LocationField: \"t\"},\n\t\t\t\t\t4: &mock.Conn{AddrField: \"f2\", NodeIDField: 4, LocationField: \"f\"},\n\t\t\t\t},\n\t\t\t\tprefer: []conn.Conn{\n\t\t\t\t\t&mock.Conn{AddrField: \"t1\", NodeIDField: 1, LocationField: \"t\"},\n\t\t\t\t\t&mock.Conn{AddrField: \"t2\", NodeIDField: 3, LocationField: \"t\"},\n\t\t\t\t},\n\t\t\t\tfallback: nil,\n\t\t\t\tall: []conn.Conn{\n\t\t\t\t\t&mock.Conn{AddrField: \"t1\", NodeIDField: 1, LocationField: \"t\"},\n\t\t\t\t\t&mock.Conn{AddrField: \"t2\", NodeIDField: 3, LocationField: \"t\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"FilterAllowFallback\",\n\t\t\tstate: newConnectionsState([]conn.Conn{\n\t\t\t\t&mock.Conn{AddrField: \"t1\", NodeIDField: 1, LocationField: \"t\"},\n\t\t\t\t&mock.Conn{AddrField: \"f1\", NodeIDField: 2, LocationField: \"f\"},\n\t\t\t\t&mock.Conn{AddrField: \"t2\", NodeIDField: 3, LocationField: \"t\"},\n\t\t\t\t&mock.Conn{AddrField: \"f2\", NodeIDField: 4, LocationField: \"f\"},\n\t\t\t}, filterFunc(func(info balancerConfig.Info, c conn.Conn) bool {\n\t\t\t\treturn info.SelfLocation == c.Endpoint().Location()\n\t\t\t}), balancerConfig.Info{SelfLocation: \"t\"}, true),\n\t\t\tres: &connectionsState{\n\t\t\t\tconnByNodeID: map[uint32]conn.Conn{\n\t\t\t\t\t1: &mock.Conn{AddrField: \"t1\", NodeIDField: 1, LocationField: \"t\"},\n\t\t\t\t\t2: &mock.Conn{AddrField: \"f1\", NodeIDField: 2, LocationField: \"f\"},\n\t\t\t\t\t3: &mock.Conn{AddrField: \"t2\", NodeIDField: 3, LocationField: \"t\"},\n\t\t\t\t\t4: &mock.Conn{AddrField: \"f2\", NodeIDField: 4, LocationField: \"f\"},\n\t\t\t\t},\n\t\t\t\tprefer: []conn.Conn{\n\t\t\t\t\t&mock.Conn{AddrField: \"t1\", NodeIDField: 1, LocationField: \"t\"},\n\t\t\t\t\t&mock.Conn{AddrField: \"t2\", NodeIDField: 3, LocationField: \"t\"},\n\t\t\t\t},\n\t\t\t\tfallback: []conn.Conn{\n\t\t\t\t\t&mock.Conn{AddrField: \"f1\", NodeIDField: 2, LocationField: \"f\"},\n\t\t\t\t\t&mock.Conn{AddrField: \"f2\", NodeIDField: 4, LocationField: \"f\"},\n\t\t\t\t},\n\t\t\t\tall: []conn.Conn{\n\t\t\t\t\t&mock.Conn{AddrField: \"t1\", NodeIDField: 1, LocationField: \"t\"},\n\t\t\t\t\t&mock.Conn{AddrField: \"f1\", NodeIDField: 2, LocationField: \"f\"},\n\t\t\t\t\t&mock.Conn{AddrField: \"t2\", NodeIDField: 3, LocationField: \"t\"},\n\t\t\t\t\t&mock.Conn{AddrField: \"f2\", NodeIDField: 4, LocationField: \"f\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"WithNodeID\",\n\t\t\tstate: newConnectionsState([]conn.Conn{\n\t\t\t\t&mock.Conn{AddrField: \"t1\", NodeIDField: 1, LocationField: \"t\"},\n\t\t\t\t&mock.Conn{AddrField: \"f1\", NodeIDField: 2, LocationField: \"f\"},\n\t\t\t\t&mock.Conn{AddrField: \"t2\", NodeIDField: 3, LocationField: \"t\"},\n\t\t\t\t&mock.Conn{AddrField: \"f2\", NodeIDField: 4, LocationField: \"f\"},\n\t\t\t}, filterFunc(func(info balancerConfig.Info, c conn.Conn) bool {\n\t\t\t\treturn info.SelfLocation == c.Endpoint().Location()\n\t\t\t}), balancerConfig.Info{SelfLocation: \"t\"}, true),\n\t\t\tres: &connectionsState{\n\t\t\t\tconnByNodeID: map[uint32]conn.Conn{\n\t\t\t\t\t1: &mock.Conn{AddrField: \"t1\", NodeIDField: 1, LocationField: \"t\"},\n\t\t\t\t\t2: &mock.Conn{AddrField: \"f1\", NodeIDField: 2, LocationField: \"f\"},\n\t\t\t\t\t3: &mock.Conn{AddrField: \"t2\", NodeIDField: 3, LocationField: \"t\"},\n\t\t\t\t\t4: &mock.Conn{AddrField: \"f2\", NodeIDField: 4, LocationField: \"f\"},\n\t\t\t\t},\n\t\t\t\tprefer: []conn.Conn{\n\t\t\t\t\t&mock.Conn{AddrField: \"t1\", NodeIDField: 1, LocationField: \"t\"},\n\t\t\t\t\t&mock.Conn{AddrField: \"t2\", NodeIDField: 3, LocationField: \"t\"},\n\t\t\t\t},\n\t\t\t\tfallback: []conn.Conn{\n\t\t\t\t\t&mock.Conn{AddrField: \"f1\", NodeIDField: 2, LocationField: \"f\"},\n\t\t\t\t\t&mock.Conn{AddrField: \"f2\", NodeIDField: 4, LocationField: \"f\"},\n\t\t\t\t},\n\t\t\t\tall: []conn.Conn{\n\t\t\t\t\t&mock.Conn{AddrField: \"t1\", NodeIDField: 1, LocationField: \"t\"},\n\t\t\t\t\t&mock.Conn{AddrField: \"f1\", NodeIDField: 2, LocationField: \"f\"},\n\t\t\t\t\t&mock.Conn{AddrField: \"t2\", NodeIDField: 3, LocationField: \"t\"},\n\t\t\t\t\t&mock.Conn{AddrField: \"f2\", NodeIDField: 4, LocationField: \"f\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range table {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\trequire.NotNil(t, test.state.rand)\n\t\t\ttest.state.rand = nil\n\t\t\trequire.Equal(t, test.res, test.state)\n\t\t})\n\t}\n}\n\nfunc TestConnection(t *testing.T) {\n\tt.Run(\"Empty\", func(t *testing.T) {\n\t\ts := newConnectionsState(nil, nil, balancerConfig.Info{}, false)\n\t\tc, failed := s.GetConnection(context.Background())\n\t\trequire.Nil(t, c)\n\t\trequire.Equal(t, 0, failed)\n\t})\n\tt.Run(\"AllGood\", func(t *testing.T) {\n\t\ts := newConnectionsState([]conn.Conn{\n\t\t\t&mock.Conn{AddrField: \"1\", State: conn.Online},\n\t\t\t&mock.Conn{AddrField: \"2\", State: conn.Online},\n\t\t}, nil, balancerConfig.Info{}, false)\n\t\tc, failed := s.GetConnection(context.Background())\n\t\trequire.NotNil(t, c)\n\t\trequire.Equal(t, 0, failed)\n\t})\n\tt.Run(\"WithBanned\", func(t *testing.T) {\n\t\ts := newConnectionsState([]conn.Conn{\n\t\t\t&mock.Conn{AddrField: \"1\", State: conn.Online},\n\t\t\t&mock.Conn{AddrField: \"2\", State: conn.Banned},\n\t\t}, nil, balancerConfig.Info{}, false)\n\t\tc, _ := s.GetConnection(context.Background())\n\t\trequire.Equal(t, &mock.Conn{AddrField: \"1\", State: conn.Online}, c)\n\t})\n\tt.Run(\"AllBanned\", func(t *testing.T) {\n\t\ts := newConnectionsState([]conn.Conn{\n\t\t\t&mock.Conn{AddrField: \"t1\", State: conn.Banned, LocationField: \"t\"},\n\t\t\t&mock.Conn{AddrField: \"f2\", State: conn.Banned, LocationField: \"f\"},\n\t\t}, filterFunc(func(info balancerConfig.Info, c conn.Conn) bool {\n\t\t\treturn c.Endpoint().Location() == info.SelfLocation\n\t\t}), balancerConfig.Info{}, true)\n\t\tpreferred := 0\n\t\tfallback := 0\n\t\tfor i := 0; i < 100; i++ {\n\t\t\tc, failed := s.GetConnection(context.Background())\n\t\t\trequire.NotNil(t, c)\n\t\t\trequire.Equal(t, 2, failed)\n\t\t\tif c.Endpoint().Address() == \"t1\" {\n\t\t\t\tpreferred++\n\t\t\t} else {\n\t\t\t\tfallback++\n\t\t\t}\n\t\t}\n\t\trequire.Equal(t, 100, preferred+fallback)\n\t\trequire.InDelta(t, 50, preferred, 21)\n\t\trequire.InDelta(t, 50, fallback, 21)\n\t})\n\tt.Run(\"PreferBannedWithFallback\", func(t *testing.T) {\n\t\ts := newConnectionsState([]conn.Conn{\n\t\t\t&mock.Conn{AddrField: \"t1\", State: conn.Banned, LocationField: \"t\"},\n\t\t\t&mock.Conn{AddrField: \"f2\", State: conn.Online, LocationField: \"f\"},\n\t\t}, filterFunc(func(info balancerConfig.Info, c conn.Conn) bool {\n\t\t\treturn c.Endpoint().Location() == info.SelfLocation\n\t\t}), balancerConfig.Info{SelfLocation: \"t\"}, true)\n\t\tc, failed := s.GetConnection(context.Background())\n\t\trequire.Equal(t, &mock.Conn{AddrField: \"f2\", State: conn.Online, LocationField: \"f\"}, c)\n\t\trequire.Equal(t, 1, failed)\n\t})\n\tt.Run(\"PreferNodeID\", func(t *testing.T) {\n\t\ts := newConnectionsState([]conn.Conn{\n\t\t\t&mock.Conn{AddrField: \"1\", State: conn.Online, NodeIDField: 1},\n\t\t\t&mock.Conn{AddrField: \"2\", State: conn.Online, NodeIDField: 2},\n\t\t}, nil, balancerConfig.Info{}, false)\n\t\tc, failed := s.GetConnection(endpoint.WithNodeID(context.Background(), 2))\n\t\trequire.Equal(t, &mock.Conn{AddrField: \"2\", State: conn.Online, NodeIDField: 2}, c)\n\t\trequire.Equal(t, 0, failed)\n\t})\n\tt.Run(\"PreferNodeIDWithBadState\", func(t *testing.T) {\n\t\ts := newConnectionsState([]conn.Conn{\n\t\t\t&mock.Conn{AddrField: \"1\", State: conn.Online, NodeIDField: 1},\n\t\t\t&mock.Conn{AddrField: \"2\", State: conn.Unknown, NodeIDField: 2},\n\t\t}, nil, balancerConfig.Info{}, false)\n\t\tc, failed := s.GetConnection(endpoint.WithNodeID(context.Background(), 2))\n\t\trequire.Equal(t, &mock.Conn{AddrField: \"1\", State: conn.Online, NodeIDField: 1}, c)\n\t\trequire.Equal(t, 0, failed)\n\t})\n}"
