[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.24.4"

[repo_info]
repository = "vmware/pinniped"
sha = "e20c5beb47391281e19d13b1e22c5fd42f577686"

[run_info]
docker_image = "golang:1.24.4"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/certauthority/certauthority.go internal/certauthority/certauthority_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/certauthority/certauthority.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 95.0
mutation_kill_rate = nan
original_mutation_kill_rate = 81.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "internal/certauthority/certauthority_test.go"
focal_file_path = "internal/certauthority/certauthority.go"
test_file_url = "https://github.com/vmware/pinniped/blob/e20c5beb47391281e19d13b1e22c5fd42f577686/internal/certauthority/certauthority_test.go"
focal_file_url = "https://github.com/vmware/pinniped/blob/e20c5beb47391281e19d13b1e22c5fd42f577686/internal/certauthority/certauthority.go"
first_commit_date = "2020-07-13"
last_commit_date = "2025-07-16"
test_file_content = "// Copyright 2020-2024 the Pinniped contributors. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\npackage certauthority\n\nimport (\n\t\"crypto\"\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t_ \"embed\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n\n\t\"go.pinniped.dev/internal/testutil\"\n)\n\nvar (\n\t//go:embed testdata/empty\n\tempty string\n\t//go:embed testdata/invalid\n\tinvalid string\n\t//go:embed testdata/multiple.crt\n\tmultiple string\n\t//go:embed testdata/test.crt\n\ttestCert string\n\t//go:embed testdata/test.key\n\ttestKey string\n\t//go:embed testdata/test2.key\n\ttestKey2 string\n)\n\nfunc TestLoad(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tcert    string\n\t\tkey     string\n\t\twantErr string\n\t\ttest    []byte\n\t}{\n\t\t{\n\t\t\tname:    \"empty key\",\n\t\t\tcert:    testCert,\n\t\t\tkey:     empty,\n\t\t\twantErr: \"could not load CA: tls: failed to find any PEM data in key input\",\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid key\",\n\t\t\tcert:    testCert,\n\t\t\tkey:     invalid,\n\t\t\twantErr: \"could not load CA: tls: failed to find any PEM data in key input\",\n\t\t},\n\t\t{\n\t\t\tname:    \"mismatched cert and key\",\n\t\t\tcert:    testCert,\n\t\t\tkey:     testKey2,\n\t\t\twantErr: \"could not load CA: tls: private key does not match public key\",\n\t\t},\n\t\t{\n\t\t\tname:    \"multiple certs\",\n\t\t\tcert:    multiple,\n\t\t\tkey:     testKey,\n\t\t\twantErr: \"invalid CA certificate: expected a single certificate, found 2 certificates\",\n\t\t},\n\t\t{\n\t\t\tname: \"success\",\n\t\t\tcert: testCert,\n\t\t\tkey:  testKey,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tca, err := Load(tt.cert, tt.key)\n\t\t\tif tt.wantErr != \"\" {\n\t\t\t\trequire.EqualError(t, err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotEmpty(t, ca.caCertBytes)\n\t\t\trequire.NotNil(t, ca.signer)\n\t\t\trequire.Nil(t, ca.privateKey) // this struct field is only used for CA's created by New()\n\t\t})\n\t}\n}\n\nfunc TestNew(t *testing.T) {\n\tnow := time.Now()\n\tca, err := New(\"Test CA\", time.Minute)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, ca)\n\n\t// Make sure the CA certificate looks roughly like what we expect.\n\tcaCert, err := x509.ParseCertificate(ca.caCertBytes)\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"Test CA\", caCert.Subject.CommonName)\n\trequire.WithinDuration(t, now.Add(-5*time.Minute), caCert.NotBefore, 10*time.Second)\n\trequire.WithinDuration(t, now.Add(time.Minute), caCert.NotAfter, 10*time.Second)\n\n\trequire.NotNil(t, ca.privateKey)\n}\n\nfunc TestNewInternal(t *testing.T) {\n\tnow := time.Date(2020, 7, 10, 12, 41, 12, 1234, time.UTC)\n\n\ttests := []struct {\n\t\tname           string\n\t\tttl            time.Duration\n\t\tenv            env\n\t\twantErr        string\n\t\twantCommonName string\n\t\twantNotBefore  time.Time\n\t\twantNotAfter   time.Time\n\t}{\n\t\t{\n\t\t\tname: \"failed to generate CA serial\",\n\t\t\tenv: env{\n\t\t\t\tserialRNG:  strings.NewReader(\"\"),\n\t\t\t\tkeygenRNG:  strings.NewReader(\"\"),\n\t\t\t\tsigningRNG: strings.NewReader(\"\"),\n\t\t\t},\n\t\t\twantErr: \"could not generate CA serial: EOF\",\n\t\t},\n\t\t{\n\t\t\tname: \"failed to generate CA key\",\n\t\t\tenv: env{\n\t\t\t\tserialRNG:  strings.NewReader(strings.Repeat(\"x\", 64)),\n\t\t\t\tkeygenRNG:  strings.NewReader(\"\"),\n\t\t\t\tsigningRNG: strings.NewReader(\"\"),\n\t\t\t},\n\t\t\twantErr: \"could not generate CA private key: EOF\",\n\t\t},\n\t\t{\n\t\t\tname: \"failed to self-sign\",\n\t\t\tenv: env{\n\t\t\t\tserialRNG:  strings.NewReader(strings.Repeat(\"x\", 64)),\n\t\t\t\tkeygenRNG:  strings.NewReader(strings.Repeat(\"y\", 64)),\n\t\t\t\tsigningRNG: strings.NewReader(\"\"),\n\t\t\t\tclock:      func() time.Time { return now },\n\t\t\t},\n\t\t\twantErr: \"could not issue CA certificate: EOF\",\n\t\t},\n\t\t{\n\t\t\tname: \"success\",\n\t\t\tttl:  time.Minute,\n\t\t\tenv: env{\n\t\t\t\tserialRNG:  strings.NewReader(strings.Repeat(\"x\", 64)),\n\t\t\t\tkeygenRNG:  strings.NewReader(strings.Repeat(\"y\", 64)),\n\t\t\t\tsigningRNG: strings.NewReader(strings.Repeat(\"z\", 64)),\n\t\t\t\tclock:      func() time.Time { return now },\n\t\t\t},\n\t\t\twantCommonName: \"Test CA\",\n\t\t\twantNotAfter:   now.Add(time.Minute),\n\t\t\twantNotBefore:  now.Add(-5 * time.Minute),\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := newInternal(\"Test CA\", tt.ttl, tt.env)\n\t\t\tif tt.wantErr != \"\" {\n\t\t\t\trequire.EqualError(t, err, tt.wantErr)\n\t\t\t\trequire.Nil(t, got)\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.NotNil(t, got)\n\n\t\t\t// Make sure the CA certificate looks roughly like what we expect.\n\t\t\tcaCert, err := x509.ParseCertificate(got.caCertBytes)\n\t\t\trequire.NoError(t, err)\n\t\t\trequire.Equal(t, tt.wantCommonName, caCert.Subject.CommonName)\n\t\t\trequire.Equal(t, tt.wantNotAfter.Unix(), caCert.NotAfter.Unix())\n\t\t\trequire.Equal(t, tt.wantNotBefore.Unix(), caCert.NotBefore.Unix())\n\t\t})\n\t}\n}\n\nfunc TestBundle(t *testing.T) {\n\tca := CA{caCertBytes: []byte{1, 2, 3, 4, 5, 6, 7, 8}}\n\tcertPEM := ca.Bundle()\n\trequire.Equal(t, \"-----BEGIN CERTIFICATE-----\\nAQIDBAUGBwg=\\n-----END CERTIFICATE-----\\n\", string(certPEM))\n}\n\nfunc TestPrivateKeyToPEM(t *testing.T) {\n\tca, err := New(\"Test CA\", time.Hour)\n\trequire.NoError(t, err)\n\tkeyPEM, err := ca.PrivateKeyToPEM()\n\trequire.NoError(t, err)\n\trequire.Regexp(t, \"(?s)-----BEGIN EC \"+\"PRIVATE KEY-----\\n.*\\n-----END EC PRIVATE KEY-----\", string(keyPEM))\n\tcertPEM := ca.Bundle()\n\t// Check that the public and private keys work together.\n\t_, err = tls.X509KeyPair(certPEM, keyPEM)\n\trequire.NoError(t, err)\n\n\treloaded, err := Load(string(certPEM), string(keyPEM))\n\trequire.NoError(t, err)\n\t_, err = reloaded.PrivateKeyToPEM()\n\trequire.EqualError(t, err, \"no private key data (did you try to use this after Load?)\")\n}\n\nfunc TestPool(t *testing.T) {\n\tca, err := New(\"test\", 1*time.Hour)\n\trequire.NoError(t, err)\n\n\texpectedPool := x509.NewCertPool()\n\texpectedPool.AppendCertsFromPEM(ca.Bundle())\n\n\trequire.True(t, expectedPool.Equal(ca.Pool()))\n}\n\ntype errSigner struct {\n\tpubkey crypto.PublicKey\n\terr    error\n}\n\nfunc (e *errSigner) Public() crypto.PublicKey { return e.pubkey }\n\nfunc (e *errSigner) Sign(_ io.Reader, _ []byte, _ crypto.SignerOpts) ([]byte, error) {\n\treturn nil, e.err\n}\n\nfunc TestIssue(t *testing.T) {\n\tconst numRandBytes = 64 * 2 // each call to issue a cert will consume 64 bytes from the reader\n\n\tnow := time.Date(2020, 7, 10, 12, 41, 12, 0, time.UTC)\n\n\trealCA, err := Load(testCert, testKey)\n\trequire.NoError(t, err)\n\n\ttests := []struct {\n\t\tname    string\n\t\tca      CA\n\t\twantErr string\n\t}{\n\t\t{\n\t\t\tname: \"failed to generate serial\",\n\t\t\tca: CA{\n\t\t\t\tenv: env{\n\t\t\t\t\tserialRNG: strings.NewReader(\"\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: \"could not generate serial number for certificate: EOF\",\n\t\t},\n\t\t{\n\t\t\tname: \"failed to generate keypair\",\n\t\t\tca: CA{\n\t\t\t\tenv: env{\n\t\t\t\t\tserialRNG: strings.NewReader(strings.Repeat(\"x\", numRandBytes)),\n\t\t\t\t\tkeygenRNG: strings.NewReader(\"\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: \"could not generate private key: EOF\",\n\t\t},\n\t\t{\n\t\t\tname: \"invalid CA certificate\",\n\t\t\tca: CA{\n\t\t\t\tenv: env{\n\t\t\t\t\tserialRNG: strings.NewReader(strings.Repeat(\"x\", numRandBytes)),\n\t\t\t\t\tkeygenRNG: strings.NewReader(strings.Repeat(\"x\", numRandBytes)),\n\t\t\t\t\tclock:     func() time.Time { return now },\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: \"could not parse CA certificate: x509: malformed certificate\",\n\t\t},\n\t\t{\n\t\t\tname: \"signing error\",\n\t\t\tca: CA{\n\t\t\t\tenv: env{\n\t\t\t\t\tserialRNG: strings.NewReader(strings.Repeat(\"x\", numRandBytes)),\n\t\t\t\t\tkeygenRNG: strings.NewReader(strings.Repeat(\"x\", numRandBytes)),\n\t\t\t\t\tclock:     func() time.Time { return now },\n\t\t\t\t},\n\t\t\t\tcaCertBytes: realCA.caCertBytes,\n\t\t\t\tsigner: &errSigner{\n\t\t\t\t\tpubkey: realCA.signer.Public(),\n\t\t\t\t\terr:    fmt.Errorf(\"some signer error\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: \"could not sign certificate: some signer error\",\n\t\t},\n\t\t{\n\t\t\tname: \"parse certificate error\",\n\t\t\tca: CA{\n\t\t\t\tenv: env{\n\t\t\t\t\tserialRNG: strings.NewReader(strings.Repeat(\"x\", numRandBytes)),\n\t\t\t\t\tkeygenRNG: strings.NewReader(strings.Repeat(\"x\", numRandBytes)),\n\t\t\t\t\tclock:     func() time.Time { return now },\n\t\t\t\t\tparseCert: func(_ []byte) (*x509.Certificate, error) {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"some parse certificate error\")\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tcaCertBytes: realCA.caCertBytes,\n\t\t\t\tsigner:      realCA.signer,\n\t\t\t},\n\t\t\twantErr: \"could not parse certificate: some parse certificate error\",\n\t\t},\n\t\t{\n\t\t\tname: \"success\",\n\t\t\tca: CA{\n\t\t\t\tenv: env{\n\t\t\t\t\tserialRNG: strings.NewReader(strings.Repeat(\"x\", numRandBytes)),\n\t\t\t\t\tkeygenRNG: strings.NewReader(strings.Repeat(\"x\", numRandBytes)),\n\t\t\t\t\tclock:     func() time.Time { return now },\n\t\t\t\t\tparseCert: x509.ParseCertificate,\n\t\t\t\t},\n\t\t\t\tcaCertBytes: realCA.caCertBytes,\n\t\t\t\tsigner:      realCA.signer,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := tt.ca.IssueServerCert([]string{\"example.com\"}, []net.IP{net.IPv4(1, 2, 3, 4)}, 10*time.Minute)\n\t\t\tif tt.wantErr != \"\" {\n\t\t\t\trequire.EqualError(t, err, tt.wantErr)\n\t\t\t\trequire.Nil(t, got)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, got)\n\t\t\t\trequire.Equal(t, now.Add(-5*time.Minute), got.Leaf.NotBefore) // always back-dated\n\t\t\t\trequire.Equal(t, now.Add(10*time.Minute), got.Leaf.NotAfter)\n\t\t\t}\n\t\t\tgot, err = tt.ca.IssueClientCert(\"test-user\", []string{\"group1\", \"group2\"}, 10*time.Minute)\n\t\t\tif tt.wantErr != \"\" {\n\t\t\t\trequire.EqualError(t, err, tt.wantErr)\n\t\t\t\trequire.Nil(t, got)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\trequire.NotNil(t, got)\n\t\t\t\trequire.Equal(t, now.Add(-5*time.Minute), got.Leaf.NotBefore) // always back-dated\n\t\t\t\trequire.Equal(t, now.Add(10*time.Minute), got.Leaf.NotAfter)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestToPEM(t *testing.T) {\n\trealCert, err := tls.LoadX509KeyPair(\"./testdata/test.crt\", \"./testdata/test.key\")\n\trequire.NoError(t, err)\n\n\tt.Run(\"error from input\", func(t *testing.T) {\n\t\tpem, err := toPEM(nil, fmt.Errorf(\"some error\"))\n\t\trequire.EqualError(t, err, \"some error\")\n\t\trequire.Nil(t, pem)\n\t})\n\n\tt.Run(\"invalid private key\", func(t *testing.T) {\n\t\tcert := realCert\n\t\tcert.PrivateKey = nil\n\t\tpem, err := toPEM(&cert, nil)\n\t\trequire.EqualError(t, err, \"failed to marshal private key into PKCS8: x509: unknown key type while marshaling PKCS#8: <nil>\")\n\t\trequire.Nil(t, pem)\n\t})\n\n\tt.Run(\"success\", func(t *testing.T) {\n\t\tpem, err := toPEM(&realCert, nil)\n\t\trequire.NoError(t, err)\n\t\trequire.NotEmpty(t, pem.CertPEM)\n\t\trequire.NotEmpty(t, pem.KeyPEM)\n\t\trequire.Equal(t, time.Date(2020, time.July, 25, 21, 4, 18, 0, time.UTC), pem.NotBefore)\n\t\trequire.Equal(t, time.Date(2030, time.July, 23, 21, 4, 18, 0, time.UTC), pem.NotAfter)\n\t})\n}\n\nfunc TestIssueMethods(t *testing.T) {\n\t// One CA can be used to issue both kinds of certs.\n\tca, err := New(\"Test CA\", time.Hour)\n\trequire.NoError(t, err)\n\n\tttl := 121 * time.Hour\n\n\tt.Run(\"client certs\", func(t *testing.T) {\n\t\tuser := \"test-username\"\n\t\tgroups := []string{\"group1\", \"group2\"}\n\n\t\tclientCert, err := ca.IssueClientCert(user, groups, ttl)\n\t\trequire.NoError(t, err)\n\t\tcertPEM, keyPEM, err := ToPEM(clientCert)\n\t\trequire.NoError(t, err)\n\t\tvalidateClientCert(t, ca.Bundle(), certPEM, keyPEM, user, groups, ttl)\n\n\t\tpem, err := ca.IssueClientCertPEM(user, groups, ttl)\n\t\trequire.NoError(t, err)\n\t\tvalidateClientCert(t, ca.Bundle(), pem.CertPEM, pem.KeyPEM, user, groups, ttl)\n\n\t\tpem, err = ca.IssueClientCertPEM(user, nil, ttl)\n\t\trequire.NoError(t, err)\n\t\tvalidateClientCert(t, ca.Bundle(), pem.CertPEM, pem.KeyPEM, user, nil, ttl)\n\n\t\tpem, err = ca.IssueClientCertPEM(user, []string{}, ttl)\n\t\trequire.NoError(t, err)\n\t\tvalidateClientCert(t, ca.Bundle(), pem.CertPEM, pem.KeyPEM, user, nil, ttl)\n\n\t\tpem, err = ca.IssueClientCertPEM(\"\", []string{}, ttl)\n\t\trequire.NoError(t, err)\n\t\tvalidateClientCert(t, ca.Bundle(), pem.CertPEM, pem.KeyPEM, \"\", nil, ttl)\n\t})\n\n\tt.Run(\"server certs\", func(t *testing.T) {\n\t\tdnsNames := []string{\"example.com\", \"pinniped.dev\"}\n\t\tips := []net.IP{net.ParseIP(\"127.0.0.1\"), net.ParseIP(\"1.2.3.4\")}\n\n\t\tserverCert, err := ca.IssueServerCert(dnsNames, ips, ttl)\n\t\trequire.NoError(t, err)\n\t\tcertPEM, keyPEM, err := ToPEM(serverCert)\n\t\trequire.NoError(t, err)\n\t\tvalidateServerCert(t, ca.Bundle(), certPEM, keyPEM, dnsNames, ips, ttl)\n\n\t\tpem, err := ca.IssueServerCertPEM(dnsNames, ips, ttl)\n\t\trequire.NoError(t, err)\n\t\tvalidateServerCert(t, ca.Bundle(), pem.CertPEM, pem.KeyPEM, dnsNames, ips, ttl)\n\n\t\tpem, err = ca.IssueServerCertPEM(nil, ips, ttl)\n\t\trequire.NoError(t, err)\n\t\tvalidateServerCert(t, ca.Bundle(), pem.CertPEM, pem.KeyPEM, nil, ips, ttl)\n\n\t\tpem, err = ca.IssueServerCertPEM(dnsNames, nil, ttl)\n\t\trequire.NoError(t, err)\n\t\tvalidateServerCert(t, ca.Bundle(), pem.CertPEM, pem.KeyPEM, dnsNames, nil, ttl)\n\n\t\tpem, err = ca.IssueServerCertPEM([]string{}, ips, ttl)\n\t\trequire.NoError(t, err)\n\t\tvalidateServerCert(t, ca.Bundle(), pem.CertPEM, pem.KeyPEM, nil, ips, ttl)\n\n\t\tpem, err = ca.IssueServerCertPEM(dnsNames, []net.IP{}, ttl)\n\t\trequire.NoError(t, err)\n\t\tvalidateServerCert(t, ca.Bundle(), pem.CertPEM, pem.KeyPEM, dnsNames, nil, ttl)\n\t})\n}\n\nfunc validateClientCert(t *testing.T, caBundle []byte, certPEM []byte, keyPEM []byte, expectedUser string, expectedGroups []string, expectedTTL time.Duration) {\n\tconst fudgeFactor = 10 * time.Second\n\tv := testutil.ValidateClientCertificate(t, string(caBundle), string(certPEM))\n\tv.RequireLifetime(time.Now(), time.Now().Add(expectedTTL), certBackdate+fudgeFactor)\n\tv.RequireMatchesPrivateKey(string(keyPEM))\n\tv.RequireCommonName(expectedUser)\n\tv.RequireOrganizations(expectedGroups)\n\tv.RequireEmptyDNSNames()\n\tv.RequireEmptyIPs()\n}\n\nfunc validateServerCert(t *testing.T, caBundle []byte, certPEM []byte, keyPEM []byte, expectedDNSNames []string, expectedIPs []net.IP, expectedTTL time.Duration) {\n\tconst fudgeFactor = 10 * time.Second\n\tv := testutil.ValidateServerCertificate(t, string(caBundle), string(certPEM))\n\tv.RequireLifetime(time.Now(), time.Now().Add(expectedTTL), certBackdate+fudgeFactor)\n\tv.RequireMatchesPrivateKey(string(keyPEM))\n\tv.RequireCommonName(\"\")\n\tv.RequireDNSNames(expectedDNSNames)\n\tv.RequireIPs(expectedIPs)\n}"
