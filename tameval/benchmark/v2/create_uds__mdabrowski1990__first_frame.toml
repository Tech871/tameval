[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "mdabrowski1990/uds"
sha = "81ca93afdc4ac9e386bbdebaf44ab0ac9cc22941"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r requirements.txt && (pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=uds/can/packet/first_frame.py -m pytest -q --junit-xml=test_output.xml tests/software_tests/can/packet/test_first_frame.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target uds.can.packet.first_frame --unit-test tests.software_tests.can.packet.test_first_frame --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target uds/can/packet/first_frame.py --unit-test tests/software_tests/can/packet/test_first_frame.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 81.0
original_coverage = 100.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = [ 2, 9, 11, 12, 14, 15, 17, 18, 20, 21, 23, 24, 25, 26, 28, 29, 33, 50, 59, 60, 61, 62, 63, 65, 66, 72, 101, 102, 105, 106, 107, 108, 109, 111, 114, 144, 145, 148, 149, 150, 151, 152, 154, 157, 170, 171, 173, 176, 191, 192, 194, 196, 199, 213, 214, 221, 240, 254, 255, 258, 271, 272, 274, 275, 277, 278, 279, 280, 283, 308, 310, 313, 314, 317, 318, 319, 320, 321, 323, 324, 326,]
missed_lines = [ 46, 47, 193, 195, 215, 216, 217, 218, 233, 234, 235, 236, 237, 309, 311, 315, 322, 325, 327,]

[input_info]
test_file_path = "tests/software_tests/can/packet/test_first_frame.py"
focal_file_path = "uds/can/packet/first_frame.py"
test_file_url = "https://github.com/mdabrowski1990/uds/blob/81ca93afdc4ac9e386bbdebaf44ab0ac9cc22941/tests/software_tests/can/packet/test_first_frame.py"
focal_file_url = "https://github.com/mdabrowski1990/uds/blob/81ca93afdc4ac9e386bbdebaf44ab0ac9cc22941/uds/can/packet/first_frame.py"
first_commit_date = "2025-07-29"
last_commit_date = "2025-07-29"
test_file_content = "import pytest\nfrom mock import Mock, patch\n\nfrom uds.can.packet.first_frame import (\n    FIRST_FRAME_N_PCI,\n    LONG_FF_DL_BYTES_USED,\n    MAX_LONG_FF_DL_VALUE,\n    MAX_SHORT_FF_DL_VALUE,\n    SHORT_FF_DL_BYTES_USED,\n    CanAddressingFormat,\n    CanDlcHandler,\n    InconsistentArgumentsError,\n    create_first_frame_data,\n    encode_ff_dl,\n    extract_ff_dl,\n    extract_ff_dl_data_bytes,\n    extract_first_frame_payload,\n    generate_ff_dl_bytes,\n    generate_first_frame_data,\n    get_first_frame_payload_size,\n    is_first_frame,\n    validate_ff_dl,\n    validate_first_frame_data,\n)\n\nSCRIPT_LOCATION = \"uds.can.packet.first_frame\"\n\nclass TestCanFirstFrame:\n    \"\"\"Unit tests for functions in CAN First Frame module.\"\"\"\n\n    def setup_method(self):\n        self._patcher_validate_raw_bytes = patch(f\"{SCRIPT_LOCATION}.validate_raw_bytes\")\n        self.mock_validate_raw_bytes = self._patcher_validate_raw_bytes.start()\n        self._patcher_can_addressing_information = patch(f\"{SCRIPT_LOCATION}.CanAddressingInformation\")\n        self.mock_can_addressing_information = self._patcher_can_addressing_information.start()\n        self._patcher_dlc_handler = patch(f\"{SCRIPT_LOCATION}.CanDlcHandler\",\n                                          Mock(MIN_BASE_UDS_DLC=CanDlcHandler.MIN_BASE_UDS_DLC))\n        self.mock_dlc_handler = self._patcher_dlc_handler.start()\n        self._patcher_get_max_sf_dl = patch(f\"{SCRIPT_LOCATION}.get_max_sf_dl\")\n        self.mock_get_max_sf_dl = self._patcher_get_max_sf_dl.start()\n\n    def teardown_method(self):\n        self._patcher_validate_raw_bytes.stop()\n        self._patcher_can_addressing_information.stop()\n        self._patcher_dlc_handler.stop()\n        self._patcher_get_max_sf_dl.stop()\n\n    # is_single_frame\n\n    # validate_first_frame_data\n\n    @pytest.mark.parametrize(\"addressing_format, raw_frame_data\", [\n        (Mock(), Mock()),\n        (CanAddressingFormat.NORMAL_ADDRESSING, list(range(8))),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.is_first_frame\")\n    def test_validate_first_frame_data__value_error(self, mock_is_first_frame,\n                                              addressing_format, raw_frame_data):\n        mock_is_first_frame.return_value = False\n        with pytest.raises(ValueError):\n            validate_first_frame_data(addressing_format=addressing_format, raw_frame_data=raw_frame_data)\n        self.mock_validate_raw_bytes.assert_called_once_with(raw_frame_data, allow_empty=False)\n        mock_is_first_frame.assert_called_once_with(addressing_format=addressing_format, raw_frame_data=raw_frame_data)\n\n    @pytest.mark.parametrize(\"addressing_format, raw_frame_data\", [\n        (Mock(), range(64)),\n        (CanAddressingFormat.NORMAL_ADDRESSING, list(range(8))),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.validate_ff_dl\")\n    @patch(f\"{SCRIPT_LOCATION}.extract_ff_dl_data_bytes\")\n    @patch(f\"{SCRIPT_LOCATION}.extract_ff_dl\")\n    @patch(f\"{SCRIPT_LOCATION}.is_first_frame\")\n    def test_validate_first_frame_data__valid(self, mock_is_first_frame, mock_extract_ff_dl,\n                                              mock_extract_ff_dl_data_bytes, mock_validate_ff_dl,\n                                              addressing_format, raw_frame_data):\n        mock_is_first_frame.return_value = True\n        assert validate_first_frame_data(addressing_format=addressing_format, raw_frame_data=raw_frame_data) is None\n        self.mock_validate_raw_bytes.assert_called_once_with(raw_frame_data, allow_empty=False)\n        mock_is_first_frame.assert_called_once_with(addressing_format=addressing_format,\n                                                    raw_frame_data=raw_frame_data)\n        mock_extract_ff_dl.assert_called_once_with(addressing_format=addressing_format,\n                                                   raw_frame_data=raw_frame_data)\n        mock_extract_ff_dl_data_bytes.assert_called_once_with(addressing_format=addressing_format,\n                                                              raw_frame_data=raw_frame_data)\n        self.mock_dlc_handler.encode_dlc.assert_called_once_with(len(raw_frame_data))\n        mock_validate_ff_dl.assert_called_once_with(\n            addressing_format=addressing_format,\n            dlc=self.mock_dlc_handler.encode_dlc.return_value,\n            ff_dl=mock_extract_ff_dl.return_value,\n            ff_dl_bytes_number=mock_extract_ff_dl_data_bytes.return_value.__len__.return_value)\n\n    # create_first_frame_data\n\n    @pytest.mark.parametrize(\"addressing_format, payload, dlc, data_length, target_address, address_extension, \"\n                             \"ai_data_bytes, ff_dl_data_bytes\", [\n        (Mock(), [0x12, 0x34, 0x56, 0x78], 8, 13, Mock(), Mock(), bytearray([0x23]), bytearray([0x12, 0x34])),\n        (CanAddressingFormat.NORMAL_ADDRESSING, range(58), 0xF, 0x98765434, 0x76, 0x65, bytearray(),\n         bytearray([0x10, 0x00, 0xFE, 0xDC, 0xBA, 0x98])),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.encode_ff_dl\")\n    def test_create_first_frame_data__valid(self, mock_encode_ff_dl,\n                                            addressing_format, payload, dlc, data_length, target_address,\n                                            address_extension,\n                                            ai_data_bytes, ff_dl_data_bytes):\n        expected_output = bytearray(ai_data_bytes) + bytearray(ff_dl_data_bytes) + bytearray(payload)\n        self.mock_can_addressing_information.encode_ai_data_bytes.return_value = ai_data_bytes\n        mock_encode_ff_dl.return_value = ff_dl_data_bytes\n        self.mock_dlc_handler.decode_dlc.return_value = len(expected_output)\n        assert create_first_frame_data(addressing_format=addressing_format,\n                                       payload=payload,\n                                       dlc=dlc,\n                                       data_length=data_length,\n                                       target_address=target_address,\n                                       address_extension=address_extension) == expected_output\n        self.mock_validate_raw_bytes.assert_called_once_with(payload, allow_empty=False)\n        self.mock_can_addressing_information.encode_ai_data_bytes.assert_called_once_with(\n            addressing_format=addressing_format,\n            target_address=target_address,\n            address_extension=address_extension)\n        mock_encode_ff_dl.assert_called_once_with(addressing_format=addressing_format, dlc=dlc, ff_dl=data_length)\n        self.mock_dlc_handler.decode_dlc.assert_called_once_with(dlc)\n\n    @pytest.mark.parametrize(\"addressing_format, payload, dlc, data_length, target_address, address_extension, \"\n                             \"ai_data_bytes, ff_dl_data_bytes, frame_data_length\", [\n        (Mock(), [0x12, 0x34, 0x56, 0x78], 8, 13, Mock(), Mock(), bytearray([0x23]), bytearray([0x12, 0x34]), 8),\n        (CanAddressingFormat.NORMAL_ADDRESSING, range(58), 0xF, 0x98765434, 0x76, 0x65, bytearray(),\n         bytearray([0x10, 0x00, 0xFE, 0xDC, 0xBA, 0x98]), 63),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.encode_ff_dl\")\n    def test_create_first_frame_data__inconsistent(self, mock_encode_ff_dl,\n                                                   addressing_format, payload, dlc, data_length, target_address,\n                                                   address_extension,\n                                                   ai_data_bytes, ff_dl_data_bytes, frame_data_length):\n        self.mock_can_addressing_information.encode_ai_data_bytes.return_value = ai_data_bytes\n        mock_encode_ff_dl.return_value = ff_dl_data_bytes\n        self.mock_dlc_handler.decode_dlc.return_value = frame_data_length\n        with pytest.raises(InconsistentArgumentsError):\n            create_first_frame_data(addressing_format=addressing_format,\n                                    payload=payload,\n                                    dlc=dlc,\n                                    data_length=data_length,\n                                    target_address=target_address,\n                                    address_extension=address_extension)\n        self.mock_validate_raw_bytes.assert_called_once_with(payload, allow_empty=False)\n        self.mock_can_addressing_information.encode_ai_data_bytes.assert_called_once_with(\n            addressing_format=addressing_format,\n            target_address=target_address,\n            address_extension=address_extension)\n        mock_encode_ff_dl.assert_called_once_with(addressing_format=addressing_format, dlc=dlc, ff_dl=data_length)\n        self.mock_dlc_handler.decode_dlc.assert_called_once_with(dlc)\n\n    # generate_first_frame_data\n\n    @pytest.mark.parametrize(\"addressing_format, payload, dlc, ff_dl, long_ff_dl_format, target_address, \"\n                             \"address_extension, ai_data_bytes, ff_dl_data_bytes\", [\n        (Mock(), [0x12, 0x34, 0x56, 0x78], 8, 13, True, Mock(), Mock(), bytearray([0x23]), bytearray([0x12, 0x34])),\n        (CanAddressingFormat.NORMAL_ADDRESSING, range(58), 0xF, 0x98765434, False, 0x76, 0x65, bytearray(),\n         bytearray([0x10, 0x00, 0xFE, 0xDC, 0xBA, 0x98])),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.generate_ff_dl_bytes\")\n    def test_generate_first_frame_data__valid(self, mock_generate_ff_dl_bytes,\n                                              addressing_format, payload, dlc, ff_dl, long_ff_dl_format,\n                                              target_address, address_extension,\n                                              ai_data_bytes, ff_dl_data_bytes):\n        expected_output = ai_data_bytes + ff_dl_data_bytes + bytearray(payload)\n        self.mock_can_addressing_information.encode_ai_data_bytes.return_value = ai_data_bytes\n        mock_generate_ff_dl_bytes.return_value = ff_dl_data_bytes\n        self.mock_dlc_handler.decode_dlc.return_value = len(expected_output)\n        assert generate_first_frame_data(addressing_format=addressing_format,\n                                         payload=payload,\n                                         dlc=dlc,\n                                         ff_dl=ff_dl,\n                                         long_ff_dl_format=long_ff_dl_format,\n                                         target_address=target_address,\n                                         address_extension=address_extension) == expected_output\n        self.mock_validate_raw_bytes.assert_called_once_with(payload, allow_empty=True)\n        self.mock_can_addressing_information.encode_ai_data_bytes.assert_called_once_with(\n            addressing_format=addressing_format,\n            target_address=target_address,\n            address_extension=address_extension)\n        mock_generate_ff_dl_bytes.assert_called_once_with(ff_dl=ff_dl, long_ff_dl_format=long_ff_dl_format)\n        self.mock_dlc_handler.decode_dlc.assert_called_once_with(dlc)\n\n    @pytest.mark.parametrize(\"addressing_format, payload, dlc, ff_dl, long_ff_dl_format, target_address, \"\n                             \"address_extension, ai_data_bytes, ff_dl_data_bytes, data_length\", [\n        (Mock(), [0x12, 0x34, 0x56, 0x78], 8, 13, False, Mock(), Mock(), bytearray([0x23]), bytearray([0x12, 0x34]), 8),\n        (CanAddressingFormat.NORMAL_ADDRESSING, range(58), 0xF, 0x98765434, True, 0x76, 0x65, bytearray(),\n         bytearray([0x10, 0x00, 0xFE, 0xDC, 0xBA, 0x98]), 63),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.generate_ff_dl_bytes\")\n    def test_generate_first_frame_data__inconsistent(self, mock_generate_ff_dl_bytes,\n                                                     addressing_format, payload, dlc, ff_dl, long_ff_dl_format,\n                                                     target_address, address_extension,\n                                                     ai_data_bytes, ff_dl_data_bytes, data_length):\n        self.mock_can_addressing_information.encode_ai_data_bytes.return_value = ai_data_bytes\n        mock_generate_ff_dl_bytes.return_value = ff_dl_data_bytes\n        self.mock_dlc_handler.decode_dlc.return_value = data_length\n        with pytest.raises(InconsistentArgumentsError):\n            generate_first_frame_data(addressing_format=addressing_format,\n                                      payload=payload,\n                                      dlc=dlc,\n                                      ff_dl=ff_dl,\n                                      long_ff_dl_format=long_ff_dl_format,\n                                      target_address=target_address,\n                                      address_extension=address_extension)\n        self.mock_validate_raw_bytes.assert_called_once_with(payload, allow_empty=True)\n        self.mock_can_addressing_information.encode_ai_data_bytes.assert_called_once_with(\n            addressing_format=addressing_format,\n            target_address=target_address,\n            address_extension=address_extension)\n        mock_generate_ff_dl_bytes.assert_called_once_with(ff_dl=ff_dl, long_ff_dl_format=long_ff_dl_format)\n        self.mock_dlc_handler.decode_dlc.assert_called_once_with(dlc)\n\n    # extract_first_frame_payload\n\n    @pytest.mark.parametrize(\"addressing_format, raw_frame_data, ai_bytes_number, ff_dl_data_bytes_number\", [\n        (Mock(), range(64), 1, SHORT_FF_DL_BYTES_USED),\n        (CanAddressingFormat.NORMAL_ADDRESSING, [0x1F, 0x2E, 0x3D, 0x4C, 0x5B, 0x6A, 0x79, 0x80], 0,\n         LONG_FF_DL_BYTES_USED),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.extract_ff_dl_data_bytes\")\n    def test_extract_first_frame_payload(self, mock_extract_ff_dl_data_bytes,\n                                        addressing_format, raw_frame_data,\n                                        ai_bytes_number, ff_dl_data_bytes_number):\n        self.mock_can_addressing_information.get_ai_data_bytes_number.return_value = ai_bytes_number\n        mock_extract_ff_dl_data_bytes.return_value.__len__.return_value = ff_dl_data_bytes_number\n        assert (extract_first_frame_payload(addressing_format=addressing_format,\n                                            raw_frame_data=raw_frame_data)\n                == bytearray(raw_frame_data)[ai_bytes_number + ff_dl_data_bytes_number:])\n        self.mock_can_addressing_information.get_ai_data_bytes_number.assert_called_once_with(addressing_format)\n        mock_extract_ff_dl_data_bytes.assert_called_once_with(addressing_format=addressing_format,\n                                                              raw_frame_data=raw_frame_data)\n\n    # extract_ff_dl\n\n    @pytest.mark.parametrize(\"addressing_format, raw_frame_data, ff_dl_data_bytes\", [\n        (Mock(), Mock(), [0x12]),\n        (CanAddressingFormat.EXTENDED_ADDRESSING, list(range(8)), [0x10, 0x00, 0x00, 0x23, 0xBD]),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.extract_ff_dl_data_bytes\")\n    def test_extract_ff_dl__not_implemented(self, mock_extract_ff_dl_data_bytes,\n                                   addressing_format, raw_frame_data, ff_dl_data_bytes):\n        mock_extract_ff_dl_data_bytes.return_value = ff_dl_data_bytes\n        with pytest.raises(NotImplementedError):\n            extract_ff_dl(addressing_format=addressing_format, raw_frame_data=raw_frame_data)\n        mock_extract_ff_dl_data_bytes.assert_called_once_with(addressing_format=addressing_format,\n                                                              raw_frame_data=raw_frame_data)\n\n    # extract_ff_dl_data_bytes\n\n    # encode_ff_dl\n\n    @pytest.mark.parametrize(\"addressing_format, dlc, ff_dl\", [\n        (Mock(), Mock(), MAX_SHORT_FF_DL_VALUE),\n        (Mock(), Mock(), MAX_SHORT_FF_DL_VALUE + 1),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.generate_ff_dl_bytes\")\n    @patch(f\"{SCRIPT_LOCATION}.validate_ff_dl\")\n    def test_encode_valid_ff_dl(self, mock_validate_ff_dl, mock_generate_ff_dl_bytes,\n                                addressing_format, dlc, ff_dl):\n        assert encode_ff_dl(addressing_format=addressing_format,\n                            dlc=dlc,\n                            ff_dl=ff_dl) == mock_generate_ff_dl_bytes.return_value\n        mock_validate_ff_dl.assert_called_once_with(addressing_format=addressing_format,\n                                                    dlc=dlc,\n                                                    ff_dl=ff_dl)\n        if ff_dl > MAX_SHORT_FF_DL_VALUE:\n            mock_generate_ff_dl_bytes.assert_called_once_with(ff_dl=ff_dl, long_ff_dl_format=True)\n        else:\n            mock_generate_ff_dl_bytes.assert_called_once_with(ff_dl=ff_dl, long_ff_dl_format=False)\n\n    # get_first_frame_payload_size\n\n    @pytest.mark.parametrize(\"addressing_format, dlc, long_ff_dl_format\", [\n        (Mock(), CanDlcHandler.MIN_BASE_UDS_DLC - 1, False),\n        (Mock(), 0, True),\n    ])\n    def test_get_first_frame_payload_size__value_error(self, addressing_format, dlc, long_ff_dl_format):\n        with pytest.raises(ValueError):\n            get_first_frame_payload_size(addressing_format=addressing_format,\n                                         dlc=dlc,\n                                         long_ff_dl_format=long_ff_dl_format)\n\n    # generate_ff_dl_bytes\n\n    # validate_ff_dl\n\n    @pytest.mark.parametrize(\"ff_dl, dlc, addressing_format, sf_dl\", [\n        (5, CanDlcHandler.MIN_BASE_UDS_DLC, Mock(), 5),\n        (50, CanDlcHandler.MIN_BASE_UDS_DLC+1, CanAddressingFormat.EXTENDED_ADDRESSING, 61),\n    ])\n    def test_validate_ff_dl__inconsistent_sf(self, ff_dl, dlc, addressing_format, sf_dl):\n        self.mock_get_max_sf_dl.return_value = sf_dl\n        with pytest.raises(InconsistentArgumentsError):\n            validate_ff_dl(ff_dl=ff_dl, dlc=dlc, addressing_format=addressing_format)\n        self.mock_get_max_sf_dl.assert_called_once_with(dlc=dlc, addressing_format=addressing_format)\n\n    @pytest.mark.parametrize(\"ff_dl, dlc, addressing_format, ff_dl_bytes_number\", [\n        (5, CanDlcHandler.MIN_BASE_UDS_DLC, Mock(), None),\n        (MAX_SHORT_FF_DL_VALUE, CanDlcHandler.MIN_BASE_UDS_DLC + 1, Mock(), SHORT_FF_DL_BYTES_USED),\n        (MAX_SHORT_FF_DL_VALUE+1, CanDlcHandler.MIN_BASE_UDS_DLC + 2, CanAddressingFormat.EXTENDED_ADDRESSING, None),\n        (MAX_LONG_FF_DL_VALUE, CanDlcHandler.MAX_DLC_VALUE, CanAddressingFormat.MIXED_29BIT_ADDRESSING,\n         LONG_FF_DL_BYTES_USED),\n    ])\n    def test_validate_ff_dl__valid(self, ff_dl, dlc, addressing_format, ff_dl_bytes_number):\n        self.mock_get_max_sf_dl.return_value = 0\n        assert validate_ff_dl(ff_dl=ff_dl,\n                              dlc=dlc,\n                              addressing_format=addressing_format,\n                              ff_dl_bytes_number=ff_dl_bytes_number) is None\n        self.mock_get_max_sf_dl.assert_called_once_with(dlc=dlc, addressing_format=addressing_format)\n\n@pytest.mark.integration\nclass TestCanFirstFrameIntegration:\n    \"\"\"Integration tests for CAN First Frame module.\"\"\"\n\n    # validate_first_frame_data\n\n    # create_first_frame_data\n\n    # generate_first_frame_data\n\n    @pytest.mark.parametrize(\"kwargs\", [\n        {\"addressing_format\": CanAddressingFormat.NORMAL_ADDRESSING,\n         \"dlc\": 7,\n         \"ff_dl\": 0x1000,\n         \"long_ff_dl_format\": False,\n         \"payload\": [0x12, 0x34, 0x56, 0x78, 0x9A]},\n        {\"addressing_format\": CanAddressingFormat.NORMAL_FIXED_ADDRESSING,\n         \"dlc\": 9,\n         \"ff_dl\": 0x12345678,\n         \"long_ff_dl_format\": True,\n         \"payload\": [0xF0, 0xE1, 0xD2, 0xC3, 0xB4],\n         \"target_address\": 0xC0},\n        {\"addressing_format\": CanAddressingFormat.EXTENDED_ADDRESSING,\n         \"dlc\": 0xF,\n         \"ff_dl\": 610,\n         \"long_ff_dl_format\": False,\n         \"payload\": tuple(range(120, 182)),\n         \"target_address\": 0xC0},\n        {\"addressing_format\": CanAddressingFormat.MIXED_11BIT_ADDRESSING,\n         \"dlc\": 0xA,\n         \"ff_dl\": 0x100000000,\n         \"long_ff_dl_format\": True,\n         \"payload\": list(range(9)),\n         \"address_extension\": 0x0B},\n        {\"addressing_format\": CanAddressingFormat.MIXED_29BIT_ADDRESSING,\n         \"dlc\": 8,\n         \"ff_dl\": -1,\n         \"long_ff_dl_format\": False,\n         \"payload\": [0x9A, 0x8B, 0x7C, 0x6D, 0x5E],\n         \"target_address\": 0x9E,\n         \"address_extension\": 0x61}\n    ])\n    def test_generate_first_frame_data__value_error(self, kwargs):\n        with pytest.raises(ValueError):\n            generate_first_frame_data(**kwargs)\n\n    # extract_first_frame_payload\n"
