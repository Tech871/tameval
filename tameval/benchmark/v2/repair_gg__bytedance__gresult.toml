[meta]
task = "repair"
scenario = "repair_invalid_constructor"

[lang_info]
lang = "Go"
go_version = "1.18"

[repo_info]
repository = "bytedance/gg"
sha = "420f8369dd6e235b8124691860e822d015969fb6"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out gresult/gresult.go gresult/gresult_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting gresult/gresult.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 97.0
mutation_kill_rate = nan
original_mutation_kill_rate = 91.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "gresult/gresult_test.go"
focal_file_path = "gresult/gresult.go"
test_file_url = "https://github.com/bytedance/gg/blob/420f8369dd6e235b8124691860e822d015969fb6/gresult/gresult_test.go"
focal_file_url = "https://github.com/bytedance/gg/blob/420f8369dd6e235b8124691860e822d015969fb6/gresult/gresult.go"
first_commit_date = "2025-05-19"
last_commit_date = "2025-05-20"
test_file_content = "\n\npackage gresult\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/bytedance/gg/goption\"\n\t\"github.com/bytedance/gg/gvalue\"\n\t\"github.com/bytedance/gg/internal/assert\"\n)\n\nvar (\n\tanErr = errors.New(\"E!R!R!O!R!\")\n)\n\nfunc TestOf(t *testing.T) {\n\tassert.NotPanic(t, func() {\n\t\t_ = Of(1, nil)\n\t})\n\tassert.NotPanic(t, func() {\n\t\t_ = Of(0, nil)\n\t})\n\tassert.NotPanic(t, func() {\n\t\t_ = Of(0, anErr)\n\t})\n\tassert.Panic(t, func() {\n\t\te := error((*fs.PathError)(nil))\n\t\t_ = Of(0, e)\n\t})\n\t_ = Of(\"string\", nil, nil)\n\t_ = Of(1, \"error\")\n}\n\nfunc TestErr(t *testing.T) {\n\tassert.Panic(t, func() {\n\t\t_ = Err[int](nil)\n\t})\n\tassert.Panic(t, func() {\n\t\te := error((*fs.PathError)(nil))\n\t\t_ = Err[int](e)\n\t})\n\tassert.NotPanic(t, func() {\n\t\t_ = Err[int](anErr)\n\t})\n\t_ = Err[int]()\n}\n\nfunc TestRValue(t *testing.T) {\n\tassert.Equal(t, 10, OK(10).Value())\n\tassert.Equal(t, 0, Err[int](anErr).Value())\n\tassert.Equal(t, 10, Of(10, nil).Value())\n\tassert.Equal(t, 10, Of(10, anErr).Value())\n\tassert.Equal(t, 0, Of(0, anErr).Value())\n\t_ = OK().Value()\n}\n\nfunc TestRValueOr(t *testing.T) {\n\tassert.Equal(t, 10, OK(10).ValueOr(1))\n\tassert.Equal(t, 1, Err[int](anErr).ValueOr(1))\n\tassert.Equal(t, 10, Of(10, nil).ValueOr(1))\n\tassert.Equal(t, 1, Of(10, anErr).ValueOr(1))\n\tassert.Equal(t, 1, Of(0, anErr).ValueOr(1))\n\t_ = OK(10).ValueOr()\n}\n\nfunc TestRValueOrZero(t *testing.T) {\n\tassert.Equal(t, 10, OK(10).ValueOrZero())\n\tassert.Equal(t, 0, Err[int](anErr).ValueOrZero())\n\tassert.Equal(t, 10, Of(10, nil).ValueOrZero())\n\tassert.Equal(t, 0, Of(10, anErr).ValueOrZero())\n\tassert.Equal(t, 0, Of(0, anErr).ValueOrZero())\n\t_ = OK(10).ValueOrZero(\"string\")\n}\n\nfunc TestRErr(t *testing.T) {\n\tassert.Nil(t, OK(10).Err())\n\tassert.Nil(t, OK(0).Err())\n\tassert.NotNil(t, Err[int](anErr).Err())\n\tassert.Nil(t, Of(10, nil).Err())\n\tassert.NotNil(t, Of(10, anErr).Err())\n\tassert.NotNil(t, Of(0, anErr).Err())\n\t_ = OK(10).Err(1)\n}\n\nfunc TestRIfOK(t *testing.T) {\n\tassert.Panic(t, func() { OK(10).IfOK(func(int) { panic(0) }) })\n\tassert.NotPanic(t, func() { Err[int](anErr).IfOK(func(int) { panic(0) }) })\n\tOK(10).IfOK()\n}\n\nfunc TestRIfErr(t *testing.T) {\n\tassert.NotPanic(t, func() { OK(10).IfErr(func(error) { panic(0) }) })\n\tassert.Panic(t, func() { Err[int](anErr).IfErr(func(error) { panic(0) }) })\n\tErr[int](anErr).IfErr()\n}\n\nfunc foo1() (int, error) {\n\treturn 1, nil\n}\n\nfunc foo2() R[int] {\n\treturn OK(1)\n}\n\nfunc Benchmark(b *testing.B) {\n\tb.Run(\"(int,error)\", func(b *testing.B) {\n\t\tfor i := 0; i <= b.N; i++ {\n\t\t\tv, err := foo1()\n\t\t\tif err != nil || v != 1 {\n\t\t\t\tb.FailNow()\n\t\t\t}\n\t\t}\n\t})\n\tb.Run(\"gresult\", func(b *testing.B) {\n\t\tfor i := 0; i <= b.N; i++ {\n\t\t\tr := foo2()\n\t\t\tif r.Err() != nil || r.Value() != 1 {\n\t\t\t\tb.FailNow()\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc TestRtyp(t *testing.T) {\n\tassert.Equal(t, \"any\", Err[any](anErr).typ())\n\tassert.Equal(t, \"int\", Err[int](anErr).typ())\n\tassert.Equal(t, \"int\", OK(11).typ())\n\tassert.Equal(t, \"int8\", OK(int8(11)).typ())\n\tassert.Equal(t, \"any\", OK(any(11)).typ())\n\tassert.Equal(t, \"any\", OK[any](11).typ())\n\tassert.Equal(t, \"any\", OK[interface{}](11).typ())\n\tassert.Equal(t, \"any\", OK((interface{})(11)).typ())\n\t_ = OK(11).typ(1)\n}\n\nfunc TestOString(t *testing.T) {\n\n\tassert.Equal(t, \"gresult.Err[int](E!R!R!O!R!)\", Err[int](anErr).String())\n\tassert.Equal(t, \"gresult.OK[int](11)\", OK(11).String())\n\tassert.Equal(t, \"gresult.OK[any](11)\", OK(any(11)).String())\n\tassert.Equal(t, \"gresult.OK[int](11)\", fmt.Sprintf(\"%s\", OK(11)))\n\t_ = OK(11).String(\"string\")\n}\n\nfunc TestJSON(t *testing.T) {\n\t{\n\t\tbs, err := json.Marshal(OK(\"test\"))\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, `{\"value\":\"test\"}`, string(bs))\n\t}\n\t{\n\t\tbs, err := json.Marshal(Err[string](errors.New(\"test\")))\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, `{\"error\":\"test\"}`, string(bs))\n\t}\n\n\t{\n\t\tbefore := OK(\"test\")\n\t\tbs, err := json.Marshal(before)\n\t\tassert.Nil(t, err)\n\n\t\tvar after1 R[int]\n\t\terr = json.Unmarshal(bs, &after1)\n\t\tassert.NotNil(t, err)\n\t\tassert.Equal(t, gvalue.Zero[R[int]](), after1)\n\n\t\tvar after2 R[float64]\n\t\terr = json.Unmarshal(bs, &after2)\n\t\tassert.NotNil(t, err)\n\t\tassert.Equal(t, gvalue.Zero[R[float64]](), after2)\n\n\t\tvar after3 R[string]\n\t\terr = json.Unmarshal(bs, &after3)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, before, after3)\n\t}\n\n\t{\n\t\tbefore := OK[*int](nil)\n\t\tbs, err := json.Marshal(before)\n\t\tassert.Nil(t, err)\n\n\t\tvar after R[*int]\n\t\terr = json.Unmarshal(bs, &after)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, before, after)\n\t}\n\n\t{\n\t\tvar r R[string]\n\t\terr := json.Unmarshal([]byte(`{\"value\":\"test\"}`), &r)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, OK(\"test\"), r)\n\t}\n\t{\n\t\tvar r R[string]\n\t\terr := json.Unmarshal([]byte(`{}`), &r)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, gvalue.Zero[R[string]](), r)\n\t}\n\t{\n\t\tvar r R[string]\n\t\terr := json.Unmarshal([]byte(`null`), &r)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, gvalue.Zero[R[string]](), r)\n\t}\n\t{\n\t\tvar r R[string]\n\t\terr := json.Unmarshal([]byte(`{\"error\":\"test\"}`), &r)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, Err[string](errors.New(\"test\")), r)\n\t}\n\t{\n\t\tvar r R[string]\n\t\terr := json.Unmarshal([]byte(`{\"value\":\"test\",\"error\":\"test\"}`), &r)\n\t\tassert.NotNil(t, err)\n\t\tt.Log(err)\n\t\tassert.Equal(t, gvalue.Zero[R[string]](), r)\n\t}\n\n\t{\n\t\tvar r R[bool]\n\t\terr := json.Unmarshal([]byte(`false`), &r)\n\t\tassert.NotNil(t, err)\n\t\tassert.Equal(t, gvalue.Zero[R[bool]](), r)\n\t}\n\t{\n\t\tvar r R[string]\n\t\terr := json.Unmarshal([]byte(``), &r)\n\t\tassert.NotNil(t, err)\n\t\tassert.Equal(t, gvalue.Zero[R[string]](), r)\n\t}\n\t{\n\t\ttype Foo struct {\n\t\t\tBar R[json.Number] `json:\"bar\"`\n\t\t}\n\n\t\tfoo := Foo{OK(json.Number(\"9007199254740992\"))}\n\t\tbs, err := json.Marshal(foo)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, `{\"bar\":{\"value\":9007199254740992}}`, string(bs))\n\n\t\tfoo1 := Foo{}\n\t\terr = json.Unmarshal(bs, &foo1)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, foo1, foo1)\n\t}\n\t{\n\t\te := errors.New(\"test\")\n\n\t\ttype Foo struct {\n\t\t\tBar R[int] `json:\"bar\"`\n\t\t}\n\n\t\tfoo1 := Foo{OK(0)}\n\t\tbs1, err := json.Marshal(foo1)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, `{\"bar\":{\"value\":0}}`, string(bs1))\n\n\t\tfoo2 := Foo{Err[int](e)}\n\t\tbs2, err := json.Marshal(foo2)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, `{\"bar\":{\"error\":\"test\"}}`, string(bs2))\n\n\t\tfoo3 := Foo{}\n\t\terr = json.Unmarshal(bs1, &foo3)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, foo1, foo3)\n\n\t\tfoo4 := Foo{}\n\t\terr = json.Unmarshal(bs2, &foo4)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, foo2, foo4)\n\t\tassert.False(t, foo2 == foo4)\n\n\t\ttype Fooo struct {\n\t\t\tBar *R[int] `json:\"bar\"`\n\t\t}\n\n\t\tfoo5 := Fooo{}\n\t\terr = json.Unmarshal(bs1, &foo5)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, foo1.Bar, *foo5.Bar)\n\t}\n}\n\nfunc TestRIsOK(t *testing.T) {\n\tassert.True(t, OK(10).IsOK())\n\tassert.True(t, OK(0).IsOK())\n\tassert.False(t, Err[int](anErr).IsOK())\n\tassert.True(t, Of(10, nil).IsOK())\n\tassert.False(t, Of(10, anErr).IsOK())\n\tassert.False(t, Of(0, anErr).IsOK())\n\t_ = OK(10).IsOK(1)\n}\n\nfunc TestRIsErr(t *testing.T) {\n\tassert.False(t, OK(10).IsErr())\n\tassert.False(t, OK(0).IsErr())\n\tassert.True(t, Err[int](anErr).IsErr())\n\tassert.False(t, Of(10, nil).IsErr())\n\tassert.True(t, Of(10, anErr).IsErr())\n\tassert.True(t, Of(0, anErr).IsErr())\n\t_ = Err[int](anErr).IsErr(\"string\")\n}\n\nfunc TestRMap(t *testing.T) {\n\tassert.Equal(t, OK(\"1\"), Map(OK(1), strconv.Itoa))\n\tassert.Equal(t, Err[string](anErr), Map(Err[int](anErr), strconv.Itoa))\n\n\tassert.NotPanic(t, func() {\n\t\tf := func(v int) string { panic(\"function should not be called\") }\n\t\tassert.Equal(t, Err[string](anErr), Map(Err[int](anErr), f))\n\t})\n\t_ = Map(OK(1), strconv.Itoa, 1)\n}\n\nfunc TestRMapErr(t *testing.T) {\n\tanotherErr := errors.New(\"another error\")\n\tmapper := func(error) error {\n\t\treturn anotherErr\n\t}\n\tassert.Equal(t, OK(1), MapErr(OK(1), mapper))\n\tassert.Equal(t, Err[int](anotherErr), MapErr(Err[int](anErr), mapper))\n\t_ = MapErr(OK(1), mapper, 1)\n}\n\nfunc TestRMapThen(t *testing.T) {\n\tanotherErr := errors.New(\"another error\")\n\tdo := func(v int) R[string] {\n\t\treturn OK(strconv.Itoa(v))\n\t}\n\tdoErr := func(v int) R[string] {\n\t\treturn Err[string](anotherErr)\n\t}\n\tassert.Equal(t, OK(\"1\"), Then(OK(1), do))\n\tassert.Equal(t, Err[string](anotherErr), Then(OK(1), doErr))\n\tassert.Equal(t, Err[string](anErr), Then(Err[int](anErr), do))\n\tassert.Equal(t, Err[string](anErr), Then(Err[int](anErr), doErr))\n\n\tassert.NotPanic(t, func() {\n\t\tf := func(v int) R[string] { panic(\"function should not be called\") }\n\t\tassert.Equal(t, Err[string](anErr), Then(Err[int](anErr), f))\n\t})\n\t_ = Then(OK(1), do, 1)\n}\n\nfunc TestROptional(t *testing.T) {\n\tassert.Equal(t, goption.OK(1), OK(1).Option())\n\tassert.Equal(t, goption.Nil[int](), Err[int](anErr).Option())\n\t_ = OK(1).Option(1)\n}"
