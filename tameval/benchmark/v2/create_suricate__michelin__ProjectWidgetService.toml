[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Java"
java_version = "21"
java_builder = "Maven"
is_multi_module = false

[repo_info]
repository = "michelin/suricate"
sha = "9a15fd2f6de4e3fced8deb8f60160c43e27ba492"

[run_info]
docker_image = "maven:3-amazoncorretto-21"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "mvn -Dmaven.repo.local=/.m2 -T 4 clean install && mvn -Dmaven.repo.local=/.m2 -T 4 clean package"
test_run_command = "mvn clean -Dmaven.repo.local=/.m2 test -q -Dtest=ProjectWidgetServiceTest && mvn jacoco:report -Djacoco.append=false"
mutation_run_command = "mvn -Dmaven.repo.local=/.m2 org.pitest:pitest-maven:mutationCoverage -DtargetClasses=**.ProjectWidgetService  -DtargetTests=**.ProjectWidgetServiceTest  -DoutputFormats=XML"
coverage_report_path = "target/jacoco-ut/jacoco.xml"
coverage_report_type = "jacoco"
mutation_report_path = "target/pit-reports/mutations.xml"
mutation_report_type = "pitest"

[coverage]
coverage = 65.0
original_coverage = 99.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = [ 59, 61, 102, 136, 137, 139, 142, 144, 145, 146, 159, 161, 171, 172, 173, 174, 175, 176, 177, 178, 179, 183, 185, 186, 237, 239, 240, 242, 243, 246, 248, 258, 259, 260, 262, 263, 265, 267, 268, 272, 273, 274, 276, 279, 281, 283, 284, 285, 288, 289, 290, 293, 348, 349, 359, 360, 362, 363, 364, 365, 367, 368, 371, 373, 375, 376, 387, 388, 390, 401, 402, 403,]
missed_lines = [ 91, 114, 124, 125, 126, 195, 197, 198, 200, 201, 205, 207, 208, 210, 214, 215, 225, 226, 277, 278, 286, 287, 306, 308, 309, 312, 313, 316, 318, 319, 331, 332, 374, 391, 392, 393, 395, 396, 399,]

[input_info]
test_file_path = "src/test/java/com/michelin/suricate/service/api/ProjectWidgetServiceTest.java"
focal_file_path = "src/main/java/com/michelin/suricate/service/api/ProjectWidgetService.java"
test_file_url = "https://github.com/michelin/suricate/blob/9a15fd2f6de4e3fced8deb8f60160c43e27ba492/src/test/java/com/michelin/suricate/service/api/ProjectWidgetServiceTest.java"
focal_file_url = "https://github.com/michelin/suricate/blob/9a15fd2f6de4e3fced8deb8f60160c43e27ba492/src/main/java/com/michelin/suricate/service/api/ProjectWidgetService.java"
first_commit_date = "2024-04-07"
last_commit_date = "2025-03-12"
test_file_content = "/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.michelin.suricate.service.api;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.argThat;\nimport static org.mockito.Mockito.eq;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport com.github.mustachejava.DefaultMustacheFactory;\nimport com.github.mustachejava.MustacheException;\nimport com.github.mustachejava.MustacheFactory;\nimport com.michelin.suricate.model.dto.api.projectwidget.ProjectWidgetPositionRequestDto;\nimport com.michelin.suricate.model.entity.Project;\nimport com.michelin.suricate.model.entity.ProjectGrid;\nimport com.michelin.suricate.model.entity.ProjectWidget;\nimport com.michelin.suricate.model.entity.Widget;\nimport com.michelin.suricate.model.entity.WidgetParam;\nimport com.michelin.suricate.model.enumeration.DataTypeEnum;\nimport com.michelin.suricate.model.enumeration.UpdateType;\nimport com.michelin.suricate.model.enumeration.WidgetStateEnum;\nimport com.michelin.suricate.repository.ProjectWidgetRepository;\nimport com.michelin.suricate.service.js.DashboardScheduleService;\nimport com.michelin.suricate.service.js.scheduler.JsExecutionScheduler;\nimport com.michelin.suricate.service.websocket.DashboardWebSocketService;\nimport java.io.StringReader;\nimport java.time.Instant;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Optional;\nimport org.jasypt.encryption.StringEncryptor;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport org.springframework.context.ApplicationContext;\n\n@ExtendWith(MockitoExtension.class)\nclass ProjectWidgetServiceTest {\n    @Mock\n    private ProjectWidgetRepository projectWidgetRepository;\n\n    @Mock\n    private DashboardWebSocketService dashboardWebsocketService;\n\n    @Mock\n    private DashboardScheduleService dashboardScheduleService;\n\n    @Mock\n    private WidgetService widgetService;\n\n    @Mock\n    private MustacheFactory mustacheFactory;\n\n    @Mock\n    private ApplicationContext ctx;\n\n    @Mock\n    private StringEncryptor stringEncryptor;\n\n    @Mock\n    private JsExecutionScheduler jsExecutionScheduler;\n\n    @InjectMocks\n    private ProjectWidgetService projectWidgetService;\n\n\n\n\n\n    @Test\n    void shouldCreateAndRefreshDashboards() {\n        Project project = new Project();\n        project.setId(1L);\n        project.setToken(\"token\");\n\n        ProjectGrid projectGrid = new ProjectGrid();\n        projectGrid.setId(1L);\n        projectGrid.setProject(project);\n\n        Widget widget = new Widget();\n        widget.setId(1L);\n\n        ProjectWidget projectWidget = new ProjectWidget();\n        projectWidget.setId(1L);\n        projectWidget.setBackendConfig(\"param=value\");\n        projectWidget.setWidget(widget);\n        projectWidget.setProjectGrid(projectGrid);\n\n        when(projectWidgetRepository.saveAndFlush(any())).thenAnswer(answer -> answer.getArgument(0));\n\n        projectWidgetService.createAndRefreshDashboards(projectWidget);\n\n        verify(projectWidgetRepository).saveAndFlush(projectWidget);\n        verify(dashboardWebsocketService)\n                .sendEventToProjectSubscribers(\n                        eq(\"token\"),\n                        argThat(event ->\n                                event.getType().equals(UpdateType.REFRESH_DASHBOARD) && event.getDate() != null));\n    }\n\n    @Test\n    void shouldUpdateWidgetPositionByProjectWidgetId() {\n        projectWidgetService.updateWidgetPositionByProjectWidgetId(1L, 1, 1, 1, 1);\n\n        verify(projectWidgetRepository).updateRowAndColAndWidthAndHeightById(1, 1, 1, 1, 1L);\n    }\n\n    @Test\n    void shouldUpdateWidgetPositionByProject() {\n        Project project = new Project();\n        project.setId(1L);\n        project.setToken(\"token\");\n\n        ProjectWidgetPositionRequestDto projectWidgetPositionRequestDto = new ProjectWidgetPositionRequestDto();\n        projectWidgetPositionRequestDto.setProjectWidgetId(1L);\n        projectWidgetPositionRequestDto.setHeight(1);\n        projectWidgetPositionRequestDto.setWidth(1);\n        projectWidgetPositionRequestDto.setGridColumn(1);\n        projectWidgetPositionRequestDto.setGridRow(1);\n\n        projectWidgetService.updateWidgetPositionByProject(\n                project, Collections.singletonList(projectWidgetPositionRequestDto));\n\n        verify(projectWidgetRepository).flush();\n        verify(dashboardWebsocketService).sendEventToProjectSubscribers(eq(\"token\"), argThat(event -> event.getType()\n                .equals(UpdateType.REFRESH_DASHBOARD)));\n    }\n\n\n\n\n\n\n    @Test\n    void shouldUpdateState() {\n        ProjectWidget projectWidget = new ProjectWidget();\n        projectWidget.setId(1L);\n        projectWidget.setBackendConfig(\"param=value\");\n\n        when(projectWidgetRepository.findById(any())).thenReturn(Optional.of(projectWidget));\n\n        Date now = Date.from(Instant.parse(\"2000-01-01T01:00:00.00Z\"));\n        projectWidgetService.updateState(WidgetStateEnum.STOPPED, 1L, now);\n\n        assertEquals(WidgetStateEnum.STOPPED, projectWidget.getState());\n        assertEquals(now, projectWidget.getLastExecutionDate());\n\n        verify(projectWidgetRepository).findById(1L);\n        verify(projectWidgetRepository).saveAndFlush(projectWidget);\n    }\n\n\n    @Test\n    void shouldInstantiateProjectWidgetHtml() {\n        WidgetParam widgetParam = new WidgetParam();\n        widgetParam.setId(1L);\n        widgetParam.setName(\"name\");\n        widgetParam.setType(DataTypeEnum.TEXT);\n\n        WidgetParam widgetParamNotRequired = new WidgetParam();\n        widgetParamNotRequired.setId(2L);\n        widgetParamNotRequired.setName(\"notRequired\");\n        widgetParamNotRequired.setRequired(false);\n        widgetParamNotRequired.setType(DataTypeEnum.TEXT);\n\n        WidgetParam widgetParamAlreadyContained = new WidgetParam();\n        widgetParamAlreadyContained.setId(3L);\n        widgetParamAlreadyContained.setName(\"param\");\n        widgetParamAlreadyContained.setType(DataTypeEnum.TEXT);\n\n        WidgetParam widgetParamAlreadyContainedNotRequired = new WidgetParam();\n        widgetParamAlreadyContainedNotRequired.setId(3L);\n        widgetParamAlreadyContainedNotRequired.setName(\"param\");\n        widgetParamAlreadyContainedNotRequired.setRequired(false);\n        widgetParamAlreadyContainedNotRequired.setType(DataTypeEnum.TEXT);\n\n        Widget widget = new Widget();\n        widget.setId(1L);\n        widget.setHtmlContent(\"<h1>{{DATA}}</h1>\");\n        widget.setTechnicalName(\"technicalName\");\n        widget.setWidgetParams(Arrays.asList(\n                widgetParam,\n                widgetParamNotRequired,\n                widgetParamAlreadyContained,\n                widgetParamAlreadyContainedNotRequired));\n\n        ProjectWidget projectWidget = new ProjectWidget();\n        projectWidget.setId(1L);\n        projectWidget.setBackendConfig(\"param=value\");\n        projectWidget.setData(\"{\\\"DATA\\\": \\\"titre\\\"}\");\n        projectWidget.setWidget(widget);\n\n        when(mustacheFactory.compile(any(), any()))\n                .thenReturn(new DefaultMustacheFactory()\n                        .compile(new StringReader(widget.getHtmlContent()), widget.getTechnicalName()));\n        when(widgetService.getWidgetParametersWithCategoryParameters(any()))\n                .thenReturn(Arrays.asList(\n                        widgetParam,\n                        widgetParamNotRequired,\n                        widgetParamAlreadyContained,\n                        widgetParamAlreadyContainedNotRequired));\n\n        String actual = projectWidgetService.instantiateProjectWidgetHtml(projectWidget);\n\n        assertEquals(\"<h1>titre</h1>\", actual);\n\n        verify(widgetService).getWidgetParametersWithCategoryParameters(widget);\n    }\n\n\n\n\n\n\n    @Test\n    void shouldUpdateWidgetInstanceAfterSucceededExecution() {\n        Date now = new Date();\n        projectWidgetService.updateWidgetInstanceAfterSucceededExecution(\n                now, \"log\", \"data\", 1L, WidgetStateEnum.STOPPED);\n\n        verify(projectWidgetRepository).updateSuccessExecution(now, \"log\", \"data\", 1L, WidgetStateEnum.STOPPED);\n    }\n\n\n    @Test\n    void shouldDecryptSecretParamsWithPasswordIfNeeded() {\n        WidgetParam widgetParam = new WidgetParam();\n        widgetParam.setId(1L);\n        widgetParam.setName(\"param\");\n        widgetParam.setType(DataTypeEnum.PASSWORD);\n\n        Widget widget = new Widget();\n        widget.setId(1L);\n\n        when(widgetService.getWidgetParametersWithCategoryParameters(any()))\n                .thenReturn(Collections.singletonList(widgetParam));\n        when(stringEncryptor.decrypt(any())).thenReturn(\"decrypted\");\n\n        String actual = projectWidgetService.decryptSecretParamsIfNeeded(widget, \"param=value\");\n\n        assertEquals(\"param=decrypted\", actual);\n\n        verify(widgetService).getWidgetParametersWithCategoryParameters(widget);\n        verify(stringEncryptor).decrypt(\"value\");\n    }\n\n    @Test\n    void shouldDecryptSecretParamsWhenNotInBackendConfig() {\n        WidgetParam widgetParam = new WidgetParam();\n        widgetParam.setId(1L);\n        widgetParam.setName(\"param\");\n        widgetParam.setType(DataTypeEnum.PASSWORD);\n\n        Widget widget = new Widget();\n        widget.setId(1L);\n\n        when(widgetService.getWidgetParametersWithCategoryParameters(any()))\n                .thenReturn(Collections.singletonList(widgetParam));\n\n        String actual = projectWidgetService.decryptSecretParamsIfNeeded(widget, \"otherParam=\");\n\n        assertTrue(actual.isEmpty());\n\n        verify(widgetService).getWidgetParametersWithCategoryParameters(widget);\n        verify(stringEncryptor, never()).decrypt(any());\n    }\n\n\n\n}\n"
