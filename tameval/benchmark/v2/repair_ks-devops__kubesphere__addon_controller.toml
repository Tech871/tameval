[meta]
task = "repair"
scenario = "repair_no_new_covered_logic"

[lang_info]
lang = "Go"
go_version = "1.23"

[repo_info]
repository = "kubesphere/ks-devops"
sha = "912f453210d5a51ed62b0b35c1073cd94f3601c2"

[run_info]
docker_image = "golang:1.23"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out controllers/addon/addon_controller.go controllers/addon/addon_controller_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting controllers/addon/addon_controller.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 45.0
original_coverage = 45.0
mutation_kill_rate = 0
original_mutation_kill_rate = nan
covered_lines = [ 69, 70, 71, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 105, 106, 107, 108, 112, 113, 114, 115, 116, 119, 120, 121, 122, 144, 149, 150, 151, 152, 153, 156, 157, 158, 159, 160, 161, 162, 164, 167, 168, 169, 170, 171, 172,]
missed_lines = [ 52, 53, 54, 55, 56, 57, 58, 59, 61, 62, 63, 65, 66, 73, 74, 75, 76, 77, 79, 80, 81, 82, 83, 101, 102, 103, 104, 123, 124, 125, 126, 128, 129, 130, 131, 133, 134, 135, 136, 137, 139, 140, 141, 142, 145, 146, 147, 148, 176, 177, 178, 179, 180, 181, 182, 183,]

[input_info]
test_file_path = "controllers/addon/addon_controller_test.go"
focal_file_path = "controllers/addon/addon_controller.go"
test_file_url = "https://github.com/kubesphere/ks-devops/blob/912f453210d5a51ed62b0b35c1073cd94f3601c2/controllers/addon/addon_controller_test.go"
focal_file_url = "https://github.com/kubesphere/ks-devops/blob/912f453210d5a51ed62b0b35c1073cd94f3601c2/controllers/addon/addon_controller.go"
first_commit_date = "2022-02-07"
last_commit_date = "2025-03-13"
test_file_content = "package addon\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/go-logr/logr\"\n\t\"github.com/kubesphere/ks-devops/pkg/api/devops/v1alpha3\"\n\t\"github.com/stretchr/testify/assert\"\n\tv1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/client-go/tools/record\"\n\t\"sigs.k8s.io/controller-runtime/pkg/client\"\n\t\"sigs.k8s.io/controller-runtime/pkg/client/fake\"\n)\n\nfunc TestReconciler_supportedStrategy(t *testing.T) {\n\ttype args struct {\n\t\tstrategy *v1alpha3.AddonStrategy\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{{\n\t\tname: \"argument is nil\",\n\t\twant: false,\n\t}, {\n\t\tname: \"empty object\",\n\t\targs: args{strategy: &v1alpha3.AddonStrategy{}},\n\t\twant: false,\n\t}, {\n\t\tname: \"fake type\",\n\t\targs: args{strategy: &v1alpha3.AddonStrategy{\n\t\t\tSpec: v1alpha3.AddStrategySpec{Type: \"fake\"},\n\t\t}},\n\t\twant: false,\n\t}, {\n\t\tname: \"simple-operator\",\n\t\targs: args{strategy: &v1alpha3.AddonStrategy{\n\t\t\tSpec: v1alpha3.AddStrategySpec{Type: \"simple-operator\"},\n\t\t}},\n\t\twant: true,\n\t}}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Reconciler{}\n\t\t\tassert.Equalf(t, tt.want, r.supportedStrategy(tt.args.strategy), \"supportedStrategy(%v)\", tt.args.strategy)\n\t\t})\n\t}\n}\n\nfunc Test_getTemplate(t *testing.T) {\n\ttype args struct {\n\t\ttpl   string\n\t\taddon *v1alpha3.Addon\n\t}\n\ttests := []struct {\n\t\tname       string\n\t\targs       args\n\t\twantResult string\n\t\twantErr    assert.ErrorAssertionFunc\n\t}{{\n\t\tname: \"addon is nil\",\n\t\targs: args{\n\t\t\ttpl: \"this is a template\",\n\t\t},\n\t\twantResult: \"this is a template\",\n\t\twantErr: func(t assert.TestingT, err error, i ...interface{}) bool {\n\t\t\treturn false\n\t\t},\n\t}, {\n\t\tname: \"addon with version\",\n\t\targs: args{\n\t\t\ttpl:   \"{{.Spec.Version}}\",\n\t\t\taddon: &v1alpha3.Addon{Spec: v1alpha3.AddonSpec{Version: \"v1alpha3\"}},\n\t\t},\n\t\twantResult: \"v1alpha3\",\n\t\twantErr: func(t assert.TestingT, err error, i ...interface{}) bool {\n\t\t\treturn false\n\t\t},\n\t}}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotResult, err := getTemplate(tt.args.tpl, tt.args.addon)\n\t\t\tif !tt.wantErr(t, err, fmt.Sprintf(\"getTemplate(%v, %v)\", tt.args.tpl, tt.args.addon)) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Equalf(t, tt.wantResult, gotResult, \"getTemplate(%v, %v)\", tt.args.tpl, tt.args.addon)\n\t\t})\n\t}\n}\n\nfunc TestReconciler_AddonHandling(t *testing.T) {\n\tschema, err := v1alpha3.SchemeBuilder.Register().Build()\n\tassert.Nil(t, err)\n\n\tstrategy := &v1alpha3.AddonStrategy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"simple-operator\",\n\t\t},\n\t\tSpec: v1alpha3.AddStrategySpec{\n\t\t\tAvailable:      true,\n\t\t\tType:           v1alpha3.AddonInstallStrategySimpleOperator,\n\t\t\tSimpleOperator: v1.ObjectReference{},\n\t\t\tTemplate: `apiVersion: devops.kubesphere.io/v1alpha1\nkind: ReleaserController\nspec:\n  image: \"ghcr.io/kubesphere-sigs/ks-releaser\"\n  version: {{.Spec.Version}}\n  webhook: false`,\n\t\t},\n\t}\n\taddon := &v1alpha3.Addon{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:            \"ks-releaser\",\n\t\t\tNamespace:       \"default\",\n\t\t\tResourceVersion: \"999\",\n\t\t},\n\t\tSpec: v1alpha3.AddonSpec{\n\t\t\tVersion: \"v0.0.1\",\n\t\t\tStrategy: v1.LocalObjectReference{\n\t\t\t\tName: \"simple-operator\",\n\t\t\t},\n\t\t},\n\t}\n\n\ttype fields struct {\n\t\tClient client.Client\n\t}\n\ttype args struct {\n\t\tctx   context.Context\n\t\taddon *v1alpha3.Addon\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\tfields  fields\n\t\targs    args\n\t\twantErr assert.ErrorAssertionFunc\n\t\tverify  func(t *testing.T, Client client.Client)\n\t}{{\n\t\tname: \"normal case\",\n\t\tfields: fields{\n\t\t\tClient: fake.NewClientBuilder().WithScheme(schema).WithObjects(strategy.DeepCopy(), addon.DeepCopy()).Build(),\n\t\t},\n\t\targs: args{\n\t\t\tctx:   context.TODO(),\n\t\t\taddon: addon.DeepCopy(),\n\t\t},\n\t\twantErr: func(t assert.TestingT, err error, i ...interface{}) bool {\n\t\t\treturn err == nil\n\t\t},\n\t\tverify: func(t *testing.T, c client.Client) {\n\t\t\tvar err error\n\t\t\taddon := &v1alpha3.Addon{}\n\t\t\terr = c.Get(context.Background(), types.NamespacedName{Name: \"ks-releaser\", Namespace: \"default\"}, addon)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.ElementsMatch(t, []string{v1alpha3.AddonFinalizerName}, addon.Finalizers)\n\n\t\t\tobj := &unstructured.Unstructured{}\n\t\t\tobj.SetKind(\"ReleaserController\")\n\t\t\tobj.SetAPIVersion(\"devops.kubesphere.io/v1alpha1\")\n\n\t\t\terr = c.Get(context.Background(), types.NamespacedName{\n\t\t\t\tNamespace: \"default\",\n\t\t\t\tName:      \"ks-releaser\",\n\t\t\t}, obj)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, \"ks-releaser\", obj.GetName())\n\n\t\t\tvar image string\n\t\t\tvar ok bool\n\t\t\timage, ok, err = unstructured.NestedString(obj.Object, \"spec\", \"image\")\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.True(t, ok)\n\t\t\tassert.Equal(t, \"ghcr.io/kubesphere-sigs/ks-releaser\", image)\n\t\t},\n\t}, {\n\t\tname: \"update existing addon\",\n\t\tfields: fields{\n\t\t\tClient: fake.NewClientBuilder().WithScheme(schema).WithObjects(strategy.DeepCopy(), &unstructured.Unstructured{Object: map[string]interface{}{\n\t\t\t\t\"apiVersion\": \"devops.kubesphere.io/v1alpha1\",\n\t\t\t\t\"kind\":       \"ReleaserController\",\n\t\t\t\t\"metadata\": map[string]interface{}{\n\t\t\t\t\t\"name\":      \"ks-releaser\",\n\t\t\t\t\t\"namespace\": \"default\",\n\t\t\t\t},\n\t\t\t}}).Build(),\n\t\t},\n\t\targs: args{\n\t\t\tctx: context.TODO(),\n\t\t\taddon: &v1alpha3.Addon{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{Name: \"ks-releaser\"},\n\t\t\t\tSpec: v1alpha3.AddonSpec{\n\t\t\t\t\tVersion: \"v0.0.1\",\n\t\t\t\t\tStrategy: v1.LocalObjectReference{\n\t\t\t\t\t\tName: \"simple-operator\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t},\n\t\twantErr: func(t assert.TestingT, err error, i ...interface{}) bool {\n\t\t\treturn err == nil\n\t\t},\n\t\tverify: func(t *testing.T, c client.Client) {\n\t\t\tobj := &unstructured.Unstructured{}\n\t\t\tobj.SetKind(\"ReleaserController\")\n\t\t\tobj.SetAPIVersion(\"devops.kubesphere.io/v1alpha1\")\n\n\t\t\terr := c.Get(context.Background(), types.NamespacedName{\n\t\t\t\tNamespace: \"default\",\n\t\t\t\tName:      \"ks-releaser\",\n\t\t\t}, obj)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, \"ks-releaser\", obj.GetName())\n\n\t\t\tvar image string\n\t\t\tvar ok bool\n\t\t\timage, ok, err = unstructured.NestedString(obj.Object, \"spec\", \"image\")\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.True(t, ok)\n\t\t\tassert.Equal(t, \"ghcr.io/kubesphere-sigs/ks-releaser\", image)\n\t\t},\n\t}}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Reconciler{\n\t\t\t\tClient:   tt.fields.Client,\n\t\t\t\tlog:      logr.Discard(),\n\t\t\t\trecorder: record.NewFakeRecorder(100),\n\t\t\t}\n\t\t\ttt.wantErr(t, r.addonHandle(tt.args.ctx, tt.args.addon), fmt.Sprintf(\"addonHandle(%v, %v)\", tt.args.ctx, tt.args.addon))\n\t\t\tif tt.verify != nil {\n\t\t\t\ttt.verify(t, tt.fields.Client)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReconciler_HandleAddon(t *testing.T) {\n\tschema, err := v1alpha3.SchemeBuilder.Register().Build()\n\tassert.Nil(t, err)\n\n\tstrategy := &v1alpha3.AddonStrategy{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"simple-operator\",\n\t\t},\n\t\tSpec: v1alpha3.AddStrategySpec{\n\t\t\tAvailable:      true,\n\t\t\tType:           v1alpha3.AddonInstallStrategySimpleOperator,\n\t\t\tSimpleOperator: v1.ObjectReference{},\n\t\t\tTemplate: `apiVersion: devops.kubesphere.io/v1alpha1\nkind: ReleaserController\nspec:\n  image: \"ghcr.io/kubesphere-sigs/ks-releaser\"\n  version: {{.Spec.Version}}\n  webhook: false`,\n\t\t},\n\t}\n\taddon := &v1alpha3.Addon{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:            \"ks-releaser\",\n\t\t\tNamespace:       \"default\",\n\t\t\tResourceVersion: \"999\",\n\t\t},\n\t\tSpec: v1alpha3.AddonSpec{\n\t\t\tVersion: \"v0.0.1\",\n\t\t\tStrategy: v1.LocalObjectReference{\n\t\t\t\tName: \"simple-operator\",\n\t\t\t},\n\t\t},\n\t}\n\n\ttype fields struct {\n\t\tClient client.Client\n\t}\n\ttype args struct {\n\t\tctx   context.Context\n\t\taddon *v1alpha3.Addon\n\t}\n\ttests := []struct {\n\t\tname    string\n\t\tfields  fields\n\t\targs    args\n\t\twantErr assert.ErrorAssertionFunc\n\t\tverify  func(t *testing.T, Client client.Client)\n\t}{{\n\t\tname: \"normal case\",\n\t\tfields: fields{\n\t\t\tClient: fake.NewClientBuilder().WithScheme(schema).WithObjects(strategy.DeepCopy(), addon.DeepCopy()).Build(),\n\t\t},\n\t\targs: args{\n\t\t\tctx:   context.TODO(),\n\t\t\taddon: addon.DeepCopy(),\n\t\t},\n\t\twantErr: func(t assert.TestingT, err error, i ...interface{}) bool {\n\t\t\treturn err == nil\n\t\t},\n\t\tverify: func(t *testing.T, c client.Client) {\n\t\t\taddon := &v1alpha3.Addon{}\n\t\t\terr := c.Get(context.Background(), types.NamespacedName{Name: \"ks-releaser\", Namespace: \"default\"}, addon)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.ElementsMatch(t, []string{v1alpha3.AddonFinalizerName}, addon.Finalizers)\n\n\t\t\tobj := &unstructured.Unstructured{}\n\t\t\tobj.SetKind(\"ReleaserController\")\n\t\t\tobj.SetAPIVersion(\"devops.kubesphere.io/v1alpha1\")\n\n\t\t\terr = c.Get(context.Background(), types.NamespacedName{\n\t\t\t\tNamespace: \"default\",\n\t\t\t\tName:      \"ks-releaser\",\n\t\t\t}, obj)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, \"ks-releaser\", obj.GetName())\n\n\t\t\timage, ok, err := unstructured.NestedString(obj.Object, \"spec\", \"image\")\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.True(t, ok)\n\t\t\tassert.Equal(t, \"ghcr.io/kubesphere-sigs/ks-releaser\", image)\n\t\t},\n\t}, {\n\t\tname: \"update existing addon\",\n\t\tfields: fields{\n\t\t\tClient: fake.NewClientBuilder().WithScheme(schema).WithObjects(strategy.DeepCopy(), &unstructured.Unstructured{Object: map[string]interface{}{\n\t\t\t\t\"apiVersion\": \"devops.kubesphere.io/v1alpha1\",\n\t\t\t\t\"kind\":       \"ReleaserController\",\n\t\t\t\t\"metadata\": map[string]interface{}{\n\t\t\t\t\t\"name\":      \"ks-releaser\",\n\t\t\t\t\t\"namespace\": \"default\",\n\t\t\t\t},\n\t\t\t}}).Build(),\n\t\t},\n\t\targs: args{\n\t\t\tctx: context.TODO(),\n\t\t\taddon: &v1alpha3.Addon{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{Name: \"ks-releaser\"},\n\t\t\t\tSpec: v1alpha3.AddonSpec{\n\t\t\t\t\tVersion: \"v0.0.1\",\n\t\t\t\t\tStrategy: v1.LocalObjectReference{\n\t\t\t\t\t\tName: \"simple-operator\",\n\t\t\t\t\t},\n\t\t\t\t}},\n\t\t},\n\t\twantErr: func(t assert.TestingT, err error, i ...interface{}) bool {\n\t\t\treturn err == nil\n\t\t},\n\t\tverify: func(t *testing.T, c client.Client) {\n\t\t\tobj := &unstructured.Unstructured{}\n\t\t\tobj.SetKind(\"ReleaserController\")\n\t\t\tobj.SetAPIVersion(\"devops.kubesphere.io/v1alpha1\")\n\n\t\t\terr := c.Get(context.Background(), types.NamespacedName{\n\t\t\t\tNamespace: \"default\",\n\t\t\t\tName:      \"ks-releaser\",\n\t\t\t}, obj)\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.Equal(t, \"ks-releaser\", obj.GetName())\n\n\t\t\timage, ok, err := unstructured.NestedString(obj.Object, \"spec\", \"image\")\n\t\t\tassert.Nil(t, err)\n\t\t\tassert.True(t, ok)\n\t\t\tassert.Equal(t, \"ghcr.io/kubesphere-sigs/ks-releaser\", image)\n\t\t},\n\t}}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tr := &Reconciler{\n\t\t\t\tClient:   tt.fields.Client,\n\t\t\t\tlog:      logr.Discard(),\n\t\t\t\trecorder: record.NewFakeRecorder(100),\n\t\t\t}\n\t\t\ttt.wantErr(t, r.addonHandle(tt.args.ctx, tt.args.addon), fmt.Sprintf(\"addonHandle(%v, %v)\", tt.args.ctx, tt.args.addon))\n\t\t\tif tt.verify != nil {\n\t\t\t\ttt.verify(t, tt.fields.Client)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_beingDeleting(t *testing.T) {\n\tnowTime := metav1.Now()\n\n\ttype args struct {\n\t\taddon *v1alpha3.Addon\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant bool\n\t}{{\n\t\tname: \"empty struct\",\n\t\targs: args{\n\t\t\taddon: &v1alpha3.Addon{},\n\t\t},\n\t\twant: false,\n\t}, {\n\t\tname: \"has deletionTimestamp\",\n\t\targs: args{\n\t\t\taddon: &v1alpha3.Addon{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tDeletionTimestamp: &nowTime,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\twant: true,\n\t}}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tassert.Equalf(t, tt.want, beingDeleting(tt.args.addon), \"beingDeleting(%v)\", tt.args.addon)\n\t\t})\n\t}\n}"
