[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Java"
java_version = "8"
java_builder = "Maven"
is_multi_module = false

[repo_info]
repository = "Password4j/password4j"
sha = "18aaa552d76471585cc40517e05adb9e8dd1ad3d"

[run_info]
docker_image = "maven:3.8.6-jdk-8"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "mvn -Dmaven.repo.local=/.m2 -T 4 clean install"
test_run_command = "mvn clean -Dmaven.repo.local=/.m2 test -q -Dtest=MessageDigestFunctionTest && mvn jacoco:report -Djacoco.append=false"
mutation_run_command = "mvn -Dmaven.repo.local=/.m2 org.pitest:pitest-maven:mutationCoverage -DtargetClasses=**.MessageDigestFunction  -DtargetTests=**.MessageDigestFunctionTest  -DoutputFormats=XML"
coverage_report_path = "target/site/jacoco/jacoco.xml"
coverage_report_type = "jacoco"
mutation_report_path = "target/pit-reports/mutations.xml"
mutation_report_type = "pitest"

[coverage]
coverage = 89.0
original_coverage = 89.0
mutation_kill_rate = 69.0
original_mutation_kill_rate = 69.0
covered_lines = [ 34, 35, 42, 43, 44, 45, 57, 71, 72, 74, 78, 79, 80, 86, 91, 97, 109, 120, 122, 123, 130, 132, 134, 141, 153, 154, 173, 184, 190, 192, 195, 197, 199, 205, 211, 212, 213, 214, 215, 216, 223,]
missed_lines = [ 103, 115, 147, 160, 161,]

[input_info]
test_file_path = "src/test/com/password4j/MessageDigestFunctionTest.java"
focal_file_path = "src/main/java/com/password4j/MessageDigestFunction.java"
test_file_url = "https://github.com/Password4j/password4j/blob/18aaa552d76471585cc40517e05adb9e8dd1ad3d/src/test/com/password4j/MessageDigestFunctionTest.java"
focal_file_url = "https://github.com/Password4j/password4j/blob/18aaa552d76471585cc40517e05adb9e8dd1ad3d/src/main/java/com/password4j/MessageDigestFunction.java"
first_commit_date = "2020-11-15"
last_commit_date = "2024-05-01"
test_file_content = "/*\n *  (C) Copyright 2020 Password4j (http://password4j.com/).\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage com.password4j;\n\nimport com.password4j.types.Bcrypt;\nimport com.password4j.types.Hmac;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.util.Base64;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.junit.Assert.assertEquals;\n\n\npublic class MessageDigestFunctionTest\n{\n\n\n    @Test\n    public void testMD5()\n    {\n        // GIVEN\n        HashingFunction strategy = MessageDigestFunction.getInstance(\"MD5\");\n        String password = \"password\";\n        String salt = \"abc\";\n\n        // WHEN\n        Hash hash = strategy.hash(password, salt);\n\n        // THEN\n        assertEquals(\"8223fe8dc0533c6ebbb717e7fda2833c\", hash.getResult());\n    }\n\n\n    @Test\n    public void testMD5noSalt()\n    {\n        // GIVEN\n        HashingFunction strategy = MessageDigestFunction.getInstance(\"MD5\");\n        String password = \"password\";\n\n        // WHEN\n        Hash hash = strategy.hash(password);\n\n        // THEN\n        assertEquals(\"5f4dcc3b5aa765d61d8327deb882cf99\", hash.getResult());\n    }\n\n    @Test\n    public void testDifferentConcatenations()\n    {\n        // GIVEN\n        HashingFunction strategy1 = MessageDigestFunction.getInstance(\"MD5\", SaltOption.PREPEND);\n        HashingFunction strategy2 = MessageDigestFunction.getInstance(\"MD5\", SaltOption.APPEND);\n\n        String password = \"password\";\n        String salt = \"abc\";\n\n        // WHEN\n        Hash hash1 = strategy1.hash(password, salt);\n        Hash hash2 = strategy2.hash(password, salt);\n\n        // THEN\n        Assert.assertNotEquals(hash1.getResult(), hash2.getResult());\n    }\n\n    @Test\n    public void testMDVariants()\n    {\n        Set<String> algorithms = AlgorithmFinder.getAllMessageDigests();\n        for (String alg : algorithms)\n        {\n            // GIVEN\n            MessageDigestFunction strategy = MessageDigestFunction.getInstance(alg);\n            String password = \"password\";\n            String salt = \"abc\";\n\n            // WHEN\n            Hash hash = strategy.hash(password);\n            Hash hashWithSalt = strategy.hash(password, salt);\n\n            // THEN\n            Assert.assertTrue(strategy.check(password, hash.getResult()));\n            Assert.assertTrue(strategy.check(password, hashWithSalt.getResult(), salt));\n        }\n    }\n\n    @Test(expected = UnsupportedOperationException.class)\n    public void testMDWrongAlgorithm()\n    {\n        // GIVEN\n        HashingFunction strategy = MessageDigestFunction.getInstance(\"notAnAlgorithm\");\n        String password = \"password\";\n        String salt = \"abc\";\n\n        // WHEN\n        strategy.hash(password, salt);\n\n        // THEN\n    }\n\n    @Test\n    public void testMDWrongSaltOption()\n    {\n        // GIVEN\n\n        PropertyReader.properties.setProperty(\"hash.md.salt.option\", \"1234\");\n\n        // WHEN\n        MessageDigestFunction function = AlgorithmFinder.getMessageDigestInstance();\n\n        // THEN\n        assertEquals(SaltOption.APPEND, function.getSaltOption());\n        PropertyReader.properties.setProperty(\"hash.md.salt.option\", \"append\");\n    }\n\n    @Test\n    public void testMDRightSaltOption()\n    {\n        // GIVEN\n\n        PropertyReader.properties.setProperty(\"hash.md.salt.option\", \"prepend\");\n\n        // WHEN\n        MessageDigestFunction function = AlgorithmFinder.getMessageDigestInstance();\n\n        // THEN\n        assertEquals(SaltOption.PREPEND, function.getSaltOption());\n        PropertyReader.properties.setProperty(\"hash.md.salt.option\", \"append\");\n\n    }\n\n\n    @Test\n    public void testPBKDF2Check()\n    {\n        // GIVEN\n        String hashed = \"$3$42949672960256$YWJj$/WTQfTTc8Hg8GlplP0LthpgdElUG+I3MyuvK8MI4MnQ=\";\n        String userSubmittedPassword = \"password\";\n\n        // WHEN\n        HashingFunction strategy = CompressedPBKDF2Function.getInstanceFromHash(hashed);\n\n        // THEN\n        Assert.assertTrue(strategy.check(userSubmittedPassword, hashed));\n    }\n\n\n    @Test\n    public void testPBKDF2WrongCheck2()\n    {\n        // GIVEN\n        String hashed = \"$3$42949672960256$YWJj$/WTQfTTc8Hg8GlplP0LthpgdElUG+I3MyuvK8MI4MnQ=\";\n        String badHash = \"$342949672960256$YWJj$/WTQfTTc8Hg8GlplP0LthpgdElUG+I3MyuvK8MI4MnQ=\";\n        String userSubmittedPassword = \"password\";\n\n        // WHEN\n        HashingFunction strategy = CompressedPBKDF2Function.getInstanceFromHash(hashed);\n\n        // THEN\n        try {\n            Assert.assertTrue(strategy.check(userSubmittedPassword, badHash));\n        } catch (BadParametersException ex) {\n            assertEquals(\"`\" + badHash + \"` is not a valid hash\", ex.getMessage());\n        }\n    }\n\n\n    @Test(expected = BadParametersException.class)\n    public void testPBKDF2BadCheck()\n    {\n        // GIVEN\n        String hashed = \"$342949672960256$YWJj$/WTQfTTc8Hg8GlplP0LthpgdElUG+I3MyuvK8MI4MnQ=\";\n        String userSubmittedPassword = \"password\";\n\n        // WHEN\n        CompressedPBKDF2Function.getInstanceFromHash(hashed);\n\n\n    }\n\n    @Test\n    public void testAlgorithmFromCode()\n    {\n        // GIVEN\n\n        // WHEN\n        Hmac algNull = Hmac.fromCode(-100);\n        for (Hmac enumAlg : Hmac.values())\n        {\n            Hmac alg = Hmac.fromCode(enumAlg.code());\n\n\n            // THEN\n            Assert.assertNotNull(alg);\n            assertEquals(enumAlg.code(), alg.code());\n            assertEquals(enumAlg.bits(), alg.bits());\n        }\n        Assert.assertNull(algNull);\n\n\n    }\n\n    @Test\n    public void testPBKDF2Coherence()\n    {\n        // GIVEN\n        String password = \"password\";\n\n        // WHEN\n        Hash hash = PBKDF2Function.getInstance(Hmac.SHA256, 8_777, 256).hash(password);\n\n        // THEN\n        Assert.assertTrue(Password.check(password, hash));\n\n    }\n\n    @Test\n    public void testPBKDF2CheckWithFixedConfigurations()\n    {\n        // GIVEN\n        String hashed = \"$3$42949672960256$YWJj$/WTQfTTc8Hg8GlplP0LthpgdElUG+I3MyuvK8MI4MnQ=\";\n        String userSubmittedPassword = \"password\";\n\n        // WHEN\n        HashingFunction strategy = new CompressedPBKDF2Function(Hmac.SHA256, 10_000, 256);\n\n        // THEN\n        Assert.assertTrue(strategy.check(userSubmittedPassword, hashed));\n    }\n\n\n    @Test\n    public void testPBKDF2equality()\n    {\n        // GIVEN\n        PBKDF2Function strategy1 = PBKDF2Function.getInstance(Hmac.SHA256, 10_000, 256);\n        PBKDF2Function strategy2 = PBKDF2Function.getInstance(Hmac.SHA256, 10_000, 256);\n        PBKDF2Function strategy3 = PBKDF2Function.getInstance(Hmac.SHA1, 10_000, 256);\n        PBKDF2Function strategy4 = PBKDF2Function.getInstance(Hmac.SHA256, 64_000, 256);\n        PBKDF2Function strategy5 = PBKDF2Function.getInstance(Hmac.SHA256, 64_000, 123);\n\n\n        // WHEN\n        Map<PBKDF2Function, String> map = new HashMap<>();\n        map.put(strategy1, strategy1.toString());\n        map.put(strategy2, strategy2.toString());\n        map.put(strategy3, strategy3.toString());\n        map.put(strategy4, strategy4.toString());\n        map.put(strategy5, strategy5.toString());\n\n\n        // THEN\n        assertEquals(4, map.size());\n        assertEquals(strategy1, strategy2);\n    }\n\n    @Test\n    public void testCompressed()\n    {\n        Hmac algorithm = Hmac.SHA512;\n\n\n        for (int i = 1; i <= 100; i++)\n        {\n            String password = PepperGenerator.generate(12);\n            String salt = PepperGenerator.generate(i);\n            Hash hash = CompressedPBKDF2Function.getInstance(algorithm, 100 * i, algorithm.bits()).hash(password, salt);\n\n            Hash notCompressedHash = PBKDF2Function.getInstance(algorithm, 100 * i, algorithm.bits()).hash(password, salt);\n\n            String params = Long.toString((((long) 100 * i) << 32) | (algorithm.bits() & 0xffffffffL));\n            String expected = \"$\" + algorithm.code() + \"$\" + params + \"$\" + Base64.getEncoder().encodeToString(salt.getBytes(Utils.DEFAULT_CHARSET)) + \"$\" + notCompressedHash.getResult();\n\n            assertEquals(expected, hash.getResult());\n        }\n    }\n\n    @Test\n    public void testAccessors()\n    {\n        // GIVEN\n\n\n        // WHEN\n        MessageDigestFunction function = MessageDigestFunction.getInstance(\"MD5\", SaltOption.APPEND);\n\n        // THEN\n        assertEquals(\"MD5\", function.getAlgorithm());\n        assertEquals(SaltOption.APPEND, function.getSaltOption());\n        assertEquals(\"MessageDigestFunction(a=MD5, o=APPEND)\", function.toString());\n    }\n\n    @Test\n    public void testEquality()\n    {\n        // GIVEN\n        String a = \"MD5\";\n        SaltOption o = SaltOption.APPEND;\n        MessageDigestFunction function = MessageDigestFunction.getInstance(a, o);\n\n        // THEN\n        boolean eqNull = function.equals(null);\n        boolean eqClass = function.equals(new BcryptFunction(Bcrypt.A, 10));\n        boolean sameInst = function.equals(MessageDigestFunction.getInstance(a, o));\n        boolean sameInst2 = function.equals(new MessageDigestFunction(a, o));\n        String toString = function.toString();\n        int hashCode = function.hashCode();\n        boolean notSameInst1 = function.equals(new MessageDigestFunction(\"SHA1\", o));\n        boolean notSameInst2 = function.equals(new MessageDigestFunction(a, SaltOption.PREPEND));\n\n\n        // END\n        Assert.assertFalse(eqNull);\n        Assert.assertFalse(eqClass);\n        Assert.assertTrue(sameInst);\n        Assert.assertTrue(sameInst2);\n        Assert.assertNotEquals(toString, new MessageDigestFunction(\"SHA1\", o).toString());\n        Assert.assertNotEquals(hashCode, new MessageDigestFunction(a, SaltOption.PREPEND).hashCode());\n        Assert.assertFalse(notSameInst1);\n        Assert.assertFalse(notSameInst2);\n    }\n\n}\n"
