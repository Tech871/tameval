[meta]
task = "repair"
scenario = "repair_duplicate_entity"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "antrea-io/antrea"
sha = "0cd2eed3cc54448553096bf4e6ee74836c9c1d11"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/avito-tech/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/agent/controller/l7flowexporter/l7_flow_export_controller.go pkg/agent/controller/l7flowexporter/l7_flow_export_controller_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/agent/controller/l7flowexporter/l7_flow_export_controller.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 55.0
mutation_kill_rate = nan
original_mutation_kill_rate = 29.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "pkg/agent/controller/l7flowexporter/l7_flow_export_controller_test.go"
focal_file_path = "pkg/agent/controller/l7flowexporter/l7_flow_export_controller.go"
test_file_url = "https://github.com/antrea-io/antrea/blob/0cd2eed3cc54448553096bf4e6ee74836c9c1d11/pkg/agent/controller/l7flowexporter/l7_flow_export_controller_test.go"
focal_file_url = "https://github.com/antrea-io/antrea/blob/0cd2eed3cc54448553096bf4e6ee74836c9c1d11/pkg/agent/controller/l7flowexporter/l7_flow_export_controller.go"
first_commit_date = "2024-01-24"
last_commit_date = "2025-02-23"
test_file_content = "\n\npackage l7flowexporter\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n\tv1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/fields\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/client-go/informers\"\n\tcoreinformers \"k8s.io/client-go/informers/core/v1\"\n\t\"k8s.io/client-go/kubernetes/fake\"\n\t\"k8s.io/client-go/tools/cache\"\n\n\t\"antrea.io/antrea/pkg/agent/interfacestore\"\n\topenflowtest \"antrea.io/antrea/pkg/agent/openflow/testing\"\n\t\"antrea.io/antrea/pkg/agent/types\"\n\t\"antrea.io/antrea/pkg/agent/util\"\n\t\"antrea.io/antrea/pkg/apis/crd/v1alpha2\"\n\t\"antrea.io/antrea/pkg/util/k8s\"\n)\n\nvar (\n\tannotationsEmpty          = map[string]string{}\n\tannotationsDifferent      = map[string]string{\"annotation.antrea.io\": \"mockVal1\"}\n\tannotationsIncorrect      = map[string]string{types.L7FlowExporterAnnotationKey: \"mockVal2\"}\n\tannotationsCorrectIngress = map[string]string{types.L7FlowExporterAnnotationKey: \"ingress\"}\n\tannotationsCorrectEgress  = map[string]string{types.L7FlowExporterAnnotationKey: \"egress\"}\n\tannotationsCorrectBoth    = map[string]string{types.L7FlowExporterAnnotationKey: \"both\"}\n\n\tpod1NN        = k8s.NamespacedName(\"test-ns1\", \"test-pod1\")\n\tpod2NN        = k8s.NamespacedName(\"test-ns1\", \"test-pod2\")\n\tpod3NN        = k8s.NamespacedName(\"test-ns2\", \"test-pod3\")\n\tpod4NN        = k8s.NamespacedName(\"test-ns2\", \"test-pod4\")\n\tpodInterface1 = newPodInterface(\"test-pod1\", \"test-ns1\", int32(pod1OFPort))\n\tpodInterface2 = newPodInterface(\"test-pod2\", \"test-ns1\", int32(pod2OFPort))\n\tpodInterface3 = newPodInterface(\"test-pod3\", \"test-ns2\", int32(pod3OFPort))\n\tpodInterface4 = newPodInterface(\"test-pod4\", \"test-ns2\", int32(pod4OFPort))\n\n\tctx = context.Background()\n)\n\nconst (\n\tpod1OFPort = uint32(1)\n\tpod2OFPort = uint32(2)\n\tpod3OFPort = uint32(3)\n\tpod4OFPort = uint32(4)\n)\n\ntype fakeController struct {\n\t*L7FlowExporterController\n\tmockOFClient     *openflowtest.MockClient\n\tclient           *fake.Clientset\n\tinformerFactory  informers.SharedInformerFactory\n\tlocalPodInformer cache.SharedIndexInformer\n\tsuricataStarted  *atomic.Bool\n}\n\nfunc (c *fakeController) startInformers(stopCh chan struct{}) {\n\tc.informerFactory.Start(stopCh)\n\tc.informerFactory.WaitForCacheSync(stopCh)\n\tgo c.localPodInformer.Run(stopCh)\n\tgo c.namespaceInformer.Run(stopCh)\n\tcache.WaitForCacheSync(stopCh, c.localPodInformer.HasSynced, c.namespaceInformer.HasSynced)\n}\n\nfunc newFakeControllerAndWatcher(t *testing.T, objects []runtime.Object, interfaces []*interfacestore.InterfaceConfig) *fakeController {\n\tcontroller := gomock.NewController(t)\n\tmockOFClient := openflowtest.NewMockClient(controller)\n\n\tclient := fake.NewSimpleClientset(objects...)\n\tinformerFactory := informers.NewSharedInformerFactory(client, 0)\n\tnsInformer := informerFactory.Core().V1().Namespaces()\n\n\tlocalPodInformer := coreinformers.NewFilteredPodInformer(\n\t\tclient,\n\t\tmetav1.NamespaceAll,\n\t\t0,\n\t\tcache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc},\n\t\tfunc(options *metav1.ListOptions) {\n\t\t\toptions.FieldSelector = fields.OneTermEqualSelector(\"spec.nodeName\", \"fakeNode\").String()\n\t\t},\n\t)\n\n\tifaceStore := interfacestore.NewInterfaceStore()\n\tfor _, itf := range interfaces {\n\t\tifaceStore.AddInterface(itf)\n\t}\n\n\tvar suricataStarted atomic.Bool\n\tl7w := NewL7FlowExporterController(mockOFClient, ifaceStore, localPodInformer, nsInformer, func() error {\n\t\tsuricataStarted.Store(true)\n\t\treturn nil\n\t})\n\n\treturn &fakeController{\n\t\tL7FlowExporterController: l7w,\n\t\tmockOFClient:             mockOFClient,\n\t\tclient:                   client,\n\t\tinformerFactory:          informerFactory,\n\t\tlocalPodInformer:         localPodInformer,\n\t\tsuricataStarted:          &suricataStarted,\n\t}\n}\n\nfunc newPodObject(name, namespace string, annotations map[string]string) *v1.Pod {\n\treturn &v1.Pod{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:        name,\n\t\t\tNamespace:   namespace,\n\t\t\tAnnotations: annotations,\n\t\t},\n\t\tSpec: v1.PodSpec{\n\t\t\tNodeName: \"fakeNode\",\n\t\t},\n\t\tStatus: v1.PodStatus{\n\t\t\tPodIP: \"10.0.0.1\",\n\t\t},\n\t}\n}\n\nfunc newNamespaceObject(name string, annotations map[string]string) *v1.Namespace {\n\treturn &v1.Namespace{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:        name,\n\t\t\tAnnotations: annotations,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"fakeKey\": \"fakeValue\",\n\t\t\t},\n\t\t},\n\t}\n}\n\nfunc newPodInterface(podName, podNamespace string, ofPort int32) *interfacestore.InterfaceConfig {\n\tcontainerName := k8s.NamespacedName(podNamespace, podName)\n\treturn &interfacestore.InterfaceConfig{\n\t\tInterfaceName:            util.GenerateContainerInterfaceName(podName, podNamespace, containerName),\n\t\tContainerInterfaceConfig: &interfacestore.ContainerInterfaceConfig{PodName: podName, PodNamespace: podNamespace, ContainerID: containerName},\n\t\tOVSPortConfig:            &interfacestore.OVSPortConfig{OFPort: ofPort},\n\t}\n}\n\nfunc TestPodAdd(t *testing.T) {\n\tvar targetPort uint32\n\ttestNS1 := newNamespaceObject(\"test-ns1\", annotationsEmpty)\n\tpod1 := newPodObject(\"test-pod1\", \"test-ns1\", annotationsCorrectIngress)\n\tpod2 := newPodObject(\"test-pod2\", \"test-ns1\", annotationsIncorrect)\n\tinterfaces := []*interfacestore.InterfaceConfig{\n\t\tpodInterface1,\n\t\tpodInterface2,\n\t}\n\ttestcases := []struct {\n\t\tname                      string\n\t\taddedPod                  *v1.Pod\n\t\texpectedPodToDirectionMap map[string]v1alpha2.Direction\n\t\texpectedSuricataStarted   bool\n\t\texpectedCalls             func(mockOFClient *openflowtest.MockClient)\n\t\texpectedError             error\n\t}{\n\t\t{\n\t\t\tname:     \"Add pod with correct annotations\",\n\t\t\taddedPod: pod1,\n\t\t\texpectedPodToDirectionMap: map[string]v1alpha2.Direction{\n\t\t\t\tpod1NN: v1alpha2.DirectionIngress,\n\t\t\t},\n\t\t\texpectedSuricataStarted: true,\n\t\t\texpectedCalls: func(mockOFClient *openflowtest.MockClient) {\n\t\t\t\tmockOFClient.EXPECT().InstallTrafficControlMarkFlows(fmt.Sprintf(\"tcl7:%s\", pod1NN), []uint32{uint32(podInterface1.OFPort)}, targetPort, v1alpha2.DirectionIngress, v1alpha2.ActionMirror, types.TrafficControlFlowPriorityLow)\n\t\t\t},\n\t\t}, {\n\t\t\tname:                      \"Add pod with incorrect annotations\",\n\t\t\taddedPod:                  pod2,\n\t\t\texpectedPodToDirectionMap: map[string]v1alpha2.Direction{},\n\t\t\texpectedCalls:             func(mockOFClient *openflowtest.MockClient) {},\n\t\t\texpectedError:             errInvalidAnnotation,\n\t\t},\n\t}\n\tfor _, tt := range testcases {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := newFakeControllerAndWatcher(t, []runtime.Object{tt.addedPod, testNS1}, interfaces)\n\t\t\tstopCh := make(chan struct{})\n\t\t\tdefer close(stopCh)\n\n\t\t\tc.startInformers(stopCh)\n\t\t\tassert.Eventuallyf(t, func() bool {\n\t\t\t\tns, _ := c.namespaceLister.List(labels.Everything())\n\t\t\t\treturn len(c.localPodInformer.GetIndexer().List()) == 1 && len(ns) == 1\n\t\t\t}, 1*time.Second, 10*time.Millisecond, \"Pod should be added to Informers\")\n\t\t\twaitEvents(t, 1, c)\n\t\t\titem, _ := c.queue.Get()\n\t\t\ttt.expectedCalls(c.mockOFClient)\n\t\t\terr := c.syncPod(item)\n\t\t\tassert.Equal(t, tt.expectedSuricataStarted, c.suricataStarted.Load())\n\t\t\tif tt.expectedError != nil {\n\t\t\t\tassert.ErrorContains(t, err, tt.expectedError.Error())\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, tt.expectedPodToDirectionMap, c.podToDirectionMap)\n\t\t\t}\n\t\t\tc.queue.Done(item)\n\t\t})\n\t}\n}\n\nfunc TestPodAdd(t *testing.T) {\n\tvar targetPort uint32\n\ttestNS1 := newNamespaceObject(\"test-ns1\", annotationsEmpty)\n\tpod1 := newPodObject(\"test-pod1\", \"test-ns1\", annotationsCorrectIngress)\n\tpod2 := newPodObject(\"test-pod2\", \"test-ns1\", annotationsIncorrect)\n\tinterfaces := []*interfacestore.InterfaceConfig{\n\t\tpodInterface1,\n\t\tpodInterface2,\n\t}\n\ttestcases := []struct {\n\t\tname                      string\n\t\taddedPod                  *v1.Pod\n\t\texpectedPodToDirectionMap map[string]v1alpha2.Direction\n\t\texpectedSuricataStarted   bool\n\t\texpectedCalls             func(mockOFClient *openflowtest.MockClient)\n\t\texpectedError             error\n\t}{\n\t\t{\n\t\t\tname:     \"Add pod with correct annotations\",\n\t\t\taddedPod: pod1,\n\t\t\texpectedPodToDirectionMap: map[string]v1alpha2.Direction{\n\t\t\t\tpod1NN: v1alpha2.DirectionIngress,\n\t\t\t},\n\t\t\texpectedSuricataStarted: true,\n\t\t\texpectedCalls: func(mockOFClient *openflowtest.MockClient) {\n\t\t\t\tmockOFClient.EXPECT().InstallTrafficControlMarkFlows(fmt.Sprintf(\"tcl7:%s\", pod1NN), []uint32{uint32(podInterface1.OFPort)}, targetPort, v1alpha2.DirectionIngress, v1alpha2.ActionMirror, types.TrafficControlFlowPriorityLow)\n\t\t\t},\n\t\t}, {\n\t\t\tname:                      \"Add pod with incorrect annotations\",\n\t\t\taddedPod:                  pod2,\n\t\t\texpectedPodToDirectionMap: map[string]v1alpha2.Direction{},\n\t\t\texpectedCalls:             func(mockOFClient *openflowtest.MockClient) {},\n\t\t\texpectedError:             errInvalidAnnotation,\n\t\t},\n\t}\n\tfor _, tt := range testcases {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := newFakeControllerAndWatcher(t, []runtime.Object{tt.addedPod, testNS1}, interfaces)\n\t\t\tstopCh := make(chan struct{})\n\t\t\tdefer close(stopCh)\n\n\t\t\tc.startInformers(stopCh)\n\t\t\tassert.Eventuallyf(t, func() bool {\n\t\t\t\tns, _ := c.namespaceLister.List(labels.Everything())\n\t\t\t\treturn len(c.localPodInformer.GetIndexer().List()) == 1 && len(ns) == 1\n\t\t\t}, 1*time.Second, 10*time.Millisecond, \"Pod should be added to Informers\")\n\t\t\twaitEvents(t, 1, c)\n\t\t\titem, _ := c.queue.Get()\n\t\t\ttt.expectedCalls(c.mockOFClient)\n\t\t\terr := c.syncPod(item)\n\t\t\tassert.Equal(t, tt.expectedSuricataStarted, c.suricataStarted.Load())\n\t\t\tif tt.expectedError != nil {\n\t\t\t\tassert.ErrorContains(t, err, tt.expectedError.Error())\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, tt.expectedPodToDirectionMap, c.podToDirectionMap)\n\t\t\t}\n\t\t\tc.queue.Done(item)\n\t\t})\n\t}\n}\n\nfunc TestPodUpdate(t *testing.T) {\n\tvar targetPort uint32\n\ttestNS1 := newNamespaceObject(\"test-ns1\", annotationsEmpty)\n\ttestNS2 := newNamespaceObject(\"test-ns2\", annotationsEmpty)\n\tpod1 := newPodObject(\"test-pod1\", \"test-ns1\", annotationsDifferent)\n\tpod2 := newPodObject(\"test-pod2\", \"test-ns1\", annotationsIncorrect)\n\tpod3 := newPodObject(\"test-pod3\", \"test-ns2\", annotationsEmpty)\n\tpod4 := newPodObject(\"test-pod4\", \"test-ns2\", annotationsCorrectIngress)\n\tinterfaces := []*interfacestore.InterfaceConfig{\n\t\tpodInterface1,\n\t\tpodInterface2,\n\t\tpodInterface3,\n\t\tpodInterface4,\n\t}\n\ttestcases := []struct {\n\t\tname                      string\n\t\tupdatedPod                *v1.Pod\n\t\texpectedPodToDirectionMap map[string]v1alpha2.Direction\n\t\texpectedSuricataStarted   bool\n\t\texpectedCalls             func(mockOFClient *openflowtest.MockClient)\n\t}{\n\t\t{\n\t\t\tname:       \"Update Pod with different annotation to correct annotation\",\n\t\t\tupdatedPod: newPodObject(\"test-pod1\", \"test-ns1\", annotationsCorrectEgress),\n\t\t\texpectedPodToDirectionMap: map[string]v1alpha2.Direction{\n\t\t\t\tpod1NN: v1alpha2.DirectionEgress,\n\t\t\t},\n\t\t\texpectedSuricataStarted: true,\n\t\t\texpectedCalls: func(mockOFClient *openflowtest.MockClient) {\n\t\t\t\tmockOFClient.EXPECT().InstallTrafficControlMarkFlows(fmt.Sprintf(\"tcl7:%s\", pod1NN), []uint32{uint32(podInterface1.OFPort)}, targetPort, v1alpha2.DirectionEgress, v1alpha2.ActionMirror, types.TrafficControlFlowPriorityLow)\n\t\t\t},\n\t\t}, {\n\t\t\tname:       \"Update Pod with Incorrect annotation to correct annotation\",\n\t\t\tupdatedPod: newPodObject(\"test-pod2\", \"test-ns1\", annotationsCorrectBoth),\n\t\t\texpectedPodToDirectionMap: map[string]v1alpha2.Direction{\n\t\t\t\tpod2NN: v1alpha2.DirectionBoth,\n\t\t\t},\n\t\t\texpectedSuricataStarted: true,\n\t\t\texpectedCalls: func(mockOFClient *openflowtest.MockClient) {\n\t\t\t\tmockOFClient.EXPECT().InstallTrafficControlMarkFlows(fmt.Sprintf(\"tcl7:%s\", pod2NN), []uint32{uint32(podInterface2.OFPort)}, targetPort, v1alpha2.DirectionBoth, v1alpha2.ActionMirror, types.TrafficControlFlowPriorityLow)\n\t\t\t},\n\t\t}, {\n\t\t\tname:       \"Update Pod with no annotation to correct annotation\",\n\t\t\tupdatedPod: newPodObject(\"test-pod3\", \"test-ns2\", annotationsCorrectIngress),\n\t\t\texpectedPodToDirectionMap: map[string]v1alpha2.Direction{\n\t\t\t\tpod3NN: v1alpha2.DirectionIngress,\n\t\t\t},\n\t\t\texpectedSuricataStarted: true,\n\t\t\texpectedCalls: func(mockOFClient *openflowtest.MockClient) {\n\t\t\t\tmockOFClient.EXPECT().InstallTrafficControlMarkFlows(fmt.Sprintf(\"tcl7:%s\", pod3NN), []uint32{uint32(podInterface3.OFPort)}, targetPort, v1alpha2.DirectionIngress, v1alpha2.ActionMirror, types.TrafficControlFlowPriorityLow)\n\t\t\t},\n\t\t}, {\n\t\t\tname:       \"Update Pod with ingress annotation to egress annotation\",\n\t\t\tupdatedPod: newPodObject(\"test-pod4\", \"test-ns2\", annotationsCorrectEgress),\n\t\t\texpectedPodToDirectionMap: map[string]v1alpha2.Direction{\n\t\t\t\tpod4NN: v1alpha2.DirectionEgress,\n\t\t\t},\n\t\t\texpectedSuricataStarted: true,\n\t\t\texpectedCalls: func(mockOFClient *openflowtest.MockClient) {\n\t\t\t\tmockOFClient.EXPECT().InstallTrafficControlMarkFlows(fmt.Sprintf(\"tcl7:%s\", pod4NN), []uint32{uint32(podInterface4.OFPort)}, targetPort, v1alpha2.DirectionEgress, v1alpha2.ActionMirror, types.TrafficControlFlowPriorityLow)\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range testcases {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tc := newFakeControllerAndWatcher(t, []runtime.Object{pod1, pod2, pod3, pod4, testNS1, testNS2}, interfaces)\n\t\t\tstopCh := make(chan struct{})\n\t\t\tdefer close(stopCh)\n\n\t\t\tc.startInformers(stopCh)\n\n\t\t\tassert.Eventuallyf(t, func() bool {\n\t\t\t\tns, _ := c.namespaceLister.List(labels.Everything())\n\t\t\t\treturn len(c.localPodInformer.GetIndexer().List()) == 4 && len(ns) == 2\n\t\t\t}, 1*time.Second, 10*time.Millisecond, \"Pods should be added to Informers\")\n\t\t\twaitEvents(t, 2, c)\n\t\t\tfor i := 0; i < 2; i++ {\n\t\t\t\titem, _ := c.queue.Get()\n\t\t\t\tc.queue.Done(item)\n\t\t\t}\n\n\t\t\ttt.expectedCalls(c.mockOFClient)\n\t\t\t_, err := c.client.CoreV1().Pods(tt.updatedPod.Namespace).Update(ctx, tt.updatedPod, metav1.UpdateOptions{})\n\t\t\trequire.NoError(t, err)\n\n\t\t\twaitEvents(t, 1, c)\n\t\t\titem, _ := c.queue.Get()\n\t\t\trequire.NoError(t, c.syncPod(item))\n\t\t\tassert.Equal(t, tt.expectedSuricataStarted, c.suricataStarted.Load())\n\t\t\tassert.Equal(t, tt.expectedPodToDirectionMap, c.podToDirectionMap)\n\t\t\tc.queue.Done(item)\n\t\t})\n\t}\n}\n\nfunc waitEvents(t *testing.T, expectedEvents int, c *fakeController) {\n\trequire.Eventually(t, func() bool {\n\t\treturn c.queue.Len() == expectedEvents\n\t}, 5*time.Second, 10*time.Millisecond)\n}"
