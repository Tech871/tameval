[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.21"

[repo_info]
repository = "grafana/dskit"
sha = "22a660c7415734a00f68fde15a1e0fcf3b7a830d"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out ring/client/pool.go ring/client/pool_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting ring/client/pool.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 74.0
original_coverage = 74.0
mutation_kill_rate = 51.0
original_mutation_kill_rate = 51.0
covered_lines = [ 46, 47, 48, 81, 82, 83, 84, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 110, 111, 112, 113, 114, 115, 119, 120, 121, 125, 126, 127, 128, 129, 132, 133, 134, 135, 136, 141, 142, 143, 144, 145, 149, 153, 154, 155, 156, 157, 158, 159, 160, 163, 168, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 189, 193, 194, 195, 200, 201, 202, 203, 204, 205, 206, 207, 211, 212, 213, 214, 215, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 255, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272,]
missed_lines = [ 38, 39, 40, 102, 103, 104, 105, 106, 107, 137, 138, 139, 146, 147, 148, 164, 165, 166, 169, 170, 171, 190, 191, 217, 218, 219, 220, 221, 223, 224, 225, 226, 227, 229, 230, 231, 233, 234,]

[input_info]
test_file_path = "ring/client/pool_test.go"
focal_file_path = "ring/client/pool.go"
test_file_url = "https://github.com/grafana/dskit/blob/22a660c7415734a00f68fde15a1e0fcf3b7a830d/ring/client/pool_test.go"
focal_file_url = "https://github.com/grafana/dskit/blob/22a660c7415734a00f68fde15a1e0fcf3b7a830d/ring/client/pool.go"
first_commit_date = "2021-09-10"
last_commit_date = "2025-03-21"
test_file_content = "package client\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/go-kit/log\"\n\t\"github.com/gogo/status\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/health/grpc_health_v1\"\n\n\t\"github.com/grafana/dskit/services\"\n)\n\ntype mockClient struct {\n\thappy  bool\n\tstatus grpc_health_v1.HealthCheckResponse_ServingStatus\n}\n\nfunc (i mockClient) Check(_ context.Context, _ *grpc_health_v1.HealthCheckRequest, _ ...grpc.CallOption) (*grpc_health_v1.HealthCheckResponse, error) {\n\tif !i.happy {\n\t\treturn nil, fmt.Errorf(\"Fail\")\n\t}\n\treturn &grpc_health_v1.HealthCheckResponse{Status: i.status}, nil\n}\n\nfunc (i mockClient) Close() error {\n\treturn nil\n}\n\nfunc (i mockClient) Watch(_ context.Context, _ *grpc_health_v1.HealthCheckRequest, _ ...grpc.CallOption) (grpc_health_v1.Health_WatchClient, error) {\n\treturn nil, status.Error(codes.Unimplemented, \"Watching is not supported\")\n}\n\nfunc TestHealthCheck(t *testing.T) {\n\ttcs := []struct {\n\t\tclient   mockClient\n\t\thasError bool\n\t}{\n\t\t{mockClient{happy: true, status: grpc_health_v1.HealthCheckResponse_UNKNOWN}, true},\n\t\t{mockClient{happy: true, status: grpc_health_v1.HealthCheckResponse_SERVING}, false},\n\t\t{mockClient{happy: true, status: grpc_health_v1.HealthCheckResponse_NOT_SERVING}, true},\n\t\t{mockClient{happy: false, status: grpc_health_v1.HealthCheckResponse_UNKNOWN}, true},\n\t\t{mockClient{happy: false, status: grpc_health_v1.HealthCheckResponse_SERVING}, true},\n\t\t{mockClient{happy: false, status: grpc_health_v1.HealthCheckResponse_NOT_SERVING}, true},\n\t}\n\tfor _, tc := range tcs {\n\t\terr := healthCheck(context.Background(), tc.client, 50*time.Millisecond)\n\t\thasError := err != nil\n\t\tif hasError != tc.hasError {\n\t\t\tt.Errorf(\"Expected error: %t, error: %v\", tc.hasError, err)\n\t\t}\n\t}\n}\n\nfunc TestPoolCache(t *testing.T) {\n\tbuildCount := 0\n\tfactory := PoolAddrFunc(func(addr string) (PoolClient, error) {\n\t\tif addr == \"bad\" {\n\t\t\treturn nil, fmt.Errorf(\"Fail\")\n\t\t}\n\t\tbuildCount++\n\t\treturn mockClient{happy: true, status: grpc_health_v1.HealthCheckResponse_SERVING}, nil\n\t})\n\n\tcfg := PoolConfig{\n\t\tHealthCheckTimeout: 50 * time.Millisecond,\n\t\tCheckInterval:      10 * time.Second,\n\t}\n\n\tpool := NewPool(\"test\", cfg, nil, factory, nil, log.NewNopLogger())\n\trequire.NoError(t, services.StartAndAwaitRunning(context.Background(), pool))\n\tdefer services.StopAndAwaitTerminated(context.Background(), pool) //nolint:errcheck\n\n\t_, err := pool.GetClientFor(\"1\")\n\trequire.NoError(t, err)\n\tif buildCount != 1 {\n\t\tt.Errorf(\"Did not create client\")\n\t}\n\n\t_, err = pool.GetClientFor(\"1\")\n\trequire.NoError(t, err)\n\tif buildCount != 1 {\n\t\tt.Errorf(\"Created client that should have been cached\")\n\t}\n\n\t_, err = pool.GetClientFor(\"2\")\n\trequire.NoError(t, err)\n\tif pool.Count() != 2 {\n\t\tt.Errorf(\"Expected Count() = 2, got %d\", pool.Count())\n\t}\n\n\tpool.RemoveClientFor(\"1\")\n\tif pool.Count() != 1 {\n\t\tt.Errorf(\"Expected Count() = 1, got %d\", pool.Count())\n\t}\n\n\t_, err = pool.GetClientFor(\"1\")\n\trequire.NoError(t, err)\n\tif buildCount != 3 || pool.Count() != 2 {\n\t\tt.Errorf(\"Did not re-create client correctly\")\n\t}\n\n\t_, err = pool.GetClientFor(\"bad\")\n\tif err == nil {\n\t\tt.Errorf(\"Bad create should have thrown an error\")\n\t}\n\tif pool.Count() != 2 {\n\t\tt.Errorf(\"Bad create should not have been added to cache\")\n\t}\n\n\taddrs := pool.RegisteredAddresses()\n\tif len(addrs) != pool.Count() {\n\t\tt.Errorf(\"Lengths of registered addresses and cache.Count() do not match\")\n\t}\n}\n\nfunc TestCleanUnhealthy(t *testing.T) {\n\ttcs := []struct {\n\t\tmaxConcurrent int\n\t}{\n\t\t{maxConcurrent: 0}, // if not set, defaults to 16\n\t\t{maxConcurrent: 1},\n\t}\n\tfor _, tc := range tcs {\n\t\tt.Run(fmt.Sprintf(\"max concurrent %d\", tc.maxConcurrent), func(t *testing.T) {\n\t\t\tgoodAddrs := []string{\"good1\", \"good2\"}\n\t\t\tbadAddrs := []string{\"bad1\", \"bad2\"}\n\t\t\tclients := map[string]PoolClient{}\n\t\t\tfor _, addr := range goodAddrs {\n\t\t\t\tclients[addr] = mockClient{happy: true, status: grpc_health_v1.HealthCheckResponse_SERVING}\n\t\t\t}\n\t\t\tfor _, addr := range badAddrs {\n\t\t\t\tclients[addr] = mockClient{happy: false, status: grpc_health_v1.HealthCheckResponse_NOT_SERVING}\n\t\t\t}\n\n\t\t\tcfg := PoolConfig{\n\t\t\t\tMaxConcurrentHealthChecks: tc.maxConcurrent,\n\t\t\t\tCheckInterval:             1 * time.Second,\n\t\t\t\tHealthCheckTimeout:        5 * time.Millisecond,\n\t\t\t}\n\t\t\tpool := NewPool(\"test\", cfg, nil, nil, nil, log.NewNopLogger())\n\t\t\tpool.clients = clients\n\t\t\tpool.cleanUnhealthy()\n\n\t\t\tfor _, addr := range badAddrs {\n\t\t\t\tif _, ok := pool.clients[addr]; ok {\n\t\t\t\t\tt.Errorf(\"Found bad client after clean: %s\\n\", addr)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, addr := range goodAddrs {\n\t\t\t\tif _, ok := pool.clients[addr]; !ok {\n\t\t\t\t\tt.Errorf(\"Could not find good client after clean: %s\\n\", addr)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRemoveClient(t *testing.T) {\n\tconst (\n\t\taddr1 = \"localhost:123\"\n\t\taddr2 = \"localhost:234\"\n\t)\n\n\tassertNotEqual := func(t *testing.T, clientA, clientB PoolClient, msg string) {\n\t\tt.Helper()\n\t\t// Using golang equality. `assert.NotEqual` inspects the value of the interface implementation.\n\t\tif clientA == clientB {\n\t\t\tt.Error(msg)\n\t\t}\n\t}\n\n\tassertEqual := func(t *testing.T, clientA, clientB PoolClient, msg string) {\n\t\tt.Helper()\n\t\t// Using golang equality. `assert.Equal` inspects the value of the interface implementation.\n\t\tif clientA != clientB {\n\t\t\tt.Error(msg)\n\t\t}\n\t}\n\n\tclientHappy := true\n\tfactory := PoolAddrFunc(func(string) (PoolClient, error) {\n\t\treturn &mockClient{happy: clientHappy, status: grpc_health_v1.HealthCheckResponse_SERVING}, nil\n\t})\n\n\tcfg := PoolConfig{\n\t\tCheckInterval:      time.Second,\n\t\tHealthCheckEnabled: false,\n\t}\n\tpool := NewPool(\"test\", cfg, nil, factory, nil, log.NewNopLogger())\n\trequire.NoError(t, services.StartAndAwaitRunning(context.Background(), pool))\n\tdefer services.StopAndAwaitTerminated(context.Background(), pool) //nolint:errcheck\n\n\tc1a, err := pool.GetClientFor(addr1)\n\trequire.NoError(t, err)\n\n\tc2a, err := pool.GetClientFor(addr2)\n\trequire.NoError(t, err)\n\tassertNotEqual(t, c1a, c2a, \"clients for different addresses should be different\")\n\n\t// Remove without providing address\n\tpool.RemoveClient(c1a, \"\")\n\n\tc1b, err := pool.GetClientFor(addr1)\n\trequire.NoError(t, err)\n\tassertNotEqual(t, c1a, c1b, \"c1a should have been removed and c1b should be a different instance\")\n\n\tc2b, err := pool.GetClientFor(addr2)\n\trequire.NoError(t, err)\n\tassertEqual(t, c2b, c2a, \"c2b should be the same\")\n\n\t// Remove with providing an address\n\tpool.RemoveClient(c1b, addr1)\n\n\t// Prepare for cleaning up unhealthy instances later\n\tclientHappy = false\n\n\tc1c, err := pool.GetClientFor(addr1)\n\trequire.NoError(t, err)\n\tassertNotEqual(t, c1a, c1c, \"c1a should have been removed and c1c should be a different instance\")\n\tassertNotEqual(t, c1b, c1c, \"c1b should have been removed and c1c should be a different instance\")\n\n\tc2c, err := pool.GetClientFor(addr2)\n\trequire.NoError(t, err)\n\tassertEqual(t, c2c, c2a, \"c2c should be the same\")\n\n\t// This should clean up c1c\n\tpool.cleanUnhealthy()\n\t// Removing c1c should be a noop\n\tpool.RemoveClient(c1c, addr1)\n\n\tc1d, err := pool.GetClientFor(addr1)\n\trequire.NoError(t, err)\n\tassertNotEqual(t, c1a, c1d, \"c1a should have been removed and c1d should be a different instance\")\n\tassertNotEqual(t, c1b, c1d, \"c1b should have been removed and c1d should be a different instance\")\n\n\tc2d, err := pool.GetClientFor(addr2)\n\trequire.NoError(t, err)\n\tassertEqual(t, c2d, c2a, \"c2c should be the same\")\n}\n"
