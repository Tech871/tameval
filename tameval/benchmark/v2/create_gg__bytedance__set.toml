[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.18"

[repo_info]
repository = "bytedance/gg"
sha = "420f8369dd6e235b8124691860e822d015969fb6"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out collection/set/set.go collection/set/set_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting collection/set/set.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 96.0
original_coverage = 96.0
mutation_kill_rate = 88.0
original_mutation_kill_rate = 88.0
covered_lines = [ 74, 75, 76, 77, 78, 79, 80, 82, 86, 87, 88, 89, 90, 94, 95, 96, 97, 98, 102, 103, 104, 105, 110, 111, 112, 113, 114, 115, 116, 121, 122, 123, 124, 125, 130, 131, 132, 133, 134, 135, 136, 137, 138, 143, 144, 145, 146, 147, 148, 149, 153, 154, 155, 156, 157, 158, 164, 165, 166, 167, 168, 169, 170, 171, 173, 179, 180, 181, 182, 183, 184, 185, 186, 188, 196, 197, 198, 199, 200, 201, 202, 203, 207, 208, 209, 210, 211, 212, 213, 217, 218, 219, 220, 221, 222, 223, 224, 225, 229, 230, 231, 232, 233, 234, 236, 240, 241, 242, 243, 244, 245, 247, 251, 252, 253, 256, 257, 258, 259, 260, 264, 265, 266, 267, 268, 273, 274, 275, 276, 277, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 295, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 312, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 329, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 351, 352, 353, 354, 355, 356, 365, 369, 370, 375, 376, 382, 383, 384, 385, 386, 388, 393, 394, 400, 401, 402, 403, 404, 405,]
missed_lines = [ 366, 367, 368, 371, 372, 373, 389, 390, 391,]

[input_info]
test_file_path = "collection/set/set_test.go"
focal_file_path = "collection/set/set.go"
test_file_url = "https://github.com/bytedance/gg/blob/420f8369dd6e235b8124691860e822d015969fb6/collection/set/set_test.go"
focal_file_url = "https://github.com/bytedance/gg/blob/420f8369dd6e235b8124691860e822d015969fb6/collection/set/set.go"
first_commit_date = "2025-05-20"
last_commit_date = "2025-06-27"
test_file_content = "// Copyright 2025 Bytedance Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage set\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/bytedance/gg/internal/assert\"\n\t\"github.com/bytedance/gg/internal/iter\"\n)\n\nfunc TestNilSet(t *testing.T) {\n\t{ // read for set value\n\t\tvar s1, s2 Set[int]\n\t\tassert.Equal(t, 0, s1.Len())\n\t\tassert.False(t, s1.Remove(1))\n\t\ts1.RemoveN(1, 2, 3)\n\t\tassert.False(t, s1.Contains(1))\n\t\tassert.False(t, s1.ContainsAny())\n\t\tassert.False(t, s1.ContainsAny(1, 2, 3))\n\t\tassert.True(t, s1.ContainsAll())\n\t\tassert.False(t, s1.ContainsAll(1, 2, 3))\n\t\ts1.Range(func(i int) bool {\n\t\t\treturn true\n\t\t})\n\t\tassert.Equal(t, true, s1.Equal(&s2))\n\t\tassert.Equal(t, true, s1.IsSubset(&s2))\n\t\tassert.Equal(t, true, s1.IsSuperset(&s2))\n\t\tassert.Equal(t, \"set[]\", s1.String())\n\t\tassert.Equal(t, []int{}, s1.ToSlice())\n\t\tassert.Equal(t, &Set[int]{m: make(map[int]struct{})}, s1.Clone())\n\t}\n\t{ // read for set pointer\n\t\tvar s1, s2 *Set[int]\n\t\tassert.Equal(t, 0, s1.Len())\n\t\tassert.False(t, s1.Remove(1))\n\t\ts1.RemoveN(1, 2, 3)\n\t\tassert.False(t, s1.Contains(1))\n\t\tassert.False(t, s1.ContainsAny())\n\t\tassert.False(t, s1.ContainsAny(1, 2, 3))\n\t\tassert.True(t, s1.ContainsAll())\n\t\tassert.False(t, s1.ContainsAll(1, 2, 3))\n\t\ts1.Range(func(i int) bool {\n\t\t\treturn true\n\t\t})\n\t\tassert.Equal(t, true, s1.Equal(s2))\n\t\tassert.Equal(t, true, s1.IsSubset(s2))\n\t\tassert.Equal(t, true, s1.IsSuperset(s2))\n\t\tassert.Equal(t, \"set[]\", s1.String())\n\t\tassert.Equal(t, []int{}, s1.ToSlice())\n\t\tassert.Equal(t, &Set[int]{m: make(map[int]struct{})}, s1.Clone())\n\t}\n\t{ // write for set value\n\t\t{\n\t\t\tvar s Set[int]\n\t\t\tassert.Equal(t, true, s.Add(1))\n\t\t}\n\t\t{\n\t\t\tvar s Set[int]\n\t\t\ts.AddN(1, 2, 3)\n\t\t\tassert.Equal(t, true, s.ContainsAll(1, 2, 3))\n\t\t}\n\t\t{\n\t\t\tvar s1, s2 Set[int]\n\t\t\tassert.Equal(t, 0, s1.Union(&s2).Len())\n\t\t}\n\t\t{\n\t\t\tvar s1, s2 Set[int]\n\t\t\tassert.Equal(t, 0, s1.Diff(&s2).Len())\n\t\t}\n\t\t{\n\t\t\tvar s1, s2 Set[int]\n\t\t\tassert.Equal(t, 0, s1.Intersect(&s2).Len())\n\t\t}\n\t\t{\n\t\t\tvar s1, s2 Set[int]\n\t\t\ts1.Update(&s2)\n\t\t\tassert.Equal(t, 0, s1.Len())\n\t\t}\n\t\t{\n\t\t\tvar s1, s2 Set[int]\n\t\t\ts1.UnionInplace(&s2)\n\t\t\tassert.Equal(t, 0, s1.Len())\n\t\t}\n\t\t{\n\t\t\tvar s1, s2 Set[int]\n\t\t\ts1.DiffInplace(&s2)\n\t\t\tassert.Equal(t, 0, s1.Len())\n\t\t}\n\t\t{\n\t\t\tvar s1, s2 Set[int]\n\t\t\ts1.IntersectInplace(&s2)\n\t\t\tassert.Equal(t, 0, s1.Len())\n\t\t}\n\t}\n\t{ // write for set pointer\n\t\t{\n\t\t\ts := new(Set[int])\n\t\t\tassert.Equal(t, true, s.Add(1))\n\t\t}\n\t\t{\n\t\t\ts := new(Set[int])\n\t\t\ts.AddN(1, 2, 3)\n\t\t\tassert.Equal(t, true, s.ContainsAll(1, 2, 3))\n\t\t}\n\t\t{\n\t\t\tvar s1, s2 *Set[int]\n\t\t\tassert.Equal(t, 0, s1.Union(s2).Len())\n\t\t}\n\t\t{\n\t\t\tvar s1, s2 *Set[int]\n\t\t\tassert.Equal(t, 0, s1.Diff(s2).Len())\n\t\t}\n\t\t{\n\t\t\tvar s1, s2 *Set[int]\n\t\t\tassert.Equal(t, 0, s1.Intersect(s2).Len())\n\t\t}\n\t\t{\n\t\t\ts1 := new(Set[int])\n\t\t\ts2 := New(1, 2, 3)\n\t\t\ts1.Update(s2)\n\t\t\tassert.Equal(t, 3, s1.Len())\n\t\t}\n\t\t{\n\t\t\ts1 := new(Set[int])\n\t\t\ts2 := New(1, 2, 3)\n\t\t\ts1.UnionInplace(s2)\n\t\t\tassert.Equal(t, 3, s1.Len())\n\t\t}\n\t\t{\n\t\t\tvar s1, s2 *Set[int]\n\t\t\ts1.DiffInplace(s2)\n\t\t\tassert.Equal(t, 0, s1.Len())\n\t\t}\n\t\t{\n\t\t\tvar s1, s2 *Set[int]\n\t\t\ts1.IntersectInplace(s2)\n\t\t\tassert.Equal(t, 0, s1.Len())\n\t\t}\n\t}\n}\n\nfunc TestLen(t *testing.T) {\n\ts := New[int]()\n\tassert.Zero(t, s.Len())\n\ts = New(1, 2, 3)\n\tassert.Equal(t, 3, s.Len())\n\ts = New(1, 1, 1, 1, 1, 1)\n\tassert.Equal(t, 1, s.Len())\n}\n\nfunc TestAdd(t *testing.T) {\n\ts := New[int]()\n\tassert.Zero(t, s.Len())\n\n\tassert.True(t, s.Add(1))\n\tassert.Equal(t, 1, s.Len())\n\tassert.True(t, s.Contains(1))\n\n\tassert.True(t, s.Add(2))\n\tassert.Equal(t, 2, s.Len())\n\tassert.True(t, s.Contains(2))\n\n\tassert.False(t, s.Add(1))\n\tassert.Equal(t, 2, s.Len())\n\tassert.True(t, s.Contains(1))\n}\n\nfunc TestAddN(t *testing.T) {\n\ts := New[int]()\n\tassert.Zero(t, s.Len())\n\n\ts.AddN(1, 2, 3, 4)\n\tassert.Equal(t, 4, s.Len())\n\tassert.True(t, s.ContainsAll(1, 2, 3, 4))\n\n\ts.AddN()\n\tassert.Equal(t, 4, s.Len())\n\n\ts.AddN(3, 4, 5)\n\tassert.Equal(t, 5, s.Len())\n\tassert.True(t, s.ContainsAll(1, 2, 3, 4, 5))\n}\n\nfunc TestRemove(t *testing.T) {\n\ts := New(1, 2, 3, 4)\n\tassert.Equal(t, 4, s.Len())\n\n\tassert.True(t, s.Remove(1))\n\tassert.Equal(t, 3, s.Len())\n\tassert.False(t, s.Contains(1))\n\n\tassert.False(t, s.Remove(1))\n\tassert.Equal(t, 3, s.Len())\n\tassert.False(t, s.Contains(1))\n\n\tassert.False(t, s.Remove(5))\n\tassert.Equal(t, 3, s.Len())\n\tassert.False(t, s.Contains(5))\n}\n\nfunc TestRemoveN(t *testing.T) {\n\ts := New(1, 2, 3, 4)\n\tassert.Equal(t, 4, s.Len())\n\n\ts.RemoveN()\n\tassert.Equal(t, 4, s.Len())\n\n\ts.RemoveN(1, 2)\n\tassert.Equal(t, 2, s.Len())\n\n\ts.RemoveN(1, 2, 3, 4)\n\tassert.Equal(t, 0, s.Len())\n\n\ts.RemoveN(1, 2, 3, 4)\n\tassert.Equal(t, 0, s.Len())\n\n\ts.RemoveN()\n\tassert.Equal(t, 0, s.Len())\n}\n\nfunc TestRange(t *testing.T) {\n\tvar s []int\n\tNew(1, 2, 3, 4).Range(func(v int) bool {\n\t\ts = append(s, v)\n\t\treturn true\n\t})\n\ts = []int{3, 1, 2, 4}\n\titer.Sort(iter.StealSlice(s))\n\tassert.Equal(t, []int{1, 2, 3, 4}, s)\n\n\ts = []int{}\n\tNew(1, 2, 3, 4).Range(func(v int) bool {\n\t\ts = append(s, v)\n\t\treturn len(s) != 3\n\t})\n\tassert.Equal(t, 3, len(s))\n}\n\nfunc TestUnion(t *testing.T) {\n\tassert.Equal(t,\n\t\tNew[int](),\n\t\tNew[int]().Union(New[int]()))\n\tassert.Equal(t,\n\t\tNew(1, 2, 3),\n\t\tNew[int]().Union(New(1, 2, 3)))\n\tassert.Equal(t,\n\t\tNew(1, 2, 3),\n\t\tNew(1, 2, 3).Union(New[int]()))\n\tassert.Equal(t,\n\t\tNew(1, 2, 3, 4, 5, 6),\n\t\tNew(1, 2, 3, 4).Union(New(3, 4, 5, 6)))\n\tassert.Equal(t,\n\t\tNew(1, 2, 3, 4, 5, 6),\n\t\tNew(1, 2, 3).Union(New(4, 5, 6)))\n\tassert.Equal(t,\n\t\tNew(1, 2, 3),\n\t\tNew(1, 2, 3).Union(New(1, 2, 3)))\n}\n\nfunc TestDiff(t *testing.T) {\n\tassert.Equal(t,\n\t\tNew[int](),\n\t\tNew[int]().Diff(New[int]()))\n\tassert.Equal(t,\n\t\tNew[int](),\n\t\tNew[int]().Diff(New(1, 2, 3)))\n\tassert.Equal(t,\n\t\tNew(1, 2, 3),\n\t\tNew(1, 2, 3).Diff(New[int]()))\n\tassert.Equal(t,\n\t\tNew(1, 2),\n\t\tNew(1, 2, 3, 4).Diff(New(3, 4, 5, 6)))\n\tassert.Equal(t,\n\t\tNew(1, 2, 3),\n\t\tNew(1, 2, 3).Diff(New(4, 5, 6)))\n\tassert.Equal(t,\n\t\tNew[int](),\n\t\tNew(1, 2, 3).Diff(New(1, 2, 3)))\n}\n\nfunc TestIntersect(t *testing.T) {\n\tassert.Equal(t,\n\t\tNew[int](),\n\t\tNew[int]().Intersect(New[int]()))\n\tassert.Equal(t,\n\t\tNew[int](),\n\t\tNew[int]().Intersect(New(1, 2, 3)))\n\tassert.Equal(t,\n\t\tNew[int](),\n\t\tNew(1, 2, 3).Intersect(New[int]()))\n\tassert.Equal(t,\n\t\tNew(3, 4),\n\t\tNew(1, 2, 3, 4).Intersect(New(3, 4, 5, 6)))\n\tassert.Equal(t,\n\t\tNew[int](),\n\t\tNew(1, 2, 3).Intersect(New(4, 5, 6)))\n\tassert.Equal(t,\n\t\tNew(1, 2, 3),\n\t\tNew(1, 2, 3).Intersect(New(1, 2, 3)))\n}\n\nfunc TestUpdate(t *testing.T) {\n\ts := New(1, 2, 3)\n\ts.Update(New(1, 2, 3))\n\tassert.Equal(t, New(1, 2, 3), s)\n}\n\nfunc TestUnionInplace(t *testing.T) {\n\ts := New[int]()\n\ts.UnionInplace(New[int]())\n\tassert.Equal(t, New[int](), s)\n\n\ts = New[int]()\n\ts.UnionInplace(New(1, 2, 3))\n\tassert.Equal(t, New(1, 2, 3), s)\n\n\ts = New(1, 2, 3)\n\ts.UnionInplace(New[int]())\n\tassert.Equal(t, New(1, 2, 3), s)\n\n\ts = New(1, 2, 3, 4)\n\ts.UnionInplace(New(3, 4, 5, 6))\n\tassert.Equal(t, New(1, 2, 3, 4, 5, 6), s)\n\n\ts = New(1, 2, 3)\n\ts.UnionInplace(New(1, 2, 3))\n\tassert.Equal(t, New(1, 2, 3), s)\n}\n\nfunc TestDiffInplace(t *testing.T) {\n\ts := New[int]()\n\ts.DiffInplace(New[int]())\n\tassert.Equal(t, New[int](), s)\n\n\ts = New[int]()\n\ts.DiffInplace(New(1, 2, 3))\n\tassert.Equal(t, New[int](), s)\n\n\ts = New(1, 2, 3)\n\ts.DiffInplace(New[int]())\n\tassert.Equal(t, New(1, 2, 3), s)\n\n\ts = New(1, 2, 3, 4)\n\ts.DiffInplace(New(3, 4, 5, 6))\n\tassert.Equal(t, New(1, 2), s)\n\n\ts = New(1, 2, 3)\n\ts.DiffInplace(New(1, 2, 3))\n\tassert.Equal(t, New[int](), s)\n}\n\nfunc TestIntersectInplace(t *testing.T) {\n\ts := New[int]()\n\ts.IntersectInplace(New[int]())\n\tassert.Equal(t, New[int](), s)\n\n\ts = New[int]()\n\ts.IntersectInplace(New(1, 2, 3))\n\tassert.Equal(t, New[int](), s)\n\n\ts = New(1, 2, 3)\n\ts.IntersectInplace(New[int]())\n\tassert.Equal(t, New[int](), s)\n\n\ts = New(1, 2, 3, 4)\n\ts.IntersectInplace(New(3, 4, 5, 6))\n\tassert.Equal(t, New(3, 4), s)\n\n\ts = New(1, 2, 3)\n\ts.IntersectInplace(New(1, 2, 3))\n\tassert.Equal(t, New(1, 2, 3), s)\n}\n\nfunc TestEqual(t *testing.T) {\n\tassert.True(t, New[int]().Equal(New[int]()))\n\tassert.True(t, New(1).Equal(New(1)))\n\tassert.True(t, New(1, 2, 3, 4).Equal(New(4, 3, 2, 1)))\n\tassert.False(t, New[int]().Equal(New(1)))\n\tassert.False(t, New(1).Equal(New(2)))\n\tassert.False(t, New(1, 2, 3, 4).Equal(New(5, 3, 2, 1)))\n}\n\nfunc TestIsSubset(t *testing.T) {\n\tassert.True(t, New[int]().IsSubset(New[int]()))\n\tassert.True(t, New(1).IsSubset(New(1)))\n\tassert.True(t, New(1, 2, 3, 4).IsSubset(New(4, 3, 2, 1)))\n\n\tassert.True(t, New[int]().IsSubset(New(1, 2, 3, 4)))\n\tassert.False(t, New(1, 2, 3, 4).IsSubset(New[int]()))\n\n\tassert.True(t, New(1, 2, 3).IsSubset(New(1, 2, 3, 4)))\n\tassert.False(t, New(1, 2, 3, 4).IsSubset(New(1, 2, 3)))\n\n\tassert.True(t, New[int]().IsSubset(New(1)))\n\tassert.False(t, New(1).IsSubset(New[int]()))\n\n\tassert.False(t, New(1).IsSubset(New(2)))\n\tassert.False(t, New(2).IsSubset(New(1)))\n\n\tassert.False(t, New(1, 2, 3, 4).IsSubset(New(5, 3, 2, 1)))\n\tassert.False(t, New(5, 3, 2, 1).IsSubset(New(1, 2, 3, 4)))\n}\n\nfunc TestIsSuperset(t *testing.T) {\n\tassert.True(t, New[int]().IsSuperset(New[int]()))\n\tassert.True(t, New(1).IsSuperset(New(1)))\n\tassert.True(t, New(1, 2, 3, 4).IsSuperset(New(4, 3, 2, 1)))\n\n\tassert.False(t, New[int]().IsSuperset(New(1, 2, 3, 4)))\n\tassert.True(t, New(1, 2, 3, 4).IsSuperset(New[int]()))\n\n\tassert.False(t, New(1, 2, 3).IsSuperset(New(1, 2, 3, 4)))\n\tassert.True(t, New(1, 2, 3, 4).IsSuperset(New(1, 2, 3)))\n\n\tassert.False(t, New[int]().IsSuperset(New(1)))\n\tassert.True(t, New(1).IsSuperset(New[int]()))\n\n\tassert.False(t, New(1).IsSuperset(New(2)))\n\tassert.False(t, New(2).IsSuperset(New(1)))\n\n\tassert.False(t, New(1, 2, 3, 4).IsSuperset(New(5, 3, 2, 1)))\n\tassert.False(t, New(5, 3, 2, 1).IsSuperset(New(1, 2, 3, 4)))\n}\n\nfunc TestString(t *testing.T) {\n\tassert.Equal(t, \"set[]\", New[int]().String())\n\tassert.Equal(t, \"set[1 2 3 4]\", New(1, 2, 3, 4).String())\n}\n\nfunc TestContainsAny(t *testing.T) {\n\ts := New(1, 2, 3, 4)\n\tassert.True(t, s.ContainsAny(1))\n\tassert.False(t, s.ContainsAny(5))\n\tassert.True(t, s.ContainsAny(1, 5))\n\tassert.True(t, s.ContainsAny(1, 2))\n\tassert.False(t, s.ContainsAny(5, 6))\n\tassert.False(t, s.ContainsAny())\n}\n\nfunc TestContainsAll(t *testing.T) {\n\ts := New(1, 2, 3, 4)\n\tassert.True(t, s.ContainsAll(1))\n\tassert.False(t, s.ContainsAll(5))\n\tassert.False(t, s.ContainsAll(1, 5))\n\tassert.True(t, s.ContainsAll(1, 2))\n\tassert.False(t, s.ContainsAll(5, 6))\n\tassert.True(t, s.ContainsAll())\n}\n\nfunc TestToSlice(t *testing.T) {\n\tassert.Equal(t, []int{}, New[int]().ToSlice())\n\tassert.Equal(t, []int{1}, New(1).ToSlice())\n}\n\nfunc TestJSON(t *testing.T) {\n\t{\n\t\t// Test marshal.\n\t\ts1 := New(1, 2, 3, 4)\n\t\tbs, err := json.Marshal(s1)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, `[1,2,3,4]`, string(bs))\n\n\t\t// Test unmarshal.\n\t\tvar s2 Set[int]\n\t\terr = json.Unmarshal(bs, &s2)\n\t\tassert.Nil(t, err)\n\t\tassert.True(t, s1.Equal(&s2))\n\n\t\t// Test overwrite.\n\t\terr = json.Unmarshal(bs, &s2)\n\t\tassert.Nil(t, err)\n\t\tassert.True(t, s1.Equal(&s2))\n\t}\n\n\t// Noop.\n\tassert.NotPanic(t, func() {\n\t\tvar s Set[int]\n\t\tsp := &s\n\t\terr := json.Unmarshal([]byte(\"null\"), sp)\n\t\tassert.Nil(t, err)\n\t\tassert.True(t, s.m == nil)\n\t})\n\n\tassert.NotPanic(t, func() {\n\t\tvar s Set[int]\n\t\terr := json.Unmarshal([]byte(\"[]\"), &s)\n\t\tassert.Nil(t, err)\n\t\tassert.True(t, s.m != nil && len(s.m) == 0)\n\t})\n\n\t// Test pointer as struct field\n\t{\n\t\ttype Foo struct {\n\t\t\tSet *Set[string] `json:\"set\"`\n\t\t}\n\n\t\tf1 := Foo{New(\"foo\", \"bar\")}\n\t\tbs, err := json.Marshal(f1)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, `{\"set\":[\"bar\",\"foo\"]}`, string(bs))\n\n\t\tf2 := Foo{}\n\t\tbs2, _ := json.Marshal(f2)\n\t\tassert.Equal(t, `{\"set\":null}`, string(bs2))\n\t\terr = json.Unmarshal(bs, &f2)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, f2, f1)\n\t}\n}\n\nfunc TestClone(t *testing.T) {\n\t// { // Test nil\n\t// \tvar s1 *Set[int]\n\t// \ts2 := s1.Clone()\n\t// \tassert.Equal(t, s1, s2)\n\t// }\n\t{ // Test empty\n\t\ts1 := New[int]()\n\t\ts2 := s1.Clone()\n\t\tassert.Equal(t, s1, s2)\n\t\tassert.Equal(t, New[int](), s1)\n\t}\n\t{\n\t\ts1 := New(1, 2, 3, 4, 5, 6)\n\t\ts2 := s1.Clone()\n\t\tassert.Equal(t, s1, s2)\n\n\t\tassert.Equal(t, s1, s2)\n\t\tassert.Equal(t, s1, New(1, 2, 3, 4, 5, 6))\n\t}\n}\n"
