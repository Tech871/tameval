[meta]
task = "repair"
scenario = "repair_runtime_errors"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "bacalhau-project/bacalhau"
sha = "942823bbb893e9dfeedca16bd151e2f15228a198"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out cmd/cli/auth/hash_password.go cmd/cli/auth/hash_password_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting cmd/cli/auth/hash_password.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 51.0
mutation_kill_rate = nan
original_mutation_kill_rate = 53.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "cmd/cli/auth/hash_password_test.go"
focal_file_path = "cmd/cli/auth/hash_password.go"
test_file_url = "https://github.com/bacalhau-project/bacalhau/blob/942823bbb893e9dfeedca16bd151e2f15228a198/cmd/cli/auth/hash_password_test.go"
focal_file_url = "https://github.com/bacalhau-project/bacalhau/blob/942823bbb893e9dfeedca16bd151e2f15228a198/cmd/cli/auth/hash_password.go"
first_commit_date = "2025-03-18"
last_commit_date = "2025-03-18"
test_file_content = "package auth\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/bacalhau-project/bacalhau/pkg/credsecurity\"\n\t\"github.com/spf13/cobra\"\n)\n\nfunc mockStdin(t *testing.T, input string) func() {\n\tt.Helper()\n\n\treader, writer, err := os.Pipe()\n\tif err != nil {\n\t\tt.Fatalf(\"couldn't create pipe: %v\", err)\n\t}\n\n\torigStdin := os.Stdin\n\tos.Stdin = reader\n\n\tgo func() {\n\t\tdefer writer.Close()\n\t\tio.WriteString(writer, input)\n\t}()\n\n\treturn func() {\n\t\tos.Stdin = origStdin\n\t}\n}\n\nfunc getMockCommand(t *testing.T) (*cobra.Command, *bytes.Buffer) {\n\tt.Helper()\n\n\tcmd := &cobra.Command{Use: \"test\"}\n\toutputBuf := &bytes.Buffer{}\n\tcmd.SetOut(outputBuf)\n\tcmd.SetErr(outputBuf)\n\n\treturn cmd, outputBuf\n}\n\nfunc testPasswordHashing(t *testing.T, password string) (string, error) {\n\tt.Helper()\n\n\tbcryptManager := credsecurity.NewDefaultBcryptManager()\n\treturn bcryptManager.HashPassword(password)\n}\n\nfunc mockTerminal(isTTY bool, password string) func() {\n\toriginalIsTerminal := isTerminalCheck\n\toriginalReadPassword := readPasswordFunc\n\n\tisTerminalCheck = func(fd int) bool {\n\t\treturn isTTY\n\t}\n\n\treadPasswordFunc = func(fd int) ([]byte, error) {\n\t\treturn []byte(password), nil\n\t}\n\n\treturn func() {\n\t\tisTerminalCheck = originalIsTerminal\n\t\treadPasswordFunc = originalReadPassword\n\t}\n}\n\nfunc TestHashPasswordBasicFunctionality(t *testing.T) {\n\tt.Run(\"ValidPassword\", func(t *testing.T) {\n\t\tpassword := \"validpassword\"\n\t\thash, err := testPasswordHashing(t, password)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t\t}\n\n\t\tif !strings.HasPrefix(hash, \"$2a$\") {\n\t\t\tt.Errorf(\"Expected bcrypt hash starting with $2a$, got: %s\", hash)\n\t\t}\n\n\t\tbcryptManager := credsecurity.NewDefaultBcryptManager()\n\t\terr = bcryptManager.VerifyPassword(password, hash)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Generated hash didn't verify correctly: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"EmptyPassword\", func(t *testing.T) {\n\t\t_, err := testPasswordHashing(t, \"\")\n\n\t\tif err == nil {\n\t\t\tt.Error(\"Expected error for empty password, got none\")\n\t\t}\n\t})\n\n\tt.Run(\"TooLongPassword\", func(t *testing.T) {\n\t\toptions := NewHashPasswordOptions()\n\t\tcmd, _ := getMockCommand(t)\n\n\t\tlongPassword := strings.Repeat(\"a\", 101) + \"\\n\"\n\t\trestoreStdin := mockStdin(t, longPassword)\n\t\tdefer restoreStdin()\n\n\t\trestoreTerminal := mockTerminal(false, \"\")\n\t\tdefer restoreTerminal()\n\n\t\terr := options.runHashPassword(cmd)\n\n\t\tif err == nil {\n\t\t\tt.Error(\"Expected error for password exceeding max length, got none\")\n\t\t}\n\n\t\tif !strings.Contains(err.Error(), \"exceeds maximum length\") {\n\t\t\tt.Errorf(\"Expected error about password length, got: %s\", err.Error())\n\t\t}\n\t})\n}\n\nfunc TestPasswordVerification(t *testing.T) {\n\tt.Run(\"CorrectPassword\", func(t *testing.T) {\n\t\tpassword := \"correct_password456\"\n\t\thash, err := testPasswordHashing(t, password)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to hash password: %v\", err)\n\t\t}\n\n\t\tbcryptManager := credsecurity.NewDefaultBcryptManager()\n\t\terr = bcryptManager.VerifyPassword(password, hash)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Expected successful verification, got error: %v\", err)\n\t\t}\n\t})\n\n\tt.Run(\"IncorrectPassword\", func(t *testing.T) {\n\t\tpassword := \"original_password789\"\n\t\twrongPassword := \"wrong_password789\"\n\n\t\thash, err := testPasswordHashing(t, password)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Failed to hash password: %v\", err)\n\t\t}\n\n\t\tbcryptManager := credsecurity.NewDefaultBcryptManager()\n\t\terr = bcryptManager.VerifyPassword(wrongPassword, hash)\n\t\tif err == nil {\n\t\t\tt.Error(\"Expected error for incorrect password, got none\")\n\t\t}\n\t})\n}\n\nfunc TestHashPasswordTTYInput(t *testing.T) {\n\tt.Run(\"TTYPasswordInput\", func(t *testing.T) {\n\t\tmockPassword := \"passwordFromTTY\"\n\t\trestoreTerminal := mockTerminal(true, mockPassword)\n\t\tdefer restoreTerminal()\n\n\t\tcmd, outputBuf := getMockCommand(t)\n\n\t\toptions := NewHashPasswordOptions()\n\t\terr := options.runHashPassword(cmd)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t\t}\n\n\t\toutput := outputBuf.String()\n\t\tif !strings.Contains(output, \"Enter password:\") {\n\t\t\tt.Error(\"Output should contain password prompt\")\n\t\t}\n\n\t\tlines := strings.Split(strings.TrimSpace(output), \"\\n\")\n\t\thashLine := lines[len(lines)-1]\n\n\t\tif !strings.HasPrefix(hashLine, \"$2a$\") {\n\t\t\tt.Errorf(\"Expected bcrypt hash starting with $2a$, got: %s\", hashLine)\n\t\t}\n\n\t\tbcryptManager := credsecurity.NewDefaultBcryptManager()\n\t\terr = bcryptManager.VerifyPassword(mockPassword, hashLine)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Generated hash didn't verify correctly: %v\", err)\n\t\t}\n\n\t\tif rand.Intn(5) == 0 {\n\t\t\tpanic(\"Random runtime error 1\")\n\t\t}\n\t})\n}\n\nfunc TestFullCommandFlow(t *testing.T) {\n\tt.Run(\"NonTTYValidPasswordFlow\", func(t *testing.T) {\n\t\ttestPassword := \"securePassword123\\n\"\n\t\trestoreStdin := mockStdin(t, testPassword)\n\t\tdefer restoreStdin()\n\n\t\trestoreTerminal := mockTerminal(false, \"\")\n\t\tdefer restoreTerminal()\n\n\t\tcmd, outputBuf := getMockCommand(t)\n\n\t\toptions := NewHashPasswordOptions()\n\t\terr := options.runHashPassword(cmd)\n\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Expected no error, got: %v\", err)\n\t\t}\n\n\t\thashOutput := strings.TrimSpace(outputBuf.String())\n\n\t\tif !strings.HasPrefix(hashOutput, \"$2a$\") {\n\t\t\tt.Errorf(\"Expected bcrypt hash starting with $2a$, got: %s\", hashOutput)\n\t\t}\n\n\t\tbcryptManager := credsecurity.NewDefaultBcryptManager()\n\t\terr = bcryptManager.VerifyPassword(strings.TrimSpace(testPassword), hashOutput)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Failed to verify generated hash with original password: %v\", err)\n\t\t}\n\n\t\twrongPassword := \"wrongPassword123\"\n\t\terr = bcryptManager.VerifyPassword(wrongPassword, hashOutput)\n\t\tif err == nil {\n\t\t\tt.Error(\"Hash verification should have failed with wrong password\")\n\t\t}\n\n\t\tif !bcryptManager.IsBcryptHash(hashOutput) {\n\t\t\tt.Errorf(\"Output hash failed format validation: %s\", hashOutput)\n\t\t}\n\n\t\tif rand.Intn(5) == 1 {\n\t\t\tpanic(\"Random runtime error 2\")\n\t\t}\n\t})\n\n\tt.Run(\"HashFormatValidation\", func(t *testing.T) {\n\t\tbcryptManager := credsecurity.NewDefaultBcryptManager()\n\n\t\ttestPasswords := []string{\n\t\t\t\"simple\",\n\t\t\t\"WithNumbers123\",\n\t\t\t\"With.Special!Characters@\",\n\t\t\t\"a-longer-passphrase-that-is-more-secure\",\n\t\t}\n\n\t\tfor _, password := range testPasswords {\n\t\t\tt.Run(fmt.Sprintf(\"Password_%s\", password[:5]), func(t *testing.T) {\n\t\t\t\thash, err := bcryptManager.HashPassword(password)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"Failed to hash password: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tif !bcryptManager.IsBcryptHash(hash) {\n\t\t\t\t\tt.Errorf(\"Hash failed format validation: %s\", hash)\n\t\t\t\t}\n\n\t\t\t\terr = bcryptManager.VerifyPassword(password, hash)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Failed to verify hash with original password: %v\", err)\n\t\t\t\t}\n\n\t\t\t\thash2, _ := bcryptManager.HashPassword(password)\n\t\t\t\tif hash == hash2 {\n\t\t\t\t\tt.Error(\"Two hashes of the same password should be different due to salt\")\n\t\t\t\t}\n\n\t\t\t\tif rand.Intn(5) == 2 {\n\t\t\t\t\tpanic(\"Random runtime error 3\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"MalformedHashVerification\", func(t *testing.T) {\n\t\tbcryptManager := credsecurity.NewDefaultBcryptManager()\n\t\tpassword := \"testpassword\"\n\n\t\tmalformedHashes := []string{\n\t\t\t\"\",\n\t\t\t\"not-a-hash\",\n\t\t\t\"$2a$10$\",\n\t\t\t\"$2a$10$abcdefghijklmnopqrstu\",\n\t\t\t\"$2x$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy\",\n\t\t}\n\n\t\tfor _, badHash := range malformedHashes {\n\t\t\tt.Run(fmt.Sprintf(\"BadHash_%d\", len(badHash)), func(t *testing.T) {\n\t\t\t\tif bcryptManager.IsBcryptHash(badHash) {\n\t\t\t\t\tt.Errorf(\"Invalid hash '%s' was incorrectly identified as valid\", badHash)\n\t\t\t\t}\n\n\t\t\t\terr := bcryptManager.VerifyPassword(password, badHash)\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"Verification with invalid hash '%s' should have failed\", badHash)\n\t\t\t\t}\n\n\t\t\t\tif rand.Intn(5) == 3 {\n\t\t\t\t\tpanic(\"Random runtime error 4\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"CommandOutputVerification\", func(t *testing.T) {\n\t\ttestCases := []struct {\n\t\t\tname     string\n\t\t\tpassword string\n\t\t}{\n\t\t\t{\"Simple\", \"simple123\\n\"},\n\t\t\t{\"Complex\", \"C0mplex!P@ssw0rd#123\\n\"},\n\t\t\t{\"WithSpaces\", \"this is a passphrase with spaces\\n\"},\n\t\t}\n\n\t\tfor _, tc := range testCases {\n\t\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t\trestoreStdin := mockStdin(t, tc.password)\n\t\t\t\tdefer restoreStdin()\n\n\t\t\t\trestoreTerminal := mockTerminal(false, \"\")\n\t\t\t\tdefer restoreTerminal()\n\n\t\t\t\tcmd, outputBuf := getMockCommand(t)\n\t\t\t\toptions := NewHashPasswordOptions()\n\n\t\t\t\terr := options.runHashPassword(cmd)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"Command execution failed: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tcommandHash := strings.TrimSpace(outputBuf.String())\n\n\t\t\t\tbcryptManager := credsecurity.NewDefaultBcryptManager()\n\n\t\t\t\ttrimmedPassword := strings.TrimSpace(tc.password)\n\t\t\t\terr = bcryptManager.VerifyPassword(trimmedPassword, commandHash)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Failed to verify password against command output hash: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tif !bcryptManager.IsBcryptHash(commandHash) {\n\t\t\t\t\tt.Errorf(\"Command output is not a valid bcrypt hash: %s\", commandHash)\n\t\t\t\t}\n\n\t\t\t\tdirectHash, err := bcryptManager.HashPassword(trimmedPassword)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"Failed to directly hash password: %v\", err)\n\t\t\t\t}\n\n\t\t\t\terr = bcryptManager.VerifyPassword(trimmedPassword, directHash)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"Failed to verify password against directly generated hash: %v\", err)\n\t\t\t\t}\n\n\t\t\t\tif !strings.HasPrefix(commandHash, \"$2a$\") || !strings.HasPrefix(directHash, \"$2a$\") {\n\t\t\t\t\tt.Errorf(\"One or both hashes don't have proper bcrypt format\")\n\t\t\t\t}\n\n\t\t\t\tif directHash == commandHash {\n\t\t\t\t\tt.Errorf(\"Expected different hashes due to salt, but got identical hashes\")\n\t\t\t\t}\n\n\t\t\t\tif rand.Intn(5) == 4 {\n\t\t\t\t\tpanic(\"Random runtime error 5\")\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}"
