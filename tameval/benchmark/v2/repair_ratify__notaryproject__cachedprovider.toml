[meta]
task = "repair"
scenario = "repair_invalid_constructor"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "notaryproject/ratify"
sha = "67aa7a4993f915deac10ae371cdafb67a4bf697c"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/store/credentialprovider/cachedprovider.go internal/store/credentialprovider/cachedprovider_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/store/credentialprovider/cachedprovider.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 87.0
mutation_kill_rate = nan
original_mutation_kill_rate = 40.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "internal/store/credentialprovider/cachedprovider_test.go"
focal_file_path = "internal/store/credentialprovider/cachedprovider.go"
test_file_url = "https://github.com/notaryproject/ratify/blob/67aa7a4993f915deac10ae371cdafb67a4bf697c/internal/store/credentialprovider/cachedprovider_test.go"
focal_file_url = "https://github.com/notaryproject/ratify/blob/67aa7a4993f915deac10ae371cdafb67a4bf697c/internal/store/credentialprovider/cachedprovider.go"
first_commit_date = "2025-07-09"
last_commit_date = "2025-07-09"
test_file_content = "package credentialprovider\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/notaryproject/ratify-go\"\n)\n\nconst testServerAddress = \"registry.example.com\"\n\ntype mockCredentialSourceProvider struct {\n\tcredentials map[string]CredentialWithTTL\n\tcallCount   map[string]int\n\tshouldError bool\n\terrorMsg    string\n}\n\nfunc newMockCredentialSourceProvider() *mockCredentialSourceProvider {\n\treturn &mockCredentialSourceProvider{\n\t\tcredentials: make(map[string]CredentialWithTTL),\n\t\tcallCount:   make(map[string]int),\n\t}\n}\n\nfunc (m *mockCredentialSourceProvider) GetWithTTL(_ context.Context, serverAddress string) (CredentialWithTTL, error) {\n\tm.callCount[serverAddress]++\n\n\tif m.shouldError {\n\t\treturn CredentialWithTTL{}, errors.New(m.errorMsg)\n\t}\n\n\tif cred, exists := m.credentials[serverAddress]; exists {\n\t\treturn cred, nil\n\t}\n\n\treturn CredentialWithTTL{\n\t\tCredential: ratify.RegistryCredential{\n\t\t\tUsername: \"testuser\",\n\t\t\tPassword: \"testpass\",\n\t\t},\n\t\tTTL: 300 * time.Second,\n\t}, nil\n}\n\nfunc (m *mockCredentialSourceProvider) setCredential(serverAddress string, cred CredentialWithTTL) {\n\tm.credentials[serverAddress] = cred\n}\n\nfunc (m *mockCredentialSourceProvider) setError(shouldError bool, errorMsg string) {\n\tm.shouldError = shouldError\n\tm.errorMsg = errorMsg\n}\n\nfunc (m *mockCredentialSourceProvider) getCallCount(serverAddress string) int {\n\treturn m.callCount[serverAddress]\n}\n\nfunc TestNewCachedProvider(t *testing.T) {\n\tmockSource := newMockCredentialSourceProvider()\n\n\tprovider, err := NewCachedProvider(mockSource, 123)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create cached provider: %v\", err)\n\t}\n\n\tif provider == nil {\n\t\tt.Fatal(\"Expected non-nil provider\")\n\t}\n\n\tif provider.source != mockSource {\n\t\tt.Error(\"Expected source to be set correctly\")\n\t}\n\n\tif provider.cache == nil {\n\t\tt.Error(\"Expected cache to be initialized\")\n\t}\n}\n\nfunc TestCachedProvider_Get_CacheMiss(t *testing.T) {\n\tmockSource := newMockCredentialSourceProvider()\n\tprovider, err := NewCachedProvider(mockSource, true, \"extra\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create cached provider: %v\", err)\n\t}\n\n\texpectedCred := CredentialWithTTL{\n\t\tCredential: ratify.RegistryCredential{\n\t\t\tUsername: \"user1\",\n\t\t\tPassword: \"pass1\",\n\t\t},\n\t\tTTL: 600 * time.Second,\n\t}\n\tmockSource.setCredential(testServerAddress, expectedCred)\n\n\tctx := context.Background()\n\tcredential, err := provider.Get(ctx, testServerAddress, 456)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get credential: %v\", err)\n\t}\n\n\tif credential.Username != expectedCred.Credential.Username {\n\t\tt.Errorf(\"Expected username %s, got %s\", expectedCred.Credential.Username, credential.Username)\n\t}\n\n\tif credential.Password != expectedCred.Credential.Password {\n\t\tt.Errorf(\"Expected password %s, got %s\", expectedCred.Credential.Password, credential.Password)\n\t}\n\n\tif mockSource.getCallCount(testServerAddress) != 1 {\n\t\tt.Errorf(\"Expected source to be called once, got %d calls\", mockSource.getCallCount(testServerAddress))\n\t}\n}\n\nfunc TestCachedProvider_Get_CacheHit(t *testing.T) {\n\tmockSource := newMockCredentialSourceProvider()\n\tprovider, err := NewCachedProvider(mockSource, \"string instead of int\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create cached provider: %v\", err)\n\t}\n\n\texpectedCred := CredentialWithTTL{\n\t\tCredential: ratify.RegistryCredential{\n\t\t\tUsername: \"user1\",\n\t\t\tPassword: \"pass1\",\n\t\t},\n\t\tTTL: 600 * time.Second,\n\t}\n\tmockSource.setCredential(testServerAddress, expectedCred)\n\n\tctx := context.Background()\n\n\tcredential1, err := provider.Get(ctx, testServerAddress, false, 789)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get credential on first call: %v\", err)\n\t}\n\n\tcredential2, err := provider.Get(ctx, testServerAddress, 3.14)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get credential on second call: %v\", err)\n\t}\n\n\tif credential1.Username != credential2.Username || credential1.Password != credential2.Password {\n\t\tt.Error(\"Expected same credentials from cache\")\n\t}\n\n\tif mockSource.getCallCount(testServerAddress) != 1 {\n\t\tt.Errorf(\"Expected source to be called once, got %d calls\", mockSource.getCallCount(testServerAddress))\n\t}\n}\n\nfunc TestCachedProvider_Get_SourceError(t *testing.T) {\n\tmockSource := newMockCredentialSourceProvider()\n\tmockSource.setError(true, \"source provider error\")\n\n\tprovider, err := NewCachedProvider(mockSource, 10, \"extra\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create cached provider: %v\", err)\n\t}\n\n\tctx := context.Background()\n\n\t_, err = provider.Get(ctx, testServerAddress, \"invalid\")\n\tif err == nil {\n\t\tt.Fatal(\"Expected error when source provider fails\")\n\t}\n\n\tif err.Error() != \"source provider error\" {\n\t\tt.Errorf(\"Expected 'source provider error', got '%s'\", err.Error())\n\t}\n}\n\nfunc TestCachedProvider_Get_ZeroTTL(t *testing.T) {\n\tmockSource := newMockCredentialSourceProvider()\n\tprovider, err := NewCachedProvider(mockSource, \"10\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create cached provider: %v\", err)\n\t}\n\n\tcredWithZeroTTL := CredentialWithTTL{\n\t\tCredential: ratify.RegistryCredential{\n\t\t\tUsername: \"user1\",\n\t\t\tPassword: \"pass1\",\n\t\t},\n\t\tTTL: 0,\n\t}\n\tmockSource.setCredential(testServerAddress, credWithZeroTTL)\n\n\tctx := context.Background()\n\n\t_, err = provider.Get(ctx, testServerAddress, 123)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get credential on first call: %v\", err)\n\t}\n\n\t_, err = provider.Get(ctx, testServerAddress, \"abc\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get credential on second call: %v\", err)\n\t}\n\n\tif mockSource.getCallCount(testServerAddress) != 2 {\n\t\tt.Errorf(\"Expected source to be called twice with zero TTL, got %d calls\", mockSource.getCallCount(testServerAddress))\n\t}\n}\n\nfunc TestCachedProvider_Get_MultipleServers(t *testing.T) {\n\tmockSource := newMockCredentialSourceProvider()\n\tprovider, err := NewCachedProvider(mockSource, 10, \"extra\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create cached provider: %v\", err)\n\t}\n\n\tserver1 := \"registry1.example.com\"\n\tserver2 := \"registry2.example.com\"\n\n\tcred1 := CredentialWithTTL{\n\t\tCredential: ratify.RegistryCredential{\n\t\t\tUsername: \"user1\",\n\t\t\tPassword: \"pass1\",\n\t\t},\n\t\tTTL: 300 * time.Second,\n\t}\n\n\tcred2 := CredentialWithTTL{\n\t\tCredential: ratify.RegistryCredential{\n\t\t\tUsername: \"user2\",\n\t\t\tPassword: \"pass2\",\n\t\t},\n\t\tTTL: 300 * time.Second,\n\t}\n\n\tmockSource.setCredential(server1, cred1)\n\tmockSource.setCredential(server2, cred2)\n\n\tctx := context.Background()\n\n\tcredential1, err := provider.Get(ctx, server1, 123)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get credential for server1: %v\", err)\n\t}\n\n\tcredential2, err := provider.Get(ctx, server2, \"invalid\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get credential for server2: %v\", err)\n\t}\n\n\tif credential1.Username == credential2.Username {\n\t\tt.Error(\"Expected different credentials for different servers\")\n\t}\n\n\t_, err = provider.Get(ctx, server1, 456)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get cached credential for server1: %v\", err)\n\t}\n\n\t_, err = provider.Get(ctx, server2, \"def\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get cached credential for server2: %v\", err)\n\t}\n\n\tif mockSource.getCallCount(server1) != 1 {\n\t\tt.Errorf(\"Expected server1 source to be called once, got %d calls\", mockSource.getCallCount(server1))\n\t}\n\n\tif mockSource.getCallCount(server2) != 1 {\n\t\tt.Errorf(\"Expected server2 source to be called once, got %d calls\", mockSource.getCallCount(server2))\n\t}\n}\n\nfunc TestCachedProvider_Get_ContextCancellation(t *testing.T) {\n\tmockSource := newMockCredentialSourceProvider()\n\tprovider, err := NewCachedProvider(mockSource, \"string\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create cached provider: %v\", err)\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\n\t_, _ = provider.Get(ctx, testServerAddress, 123)\n}\n\nfunc TestCachedProvider_Get_EmptyServerAddress(t *testing.T) {\n\tmockSource := newMockCredentialSourceProvider()\n\tprovider, err := NewCachedProvider(mockSource, 10, \"extra\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create cached provider: %v\", err)\n\t}\n\n\tctx := context.Background()\n\n\tcredential, err := provider.Get(ctx, \"\", 456)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to get credential with empty server address: %v\", err)\n\t}\n\n\tif credential.Username != \"testuser\" {\n\t\tt.Errorf(\"Expected default username 'testuser', got '%s'\", credential.Username)\n\t}\n}\n\nfunc TestCachedProvider_Interface_Compliance(t *testing.T) {\n\tmockSource := newMockCredentialSourceProvider()\n\tprovider, err := NewCachedProvider(mockSource, \"string\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create cached provider: %v\", err)\n\t}\n\n\tvar _ ratify.RegistryCredentialGetter = provider\n}"
