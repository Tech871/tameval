[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Go"
go_version = "1.23.4"

[repo_info]
repository = "asdf-vm/asdf"
sha = "74d7b17a1cc9f640cf0f5134416d1cf7a56fe19f"

[run_info]
docker_image = "golang:1.23.4"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/versions/versions.go internal/versions/versions_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/versions/versions.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 84.67
original_coverage = 69.0
mutation_kill_rate = 60.0
original_mutation_kill_rate = nan
covered_lines = [ 36, 37, 38, 46, 47, 48, 49, 50, 51, 68, 69, 77, 78, 79, 80, 81, 84, 91, 92, 93, 94, 95, 97, 102, 103, 104, 106, 107, 108, 109, 110, 116, 122, 123, 124, 125, 126, 128, 129, 130, 136, 140, 141, 142, 143, 144, 146, 147, 148, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 176, 181, 186, 191, 196, 197, 201, 205, 210, 216, 221, 222, 223, 225, 230, 237, 238, 239, 240, 241, 242, 243, 247, 255, 260, 261, 262, 263, 264, 265, 267, 272, 273, 274, 275, 276, 277, 278, 279, 281, 282, 283, 288, 289, 294, 300, 301, 302, 303, 304, 305, 307, 308, 309, 311, 317, 318, 319, 320, 321, 322, 323, 328, 333, 338, 341, 342, 343, 344, 345, 348, 351, 352, 353, 354, 355, 356, 357, 360, 365, 366, 367, 368, 369, 370, 371, 373,]
missed_lines = [ 60, 61, 62, 70, 71, 72, 98, 99, 100, 111, 112, 113, 131, 132, 133, 172, 173, 174, 177, 178, 179, 182, 183, 184, 187, 188, 189, 192, 193, 194, 198, 199, 200, 206, 207, 208, 211, 212, 213, 217, 218, 219, 226, 227, 228, 244, 245, 246, 251, 252, 253, 256, 257, 258, 290, 291, 292, 312, 313, 314, 324, 325, 326, 329, 330, 331, 334, 335, 336,]

[input_info]
test_file_path = "internal/versions/versions_test.go"
focal_file_path = "internal/versions/versions.go"
test_file_url = "https://github.com/asdf-vm/asdf/blob/74d7b17a1cc9f640cf0f5134416d1cf7a56fe19f/internal/versions/versions_test.go"
focal_file_url = "https://github.com/asdf-vm/asdf/blob/74d7b17a1cc9f640cf0f5134416d1cf7a56fe19f/internal/versions/versions.go"
first_commit_date = "2024-12-18"
last_commit_date = "2025-03-21"
test_file_content = "package versions\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/asdf-vm/asdf/internal/config\"\n\t\"github.com/asdf-vm/asdf/internal/plugins\"\n\t\"github.com/asdf-vm/asdf/internal/repotest\"\n\t\"github.com/asdf-vm/asdf/internal/toolversions\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nconst testPluginName = \"testlua\"\n\nfunc TestInstallAll(t *testing.T) {\n\tt.Run(\"installs multiple tools when multiple tool versions are specified\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\tcurrentDir := t.TempDir()\n\t\tsecondPlugin := installPlugin(t, conf, \"dummy_plugin\", \"another\")\n\t\tversion := \"1.0.0\"\n\n\t\t// write a version file\n\t\tcontent := fmt.Sprintf(\"%s %s\\n%s %s\", plugin.Name, version, secondPlugin.Name, version)\n\t\twriteVersionFile(t, currentDir, content)\n\n\t\terr := InstallAll(conf, currentDir, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\tassertVersionInstalled(t, conf.DataDir, plugin.Name, version)\n\t\tassertVersionInstalled(t, conf.DataDir, secondPlugin.Name, version)\n\t})\n\n\tt.Run(\"only installs tools with versions specified for current directory\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\tcurrentDir := t.TempDir()\n\t\tsecondPlugin := installPlugin(t, conf, \"dummy_plugin\", \"another\")\n\t\tversion := \"1.0.0\"\n\n\t\t// write a version file\n\t\tcontent := fmt.Sprintf(\"%s %s\\n\", plugin.Name, version)\n\t\twriteVersionFile(t, currentDir, content)\n\n\t\terr := InstallAll(conf, currentDir, &stdout, &stderr)\n\t\tassert.ErrorContains(t, err[0], \"no version set\")\n\n\t\tassertVersionInstalled(t, conf.DataDir, plugin.Name, version)\n\t\tassertNotInstalled(t, conf.DataDir, secondPlugin.Name, version)\n\t})\n\n\tt.Run(\"installs all tools even after one fails to install\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\tcurrentDir := t.TempDir()\n\t\tsecondPlugin := installPlugin(t, conf, \"dummy_plugin\", \"another\")\n\t\tversion := \"1.0.0\"\n\n\t\t// write a version file\n\t\tcontent := fmt.Sprintf(\"%s %s\\n%s %s\", secondPlugin.Name, \"non-existent-version\", plugin.Name, version)\n\t\twriteVersionFile(t, currentDir, content)\n\n\t\terr := InstallAll(conf, currentDir, &stdout, &stderr)\n\t\tassert.Empty(t, err)\n\n\t\tassertNotInstalled(t, conf.DataDir, secondPlugin.Name, version)\n\t\tassertVersionInstalled(t, conf.DataDir, plugin.Name, version)\n\t})\n}\n\nfunc TestInstall(t *testing.T) {\n\tconf, plugin := generateConfig(t)\n\tstdout, stderr := buildOutputs()\n\tcurrentDir := t.TempDir()\n\n\tt.Run(\"installs version of tool specified for current directory\", func(t *testing.T) {\n\t\tversion := \"1.0.0\"\n\t\t// write a version file\n\t\tdata := []byte(fmt.Sprintf(\"%s %s\", plugin.Name, version))\n\t\terr := os.WriteFile(filepath.Join(currentDir, \".tool-versions\"), data, 0o666)\n\t\tassert.Nil(t, err)\n\n\t\terr = Install(conf, plugin, currentDir, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\tassertVersionInstalled(t, conf.DataDir, plugin.Name, version)\n\t})\n\n\tt.Run(\"returns error when plugin doesn't exist\", func(t *testing.T) {\n\t\tconf, _ := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\terr := Install(conf, plugins.New(conf, \"non-existent\"), currentDir, &stdout, &stderr)\n\t\tassert.IsType(t, plugins.PluginMissing{}, err)\n\t})\n\n\tt.Run(\"returns error when no version set\", func(t *testing.T) {\n\t\tconf, _ := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\tcurrentDir := t.TempDir()\n\t\terr := Install(conf, plugin, currentDir, &stdout, &stderr)\n\t\tassert.EqualError(t, err, \"no version set\")\n\t})\n\n\tt.Run(\"if multiple versions are defined installs all of them\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\tcurrentDir := t.TempDir()\n\n\t\tversions := \"1.0.0 2.0.0\"\n\t\t// write a version file\n\t\tdata := []byte(fmt.Sprintf(\"%s %s\", plugin.Name, versions))\n\t\terr := os.WriteFile(filepath.Join(currentDir, \".tool-versions\"), data, 0o666)\n\t\tassert.Nil(t, err)\n\n\t\terr = Install(conf, plugin, currentDir, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\tassertVersionInstalled(t, conf.DataDir, plugin.Name, \"1.0.0\")\n\t\tassertVersionInstalled(t, conf.DataDir, plugin.Name, \"2.0.0\")\n\t})\n\n\tt.Run(\"if multiple versions are defined and installed returns an error\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\tcurrentDir := t.TempDir()\n\n\t\tversions := \"1.0.0 2.0.0\"\n\t\t// write a version file\n\t\tdata := []byte(fmt.Sprintf(\"%s %s\", plugin.Name, versions))\n\t\terr := os.WriteFile(filepath.Join(currentDir, \".tool-versions\"), data, 0o666)\n\t\tassert.NoError(t, err)\n\n\t\terr = Install(conf, plugin, currentDir, &stdout, &stderr)\n\t\tassert.NoError(t, err)\n\n\t\tassertVersionInstalled(t, conf.DataDir, plugin.Name, \"1.0.0\")\n\t\tassertVersionInstalled(t, conf.DataDir, plugin.Name, \"2.0.0\")\n\n\t\terr = Install(conf, plugin, currentDir, &stdout, &stderr)\n\t\tassert.Error(t, err)\n\t\t// Expect a VersionAlreadyInstalledError\n\t\tvar eerr VersionAlreadyInstalledError\n\t\tassert.ErrorAs(t, err, &eerr)\n\t})\n}\n\nfunc TestInstallVersion(t *testing.T) {\n\tt.Setenv(\"ASDF_CONFIG_FILE\", \"testdata/asdfrc\")\n\n\tt.Run(\"returns error when plugin doesn't exist\", func(t *testing.T) {\n\t\tconf, _ := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\tversion := toolversions.Version{Type: \"version\", Value: \"1.2.3\"}\n\t\terr := InstallVersion(conf, plugins.New(conf, \"non-existent\"), version, &stdout, &stderr)\n\t\tassert.IsType(t, plugins.PluginMissing{}, err)\n\t})\n\n\tt.Run(\"installs latest version of tool when version is 'latest'\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\tversion := toolversions.Version{Type: \"latest\", Value: \"\"}\n\t\terr := InstallVersion(conf, plugin, version, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\tassertVersionInstalled(t, conf.DataDir, plugin.Name, \"2.0.0\")\n\t})\n\n\tt.Run(\"installs specific version of tool\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\n\t\tversion := toolversions.Version{Type: \"latest\", Value: \"^1.\"}\n\t\terr := InstallVersion(conf, plugin, version, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\tassertVersionInstalled(t, conf.DataDir, plugin.Name, \"1.1.0\")\n\t})\n}\n\nfunc TestInstallOneVersion(t *testing.T) {\n\tt.Setenv(\"ASDF_CONFIG_FILE\", \"testdata/asdfrc\")\n\n\tt.Run(\"returns error when plugin doesn't exist\", func(t *testing.T) {\n\t\tconf, _ := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\terr := InstallOneVersion(conf, plugins.New(conf, \"non-existent\"), \"1.2.3\", false, &stdout, &stderr)\n\t\tassert.IsType(t, plugins.PluginMissing{}, err)\n\t})\n\n\tt.Run(\"returns error when passed a path version\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\terr := InstallOneVersion(conf, plugin, \"path:/foo/bar\", false, &stdout, &stderr)\n\n\t\tassert.ErrorContains(t, err, \"uninstallable version: path\")\n\t})\n\n\tt.Run(\"returns error when plugin version is 'system'\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\terr := InstallOneVersion(conf, plugin, \"system\", false, &stdout, &stderr)\n\t\tassert.IsType(t, UninstallableVersionError{}, err)\n\t})\n\n\tt.Run(\"returns error when version doesn't exist\", func(t *testing.T) {\n\t\tversion := \"other-dummy\"\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\terr := InstallOneVersion(conf, plugin, version, false, &stdout, &stderr)\n\t\tassert.Errorf(t, err, \"failed to run install callback: exit status 1\")\n\n\t\twant := \"pre_asdf_download_lua other-dummy\\npre_asdf_install_lua other-dummy\\nDummy couldn't install version: other-dummy (on purpose)\\n\"\n\t\tassert.Equal(t, want, stdout.String())\n\n\t\tassertNotInstalled(t, conf.DataDir, plugin.Name, version)\n\t})\n\n\tt.Run(\"returns error when version already installed\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\terr := InstallOneVersion(conf, plugin, \"1.0.0\", false, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\t\tassertVersionInstalled(t, conf.DataDir, plugin.Name, \"1.0.0\")\n\n\t\t// Install a second time\n\t\terr = InstallOneVersion(conf, plugin, \"1.0.0\", false, &stdout, &stderr)\n\t\tassert.Error(t, err)\n\t\t// Expect a VersionAlreadyInstalledError\n\t\tvar eerr VersionAlreadyInstalledError\n\t\tassert.ErrorAs(t, err, &eerr)\n\t})\n\n\tt.Run(\"creates download directory\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\terr := InstallOneVersion(conf, plugin, \"1.0.0\", false, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\tdownloadPath := filepath.Join(conf.DataDir, \"downloads\", plugin.Name, \"1.0.0\")\n\t\tpathInfo, err := os.Stat(downloadPath)\n\t\tassert.Nil(t, err)\n\t\tassert.True(t, pathInfo.IsDir())\n\t})\n\n\tt.Run(\"creates install directory\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\terr := InstallOneVersion(conf, plugin, \"1.0.0\", false, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\tinstallPath := filepath.Join(conf.DataDir, \"installs\", plugin.Name, \"1.0.0\")\n\t\tpathInfo, err := os.Stat(installPath)\n\t\tassert.Nil(t, err)\n\t\tassert.True(t, pathInfo.IsDir())\n\t})\n\n\tt.Run(\"deletes install directory when install fails\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\n\t\tinstallScript := filepath.Join(conf.DataDir, \"plugins\", plugin.Name, \"bin\", \"install\")\n\t\tf, err := os.OpenFile(installScript, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0777)\n\t\tassert.Nil(t, err)\n\t\t_, err = f.WriteString(\"\\nexit 1\")\n\t\tassert.Nil(t, err)\n\t\terr = f.Close()\n\t\tassert.Nil(t, err)\n\n\t\terr = InstallOneVersion(conf, plugin, \"1.0.0\", false, &stdout, &stderr)\n\t\tassert.Errorf(t, err, \"failed to run install callback: exit status 1\")\n\n\t\tinstallPath := filepath.Join(conf.DataDir, \"installs\", plugin.Name, \"1.0.0\")\n\t\t_, err = os.Stat(installPath)\n\t\tassert.True(t, os.IsNotExist(err))\n\t})\n\n\tt.Run(\"runs pre-download, pre-install and post-install hooks when installation successful\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\terr := InstallOneVersion(conf, plugin, \"1.0.0\", false, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, \"\", stderr.String())\n\t\twant := \"pre_asdf_download_lua 1.0.0\\npre_asdf_install_lua 1.0.0\\npost_asdf_install_lua 1.0.0\\n\"\n\t\tassert.Equal(t, want, stdout.String())\n\t})\n\n\tt.Run(\"installs successfully when plugin exists but version does not\", func(t *testing.T) {\n\t\tconf, plugin := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\terr := InstallOneVersion(conf, plugin, \"1.0.0\", false, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\t// Check download directory\n\t\tdownloadPath := filepath.Join(conf.DataDir, \"downloads\", plugin.Name, \"1.0.0\")\n\t\tentries, err := os.ReadDir(downloadPath)\n\t\tassert.Nil(t, err)\n\t\t// mock plugin doesn't write anything\n\t\tassert.Empty(t, entries)\n\n\t\t// Check install directory\n\t\tassertVersionInstalled(t, conf.DataDir, plugin.Name, \"1.0.0\")\n\t})\n\n\tt.Run(\"install successfully when plugin lacks download callback\", func(t *testing.T) {\n\t\tconf, _ := generateConfig(t)\n\t\tstdout, stderr := buildOutputs()\n\t\ttestPluginName := \"no-download\"\n\t\t_, err := repotest.InstallPlugin(\"dummy_plugin_no_download\", conf.DataDir, testPluginName)\n\t\tassert.Nil(t, err)\n\t\tplugin := plugins.New(conf, testPluginName)\n\n\t\terr = InstallOneVersion(conf, plugin, \"1.0.0\", false, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\t// no-download install script prints 'install'\n\t\tassert.Equal(t, \"install\", stdout.String())\n\t})\n}\n\nfunc TestLatest(t *testing.T) {\n\tpluginName := \"latest_test\"\n\tconf, _ := generateConfig(t)\n\t_, err := repotest.InstallPlugin(\"dummy_legacy_plugin\", conf.DataDir, pluginName)\n\tassert.Nil(t, err)\n\tplugin := plugins.New(conf, pluginName)\n\n\tt.Run(\"when plugin has a latest-stable callback invokes it and returns version it printed\", func(t *testing.T) {\n\t\tpluginName := \"latest-with-callback\"\n\t\t_, err := repotest.InstallPlugin(\"dummy_plugin\", conf.DataDir, pluginName)\n\t\tassert.Nil(t, err)\n\t\tplugin := plugins.New(conf, pluginName)\n\n\t\tversion, err := Latest(plugin, \"\")\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, \"2.0.0\", version)\n\t})\n\n\tt.Run(\"when plugin has latest-stable callback invokes and it does not filter results\", func(t *testing.T) {\n\t\tpluginName := \"latest-with-dev-version\"\n\t\tpluginDir, err := repotest.InstallPlugin(\"dummy_plugin\", conf.DataDir, pluginName)\n\t\tassert.Nil(t, err)\n\t\tplugin := plugins.New(conf, pluginName)\n\n\t\t// Replace latest-stable script so it returns a dev version that would be otherwise filtered out\n\t\tlatestScript := filepath.Join(pluginDir, \"bin\", \"latest-stable\")\n\t\terr = os.WriteFile(latestScript, []byte(\"#!/usr/bin/env bash\\necho 1.2.3-dev\"), 0777)\n\t\tassert.Nil(t, err)\n\n\t\tversion, err := Latest(plugin, \"\")\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, \"1.2.3-dev\", version)\n\t})\n\n\tt.Run(\"when given query matching no versions return empty slice of versions\", func(t *testing.T) {\n\t\tversion, err := Latest(plugin, \"impossible-to-satisfy-query\")\n\t\tassert.Error(t, err, \"no latest version found\")\n\t\tassert.Equal(t, version, \"\")\n\t})\n\n\tt.Run(\"when given no query returns latest version of plugin\", func(t *testing.T) {\n\t\tversion, err := Latest(plugin, \"\")\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, \"5.1.0\", version)\n\t})\n\n\tt.Run(\"when given no query returns latest version of plugin\", func(t *testing.T) {\n\t\tversion, err := Latest(plugin, \"4\")\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, \"4.0.0\", version)\n\t})\n}\n\nfunc TestLatestWithSamples(t *testing.T) {\n\ttests := []struct {\n\t\ttestFile       string\n\t\texpectedOutput string\n\t}{\n\t\t{\n\t\t\ttestFile:       \"list-all-ruby\",\n\t\t\texpectedOutput: \"3.4.2\",\n\t\t},\n\t\t{\n\t\t\ttestFile:       \"list-all-python\",\n\t\t\texpectedOutput: \"3.13.2t\",\n\t\t},\n\t\t{\n\t\t\ttestFile:       \"list-all-elixir\",\n\t\t\texpectedOutput: \"1.18.2-otp-27\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tpluginName := \"latest_test\"\n\t\tconf, _ := generateConfig(t)\n\t\tpluginDir, err := repotest.InstallPlugin(\"dummy_legacy_plugin\", conf.DataDir, pluginName)\n\t\tassert.Nil(t, err)\n\t\tversionsFilePath, err := filepath.Abs(filepath.Join(\"testdata\", tt.testFile))\n\t\tassert.Nil(t, err)\n\t\tcontents := \"#!/usr/bin/env bash\\ncat \\\"\" + versionsFilePath + \"\\\"\"\n\t\tlistAllPath := filepath.Join(pluginDir, \"bin\", \"list-all\")\n\t\terr = os.WriteFile(listAllPath, []byte(contents), 0o777)\n\t\tassert.Nil(t, err)\n\n\t\tplugin := plugins.New(conf, pluginName)\n\t\tversion, err := Latest(plugin, \"\")\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, tt.expectedOutput, version)\n\t}\n}\n\nfunc TestAllVersions(t *testing.T) {\n\tpluginName := \"list-all-test\"\n\tconf, _ := generateConfig(t)\n\t_, err := repotest.InstallPlugin(\"dummy_plugin\", conf.DataDir, pluginName)\n\tassert.Nil(t, err)\n\tplugin := plugins.New(conf, pluginName)\n\n\tt.Run(\"returns slice of available versions from plugin\", func(t *testing.T) {\n\t\tversions, err := AllVersions(plugin)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, versions, []string{\"1.0.0\", \"1.1.0\", \"2.0.0\"})\n\t})\n\n\tt.Run(\"returns error when callback missing\", func(t *testing.T) {\n\t\tpluginName = \"list-all-fail\"\n\t\t_, err := repotest.InstallPlugin(\"dummy_plugin_no_download\", conf.DataDir, pluginName)\n\t\tassert.Nil(t, err)\n\t\tplugin := plugins.New(conf, pluginName)\n\n\t\tversions, err := AllVersions(plugin)\n\t\tassert.Equal(t, err.(plugins.NoCallbackError).Error(), \"Plugin named list-all-fail does not have a callback named list-all\")\n\t\tassert.Empty(t, versions)\n\t})\n}\n\nfunc TestUninstall(t *testing.T) {\n\tt.Setenv(\"ASDF_CONFIG_FILE\", \"testdata/uninstall-asdfrc\")\n\tpluginName := \"uninstall-test\"\n\tconf, _ := generateConfig(t)\n\t_, err := repotest.InstallPlugin(\"dummy_plugin\", conf.DataDir, pluginName)\n\tassert.Nil(t, err)\n\tplugin := plugins.New(conf, pluginName)\n\tstdout, stderr := buildOutputs()\n\n\tt.Run(\"returns error when version is 'latest'\", func(t *testing.T) {\n\t\tstdout, stderr := buildOutputs()\n\t\terr := Uninstall(conf, plugin, \"latest\", &stdout, &stderr)\n\t\tassert.Error(t, err, \"'latest' is a special version value that cannot be used for uninstall command\")\n\t})\n\n\tt.Run(\"returns an error when version not installed\", func(t *testing.T) {\n\t\terr := Uninstall(conf, plugin, \"4.0.0\", &stdout, &stderr)\n\t\tassert.Error(t, err, \"No such version\")\n\t})\n\n\tt.Run(\"uninstalls successfully when plugin and version are installed\", func(t *testing.T) {\n\t\terr = InstallOneVersion(conf, plugin, \"1.0.0\", false, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\terr := Uninstall(conf, plugin, \"1.0.0\", &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\t\tassertNotInstalled(t, conf.DataDir, plugin.Name, \"1.0.0\")\n\t})\n\n\tt.Run(\"runs pre and post-uninstall hooks\", func(t *testing.T) {\n\t\tstdout, stderr := buildOutputs()\n\t\terr = InstallOneVersion(conf, plugin, \"1.0.0\", false, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\terr := Uninstall(conf, plugin, \"1.0.0\", &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\t\twant := \"pre_asdf_uninstall_test 1.0.0\\npost_asdf_uninstall_test 1.0.0\\n\"\n\t\tassert.Equal(t, want, stdout.String())\n\t})\n\n\tt.Run(\"invokes uninstall callback when present\", func(t *testing.T) {\n\t\tstdout, stderr := buildOutputs()\n\t\terr = InstallOneVersion(conf, plugin, \"1.0.0\", false, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\tdata := []byte(\"echo custom uninstall\")\n\t\terr := os.WriteFile(filepath.Join(plugin.Dir, \"bin\", \"uninstall\"), data, 0o755)\n\t\tassert.Nil(t, err)\n\n\t\terr = Uninstall(conf, plugin, \"1.0.0\", &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\t\twant := \"pre_asdf_uninstall_test 1.0.0\\ncustom uninstall\\npost_asdf_uninstall_test 1.0.0\\n\"\n\t\tassert.Equal(t, want, stdout.String())\n\t})\n}\n\n// Helper functions\nfunc buildOutputs() (strings.Builder, strings.Builder) {\n\tvar stdout strings.Builder\n\tvar stderr strings.Builder\n\n\treturn stdout, stderr\n}\n\nfunc assertVersionInstalled(t *testing.T, dataDir, pluginName, version string) {\n\tt.Helper()\n\n\tinstallDir := filepath.Join(dataDir, \"installs\", pluginName, version)\n\tinstalledVersionFile := filepath.Join(installDir, \"version\")\n\n\tbytes, err := os.ReadFile(installedVersionFile)\n\tassert.Nil(t, err, \"expected file from install to exist\")\n\n\twant := fmt.Sprintf(\"%s\\n\", version)\n\tassert.Equal(t, want, string(bytes), \"got wrong version\")\n\n\tentries, err := os.ReadDir(installDir)\n\tassert.Nil(t, err)\n\n\tvar fileNames []string\n\tfor _, e := range entries {\n\t\tfileNames = append(fileNames, e.Name())\n\t}\n\n\tassert.Equal(t, fileNames, []string{\"bin\", \"env\", \"version\"})\n}\n\nfunc assertNotInstalled(t *testing.T, dataDir, pluginName, version string) {\n\tt.Helper()\n\n\tinstallPath := filepath.Join(dataDir, \"installs\", pluginName, version)\n\tentries, err := os.ReadDir(installPath)\n\tif err != nil && !os.IsNotExist(err) {\n\t\tt.Errorf(\"failed to check directory %s due to error %s\", installPath, err)\n\t}\n\tassert.Empty(t, entries)\n}\n\nfunc generateConfig(t *testing.T) (config.Config, plugins.Plugin) {\n\tt.Helper()\n\ttestDataDir := t.TempDir()\n\tconf, err := config.LoadConfig()\n\tassert.Nil(t, err)\n\tconf.DataDir = testDataDir\n\n\t_, err = repotest.InstallPlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\tassert.Nil(t, err)\n\n\treturn conf, plugins.New(conf, testPluginName)\n}\n\nfunc installPlugin(t *testing.T, conf config.Config, fixture, name string) plugins.Plugin {\n\t_, err := repotest.InstallPlugin(fixture, conf.DataDir, name)\n\tassert.Nil(t, err)\n\treturn plugins.New(conf, name)\n}\n\nfunc writeVersionFile(t *testing.T, dir, contents string) {\n\tt.Helper()\n\terr := os.WriteFile(filepath.Join(dir, \".tool-versions\"), []byte(contents), 0o666)\n\tassert.Nil(t, err)\n}\n"
