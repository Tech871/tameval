[meta]
task = "repair"
scenario = "repair_undefined_enitity"

[lang_info]
lang = "Go"
go_version = "1.23.0"

[repo_info]
repository = "synfinatic/aws-sso-cli"
sha = "7bd3daa96362d3ec107ffa9f1714f4808e089051"
bench_version = 1

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/ecs/client/client.go internal/ecs/client/client_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/ecs/client/client.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 92.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "internal/ecs/client/client_test.go"
focal_file_path = "internal/ecs/client/client.go"
test_file_url = "https://github.com/synfinatic/aws-sso-cli/blob/7bd3daa96362d3ec107ffa9f1714f4808e089051/internal/ecs/client/client_test.go"
focal_file_url = "https://github.com/synfinatic/aws-sso-cli/blob/7bd3daa96362d3ec107ffa9f1714f4808e089051/internal/ecs/client/client.go"
first_commit_date = "2023-08-24"
last_commit_date = "2025-01-23"
test_file_content = "package client\n\n/*\n * AWS SSO CLI\n * Copyright (c) 2021-2025 Aaron Turner  <synfinatic at gmail dot com>\n *\n * This program is free software: you can redistribute it\n * and/or modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or with the authors permission any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http:\n */\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/synfinatic/aws-sso-cli/internal/ecs\"\n\t\"github.com/synfinatic/aws-sso-cli/internal/storage\"\n)\n\nfunc TestCheckDoResponse(t *testing.T) {\n\tt.Parallel()\n\n\tresp := http.Response{\n\t\tStatusCode: http.StatusOK,\n\t\tStatus:     \"200 OK\",\n\t}\n\tassert.NoError(t, checkDoResponse(&resp))\n\n\tresp.StatusCode = http.StatusNotFound\n\tresp.Status = \"404 Not Found\"\n\tassert.Error(t, checkDoResponse(&resp))\n}\n\nfunc TestNewECSClient(t *testing.T) {\n\tt.Parallel()\n\n\tc := NewECSClient(\"localhost:4144\", \"token\", \"\")\n\tassert.NotNil(t, c)\n\tassert.Equal(t, \"localhost:4144\", c.server)\n\tassert.Equal(t, \"token\", c.authToken)\n\tassert.NotEmpty(t, c.loadUrl)\n\tassert.NotEmpty(t, c.loadSlotUrl)\n\tassert.NotEmpty(t, c.profileUrl)\n\tassert.NotEmpty(t, c.listUrl)\n\n\tcertChain, err := os.ReadFile(\"../server/testdata/localhost.crt\")\n\tassert.NoError(t, err)\n\tc = NewECSClient(\"localhost:4144\", \"token\", string(certChain))\n\tassert.NotNil(t, c)\n}\n\nfunc TestNewEcsClientFail(t *testing.T) {\n\tt.Parallel()\n\tassert.Panics(t, func() { NewECSClient(\"localhost:4144\", \"token\", \"foobar\") })\n\n\tassert.Panics(t, func() { NewECSClient(\"localhost\", \"token\", \"\") })\n\n\tassert.Panics(t, func() { NewECSClient(\"localhost:\", \"token\", \"\") })\n\n\tassert.Panics(t, func() { NewECSClient(\":4144\", \"token\", \"\") })\n\n\tassert.Panics(t, func() { NewECSClient(\"localhost:foo\", \"token\", \"\") })\n\n\tassert.Panics(t, func() { NewECSClient(\"localhost:0\", \"token\", \"\") })\n\n\tassert.Panics(t, func() { NewECSClient(\"localhost:65536\", \"token\", \"\") })\n}\n\nfunc TestECSClientLoadUrl(t *testing.T) {\n\tt.Parallel()\n\n\tc := NewECSClient(\"localhost:4144\", \"token\", \"\")\n\tassert.NotNil(t, c)\n\tassert.Equal(t, \"http:\n\n\turl := c.LoadUrl(\"myprofile\")\n\tassert.Equal(t, \"http:\n}\n\nfunc TestECSClientProfileUrl(t *testing.T) {\n\tt.Parallel()\n\n\tc := NewECSClient(\"localhost:4144\", \"token\", \"\")\n\tassert.NotNil(t, c)\n\tassert.Equal(t, \"http:\n}\n\nfunc TestECSClientListUrl(t *testing.T) {\n\tt.Parallel()\n\n\tc := NewECSClient(\"localhost:4144\", \"token\", \"\")\n\tassert.NotNil(t, c)\n\tassert.Equal(t, \"http:\n}\n\nfunc TestECSClientNewRequest(t *testing.T) {\n\tt.Parallel()\n\n\tc := NewECSClient(\"localhost:4144\", \"token\", \"\")\n\tassert.NotNil(t, c)\n\n\treq, err := c.newRequest(http.MethodGet, \"http:\n\tassert.NoError(t, err)\n\tassert.NotNil(t, req)\n\tassert.Equal(t, \"http:\n\tassert.Equal(t, \"Bearer token\", req.Header.Get(\"Authorization\"))\n\tassert.Equal(t, \"application/json; charset=utf-8\", req.Header.Get(\"Content-Type\"))\n\n\tc = NewECSClient(\"localhost:4144\", \"\", \"\")\n\treq, err = c.newRequest(http.MethodGet, \"http:\n\tassert.NoError(t, err)\n\tassert.NotNil(t, req)\n\tassert.Equal(t, \"http:\n\tassert.Equal(t, \"\", req.Header.Get(\"Authorization\"))\n\tassert.Equal(t, \"application/json; charset=utf-8\", req.Header.Get(\"Content-Type\"))\n\n\t_, err = c.newRequest(\"-55 foobar\", \"udp:adsf\", nil)\n\tassert.Error(t, err)\n}\n\nfunc TestECSClientSubmitCredsPass(t *testing.T) {\n\tt.Parallel()\n\tts := httptest.NewServer(\n\t\thttp.HandlerFunc(\n\t\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t\tfmt.Fprintln(w, \"{\\\"code\\\": 200, \\\"message\\\": \\\"OK\\\"}\")\n\t\t\t},\n\t\t),\n\t)\n\tdefer ts.Close()\n\n\tc := NewECSClient(\"localhost:4144\", \"\", \"\")\n\tc.loadUrl = ts.URL\n\tc.loadSlotUrl = ts.URL\n\tassert.NotNil(t, c)\n\n\tcreds := storage.RoleCredentials{\n\t\tRoleName:        \"role\",\n\t\tAccountId:       123456,\n\t\tAccessKeyId:     \"accesskey\",\n\t\tSecretAccessKey: \"secretkey\",\n\t\tSessionToken:    \"sessiontoken\",\n\t\tExpiration:      1234567890,\n\t}\n\n\terr := c.SubmitCreds(&creds, \"myprofile\", false)\n\tassert.NoError(t, err)\n\n\tcreds.RoleName = \"role2\"\n\terr = c.SubmitCreds(&creds, \"myotherprofile\", true)\n\tassert.NoError(t, err)\n\n\tc.loadUrl = \"http:\n\terr = c.SubmitCreds(&creds, \"myprofile\", false)\n\tassert.Error(t, err)\n\n\tc.loadSlotUrl = \"http:\n\terr = c.SubmitCreds(&creds, \"myprofile\", true)\n\tassert.Error(t, err)\n}\n\nfunc TestECSClientSubmitCredsFail(t *testing.T) {\n\tt.Parallel()\n\tts := httptest.NewServer(\n\t\thttp.HandlerFunc(\n\t\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t\t\tfmt.Fprintln(w, \"{\\\"code\\\": 404, \\\"message\\\": \\\"404 Error\\\"}\")\n\t\t\t},\n\t\t),\n\t)\n\tdefer ts.Close()\n\n\tc := NewECSClient(\"localhost:4144\", \"token\", \"\")\n\tc.loadUrl = ts.URL\n\tassert.NotNil(t, c)\n\n\tcreds := &storage.RoleCredentials{\n\t\tRoleName:        \"role\",\n\t\tAccountId:       123456,\n\t\tAccessKeyId:     \"accesskey\",\n\t\tSecretAccessKey: \"secretkey\",\n\t\tSessionToken:    \"sessiontoken\",\n\t\tExpiration:      1234567890,\n\t}\n\n\terr := c.SubmitCreds(creds, \"myprofile\", false)\n\tassert.Error(t, err)\n}\n\nfunc TestECSGetProfile(t *testing.T) {\n\tt.Parallel()\n\n\tlpr := ecs.ListProfilesResponse{\n\t\tProfileName:  \"myprofile\",\n\t\tAccountIdPad: \"123456\",\n\t\tRoleName:     \"role\",\n\t\tExpiration:   1234567890,\n\t\tExpires:      \"1h 23m 45s\",\n\t}\n\tts := httptest.NewServer(\n\t\thttp.HandlerFunc(\n\t\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tecs.WriteListProfileResponse(w, lpr)\n\t\t\t},\n\t\t),\n\t)\n\tdefer ts.Close()\n\n\tc := NewECSClient(\"localhost:4144\", \"token\", \"\")\n\tassert.NotNil(t, c)\n\tc.profileUrl = ts.URL\n\n\tlprResp, err := c.GetProfile()\n\tassert.NoError(t, err)\n\tassert.Equal(t, lpr, lprResp)\n\n\tc.profileUrl = \"http\n\t_, err = c.GetProfile()\n\tassert.Error(t, err)\n\n\tts2 := httptest.NewServer(\n\t\thttp.HandlerFunc(\n\t\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tfmt.Fprintln(w, \"bad json\")\n\t\t\t},\n\t\t),\n\t)\n\tdefer ts2.Close()\n\n\tc.profileUrl = ts2.URL\n\t_, err = c.GetProfile()\n\tassert.Error(t, err)\n}\n\nfunc TestECSAuthFailures(t *testing.T) {\n\tt.Parallel()\n\tts := httptest.NewServer(\n\t\thttp.HandlerFunc(\n\t\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tecs.WriteMessage(w, \"Invalid authorization token\", http.StatusForbidden)\n\t\t\t},\n\t\t),\n\t)\n\tdefer ts.Close()\n\n\tc := NewECSClient(\"localhost:4144\", \"token\", \"\")\n\tassert.NotNil(t, c)\n\tc.profileUrl = ts.URL\n\n\t_, err := c.GetProfile()\n\tassert.Error(t, err)\n\n\t_, err = c.ListProfiles()\n\tassert.Error(t, err)\n\terr = c.DeleteProfile(\"myprofile\")\n\tassert.Error(t, err)\n}\n\nfunc TestECSListProfiles(t *testing.T) {\n\tt.Parallel()\n\n\tlpr := []ecs.ListProfilesResponse{\n\t\t{\n\t\t\tProfileName:  \"myprofile\",\n\t\t\tAccountIdPad: \"000001234567\",\n\t\t\tRoleName:     \"role\",\n\t\t\tExpiration:   1234567890,\n\t\t\tExpires:      \"1h 23m 45s\",\n\t\t},\n\t\t{\n\t\t\tProfileName:  \"myotherprofile\",\n\t\t\tAccountIdPad: \"000001234567\",\n\t\t\tRoleName:     \"role2\",\n\t\t\tExpiration:   1234567890,\n\t\t\tExpires:      \"1h 23m 45s\",\n\t\t},\n\t}\n\tts := httptest.NewServer(\n\t\thttp.HandlerFunc(\n\t\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tecs.WriteListProfilesResponse(w, lpr)\n\t\t\t},\n\t\t),\n\t)\n\tdefer ts.Close()\n\n\tc := NewECSClient(\"localhost:4144\", \"token\", \"\")\n\tc.listUrl = ts.URL\n\tassert.NotNil(t, c)\n\n\tlprResp, err := c.ListProfiles()\n\tassert.NoError(t, err)\n\tassert.Equal(t, lpr, lprResp)\n\tassert.Equal(t, \"myprofile\", lprResp[0].ProfileNme)\n\n\tc.listUrl = \"http:\n\t_, err = c.ListProfiles()\n\tassert.Error(t, err)\n\tts2 := httptest.NewServer(\n\t\thttp.HandlerFunc(\n\t\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tecs.WriteMessage(w, \"Invalid authorization token\", http.StatusForbidden)\n\t\t\t},\n\t\t),\n\t)\n\tdefer ts2.Close()\n\tc.listUrl = ts2.URL\n\t_, err = c.ListProfiles()\n\tassert.Error(t, err)\n}\n\nfunc TestECSDelete(t *testing.T) {\n\tt.Parallel()\n\tts := httptest.NewServer(\n\t\thttp.HandlerFunc(\n\t\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tecs.OK(w)\n\t\t\t},\n\t\t),\n\t)\n\tdefer ts.Close()\n\n\tc := NewECSClient(\"localhost:4144\", \"token\", \"\")\n\tc.loadUrl = ts.URL\n\tc.loadSlotUrl = ts.URL\n\tassert.NotNil(t, c)\n\n\terr := c.Delete(\"myprofile\")\n\tassert.NoError(t, err)\n\tc.RemoveSlot(\"myprofile\")\n\n\tc.loadUrl = \"http:\n\tc.loadSlotUrl = \"http:\n\terr = c.Delete(\"foo\")\n\tassert.Error(t, err)\n}\n\nfunc TestNewHTTPClient(t *testing.T) {\n\tt.Parallel()\n\n\tcert, err := os.ReadFile(\"../server/testdata/localhost.crt\")\n\tassert.NoError(t, err)\n\n\tc, err := NewHTTPClient(string(cert))\n\tassert.NoError(t, err)\n\tassert.NotNil(t, c)\n\tassert.Equal(t, \"TLS\", c.securityProtocol)\n\n\t_, err = NewHTTPClient(\"foobar\")\n\tassert.Error(t, err)\n}"
