[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "notaryproject/ratify"
sha = "67aa7a4993f915deac10ae371cdafb67a4bf697c"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/store/credentialprovider/credmanager.go internal/store/credentialprovider/credmanager_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/store/credentialprovider/credmanager.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 32.0
original_coverage = 100.0
mutation_kill_rate = 20.0
original_mutation_kill_rate = 100.0
covered_lines = [ 35, 42, 43, 44, 48, 53, 57, 61, 69, 73,]
missed_lines = [ 36, 37, 39, 40, 45, 46, 54, 55, 56, 58, 59, 60, 62, 63, 64, 65, 66, 67, 70, 71, 72,]

[input_info]
test_file_path = "internal/store/credentialprovider/credmanager_test.go"
focal_file_path = "internal/store/credentialprovider/credmanager.go"
test_file_url = "https://github.com/notaryproject/ratify/blob/67aa7a4993f915deac10ae371cdafb67a4bf697c/internal/store/credentialprovider/credmanager_test.go"
focal_file_url = "https://github.com/notaryproject/ratify/blob/67aa7a4993f915deac10ae371cdafb67a4bf697c/internal/store/credentialprovider/credmanager.go"
first_commit_date = "2025-07-02"
last_commit_date = "2025-07-02"
test_file_content = "/*\nCopyright The Ratify Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage credentialprovider\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/notaryproject/ratify-go\"\n)\n\n// mockCredentialProvider is a mock implementation of ratify.RegistryCredentialGetter for testing\ntype mockCredentialProvider struct {\n\tusername string\n\tpassword string\n\terr      error\n}\n\nfunc (m *mockCredentialProvider) Get(_ context.Context, _ string) (ratify.RegistryCredential, error) {\n\tif m.err != nil {\n\t\treturn ratify.RegistryCredential{}, m.err\n\t}\n\treturn ratify.RegistryCredential{\n\t\tUsername: m.username,\n\t\tPassword: m.password,\n\t}, nil\n}\n\n// mockCredentialProviderFactory creates a mock credential provider\nfunc mockCredentialProviderFactory(opts Options) (ratify.RegistryCredentialGetter, error) {\n\tusername, _ := opts[\"username\"].(string)\n\tpassword, _ := opts[\"password\"].(string)\n\tshouldError, _ := opts[\"error\"].(bool)\n\n\tprovider := &mockCredentialProvider{\n\t\tusername: username,\n\t\tpassword: password,\n\t}\n\n\tif shouldError {\n\t\tprovider.err = fmt.Errorf(\"mock error\")\n\t}\n\n\treturn provider, nil\n}\n\n// mockFailingCredentialProviderFactory creates a factory that always fails\nfunc mockFailingCredentialProviderFactory(_ Options) (ratify.RegistryCredentialGetter, error) {\n\treturn nil, fmt.Errorf(\"factory creation failed\")\n}\n\n// resetRegisteredProviders clears the registered providers map for testing\nfunc resetRegisteredProviders() {\n\tregisteredProviders = nil\n}\n\n\n\n\n\nfunc TestNewCredentialProvider_ProviderError(t *testing.T) {\n\t// Test that errors from the provider are properly handled\n\tresetRegisteredProviders()\n\tRegisterCredentialProviderFactory(\"error-provider\", mockCredentialProviderFactory)\n\n\topts := Options{\n\t\t\"provider\": \"error-provider\",\n\t\t\"error\":    true, // This will cause the mock provider to return an error\n\t}\n\n\tprovider, err := NewCredentialProvider(opts)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error creating provider: %v\", err)\n\t}\n\n\t// Test that the provider returns the expected error\n\tctx := context.Background()\n\t_, err = provider.Get(ctx, \"registry.example.com\")\n\tif err == nil {\n\t\tt.Errorf(\"expected error from provider but got none\")\n\t} else if err.Error() != \"mock error\" {\n\t\tt.Errorf(\"expected error message %q, got %q\", \"mock error\", err.Error())\n\t}\n}\n\n// Benchmark tests to ensure performance\nfunc BenchmarkRegisterCredentialProviderFactory(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tresetRegisteredProviders()\n\t\tRegisterCredentialProviderFactory(\"test-provider\", mockCredentialProviderFactory)\n\t}\n}\n\nfunc BenchmarkNewCredentialProvider(b *testing.B) {\n\tresetRegisteredProviders()\n\tRegisterCredentialProviderFactory(\"test-provider\", mockCredentialProviderFactory)\n\n\topts := Options{\n\t\t\"provider\": \"test-provider\",\n\t\t\"username\": \"testuser\",\n\t\t\"password\": \"testpass\",\n\t}\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := NewCredentialProvider(opts)\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\t}\n}\n\n// Test concurrent access to ensure thread safety\nfunc TestConcurrentRegistration(t *testing.T) {\n\tresetRegisteredProviders()\n\n\tdone := make(chan bool, 2)\n\n\t// Register different providers concurrently\n\tgo func() {\n\t\tdefer func() {\n\t\t\tdone <- true\n\t\t}()\n\t\tRegisterCredentialProviderFactory(\"provider1\", mockCredentialProviderFactory)\n\t}()\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tdone <- true\n\t\t}()\n\t\tRegisterCredentialProviderFactory(\"provider2\", mockCredentialProviderFactory)\n\t}()\n\n\t// Wait for both goroutines to complete\n\t<-done\n\t<-done\n\n\t// Verify that at least some providers were registered\n\tif registeredProviders == nil {\n\t\tt.Errorf(\"registeredProviders should not be nil after concurrent registration\")\n\t}\n}\n"
