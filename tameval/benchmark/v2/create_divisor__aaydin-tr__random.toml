[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.22"

[repo_info]
repository = "aaydin-tr/divisor"
sha = "be1010bf44bd1fcf47537b6a7423b664e5016985"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out core/random/random.go core/random/random_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting core/random/random.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 94.0
original_coverage = 94.0
mutation_kill_rate = 66.0
original_mutation_kill_rate = 66.0
covered_lines = [ 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 48, 49, 52, 53, 54, 56, 57, 58, 61, 62, 63, 64, 67, 68, 69, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 98, 99, 100, 101, 102, 103, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 121, 124, 125, 126, 127, 128, 131, 132, 136, 142, 143,]
missed_lines = [ 129, 130, 137, 138, 139,]

[input_info]
test_file_path = "core/random/random_test.go"
focal_file_path = "core/random/random.go"
test_file_url = "https://github.com/aaydin-tr/divisor/blob/be1010bf44bd1fcf47537b6a7423b664e5016985/core/random/random_test.go"
focal_file_url = "https://github.com/aaydin-tr/divisor/blob/be1010bf44bd1fcf47537b6a7423b664e5016985/core/random/random.go"
first_commit_date = "2022-11-20"
last_commit_date = "2025-06-08"
test_file_content = "package random\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aaydin-tr/divisor/mocks\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/valyala/fasthttp\"\n)\n\nfunc TestNewRandom(t *testing.T) {\n\tfor _, rand := range mocks.TestCases {\n\t\tif rand.ExpectedServerCount == 0 {\n\t\t\trandom := NewRandom(&rand.Config, rand.ProxyFunc)\n\t\t\tassert.Nil(t, random)\n\t\t} else {\n\t\t\trandom := NewRandom(&rand.Config, rand.ProxyFunc).(*Random)\n\t\t\tassert.Equal(t, rand.ExpectedServerCount, len(random.serversMap))\n\t\t}\n\t}\n}\n\nfunc TestNext(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tbalancer := NewRandom(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\trandom := balancer.(*Random)\n\tproxy := random.next()\n\n\tassert.IsType(t, &mocks.MockProxy{}, proxy)\n}\n\nfunc TestServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[1]\n\tbalancer := NewRandom(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\trandom := balancer.(*Random)\n\thandlerFunc := random.Serve()\n\n\tctx := fasthttp.RequestCtx{\n\t\tRequest: *fasthttp.AcquireRequest(),\n\t}\n\tproxy := random.next().(*mocks.MockProxy)\n\tassert.False(t, proxy.IsCalled, \"expected Server func not be called, but it was called\")\n\thandlerFunc(&ctx)\n\tassert.True(t, proxy.IsCalled, \"expected Server func to be called, but it wasn't\")\n}\n\nfunc TestStats(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tbalancer := NewRandom(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\trandom := balancer.(*Random)\n\tstats := random.Stats()\n\n\tfor i, backend := range caseOne.Config.Backends {\n\t\thash := random.hashFunc([]byte(backend.Url + strconv.Itoa(i)))\n\t\ts := random.serversMap[hash]\n\n\t\tassert.Equal(t, s.isHostAlive, stats[i].IsHostAlive)\n\t\tassert.Equal(t, hash, stats[i].BackendHash)\n\t}\n}\n\nfunc TestHealthChecker(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\trandom := &Random{stopHealthChecker: make(chan bool)}\n\n\trandom.isHostAlive = func(s string) bool {\n\t\tgo func() {\n\t\t\trandom.stopHealthChecker <- true\n\t\t}()\n\t\treturn false\n\t}\n\trandom.hashFunc = func(b []byte) uint32 {\n\t\treturn 0\n\t}\n\n\tcaseOne.Config.HealthCheckerTime = 1\n\trandom.healthChecker(caseOne.Config.Backends)\n}\n\nfunc TestRemoveOneServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\trandom := NewRandom(&caseOne.Config, caseOne.ProxyFunc).(*Random)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(random.serversMap))\n\n\t// Remove one server\n\tbackend := caseOne.Config.Backends[0]\n\tif b, ok := random.serversMap[random.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\trandom.isHostAlive = func(s string) bool {\n\t\t\treturn false\n\t\t}\n\t\toldServerCount := random.len\n\t\trandom.healthCheck(backend, 0)\n\n\t\tassert.False(t, b.isHostAlive, \"expected isHostAlive equal to false, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, oldServerCount, random.len, \"expected server to be removed after health check, but it did not.\")\n\t}\n\n}\n\nfunc TestRemoveAndAddServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\trandom := NewRandom(&caseOne.Config, caseOne.ProxyFunc).(*Random)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(random.serversMap))\n\n\t// Remove one server\n\tbackend := caseOne.Config.Backends[0]\n\tif b, ok := random.serversMap[random.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\trandom.isHostAlive = func(s string) bool {\n\t\t\treturn false\n\t\t}\n\t\toldServerCount := random.len\n\t\trandom.healthCheck(backend, 0)\n\n\t\tassert.False(t, b.isHostAlive, \"expected isHostAlive equal to false, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, oldServerCount, random.len, \"expected server to be removed after health check, but it did not.\")\n\t}\n\n\t// Add one server\n\tif b, ok := random.serversMap[random.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\tb.isHostAlive = false\n\t\trandom.isHostAlive = func(s string) bool {\n\t\t\treturn true\n\t\t}\n\n\t\toldServerCount := random.len\n\t\trandom.healthCheck(backend, 0)\n\n\t\tassert.True(t, b.isHostAlive, \"expected isHostAlive equal to true, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, random.len, oldServerCount, \"expected server to be added after health check, but it did not.\")\n\n\t}\n}\n\nfunc TestRemmoveAllServers(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\trandom := NewRandom(&caseOne.Config, caseOne.ProxyFunc).(*Random)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(random.serversMap))\n\n\t// Remove All\n\tfor i, backend := range caseOne.Config.Backends {\n\t\tif _, ok := random.serversMap[random.hashFunc([]byte(backend.Url+strconv.Itoa(i)))]; ok {\n\t\t\trandom.isHostAlive = func(s string) bool {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\toldServerCount := random.len\n\t\t\tif oldServerCount == 1 {\n\t\t\t\tassert.Panics(t, func() {\n\t\t\t\t\trandom.healthCheck(backend, i)\n\t\t\t\t}, \"expected panic after remove all servers\")\n\n\t\t\t} else {\n\t\t\t\trandom.healthCheck(backend, i)\n\t\t\t\tassert.GreaterOrEqual(t, oldServerCount, random.len, \"expected server to be removed after health check, but it did not.\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShutdown(t *testing.T) {\n\tt.Run(\"shutdown calls close on all proxies\", func(t *testing.T) {\n\t\tcaseOne := mocks.TestCases[0]\n\t\trandom := NewRandom(&caseOne.Config, caseOne.ProxyFunc).(*Random)\n\t\tassert.NotNil(t, random)\n\n\t\t// Verify proxy Close() methods are not called yet\n\t\tfor _, sm := range random.serversMap {\n\t\t\tmockProxy := sm.proxy.(*mocks.MockProxy)\n\t\t\tassert.False(t, mockProxy.CloseCalled, \"Proxy Close() should not be called before shutdown\")\n\t\t}\n\n\t\t// Call shutdown\n\t\terr := random.Shutdown()\n\t\tassert.NoError(t, err, \"Shutdown() should not return an error\")\n\n\t\t// Verify that Close() was called on all proxy clients\n\t\tfor _, sm := range random.serversMap {\n\t\t\tmockProxy := sm.proxy.(*mocks.MockProxy)\n\t\t\tassert.True(t, mockProxy.CloseCalled, \"Proxy Close() should be called during shutdown\")\n\t\t}\n\t})\n\n\tt.Run(\"shutdown with no servers\", func(t *testing.T) {\n\t\temptyCase := mocks.TestCases[3] // Case with 0 servers\n\t\temptyRandom := NewRandom(&emptyCase.Config, emptyCase.ProxyFunc)\n\t\tif emptyRandom != nil {\n\t\t\terr := emptyRandom.Shutdown()\n\t\t\tassert.NoError(t, err, \"Shutdown() should not return an error even with no servers\")\n\t\t}\n\t})\n\n\tt.Run(\"shutdown with actual health checker goroutine\", func(t *testing.T) {\n\t\tcaseOne := mocks.TestCases[0]\n\t\tcaseOne.Config.HealthCheckerTime = 100 * time.Millisecond // Fast health check for testing\n\t\trandom := NewRandom(&caseOne.Config, caseOne.ProxyFunc).(*Random)\n\t\tassert.NotNil(t, random)\n\n\t\t// Give health checker time to start\n\t\ttime.Sleep(50 * time.Millisecond)\n\n\t\t// Call shutdown - this should stop the health checker goroutine\n\t\terr := random.Shutdown()\n\t\tassert.NoError(t, err, \"Shutdown() should not return an error\")\n\n\t\t// Verify that Close() was called on all proxy clients\n\t\tfor _, sm := range random.serversMap {\n\t\t\tmockProxy := sm.proxy.(*mocks.MockProxy)\n\t\t\tassert.True(t, mockProxy.CloseCalled, \"Proxy Close() should be called during shutdown\")\n\t\t}\n\n\t\t// Give some time for health checker to actually stop\n\t\ttime.Sleep(150 * time.Millisecond)\n\t})\n}\n"
