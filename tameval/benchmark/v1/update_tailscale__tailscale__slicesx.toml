[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "tailscale/tailscale"
sha = "6bbf98bef457b4403f27da79eb1861e6197ab539"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out util/slicesx/slicesx.go util/slicesx/slicesx_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting util/slicesx/slicesx.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 77.0
original_coverage = 84.0
mutation_kill_rate = 66.0
original_mutation_kill_rate = 68.0
covered_lines = [ 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 32, 33, 34, 35, 36, 37, 42, 43, 44, 45, 52, 53, 54, 55, 56, 57, 58, 60, 71, 72, 73, 74, 75, 76, 77, 78, 80, 88, 89, 90, 91, 92, 94, 109, 110, 111, 112, 113, 115, 119, 120, 121, 124, 125, 126, 132, 133, 134, 135, 136, 143, 144, 145, 146, 147, 152, 153, 154, 158, 159, 160,]
missed_lines = [ 38, 39, 40, 41, 98, 99, 100, 101, 102, 103, 105, 174, 175, 176, 177, 178, 179, 194, 195, 196, 197, 198, 199,]

[input_info]
test_file_path = "util/slicesx/slicesx_test.go"
focal_file_path = "util/slicesx/slicesx.go"
test_file_url = "https://github.com/tailscale/tailscale/blob/6bbf98bef457b4403f27da79eb1861e6197ab539/util/slicesx/slicesx_test.go"
focal_file_url = "https://github.com/tailscale/tailscale/blob/6bbf98bef457b4403f27da79eb1861e6197ab539/util/slicesx/slicesx.go"
first_commit_date = "2023-03-03"
last_commit_date = "2025-01-22"
test_file_content = "// Copyright (c) Tailscale Inc & AUTHORS\n// SPDX-License-Identifier: BSD-3-Clause\n\npackage slicesx\n\nimport (\n\t\"reflect\"\n\t\"slices\"\n\t\"testing\"\n\n\tqt \"github.com/frankban/quicktest\"\n)\n\nfunc TestInterleave(t *testing.T) {\n\ttestCases := []struct {\n\t\tname string\n\t\ta, b []int\n\t\twant []int\n\t}{\n\t\t{name: \"equal\", a: []int{1, 3, 5}, b: []int{2, 4, 6}, want: []int{1, 2, 3, 4, 5, 6}},\n\t\t{name: \"short_b\", a: []int{1, 3, 5}, b: []int{2, 4}, want: []int{1, 2, 3, 4, 5}},\n\t\t{name: \"short_a\", a: []int{1, 3}, b: []int{2, 4, 6}, want: []int{1, 2, 3, 4, 6}},\n\t\t{name: \"len_1\", a: []int{1}, b: []int{2, 4, 6}, want: []int{1, 2, 4, 6}},\n\t\t{name: \"nil_a\", a: nil, b: []int{2, 4, 6}, want: []int{2, 4, 6}},\n\t\t{name: \"nil_all\", a: nil, b: nil, want: nil},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tmerged := Interleave(tc.a, tc.b)\n\t\t\tif !reflect.DeepEqual(merged, tc.want) {\n\t\t\t\tt.Errorf(\"got %v; want %v\", merged, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkInterleave(b *testing.B) {\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor range b.N {\n\t\tInterleave(\n\t\t\t[]int{1, 2, 3},\n\t\t\t[]int{9, 8, 7},\n\t\t)\n\t}\n}\n\nfunc TestShuffle(t *testing.T) {\n\tvar sl []int\n\tfor i := range 100 {\n\t\tsl = append(sl, i)\n\t}\n\n\tvar wasShuffled bool\n\tfor try := 0; try < 10; try++ {\n\t\tshuffled := slices.Clone(sl)\n\t\tShuffle(shuffled)\n\t\tif !reflect.DeepEqual(shuffled, sl) {\n\t\t\twasShuffled = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !wasShuffled {\n\t\tt.Errorf(\"expected shuffle after 10 tries\")\n\t}\n}\n\nfunc TestPartition(t *testing.T) {\n\tvar sl []int\n\tfor i := 1; i <= 10; i++ {\n\t\tsl = append(sl, i)\n\t}\n\n\tevens, odds := Partition(sl, func(elem int) bool {\n\t\treturn elem%2 == 0\n\t})\n\n\twantEvens := []int{2, 4, 6, 8, 10}\n\twantOdds := []int{1, 3, 5, 7, 9}\n\tif !reflect.DeepEqual(evens, wantEvens) {\n\t\tt.Errorf(\"evens: got %v, want %v\", evens, wantEvens)\n\t}\n\tif !reflect.DeepEqual(odds, wantOdds) {\n\t\tt.Errorf(\"odds: got %v, want %v\", odds, wantOdds)\n\t}\n}\n\nfunc TestEqualSameNil(t *testing.T) {\n\tc := qt.New(t)\n\tc.Check(EqualSameNil([]string{\"a\"}, []string{\"a\"}), qt.Equals, true)\n\tc.Check(EqualSameNil([]string{\"a\"}, []string{\"b\"}), qt.Equals, false)\n\tc.Check(EqualSameNil([]string{\"a\"}, []string{}), qt.Equals, false)\n\tc.Check(EqualSameNil([]string{}, []string{}), qt.Equals, true)\n\tc.Check(EqualSameNil(nil, []string{}), qt.Equals, false)\n\tc.Check(EqualSameNil([]string{}, nil), qt.Equals, false)\n\tc.Check(EqualSameNil[[]string](nil, nil), qt.Equals, true)\n}\n\nfunc TestFilter(t *testing.T) {\n\tvar sl []int\n\tfor i := 1; i <= 10; i++ {\n\t\tsl = append(sl, i)\n\t}\n\n\tevens := Filter(nil, sl, func(elem int) bool {\n\t\treturn elem%2 == 0\n\t})\n\n\twant := []int{2, 4, 6, 8, 10}\n\tif !reflect.DeepEqual(evens, want) {\n\t\tt.Errorf(\"evens: got %v, want %v\", evens, want)\n\t}\n}\n\nfunc TestFilterNoAllocations(t *testing.T) {\n\tvar sl []int\n\tfor i := 1; i <= 10; i++ {\n\t\tsl = append(sl, i)\n\t}\n\n\twant := []int{2, 4, 6, 8, 10}\n\tallocs := testing.AllocsPerRun(1000, func() {\n\t\tsrc := slices.Clone(sl)\n\t\tevens := Filter(src[:0], src, func(elem int) bool {\n\t\t\treturn elem%2 == 0\n\t\t})\n\t\tif !slices.Equal(evens, want) {\n\t\t\tt.Errorf(\"evens: got %v, want %v\", evens, want)\n\t\t}\n\t})\n\n\t// 1 alloc for 'src', nothing else\n\tif allocs != 1 {\n\t\tt.Fatalf(\"got %.4f allocs, want 1\", allocs)\n\t}\n}\n\nfunc TestAppendMatching(t *testing.T) {\n\tv := []string{\"one\", \"two\", \"three\", \"four\"}\n\tgot := AppendMatching(v[:0], v, func(s string) bool { return len(s) > 3 })\n\n\twant := []string{\"three\", \"four\"}\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"got %v; want %v\", got, want)\n\t}\n\n\twantOrigMem := []string{\"three\", \"four\", \"three\", \"four\"}\n\tif !reflect.DeepEqual(v, wantOrigMem) {\n\t\tt.Errorf(\"got %v; want %v\", v, wantOrigMem)\n\t}\n}\n\nfunc TestCutPrefix(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\ts, prefix []int\n\t\tafter     []int\n\t\tfound     bool\n\t}{\n\t\t{\"has-prefix\", []int{1, 2, 3}, []int{1}, []int{2, 3}, true},\n\t\t{\"exact-prefix\", []int{1, 2, 3}, []int{1, 2, 3}, []int{}, true},\n\t\t{\"blank-prefix\", []int{1, 2, 3}, []int{}, []int{1, 2, 3}, true},\n\t\t{\"no-prefix\", []int{1, 2, 3}, []int{42}, []int{1, 2, 3}, false},\n\t\t{\"blank-slice\", []int{}, []int{42}, []int{}, false},\n\t\t{\"blank-all\", []int{}, []int{}, []int{}, true},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif after, found := CutPrefix(tt.s, tt.prefix); !slices.Equal(after, tt.after) || found != tt.found {\n\t\t\t\tt.Errorf(\"CutPrefix(%v, %v) = %v, %v; want %v, %v\", tt.s, tt.prefix, after, found, tt.after, tt.found)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCutSuffix(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\ts, suffix []int\n\t\tbefore    []int\n\t\tfound     bool\n\t}{\n\t\t{\"has-suffix\", []int{1, 2, 3}, []int{3}, []int{1, 2}, true},\n\t\t{\"exact-suffix\", []int{1, 2, 3}, []int{1, 2, 3}, []int{}, true},\n\t\t{\"blank-suffix\", []int{1, 2, 3}, []int{}, []int{1, 2, 3}, true},\n\t\t{\"no-suffix\", []int{1, 2, 3}, []int{42}, []int{1, 2, 3}, false},\n\t\t{\"blank-slice\", []int{}, []int{42}, []int{}, false},\n\t\t{\"blank-all\", []int{}, []int{}, []int{}, true},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif before, found := CutSuffix(tt.s, tt.suffix); !slices.Equal(before, tt.before) || found != tt.found {\n\t\t\t\tt.Errorf(\"CutSuffix(%v, %v) = %v, %v; want %v, %v\", tt.s, tt.suffix, before, found, tt.before, tt.found)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFirstLastEqual(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\tin   string\n\t\tv    byte\n\t\tf    func([]byte, byte) bool\n\t\twant bool\n\t}{\n\t\t{\"first-empty\", \"\", 'f', FirstEqual[byte], false},\n\t\t{\"first-true\", \"foo\", 'f', FirstEqual[byte], true},\n\t\t{\"first-false\", \"foo\", 'b', FirstEqual[byte], false},\n\t\t{\"last-empty\", \"\", 'f', LastEqual[byte], false},\n\t\t{\"last-true\", \"bar\", 'r', LastEqual[byte], true},\n\t\t{\"last-false\", \"bar\", 'o', LastEqual[byte], false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.f([]byte(tt.in), tt.v); got != tt.want {\n\t\t\t\tt.Errorf(\"got %v; want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n\n}"
