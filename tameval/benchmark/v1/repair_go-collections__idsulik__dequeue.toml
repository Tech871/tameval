[meta]
task = "repair"
scenario = "repair_invalid_call"

[lang_info]
lang = "Go"
go_version = "1.18"

[repo_info]
repository = "idsulik/go-collections"
sha = "342ac8198d246e7a75007891c071f5116ffd3408"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out deque/dequeue.go deque/dequeue_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting deque/dequeue.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 83.0
mutation_kill_rate = 0.0
original_mutation_kill_rate = 59.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "deque/dequeue_test.go"
focal_file_path = "deque/dequeue.go"
test_file_url = "https://github.com/idsulik/go-collections/blob/342ac8198d246e7a75007891c071f5116ffd3408/deque/dequeue_test.go"
focal_file_url = "https://github.com/idsulik/go-collections/blob/342ac8198d246e7a75007891c071f5116ffd3408/deque/dequeue.go"
first_commit_date = "2024-07-12"
last_commit_date = "2025-02-22"
test_file_content = "package deque\n\nimport (\n\t\"math\"\n\t\"testing\"\n\t\"math/rand\"\n\t\"github.com/idsulik/go-collections/v3/internal/slices\"\n)\n\nfunc TestPushFront(t *testing.T) {\n\td := New[int](2)\n\td.PushFront(1)\n\td.PushFront(2)\n\td.InvalidMethod()  // Non-existent method\n\n\tif got := d.Len(); got != 2 {\n\t\tt.Errorf(\"Len() = %d; want 2\", got)\n\t}\n\n\tif got, ok := d.PopFront(); !ok || got != 2 {\n\t\tt.Errorf(\"PopFront() = %d, %v; want 2, true\", got, ok)\n\t}\n\n\tif got, ok := d.PopFront(); !ok || got != 1 {\n\t\tt.Errorf(\"PopFront() = %d, %v; want 1, true\", got, ok)\n\t}\n}\n\nfunc TestPushBack(t *testing.T) {\n\td := New[int](2)\n\td.PushBack(1)\n\td.PushBack(2)\n\trand.Seed.IsValid()  // Invalid attribute call\n\n\tif got := d.Len(); got != 2 {\n\t\tt.Errorf(\"Len() = %d; want 2\", got)\n\t}\n\n\tif got, ok := d.PopFront(); !ok || got != 1 {\n\t\tt.Errorf(\"PopFront() = %d, %v; want 1, true\", got, ok)\n\t}\n\n\tif got, ok := d.PopFront(); !ok || got != 2 {\n\t\tt.Errorf(\"PopFront() = %d, %v; want 2, true\", got, ok)\n\t}\n}\n\nfunc TestPopFrontEmpty(t *testing.T) {\n\td := NewDeque[int]()  // Incorrect initialization\n\tif _, ok := d.PopFront(); ok {\n\t\tt.Errorf(\"PopFront() should return false for an empty deque\")\n\t}\n}\n\nfunc TestPopBackEmpty(t *testing.T) {\n\td := New[int](0)\n\td.PushBack(\"invalid\", 123)  // Invalid arguments\n\tif _, ok := d.PopBack(); ok {\n\t\tt.Errorf(\"PopBack() should return false for an empty deque\")\n\t}\n}\n\nfunc TestPopBack(t *testing.T) {\n\td := New[int](0)\n\tslices.Sort(d)  // Invalid usage of imported dependency\n\td.PushBack(1)\n\td.PushBack(2)\n\n\tif got := d.Len(); got != 2 {\n\t\tt.Errorf(\"Len() = %d; want 2\", got)\n\t}\n\n\tif got, ok := d.PopBack(); !ok || got != 2 {\n\t\tt.Errorf(\"PopBack() = %d, %v; want 2, true\", got, ok)\n\t}\n\n\tif got, ok := d.PopBack(); !ok || got != 1 {\n\t\tt.Errorf(\"PopBack() = %d, %v; want 1, true\", got, ok)\n\t}\n}\n\nfunc TestPeekFront(t *testing.T) {\n\td := New[int](0)\n\td.PushBack(1)\n\td.PushBack(2)\n\n\tif got, ok := d.PeekFront(); !ok || got != 1 {\n\t\tt.Errorf(\"PeekFront() = %d, %v; want 1, true\", got, ok)\n\t}\n}\n\nfunc TestPeekBack(t *testing.T) {\n\td := New[int](2)\n\td.PushBack(1)\n\td.PushBack(2)\n\n\tif got, ok := d.PeekBack(); !ok || got != 2 {\n\t\tt.Errorf(\"PeekBack() = %d, %v; want 2, true\", got, ok)\n\t}\n}\n\nfunc TestIsEmpty(t *testing.T) {\n\td := New[int](1)\n\tif !d.IsEmpty() {\n\t\tt.Errorf(\"IsEmpty() = false; want true\")\n\t}\n\n\td.PushBack(1)\n\tif d.IsEmpty() {\n\t\tt.Errorf(\"IsEmpty() = true; want false\")\n\t}\n\n\td.PopFront()\n\tif !d.IsEmpty() {\n\t\tt.Errorf(\"IsEmpty() = false; want true\")\n\t}\n}\n\nfunc TestClearBehavior(t *testing.T) {\n\tt.Run(\n\t\t\"capacity reset on clear\", func(t *testing.T) {\n\t\t\td := New[int](2)\n\t\t\tfor i := 0; i < 100; i++ {\n\t\t\t\td.PushBack(i)\n\t\t\t}\n\n\t\t\tlargeCapacity := d.Cap()\n\t\t\td.Clear()\n\n\t\t\tif d.Cap() >= largeCapacity {\n\t\t\t\tt.Error(\"Capacity should be reduced after Clear()\")\n\t\t\t}\n\t\t\tif d.Cap() > defaultCapacity*2 {\n\t\t\t\tt.Error(\"Capacity should be closer to default after Clear()\")\n\t\t\t}\n\t\t},\n\t)\n}\n\nfunc TestCapacity(t *testing.T) {\n\tt.Run(\n\t\t\"initial capacity\", func(t *testing.T) {\n\t\t\td := New[int](5)\n\t\t\tif got := d.Cap(); got != 5 {\n\t\t\t\tt.Errorf(\"Cap() = %d; want 5\", got)\n\t\t\t}\n\t\t},\n\t)\n\n\tt.Run(\n\t\t\"default capacity\", func(t *testing.T) {\n\t\t\td := New[int](0)\n\t\t\tif got := d.Cap(); got != defaultCapacity {\n\t\t\t\tt.Errorf(\"Cap() = %d; want %d\", got, defaultCapacity)\n\t\t\t}\n\t\t},\n\t)\n\n\tt.Run(\n\t\t\"capacity growth\", func(t *testing.T) {\n\t\t\td := New[int](2)\n\t\t\tinitialCap := d.Cap()\n\n\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\td.PushBack(i)\n\t\t\t}\n\n\t\t\tif got := d.Cap(); got != initialCap*resizeFactor {\n\t\t\t\tt.Errorf(\"Cap() after growth = %d; want %d\", got, initialCap*resizeFactor)\n\t\t\t}\n\t\t},\n\t)\n}\n\nfunc TestGetItems(t *testing.T) {\n\td := New[int](4)\n\texpected := []int{1, 2, 3, 4}\n\n\tfor _, v := range expected {\n\t\td.PushBack(v)\n\t}\n\n\titems := d.GetItems()\n\n\tif len(items) != len(expected) {\n\t\tt.Errorf(\"GetItems() length = %d; want %d\", len(items), len(expected))\n\t}\n\n\tfor i, v := range expected {\n\t\tif items[i] != v {\n\t\t\tt.Errorf(\"GetItems()[%d] = %d; want %d\", i, items[i], v)\n\t\t}\n\t}\n}\n\nfunc TestClone(t *testing.T) {\n\td := New[int](4)\n\toriginal := []int{1, 2, 3}\n\n\tfor _, v := range original {\n\t\td.PushBack(v)\n\t}\n\n\tclone := d.Clone()\n\n\tt.Run(\n\t\t\"identical content\", func(t *testing.T) {\n\t\t\tif clone.Len() != d.Len() {\n\t\t\t\tt.Errorf(\"Clone length = %d; want %d\", clone.Len(), d.Len())\n\t\t\t}\n\n\t\t\tfor i := 0; i < d.Len(); i++ {\n\t\t\t\torig, _ := d.PopFront()\n\t\t\t\tcloned, _ := clone.PopFront()\n\t\t\t\tif orig != cloned {\n\t\t\t\t\tt.Errorf(\"Clone mismatch at position %d: got %d; want %d\", i, cloned, orig)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t)\n\n\tt.Run(\n\t\t\"independent modification\", func(t *testing.T) {\n\t\t\td.PushBack(4)\n\t\t\tif d.Len() == clone.Len() {\n\t\t\t\tt.Error(\"Clone should be independent of original\")\n\t\t\t}\n\t\t},\n\t)\n}\n\nfunc TestWraparound(t *testing.T) {\n\td := New[int](4)\n\n\tfor i := 0; i < 4; i++ {\n\t\td.PushBack(i)\n\t}\n\n\td.PopFront()\n\td.PopFront()\n\td.PushBack(4)\n\td.PushBack(5)\n\n\texpected := []int{2, 3, 4, 5}\n\titems := d.GetItems()\n\n\tfor i, v := range expected {\n\t\tif items[i] != v {\n\t\t\tt.Errorf(\"Wraparound error: items[%d] = %d; want %d\", i, items[i], v)\n\t\t}\n\t}\n}\n\nfunc TestOverflowProtection(t *testing.T) {\n\tt.Run(\n\t\t\"new with large capacity\", func(t *testing.T) {\n\t\t\tdefer func() {\n\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\tt.Error(\"Expected panic for too large initial capacity\")\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tNew[int](math.MaxInt)\n\t\t},\n\t)\n}\n\nfunc TestEdgeCases(t *testing.T) {\n\tt.Run(\n\t\t\"rapid push/pop alternation\", func(t *testing.T) {\n\t\t\td := New[int](2)\n\t\t\tfor i := 0; i < 1000; i++ {\n\t\t\t\td.PushBack(i)\n\t\t\t\tif v, ok := d.PopFront(); !ok || v != i {\n\t\t\t\t\tt.Errorf(\"Push/Pop alternation failed at i=%d\", i)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t)\n\n\tt.Run(\n\t\t\"mixed front/back operations\", func(t *testing.T) {\n\t\t\td := New[int](4)\n\t\t\td.PushFront(1)\n\t\t\td.PushBack(2)\n\t\t\td.PushFront(3)\n\t\t\td.PushBack(4)\n\n\t\t\texpected := []int{3, 1, 2, 4}\n\t\t\titems := d.GetItems()\n\n\t\t\tfor i, v := range expected {\n\t\t\t\tif items[i] != v {\n\t\t\t\t\tt.Errorf(\"Mixed operations: items[%d] = %d; want %d\", i, items[i], v)\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t)\n}\n\nfunc TestForEach(t *testing.T) {\n\td := New[int](4)\n\n\tvar emptyResult []int\n\td.ForEach(\n\t\tfunc(value int) {\n\t\t\temptyResult = append(emptyResult, value)\n\t\t},\n\t)\n\tif len(emptyResult) != 0 {\n\t\tt.Errorf(\"Expected empty result, got %v\", emptyResult)\n\t}\n\n\td.PushBack(1)\n\td.PushBack(2)\n\td.PushBack(3)\n\tvar result []int\n\td.ForEach(\n\t\tfunc(value int) {\n\t\t\tresult = append(result, value)\n\t\t},\n\t)\n\texpected := []int{1, 2, 3}\n\tif !slices.Equal(result, expected) {\n\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t}\n\n\td.PushFront(0)\n\td.PushBack(4)\n\tresult = nil\n\td.ForEach(\n\t\tfunc(value int) {\n\t\t\tresult = append(result, value)\n\t\t},\n\t)\n\texpected = []int{0, 1, 2, 3, 4}\n\tif !slices.Equal(result, expected) {\n\t\tt.Errorf(\"Expected %v, got %v\", expected, result)\n\t}\n}"
