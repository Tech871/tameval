[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Java"
java_builder = "Maven"
is_multi_module = true

[repo_info]
repository = "dapr/java-sdk"
sha = "57f6b96d60aefd07b736d747995addf0e40b95d1"

[run_info]
docker_image = "maven:3.8.3-openjdk-17"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "mvn -Dmaven.repo.local=/.m2 -T 4 clean install"
test_run_command = "mvn clean -Dmaven.repo.local=/.m2 test -q -pl sdk-actors -Dtest=ActorRuntimeTest && mvn jacoco:report -Djacoco.append=false"
mutation_run_command = "mvn -Dmaven.repo.local=/.m2 org.pitest:pitest-maven:mutationCoverage -pl sdk-actors -DtargetClasses=**.ActorRuntime  -DtargetTests=**.ActorRuntimeTest  -DoutputFormats=XML"
coverage_report_path = "sdk-actors/target/jacoco-report/jacoco.xml"
coverage_report_type = "jacoco"
mutation_report_path = "sdk-actors/target/pit-reports/mutations.xml"
mutation_report_type = "pitest"

[coverage]
coverage = 58.0
original_coverage = 58.0
mutation_kill_rate = 0.0
original_mutation_kill_rate = 0.0
covered_lines = [ 38, 48, 110, 111, 115, 116, 117, 118, 119, 162, 172, 183, 184, 195, 196, 208, 209, 224, 225, 227, 228, 230, 231, 233, 234, 237, 240, 241, 248, 249, 251, 261, 262, 276, 277, 278, 279, 322, 324, 325, 326, 327, 330,]
missed_lines = [ 81, 82, 90, 91, 100, 101, 112, 127, 128, 129, 130, 132, 135, 145, 146, 147, 148, 150, 153, 292, 293, 294, 295, 308, 309, 310, 311, 341, 349, 350, 352,]

[input_info]
test_file_path = "sdk-actors/src/test/java/io/dapr/actors/runtime/ActorRuntimeTest.java"
focal_file_path = "sdk-actors/src/main/java/io/dapr/actors/runtime/ActorRuntime.java"
test_file_url = "https://github.com/dapr/java-sdk/blob/57f6b96d60aefd07b736d747995addf0e40b95d1/sdk-actors/src/test/java/io/dapr/actors/runtime/ActorRuntimeTest.java"
focal_file_url = "https://github.com/dapr/java-sdk/blob/57f6b96d60aefd07b736d747995addf0e40b95d1/sdk-actors/src/main/java/io/dapr/actors/runtime/ActorRuntime.java"
first_commit_date = "2020-01-24"
last_commit_date = "2025-03-01"
test_file_content = "/*\n * Copyright 2021 The Dapr Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage io.dapr.actors.runtime;\n\nimport io.dapr.actors.ActorId;\nimport io.dapr.actors.ActorType;\nimport io.dapr.serializer.DefaultObjectSerializer;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport reactor.core.publisher.Mono;\n\nimport java.lang.reflect.Constructor;\nimport java.time.Duration;\nimport java.util.Arrays;\nimport java.util.UUID;\n\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.mockito.Mockito.mock;\n\npublic class ActorRuntimeTest {\n\n  private static final String ACTOR_NAME = \"MyGreatActor\";\n\n  public interface MyActor {\n    String say();\n\n    int count();\n  }\n\n  @ActorType(name = ACTOR_NAME)\n  public static class MyActorImpl extends AbstractActor implements MyActor {\n\n    private int count = 0;\n\n    private Boolean activated;\n\n    public MyActorImpl(ActorRuntimeContext runtimeContext, ActorId id) {\n      super(runtimeContext, id);\n    }\n\n    public Mono<Void> onActivate() {\n      return Mono.fromRunnable(() -> {\n        if (this.activated != null) {\n          throw new IllegalStateException(\"already activated once\");\n        }\n\n        this.activated = true;\n      });\n    }\n\n    public Mono<Void> onDeactivate() {\n      return Mono.fromRunnable(() -> {\n        if (this.activated == null) {\n          throw new IllegalStateException(\"never activated\");\n        }\n\n        if (this.activated == false) {\n          throw new IllegalStateException(\"already deactivated\");\n        }\n\n        if (this.count == 0) {\n          throw new IllegalStateException(\"test expects a call before deactivate\");\n        }\n\n        this.activated = false;\n      });\n    }\n\n    public String say() {\n      if (!this.activated) {\n        throw new IllegalStateException(\"not activated\");\n      }\n\n      this.count++;\n      return \"Nothing to say.\";\n    }\n\n    public int count() {\n      return this.count;\n    }\n  }\n\n  private static final ActorObjectSerializer ACTOR_STATE_SERIALIZER = new ActorObjectSerializer();\n\n  private static Constructor<ActorRuntime> constructor;\n\n  private DaprClient mockDaprClient;\n\n  private ActorRuntime runtime;\n\n  @BeforeAll\n  public static void beforeAll() throws Exception {\n    constructor =\n            (Constructor<ActorRuntime>) Arrays.stream(ActorRuntime.class.getDeclaredConstructors())\n                    .filter(c -> c.getParameters().length == 2).map(c -> {\n                      c.setAccessible(true);\n                      return c;\n                    }).findFirst().get();\n  }\n\n  @BeforeEach\n  public void setup() throws Exception {\n    this.mockDaprClient = mock(DaprClient.class);\n    this.runtime = constructor.newInstance(null, this.mockDaprClient);\n  }\n\n  @Test\n  public void registerActorNullClass() {\n    assertThrows(IllegalArgumentException.class, () -> this.runtime.registerActor(null));\n  }\n\n  @Test\n  public void registerActorNullFactory() {\n    assertThrows(IllegalArgumentException.class, () -> this.runtime.registerActor(MyActorImpl.class, null, new DefaultObjectSerializer(),\n        new DefaultObjectSerializer()));\n  }\n\n  @Test\n  public void registerActorNullSerializer() {\n    assertThrows(IllegalArgumentException.class, () -> this.runtime.registerActor(MyActorImpl.class, new DefaultActorFactory<>(), null,\n        new DefaultObjectSerializer()));\n  }\n\n  @Test\n  public void registerActorNullStateSerializer() {\n    assertThrows(IllegalArgumentException.class, () -> this.runtime.registerActor(MyActorImpl.class, new DefaultActorFactory<>(),\n        new DefaultObjectSerializer(), null));\n  }\n\n  @Test\n  public void setActorIdleTimeout() throws Exception {\n    this.runtime.getConfig().setActorIdleTimeout(Duration.ofSeconds(123));\n    Assertions.assertEquals(\"{\\\"entities\\\":[],\\\"actorIdleTimeout\\\":\\\"0h2m3s0ms\\\"}\",\n        new String(this.runtime.serializeConfig()));\n  }\n\n  @Test\n  public void setActorScanInterval() throws Exception {\n    this.runtime.getConfig().setActorScanInterval(Duration.ofSeconds(123));\n    Assertions.assertEquals(\"{\\\"entities\\\":[],\\\"actorScanInterval\\\":\\\"0h2m3s0ms\\\"}\",\n        new String(this.runtime.serializeConfig()));\n  }\n\n  @Test\n  public void setDrainBalancedActors() throws Exception {\n    this.runtime.getConfig().setDrainBalancedActors(true);\n    Assertions.assertEquals(\"{\\\"entities\\\":[],\\\"drainBalancedActors\\\":true}\",\n        new String(this.runtime.serializeConfig()));\n  }\n\n  @Test\n  public void addActorTypeConfig() throws Exception {\n    ActorTypeConfig actorTypeConfig1 = new ActorTypeConfig();\n    actorTypeConfig1.setActorTypeName(\"actor1\");\n    actorTypeConfig1.setActorIdleTimeout(Duration.ofSeconds(123));\n    actorTypeConfig1.setActorScanInterval(Duration.ofSeconds(123));\n    actorTypeConfig1.setDrainOngoingCallTimeout(Duration.ofSeconds(123));\n    actorTypeConfig1.setDrainBalancedActors(true);\n    actorTypeConfig1.setRemindersStoragePartitions(1);\n    this.runtime.getConfig().addActorTypeConfig(actorTypeConfig1);\n    this.runtime.getConfig().addRegisteredActorType(\"actor1\");\n\n    ActorTypeConfig actorTypeConfig2 = new ActorTypeConfig();\n    actorTypeConfig2.setActorTypeName(\"actor2\");\n    actorTypeConfig2.setActorIdleTimeout(Duration.ofSeconds(123));\n    actorTypeConfig2.setActorScanInterval(Duration.ofSeconds(123));\n    actorTypeConfig2.setDrainOngoingCallTimeout(Duration.ofSeconds(123));\n    actorTypeConfig2.setDrainBalancedActors(false);\n    actorTypeConfig2.setRemindersStoragePartitions(2);\n    this.runtime.getConfig().addActorTypeConfig(actorTypeConfig2);\n    this.runtime.getConfig().addRegisteredActorType(\"actor2\");\n\n    Assertions.assertEquals(\n            \"{\\\"entities\\\":[\\\"actor1\\\",\\\"actor2\\\"],\\\"entitiesConfig\\\":[{\\\"entities\\\":[\\\"actor1\\\"],\\\"actorIdleTimeout\\\":\\\"0h2m3s0ms\\\",\\\"actorScanInterval\\\":\\\"0h2m3s0ms\\\",\\\"drainOngoingCallTimeout\\\":\\\"0h2m3s0ms\\\",\\\"drainBalancedActors\\\":true,\\\"remindersStoragePartitions\\\":1},{\\\"entities\\\":[\\\"actor2\\\"],\\\"actorIdleTimeout\\\":\\\"0h2m3s0ms\\\",\\\"actorScanInterval\\\":\\\"0h2m3s0ms\\\",\\\"drainOngoingCallTimeout\\\":\\\"0h2m3s0ms\\\",\\\"drainBalancedActors\\\":false,\\\"remindersStoragePartitions\\\":2}]}\",\n            new String(this.runtime.serializeConfig())\n    );\n  }\n\n  @Test\n  public void addNullActorTypeConfig() throws Exception {\n    try {\n      this.runtime.getConfig().addActorTypeConfig(null);\n    } catch (Exception ex) {\n      Assertions.assertTrue(ex instanceof IllegalArgumentException);\n      Assertions.assertTrue(ex.getMessage().contains(\"Add actor type config failed.\"));\n    }\n    try {\n      this.runtime.getConfig().addRegisteredActorType(null);\n    } catch (Exception ex) {\n      Assertions.assertTrue(ex instanceof IllegalArgumentException);\n      Assertions.assertTrue(ex.getMessage().contains(\"Registered actor must have a type name.\"));\n    }\n  }\n\n  @Test\n  public void setDrainOngoingCallTimeout() throws Exception {\n    this.runtime.getConfig().setDrainOngoingCallTimeout(Duration.ofSeconds(123));\n    Assertions.assertEquals(\"{\\\"entities\\\":[],\\\"drainOngoingCallTimeout\\\":\\\"0h2m3s0ms\\\"}\",\n        new String(this.runtime.serializeConfig()));\n  }\n\n  @Test\n  public void setRemindersStoragePartitions() throws Exception {\n    this.runtime.getConfig().setRemindersStoragePartitions(12);\n    Assertions.assertEquals(\"{\\\"entities\\\":[],\\\"remindersStoragePartitions\\\":12}\",\n        new String(this.runtime.serializeConfig()));\n  }\n\n  @Test\n  public void invokeActor() throws Exception {\n    String actorId = UUID.randomUUID().toString();\n    this.runtime.registerActor(MyActorImpl.class);\n\n    byte[] response = this.runtime.invoke(ACTOR_NAME, actorId, \"say\", null).block();\n    String message = ACTOR_STATE_SERIALIZER.deserialize(response, String.class);\n    Assertions.assertEquals(\"Nothing to say.\", message);\n  }\n\n  @Test\n  public void invokeUnknownActor() {\n    String actorId = UUID.randomUUID().toString();\n    this.runtime.registerActor(MyActorImpl.class);\n\n    assertThrows(IllegalArgumentException.class, () -> this.runtime.invoke(\"UnknownActor\", actorId, \"say\", null).block());\n  }\n\n  @Test\n  public void deactivateActor() throws Exception {\n    String actorId = UUID.randomUUID().toString();\n    this.runtime.registerActor(MyActorImpl.class);\n    this.runtime.deactivate(ACTOR_NAME, actorId).block();\n  }\n\n  @Test\n  public void lazyDeactivate() throws Exception {\n    String actorId = UUID.randomUUID().toString();\n    this.runtime.registerActor(MyActorImpl.class);\n\n    Mono<Void> deactivateCall = this.runtime.deactivate(ACTOR_NAME, actorId);\n\n    this.runtime.invoke(ACTOR_NAME, actorId, \"say\", null).block();\n\n    deactivateCall.block();\n\n    this.runtime.invoke(ACTOR_NAME, actorId, \"say\", null)\n        .doOnError(e -> Assertions.assertTrue(e.getMessage().contains(\"Could not find actor\")))\n        .doOnSuccess(s -> Assertions.fail()).onErrorReturn(\"\".getBytes()).block();\n  }\n\n  @Test\n  public void lazyInvoke() throws Exception {\n    String actorId = UUID.randomUUID().toString();\n    this.runtime.registerActor(MyActorImpl.class, new DefaultActorFactory<>());\n\n    Mono<byte[]> invokeCall = this.runtime.invoke(ACTOR_NAME, actorId, \"say\", null);\n\n    byte[] response = this.runtime.invoke(ACTOR_NAME, actorId, \"count\", null).block();\n    int count = ACTOR_STATE_SERIALIZER.deserialize(response, Integer.class);\n    Assertions.assertEquals(0, count);\n\n    invokeCall.block();\n\n    response = this.runtime.invoke(ACTOR_NAME, actorId, \"count\", null).block();\n    count = ACTOR_STATE_SERIALIZER.deserialize(response, Integer.class);\n    Assertions.assertEquals(1, count);\n  }\n\n}\n"
