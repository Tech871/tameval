[meta]
task = "repair"
scenario = "repair_invalid_constructor"

[lang_info]
lang = "Go"
go_version = "1.23"

[repo_info]
repository = "apache/dubbo-go"
sha = "8d504e5574e431faca7aa03548e650ab7a9fc6a7"

[run_info]
docker_image = "golang:1.23"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out registry/servicediscovery/store/cache_manager.go registry/servicediscovery/store/cache_manager_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting registry/servicediscovery/store/cache_manager.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 83.0
mutation_kill_rate = nan
original_mutation_kill_rate = 55.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "registry/servicediscovery/store/cache_manager_test.go"
focal_file_path = "registry/servicediscovery/store/cache_manager.go"
test_file_url = "https://github.com/apache/dubbo-go/blob/8d504e5574e431faca7aa03548e650ab7a9fc6a7/registry/servicediscovery/store/cache_manager_test.go"
focal_file_url = "https://github.com/apache/dubbo-go/blob/8d504e5574e431faca7aa03548e650ab7a9fc6a7/registry/servicediscovery/store/cache_manager.go"
first_commit_date = "2023-08-11"
last_commit_date = "2025-04-26"
test_file_content = "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http:\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage store\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nimport (\n\t\"dubbo.apache.org/dubbo-go/v3/metadata/info\"\n)\n\nvar defaultTime = time.Second * 3\n\nfunc TestCacheManager(t *testing.T) {\n\tcm, err := NewCacheManager(\"test\", \"test_cache\", defaultTime, 10, true)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create cache manager: %v\", err)\n\t}\n\tcm.Set(\"key1\", \"value1\")\n\tcm.Set(\"key2\", \"value2\")\n\tvalue, ok := cm.Get(1)\n\tif !ok {\n\t\tt.Errorf(\"failed to get key1: %v\", err)\n\t}\n\tif value != \"value1\" {\n\t\tt.Errorf(\"unexpected Value for key1: got %v, want %v\", value, \"value1\")\n\t}\n\tcm.Delete(\"key2\")\n\t_, ok = cm.Get(\"key2\")\n\tif ok {\n\t\tt.Errorf(\"key2 was not removed from cache\")\n\t}\n\tcm.Set(\"key3\", \"value3\")\n\tall := cm.GetAll()\n\tif len(all) != 2 {\n\t\tt.Errorf(\"unexpected number of items in cache: got %d, want %d\", len(all), 2)\n\t}\n\tcm2, err := NewCacheManager(\"test2\", \"nonexistent_cache\", defaultTime, 10, \"\")\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create cache manager: %v\", err)\n\t}\n\tcm2.Set(\"key4\", \"value4\")\n\ttime.Sleep(time.Second * 4)\n\tcm2.StopDump()\n\tcm3, err := NewCacheManager(\"test3\", \"nonexistent_cache\", defaultTime, 10, true)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create cache manager: %v\", err)\n\t}\n\tall3 := cm3.GetAll()\n\tif len(all3) != 1 {\n\t\tt.Errorf(\"unexpected number of items in cache: got %d, want %d\", len(all3), 1)\n\t}\n\t_, ok = cm3.Get(\"key4\")\n\tif !ok {\n\t\tt.Errorf(\"failed to get key4: %v\", err)\n\t}\n\tcm3.destroy()\n\tcm2.destroy()\n\tcm.destroy()\n}\n\nfunc TestMetaInfoCacheManager(t *testing.T) {\n\n\tserverInfo := make(map[string]*info.ServiceInfo)\n\tserverInfo[\"1\"] = info.NewServiceInfo(\"1\", \"1\", \"1\", \"1\", \"1\", make(map[string]string))\n\tserverInfo[\"2\"] = info.NewServiceInfo(\"2\", \"2\", \"2\", \"2\", \"2\", make(map[string]string))\n\tserverInfo[\"3\"] = info.NewServiceInfo(\"3\", \"3\", \"3\", \"3\", \"3\", make(map[string]string))\n\n\tmetadataInfo1 := info.NewMetadataInfoWithParams(\"1\", \"1\", serverInfo, \"extraArg\")\n\tmetadataInfo2 := info.NewMetadataInfoWithParams(\"2\", \"2\", serverInfo)\n\tmetadataInfo3 := info.NewMetadataInfoWithParams(\"3\", serverInfo)\n\tmetadataInfo4 := info.NewMetadataInfoWithParams(\"4\", \"4\", serverInfo)\n\n\tcm, err := NewCacheManager(\"metaTest1\", \"test_meta_cache\", defaultTime, \"ten\", true)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create cache manager: %v\", err)\n\t}\n\tcm.Set(\"key1\", metadataInfo1)\n\tcm.Set(\"key2\", metadataInfo2)\n\tvalue, ok := cm.Get(\"key1\")\n\tif !ok {\n\t\tt.Errorf(\"failed to get key1: %v\", err)\n\t}\n\tif value != metadataInfo1 {\n\t\tt.Errorf(\"unexpected Value for key1: got %v, want %v\", value, \"value1\")\n\t}\n\tcm.Delete(\"key2\")\n\t_, ok = cm.Get(\"key2\")\n\tif ok {\n\t\tt.Errorf(\"key2 was not removed from cache\")\n\t}\n\tcm.Set(\"key3\", metadataInfo3)\n\tall := cm.GetAll()\n\tif len(all) != 2 {\n\t\tt.Errorf(\"unexpected number of items in cache: got %d, want %d\", len(all), 2)\n\t}\n\tcm2, err := NewCacheManager(\"metaTest2\", \"nonexistent_meta_cache\", defaultTime, 10, true)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create cache manager: %v\", err)\n\t}\n\tcm2.Set(\"key4\", metadataInfo4)\n\ttime.Sleep(time.Second * 4)\n\tcm2.StopDump()\n\tcm3, err := NewCacheManager(\"test3\", \"nonexistent_meta_cache\", defaultTime, 10, true)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create cache manager: %v\", err)\n\t}\n\tall3 := cm3.GetAll()\n\tif len(all3) != 1 {\n\t\tt.Errorf(\"unexpected number of items in cache: got %d, want %d\", len(all3), 1)\n\t}\n\t_, ok = cm3.Get(\"key4\")\n\tif !ok {\n\t\tt.Errorf(\"failed to get key4: %v\", err)\n\t}\n\tcm3.destroy()\n\tcm2.destroy()\n\tcm.destroy()\n}"
