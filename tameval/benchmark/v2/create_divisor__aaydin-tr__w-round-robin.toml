[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.22"

[repo_info]
repository = "aaydin-tr/divisor"
sha = "be1010bf44bd1fcf47537b6a7423b664e5016985"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out core/w-round-robin/w-round-robin.go core/w-round-robin/w-round-robin_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting core/w-round-robin/w-round-robin.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 95.0
original_coverage = 95.0
mutation_kill_rate = 60.0
original_mutation_kill_rate = 60.0
covered_lines = [ 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 49, 50, 51, 52, 54, 55, 58, 59, 60, 61, 62, 63, 64, 65, 66, 68, 69, 70, 73, 74, 75, 76, 79, 80, 81, 82, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 113, 114, 115, 116, 118, 119, 120, 121, 123, 124, 125, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 144, 147, 148, 149, 150, 151, 154, 155, 159, 165, 166,]
missed_lines = [ 152, 153, 160, 161, 162,]

[input_info]
test_file_path = "core/w-round-robin/w-round-robin_test.go"
focal_file_path = "core/w-round-robin/w-round-robin.go"
test_file_url = "https://github.com/aaydin-tr/divisor/blob/be1010bf44bd1fcf47537b6a7423b664e5016985/core/w-round-robin/w-round-robin_test.go"
focal_file_url = "https://github.com/aaydin-tr/divisor/blob/be1010bf44bd1fcf47537b6a7423b664e5016985/core/w-round-robin/w-round-robin.go"
first_commit_date = "2022-10-30"
last_commit_date = "2025-06-08"
test_file_content = "package w_round_robin\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aaydin-tr/divisor/mocks\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/valyala/fasthttp\"\n)\n\nfunc TestNewWRoundRobin(t *testing.T) {\n\tfor _, r := range mocks.TestCases {\n\t\tif r.ExpectedServerCount == 0 {\n\t\t\twRoundRobin := NewWRoundRobin(&r.Config, r.ProxyFunc)\n\t\t\tassert.Nil(t, wRoundRobin)\n\t\t} else {\n\t\t\twRoundRobin := NewWRoundRobin(&r.Config, r.ProxyFunc).(*WRoundRobin)\n\t\t\tassert.Equal(t, r.ExpectedServerCount, len(wRoundRobin.serversMap))\n\t\t}\n\t}\n}\n\nfunc TestNext(t *testing.T) {\n\tcaseOne := mocks.TestCases[1]\n\tbalancer := NewWRoundRobin(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\twRoundRobin := balancer.(*WRoundRobin)\n\tproxy := wRoundRobin.next()\n\n\tassert.IsType(t, &mocks.MockProxy{}, proxy)\n\n\tmockProxy := proxy.(*mocks.MockProxy)\n\tassert.Equal(t, caseOne.Config.Backends[0].Url, mockProxy.Addr)\n}\n\nfunc TestServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[1]\n\tbalancer := NewWRoundRobin(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\twRoundRobin := balancer.(*WRoundRobin)\n\thandlerFunc := wRoundRobin.Serve()\n\n\tctx := fasthttp.RequestCtx{\n\t\tRequest: *fasthttp.AcquireRequest(),\n\t}\n\n\tproxy := wRoundRobin.next().(*mocks.MockProxy)\n\tassert.False(t, proxy.IsCalled, \"expected Server func not be called, but it was called\")\n\thandlerFunc(&ctx)\n\tassert.True(t, proxy.IsCalled, \"expected Server func to be called, but it wasn't\")\n}\n\nfunc TestStats(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tbalancer := NewWRoundRobin(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\twRoundRobin := balancer.(*WRoundRobin)\n\tstats := wRoundRobin.Stats()\n\n\tfor i, backend := range caseOne.Config.Backends {\n\t\thash := wRoundRobin.hashFunc([]byte(backend.Url + strconv.Itoa(i)))\n\t\ts := wRoundRobin.serversMap[hash]\n\t\tp := s.proxy.(*mocks.MockProxy)\n\n\t\tassert.Equal(t, s.isHostAlive, stats[i].IsHostAlive)\n\t\tassert.Equal(t, hash, stats[i].BackendHash)\n\t\tassert.Equal(t, backend.Url, p.Addr)\n\t}\n}\n\nfunc TestHealthChecker(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\twRoundRobin := &WRoundRobin{stopHealthChecker: make(chan bool)}\n\n\twRoundRobin.isHostAlive = func(s string) bool {\n\t\tgo func() {\n\t\t\twRoundRobin.stopHealthChecker <- true\n\t\t}()\n\t\treturn false\n\t}\n\twRoundRobin.hashFunc = func(b []byte) uint32 {\n\t\treturn 0\n\t}\n\n\tcaseOne.Config.HealthCheckerTime = 1\n\twRoundRobin.healthChecker(caseOne.Config.Backends)\n}\n\nfunc TestRemoveOneServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\twRoundRobin := NewWRoundRobin(&caseOne.Config, caseOne.ProxyFunc).(*WRoundRobin)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(wRoundRobin.serversMap))\n\n\t// Remove one server\n\tbackend := caseOne.Config.Backends[0]\n\tif b, ok := wRoundRobin.serversMap[wRoundRobin.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\twRoundRobin.isHostAlive = func(s string) bool {\n\t\t\treturn false\n\t\t}\n\t\toldServerCount := wRoundRobin.len\n\t\twRoundRobin.healthCheck(backend, 0)\n\n\t\tassert.False(t, b.isHostAlive, \"expected isHostAlive equal to false, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, oldServerCount, wRoundRobin.len, \"expected server to be removed after health check, but it did not.\")\n\t}\n}\n\nfunc TestRemoveAndAddServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\twRoundRobin := NewWRoundRobin(&caseOne.Config, caseOne.ProxyFunc).(*WRoundRobin)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(wRoundRobin.serversMap))\n\n\t// Remove one server\n\tbackend := caseOne.Config.Backends[0]\n\tif b, ok := wRoundRobin.serversMap[wRoundRobin.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\twRoundRobin.isHostAlive = func(s string) bool {\n\t\t\treturn false\n\t\t}\n\t\toldServerCount := wRoundRobin.len\n\t\twRoundRobin.healthCheck(backend, 0)\n\n\t\tassert.False(t, b.isHostAlive, \"expected isHostAlive equal to false, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, oldServerCount, wRoundRobin.len, \"expected server to be removed after health check, but it did not.\")\n\t}\n\n\t// Add one server\n\tif b, ok := wRoundRobin.serversMap[wRoundRobin.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\tb.isHostAlive = false\n\t\twRoundRobin.isHostAlive = func(s string) bool {\n\t\t\treturn true\n\t\t}\n\n\t\toldServerCount := wRoundRobin.len\n\t\twRoundRobin.healthCheck(backend, 0)\n\n\t\tassert.True(t, b.isHostAlive, \"expected isHostAlive equal to true, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, wRoundRobin.len, oldServerCount, \"expected server to be added after health check, but it did not.\")\n\n\t}\n}\n\nfunc TestRemmoveAllServers(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\twRoundRobin := NewWRoundRobin(&caseOne.Config, caseOne.ProxyFunc).(*WRoundRobin)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(wRoundRobin.serversMap))\n\n\t// Remove All\n\tfor i, backend := range caseOne.Config.Backends {\n\t\tif _, ok := wRoundRobin.serversMap[wRoundRobin.hashFunc([]byte(backend.Url+strconv.Itoa(i)))]; ok {\n\t\t\twRoundRobin.isHostAlive = func(s string) bool {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\toldServerCount := wRoundRobin.len\n\t\t\tif oldServerCount == 1 {\n\t\t\t\tassert.Panics(t, func() {\n\t\t\t\t\twRoundRobin.healthCheck(backend, i)\n\t\t\t\t}, \"expected panic after remove all servers\")\n\t\t\t} else {\n\t\t\t\twRoundRobin.healthCheck(backend, i)\n\t\t\t\tassert.GreaterOrEqual(t, oldServerCount, wRoundRobin.len, \"expected server to be removed after health check, but it did not.\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShutdown(t *testing.T) {\n\tt.Run(\"shutdown calls close on all proxies\", func(t *testing.T) {\n\t\tcaseOne := mocks.TestCases[0]\n\t\twRoundRobin := NewWRoundRobin(&caseOne.Config, caseOne.ProxyFunc).(*WRoundRobin)\n\t\tassert.NotNil(t, wRoundRobin)\n\n\t\t// Verify proxy Close() methods are not called yet\n\t\tfor _, sm := range wRoundRobin.serversMap {\n\t\t\tmockProxy := sm.proxy.(*mocks.MockProxy)\n\t\t\tassert.False(t, mockProxy.CloseCalled, \"Proxy Close() should not be called before shutdown\")\n\t\t}\n\n\t\t// Call shutdown\n\t\terr := wRoundRobin.Shutdown()\n\t\tassert.NoError(t, err, \"Shutdown() should not return an error\")\n\n\t\t// Verify that Close() was called on all proxy clients\n\t\tfor _, sm := range wRoundRobin.serversMap {\n\t\t\tmockProxy := sm.proxy.(*mocks.MockProxy)\n\t\t\tassert.True(t, mockProxy.CloseCalled, \"Proxy Close() should be called during shutdown\")\n\t\t}\n\t})\n\n\tt.Run(\"shutdown with no servers\", func(t *testing.T) {\n\t\temptyCase := mocks.TestCases[3] // Case with 0 servers\n\t\temptyWRoundRobin := NewWRoundRobin(&emptyCase.Config, emptyCase.ProxyFunc)\n\t\tif emptyWRoundRobin != nil {\n\t\t\terr := emptyWRoundRobin.Shutdown()\n\t\t\tassert.NoError(t, err, \"Shutdown() should not return an error even with no servers\")\n\t\t}\n\t})\n\n\tt.Run(\"shutdown with actual health checker goroutine\", func(t *testing.T) {\n\t\tcaseOne := mocks.TestCases[0]\n\t\tcaseOne.Config.HealthCheckerTime = 100 * time.Millisecond // Fast health check for testing\n\t\twRoundRobin := NewWRoundRobin(&caseOne.Config, caseOne.ProxyFunc).(*WRoundRobin)\n\t\tassert.NotNil(t, wRoundRobin)\n\n\t\t// Give health checker time to start\n\t\ttime.Sleep(50 * time.Millisecond)\n\n\t\t// Call shutdown - this should stop the health checker goroutine\n\t\terr := wRoundRobin.Shutdown()\n\t\tassert.NoError(t, err, \"Shutdown() should not return an error\")\n\n\t\t// Verify that Close() was called on all proxy clients\n\t\tfor _, sm := range wRoundRobin.serversMap {\n\t\t\tmockProxy := sm.proxy.(*mocks.MockProxy)\n\t\t\tassert.True(t, mockProxy.CloseCalled, \"Proxy Close() should be called during shutdown\")\n\t\t}\n\n\t\t// Give some time for health checker to actually stop\n\t\ttime.Sleep(150 * time.Millisecond)\n\t})\n}\n"
