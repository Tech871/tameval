[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Python"
python_version = "3.12"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "visivo-io/visivo"
sha = "65f80739da9eae151e990b6d21751f8d904c80e9"

[run_info]
docker_image = "python:3.12"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "(pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=visivo/server/source_metadata.py -m pytest -q --junit-xml=test_output.xml tests/server/test_source_metadata.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target visivo.server.source_metadata --unit-test tests.server.test_source_metadata --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target visivo/server/source_metadata.py --unit-test tests/server/test_source_metadata.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 89.0
original_coverage = 89.0
mutation_kill_rate = 100.0
original_mutation_kill_rate = 100.0
covered_lines = [ 0, 1, 2, 3, 9, 11, 12, 13, 14, 17, 19, 20, 25, 27, 29, 30, 31, 32, 33, 36, 46, 48, 54, 56, 57, 58, 60, 61, 62, 65, 66, 68, 70, 71, 72, 75, 77, 78, 79, 81, 82, 83, 84, 89, 90, 91, 99, 101, 102, 103, 105, 106, 107, 109, 110, 113, 114, 115, 116, 119, 120, 121, 127, 129, 141, 143, 144, 145, 147, 148, 151, 153, 154, 157, 158, 159, 163, 164, 179, 181, 182, 183, 185, 186, 189, 191, 192, 195, 196, 197, 198, 201, 202, 220, 222, 223, 224, 225, 226, 227, 230, 231, 234, 241, 243, 244, 245, 247, 248, 250, 257, 258,]
missed_lines = [ 22, 38, 42, 43, 136, 137, 138, 160, 171, 172, 173, 210, 211, 212,]

[input_info]
test_file_path = "tests/server/test_source_metadata.py"
focal_file_path = "visivo/server/source_metadata.py"
test_file_url = "https://github.com/visivo-io/visivo/blob/65f80739da9eae151e990b6d21751f8d904c80e9/tests/server/test_source_metadata.py"
focal_file_url = "https://github.com/visivo-io/visivo/blob/65f80739da9eae151e990b6d21751f8d904c80e9/visivo/server/source_metadata.py"
first_commit_date = "2025-07-19"
last_commit_date = "2025-07-19"
test_file_content = "import pytest\nfrom unittest.mock import Mock, patch, MagicMock\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.exc import OperationalError\nfrom visivo.server.source_metadata import (\n    check_source_connection,\n    get_source_databases,\n    get_database_schemas,\n    get_schema_tables,\n    get_table_columns,\n    gather_source_metadata,\n)\n\n\nclass TestSourceMetadata:\n    \"\"\"Test suite for source_metadata module functions.\"\"\"\n\n    def setup_method(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        # Create mock SqlalchemySource\n        self.mock_source = Mock()\n        self.mock_source.name = \"test_source\"\n        self.mock_source.type = \"postgresql\"\n        self.mock_source.database = \"test_db\"\n\n        # Patch isinstance to recognize our mocks as SqlalchemySource\n        self.isinstance_patcher = patch(\"visivo.server.source_metadata.isinstance\")\n        self.mock_isinstance = self.isinstance_patcher.start()\n\n        def isinstance_side_effect(obj, cls):\n            from visivo.models.sources.sqlalchemy_source import SqlalchemySource\n\n            if cls == SqlalchemySource and hasattr(obj, \"name\") and hasattr(obj, \"type\"):\n                return True\n            return isinstance.__wrapped__(obj, cls)\n\n        self.mock_isinstance.side_effect = isinstance_side_effect\n\n    def teardown_method(self):\n        \"\"\"Clean up patches.\"\"\"\n        self.isinstance_patcher.stop()\n\n    def test_test_source_connection_success(self):\n        \"\"\"Test successful source connection test.\"\"\"\n        # Setup\n        mock_engine = Mock()\n        mock_conn = Mock()\n        mock_engine.connect.return_value.__enter__ = Mock(return_value=mock_conn)\n        mock_engine.connect.return_value.__exit__ = Mock(return_value=None)\n        mock_engine.dialect.name = \"postgresql\"\n\n        # Set up get_engine without __code__ attribute check\n        def mock_get_engine(read_only=True):\n            return mock_engine\n\n        self.mock_source.get_engine = mock_get_engine\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            result = check_source_connection(sources, \"test_source\")\n\n        # Assert\n        assert result == {\"source\": \"test_source\", \"status\": \"connected\"}\n        mock_conn.execute.assert_called_once()\n\n    def test_test_source_connection_with_read_only_param(self):\n        \"\"\"Test connection test when get_engine accepts read_only parameter.\"\"\"\n        # Setup\n        mock_engine = Mock()\n        mock_conn = Mock()\n        mock_engine.connect.return_value.__enter__ = Mock(return_value=mock_conn)\n        mock_engine.connect.return_value.__exit__ = Mock(return_value=None)\n        mock_engine.dialect.name = \"postgresql\"\n\n        # Mock get_engine with read_only parameter\n        def get_engine_with_read_only(read_only=True):\n            return mock_engine\n\n        self.mock_source.get_engine = get_engine_with_read_only\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            result = check_source_connection(sources, \"test_source\")\n\n        # Assert\n        assert result == {\"source\": \"test_source\", \"status\": \"connected\"}\n\n    def test_test_source_connection_failure(self):\n        \"\"\"Test failed source connection test.\"\"\"\n\n        # Setup\n        def mock_get_engine(read_only=True):\n            raise OperationalError(\"Connection failed\", None, None)\n\n        self.mock_source.get_engine = mock_get_engine\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            result = check_source_connection(sources, \"test_source\")\n\n        # Assert\n        assert result[\"source\"] == \"test_source\"\n        assert result[\"status\"] == \"connection_failed\"\n        assert \"Connection failed\" in result[\"error\"]\n\n    def test_test_source_connection_not_found(self):\n        \"\"\"Test connection test with non-existent source.\"\"\"\n        sources = [self.mock_source]\n\n        result = check_source_connection(sources, \"non_existent\")\n\n        assert result == ({\"error\": \"Source 'non_existent' not found\"}, 404)\n\n    def test_test_source_connection_different_dialects(self):\n        \"\"\"Test connection test for different SQL dialects.\"\"\"\n        dialects = [\"snowflake\", \"mysql\", \"sqlite\", \"duckdb\", \"unknown_dialect\"]\n\n        for dialect in dialects:\n            mock_engine = Mock()\n            mock_conn = Mock()\n            mock_engine.connect.return_value.__enter__ = Mock(return_value=mock_conn)\n            mock_engine.connect.return_value.__exit__ = Mock(return_value=None)\n            mock_engine.dialect.name = dialect\n\n            def mock_get_engine(read_only=True):\n                return mock_engine\n\n            self.mock_source.get_engine = mock_get_engine\n            sources = [self.mock_source]\n\n            with patch(\"visivo.server.source_metadata.Logger\"):\n                result = check_source_connection(sources, \"test_source\")\n\n            assert result == {\"source\": \"test_source\", \"status\": \"connected\"}\n            mock_conn.execute.assert_called_once()\n            mock_conn.reset_mock()  # Reset for next iteration\n\n    def test_get_source_databases_success(self):\n        \"\"\"Test successful database listing.\"\"\"\n        # Setup\n        self.mock_source.list_databases = Mock(return_value=[\"db1\", \"db2\", \"db3\"])\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            result = get_source_databases(sources, \"test_source\")\n\n        # Assert\n        assert result == {\n            \"source\": \"test_source\",\n            \"databases\": [{\"name\": \"db1\"}, {\"name\": \"db2\"}, {\"name\": \"db3\"}],\n            \"status\": \"connected\",\n        }\n\n    def test_get_source_databases_failure(self):\n        \"\"\"Test failed database listing.\"\"\"\n        # Setup\n        self.mock_source.list_databases = Mock(side_effect=Exception(\"Access denied\"))\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            result = get_source_databases(sources, \"test_source\")\n\n        # Assert\n        assert result[\"source\"] == \"test_source\"\n        assert result[\"databases\"] == []\n        assert result[\"status\"] == \"connection_failed\"\n        assert \"Access denied\" in result[\"error\"]\n\n    def test_get_source_databases_not_found(self):\n        \"\"\"Test database listing with non-existent source.\"\"\"\n        sources = [self.mock_source]\n\n        result = get_source_databases(sources, \"non_existent\")\n\n        assert result == ({\"error\": \"Source 'non_existent' not found\"}, 404)\n\n    def test_get_database_schemas_with_schemas(self):\n        \"\"\"Test schema listing for database with schemas.\"\"\"\n        # Setup\n        mock_engine = Mock()\n        mock_conn = Mock()\n        mock_engine.connect.return_value.__enter__ = Mock(return_value=mock_conn)\n        mock_engine.connect.return_value.__exit__ = Mock(return_value=None)\n        mock_engine.dialect.name = \"postgresql\"\n\n        mock_inspector = Mock()\n        mock_inspector.get_schema_names = Mock(return_value=[\"public\", \"private\", \"test\"])\n\n        def mock_get_engine(read_only=True):\n            return mock_engine\n\n        self.mock_source.get_engine = mock_get_engine\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            with patch(\"sqlalchemy.inspect\", return_value=mock_inspector):\n                result = get_database_schemas(sources, \"test_source\", \"test_db\")\n\n        # Assert\n        assert result == {\n            \"source\": \"test_source\",\n            \"database\": \"test_db\",\n            \"schemas\": [{\"name\": \"public\"}, {\"name\": \"private\"}, {\"name\": \"test\"}],\n            \"has_schemas\": True,\n        }\n\n    def test_get_database_schemas_without_schemas(self):\n        \"\"\"Test schema listing for database without schema support.\"\"\"\n        # Setup\n        mock_engine = Mock()\n        mock_conn = Mock()\n        mock_engine.connect.return_value.__enter__ = Mock(return_value=mock_conn)\n        mock_engine.connect.return_value.__exit__ = Mock(return_value=None)\n        mock_engine.dialect.name = \"sqlite\"\n\n        mock_inspector = Mock()\n        mock_inspector.get_schema_names = Mock(side_effect=NotImplementedError)\n\n        def mock_get_engine(read_only=True):\n            return mock_engine\n\n        self.mock_source.get_engine = mock_get_engine\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            with patch(\"sqlalchemy.inspect\", return_value=mock_inspector):\n                result = get_database_schemas(sources, \"test_source\", \"test_db\")\n\n        # Assert\n        assert result == {\n            \"source\": \"test_source\",\n            \"database\": \"test_db\",\n            \"schemas\": None,\n            \"has_schemas\": False,\n        }\n\n    def test_get_database_schemas_with_database_switch(self):\n        \"\"\"Test schema listing with database context switch.\"\"\"\n        # Setup\n        mock_engine = Mock()\n        mock_conn = Mock()\n        mock_engine.connect.return_value.__enter__ = Mock(return_value=mock_conn)\n        mock_engine.connect.return_value.__exit__ = Mock(return_value=None)\n        mock_engine.dialect.name = \"mysql\"\n\n        mock_inspector = Mock()\n        mock_inspector.get_schema_names = Mock(return_value=[\"schema1\", \"schema2\"])\n\n        def mock_get_engine(read_only=True):\n            return mock_engine\n\n        self.mock_source.get_engine = mock_get_engine\n        self.mock_source.database = \"default_db\"\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            with patch(\"sqlalchemy.inspect\", return_value=mock_inspector):\n                result = get_database_schemas(sources, \"test_source\", \"other_db\")\n\n        # Assert\n        mock_conn.execute.assert_called_once()\n        # Check that the SQL text contains USE statement\n        call_args = mock_conn.execute.call_args[0][0]\n        assert hasattr(call_args, \"text\") and \"USE other_db\" in call_args.text\n        assert result[\"schemas\"] == [{\"name\": \"schema1\"}, {\"name\": \"schema2\"}]\n\n    def test_get_schema_tables_success(self):\n        \"\"\"Test successful table listing.\"\"\"\n        # Setup\n        mock_engine = Mock()\n        mock_conn = Mock()\n        mock_engine.connect.return_value.__enter__ = Mock(return_value=mock_conn)\n        mock_engine.connect.return_value.__exit__ = Mock(return_value=None)\n        mock_engine.dialect.name = \"postgresql\"\n\n        mock_inspector = Mock()\n        mock_inspector.get_table_names = Mock(return_value=[\"users\", \"orders\", \"products\"])\n\n        def mock_get_engine(read_only=True):\n            return mock_engine\n\n        self.mock_source.get_engine = mock_get_engine\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            with patch(\"sqlalchemy.inspect\", return_value=mock_inspector):\n                result = get_schema_tables(sources, \"test_source\", \"test_db\", \"public\")\n\n        # Assert\n        assert result == {\n            \"source\": \"test_source\",\n            \"database\": \"test_db\",\n            \"schema\": \"public\",\n            \"tables\": [{\"name\": \"users\"}, {\"name\": \"orders\"}, {\"name\": \"products\"}],\n        }\n        mock_inspector.get_table_names.assert_called_once_with(schema=\"public\")\n\n    def test_get_schema_tables_no_schema(self):\n        \"\"\"Test table listing without schema (SQLite-style).\"\"\"\n        # Setup\n        mock_engine = Mock()\n        mock_conn = Mock()\n        mock_engine.connect.return_value.__enter__ = Mock(return_value=mock_conn)\n        mock_engine.connect.return_value.__exit__ = Mock(return_value=None)\n        mock_engine.dialect.name = \"sqlite\"\n\n        mock_inspector = Mock()\n        mock_inspector.get_table_names = Mock(return_value=[\"table1\", \"table2\"])\n\n        def mock_get_engine(read_only=True):\n            return mock_engine\n\n        self.mock_source.get_engine = mock_get_engine\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            with patch(\"sqlalchemy.inspect\", return_value=mock_inspector):\n                result = get_schema_tables(sources, \"test_source\", \"test_db\", None)\n\n        # Assert\n        assert result[\"schema\"] is None\n        assert len(result[\"tables\"]) == 2\n        mock_inspector.get_table_names.assert_called_once_with(schema=None)\n\n    def test_get_table_columns_success(self):\n        \"\"\"Test successful column listing.\"\"\"\n        # Setup\n        mock_engine = Mock()\n        mock_conn = Mock()\n        mock_engine.connect.return_value.__enter__ = Mock(return_value=mock_conn)\n        mock_engine.connect.return_value.__exit__ = Mock(return_value=None)\n        mock_engine.dialect.name = \"postgresql\"\n\n        mock_inspector = Mock()\n        mock_inspector.get_columns = Mock(\n            return_value=[\n                {\"name\": \"id\", \"type\": \"INTEGER\"},\n                {\"name\": \"name\", \"type\": \"VARCHAR(255)\"},\n                {\"name\": \"created_at\", \"type\": \"TIMESTAMP\"},\n            ]\n        )\n\n        def mock_get_engine(read_only=True):\n            return mock_engine\n\n        self.mock_source.get_engine = mock_get_engine\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            with patch(\"sqlalchemy.inspect\", return_value=mock_inspector):\n                result = get_table_columns(sources, \"test_source\", \"test_db\", \"users\", \"public\")\n\n        # Assert\n        assert result == {\n            \"source\": \"test_source\",\n            \"database\": \"test_db\",\n            \"schema\": \"public\",\n            \"table\": \"users\",\n            \"columns\": [\n                {\"name\": \"id\", \"type\": \"INTEGER\"},\n                {\"name\": \"name\", \"type\": \"VARCHAR(255)\"},\n                {\"name\": \"created_at\", \"type\": \"TIMESTAMP\"},\n            ],\n        }\n        mock_inspector.get_columns.assert_called_once_with(\"users\", schema=\"public\")\n\n    def test_get_table_columns_with_database_switch(self):\n        \"\"\"Test column listing with database context switch.\"\"\"\n        # Setup\n        mock_engine = Mock()\n        mock_conn = Mock()\n        mock_engine.connect.return_value.__enter__ = Mock(return_value=mock_conn)\n        mock_engine.connect.return_value.__exit__ = Mock(return_value=None)\n        mock_engine.dialect.name = \"snowflake\"\n\n        mock_inspector = Mock()\n        mock_inspector.get_columns = Mock(return_value=[{\"name\": \"col1\", \"type\": \"NUMBER\"}])\n\n        def mock_get_engine(read_only=True):\n            return mock_engine\n\n        self.mock_source.get_engine = mock_get_engine\n        self.mock_source.database = \"default_db\"\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            with patch(\"sqlalchemy.inspect\", return_value=mock_inspector):\n                result = get_table_columns(sources, \"test_source\", \"other_db\", \"table1\", \"schema1\")\n\n        # Assert\n        mock_conn.execute.assert_called_once()\n        # Check that the SQL text contains USE statement\n        call_args = mock_conn.execute.call_args[0][0]\n        assert hasattr(call_args, \"text\") and \"USE other_db\" in call_args.text\n\n    def test_gather_source_metadata_success(self):\n        \"\"\"Test successful metadata gathering for all sources.\"\"\"\n        # Setup\n        mock_metadata = {\n            \"name\": \"test_source\",\n            \"type\": \"postgresql\",\n            \"databases\": [\n                {\"name\": \"db1\", \"schemas\": [{\"name\": \"public\", \"tables\": [\"users\", \"orders\"]}]}\n            ],\n        }\n        self.mock_source.introspect = Mock(return_value=mock_metadata)\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            result = gather_source_metadata(sources)\n\n        # Assert\n        assert len(result[\"sources\"]) == 1\n        assert result[\"sources\"][0][\"name\"] == \"test_source\"\n        assert result[\"sources\"][0][\"status\"] == \"connected\"\n        assert \"databases\" in result[\"sources\"][0]\n\n    def test_gather_source_metadata_with_error_result(self):\n        \"\"\"Test metadata gathering when introspection returns error.\"\"\"\n        # Setup\n        mock_error_metadata = {\"error\": \"Access denied to database\"}\n        self.mock_source.introspect = Mock(return_value=mock_error_metadata)\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            result = gather_source_metadata(sources)\n\n        # Assert\n        assert len(result[\"sources\"]) == 1\n        assert result[\"sources\"][0][\"name\"] == \"test_source\"\n        assert result[\"sources\"][0][\"status\"] == \"connection_failed\"\n        assert result[\"sources\"][0][\"error\"] == \"Access denied to database\"\n        assert result[\"sources\"][0][\"databases\"] == []\n\n    def test_gather_source_metadata_with_exception(self):\n        \"\"\"Test metadata gathering when introspection raises exception.\"\"\"\n        # Setup\n        self.mock_source.introspect = Mock(side_effect=Exception(\"Connection timeout\"))\n        sources = [self.mock_source]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            result = gather_source_metadata(sources)\n\n        # Assert\n        assert len(result[\"sources\"]) == 1\n        assert result[\"sources\"][0][\"name\"] == \"test_source\"\n        assert result[\"sources\"][0][\"status\"] == \"connection_failed\"\n        assert \"Connection timeout\" in result[\"sources\"][0][\"error\"]\n\n    def test_gather_source_metadata_multiple_sources(self):\n        \"\"\"Test metadata gathering with multiple sources.\"\"\"\n        # Setup\n        source1 = Mock()\n        source1.name = \"source1\"\n        source1.type = \"postgresql\"\n        source1.introspect = Mock(return_value={\"name\": \"source1\", \"type\": \"postgresql\"})\n\n        source2 = Mock()\n        source2.name = \"source2\"\n        source2.type = \"mysql\"\n        source2.introspect = Mock(side_effect=Exception(\"Failed\"))\n\n        sources = [source1, source2]\n\n        # Execute\n        with patch(\"visivo.server.source_metadata.Logger\"):\n            result = gather_source_metadata(sources)\n\n        # Assert\n        assert len(result[\"sources\"]) == 2\n        assert result[\"sources\"][0][\"status\"] == \"connected\"\n        assert result[\"sources\"][1][\"status\"] == \"connection_failed\"\n\n    def test_all_functions_handle_non_sqlalchemy_sources(self):\n        \"\"\"Test that all functions skip non-SqlalchemySource objects.\"\"\"\n        # Setup\n        non_sqlalchemy_source = Mock()\n        non_sqlalchemy_source.name = \"not_sqlalchemy\"\n        sources = [non_sqlalchemy_source]\n\n        # Create a custom isinstance patcher for this test that returns False for non-SqlalchemySource\n        with patch(\"visivo.server.source_metadata.isinstance\") as mock_isinstance_local:\n\n            def isinstance_side_effect_local(obj, cls):\n                from visivo.models.sources.sqlalchemy_source import SqlalchemySource\n\n                if cls == SqlalchemySource:\n                    return False  # This mock is not a SqlalchemySource\n                return isinstance.__wrapped__(obj, cls)\n\n            mock_isinstance_local.side_effect = isinstance_side_effect_local\n\n            # Test each function\n            assert check_source_connection(sources, \"not_sqlalchemy\") == (\n                {\"error\": \"Source 'not_sqlalchemy' not found\"},\n                404,\n            )\n            assert get_source_databases(sources, \"not_sqlalchemy\") == (\n                {\"error\": \"Source 'not_sqlalchemy' not found\"},\n                404,\n            )\n            assert get_database_schemas(sources, \"not_sqlalchemy\", \"db\") == (\n                {\"error\": \"Source 'not_sqlalchemy' not found\"},\n                404,\n            )\n            assert get_schema_tables(sources, \"not_sqlalchemy\", \"db\") == (\n                {\"error\": \"Source 'not_sqlalchemy' not found\"},\n                404,\n            )\n            assert get_table_columns(sources, \"not_sqlalchemy\", \"db\", \"table\") == (\n                {\"error\": \"Source 'not_sqlalchemy' not found\"},\n                404,\n            )\n            assert gather_source_metadata(sources) == {\"sources\": []}\n"
