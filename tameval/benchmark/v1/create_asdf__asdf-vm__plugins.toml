[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Go"
go_version = "1.23.4"

[repo_info]
repository = "asdf-vm/asdf"
sha = "74d7b17a1cc9f640cf0f5134416d1cf7a56fe19f"

[run_info]
docker_image = "golang:1.23.4"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/plugins/plugins.go internal/plugins/plugins_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/plugins/plugins.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 84.02
original_coverage = 77.0
mutation_kill_rate = 58.7
original_mutation_kill_rate = nan
covered_lines = [ 23, 24, 25, 33, 34, 35, 54, 55, 56, 65, 66, 67, 90, 91, 92, 93, 97, 98, 99, 100, 101, 102, 103, 104, 105, 110, 111, 112, 113, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 135, 136, 137, 142, 145, 146, 147, 149, 153, 154, 159, 160, 161, 163, 167, 168, 169, 170, 171, 173, 174, 175, 176, 177, 178, 179, 183, 184, 185, 186, 187, 188, 190, 195, 196, 197, 198, 199, 200, 206, 207, 208, 209, 210, 211, 212, 213, 214, 218, 223, 224, 225, 226, 227, 228, 230, 231, 232, 233, 234, 236, 240, 241, 242, 243, 244, 246, 247, 248, 249, 250, 251, 252, 253, 254, 256, 257, 258, 259, 260, 261, 262, 263, 268, 269, 270, 271, 276, 277, 278, 287, 288, 289, 290, 291, 292, 293, 294, 295, 300, 301, 307, 308, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 329, 334, 335, 336, 337, 338, 340, 345, 346, 347, 349, 350, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 386, 391, 392, 393, 394, 395, 396, 397, 398, 402, 403, 404, 405, 406, 408, 409, 410, 415, 416, 417, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 444, 445, 446, 447, 452, 453, 454, 455, 457, 458, 459, 460, 461, 467, 470, 471, 476, 477, 478, 480,]
missed_lines = [ 43, 44, 45, 107, 138, 139, 140, 155, 156, 157, 202, 203, 204, 264, 265, 266, 279, 280, 281, 282, 284, 296, 297, 298, 302, 303, 304, 309, 310, 311, 341, 342, 343, 351, 352, 353, 354, 355, 356, 357, 359, 360, 361, 362, 363, 364, 365, 367, 368, 369, 370, 371, 372, 387, 388, 389, 411, 412, 413, 436, 437, 438, 440, 441, 442, 463, 464, 465, 472, 473, 474,]

[input_info]
test_file_path = "internal/plugins/plugins_test.go"
focal_file_path = "internal/plugins/plugins.go"
test_file_url = "https://github.com/asdf-vm/asdf/blob/74d7b17a1cc9f640cf0f5134416d1cf7a56fe19f/internal/plugins/plugins_test.go"
focal_file_url = "https://github.com/asdf-vm/asdf/blob/74d7b17a1cc9f640cf0f5134416d1cf7a56fe19f/internal/plugins/plugins.go"
first_commit_date = "2024-12-18"
last_commit_date = "2025-02-25"
test_file_content = "package plugins\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/asdf-vm/asdf/internal/config\"\n\t\"github.com/asdf-vm/asdf/internal/data\"\n\t\"github.com/asdf-vm/asdf/internal/repotest\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nconst testPluginName = \"lua\"\n\nfunc TestList(t *testing.T) {\n\ttestDataDir := t.TempDir()\n\tconf := config.Config{DataDir: testDataDir}\n\ttestRepo, err := repotest.GeneratePlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\tassert.Nil(t, err)\n\n\terr = Add(conf, testPluginName, testRepo, \"\")\n\tassert.Nil(t, err)\n\n\tt.Run(\"when urls and refs are set to false returns plugin names\", func(t *testing.T) {\n\t\tplugins, err := List(conf, false, false)\n\t\tassert.Nil(t, err)\n\n\t\tplugin := plugins[0]\n\t\tassert.Equal(t, \"lua\", plugin.Name)\n\t\tassert.NotZero(t, plugin.Dir)\n\t\tassert.Zero(t, plugin.URL)\n\t\tassert.Zero(t, plugin.Ref)\n\t})\n\n\tt.Run(\"when urls is set to true returns plugins with repo urls set\", func(t *testing.T) {\n\t\tplugins, err := List(conf, true, false)\n\t\tassert.Nil(t, err)\n\n\t\tplugin := plugins[0]\n\t\tassert.Equal(t, \"lua\", plugin.Name)\n\t\tassert.NotZero(t, plugin.Dir)\n\t\tassert.Zero(t, plugin.Ref)\n\t\tassert.NotZero(t, plugin.URL)\n\t})\n\n\tt.Run(\"when refs is set to true returns plugins with current repo refs set\", func(t *testing.T) {\n\t\tplugins, err := List(conf, false, true)\n\t\tassert.Nil(t, err)\n\n\t\tplugin := plugins[0]\n\t\tassert.Equal(t, \"lua\", plugin.Name)\n\t\tassert.NotZero(t, plugin.Dir)\n\t\tassert.NotZero(t, plugin.Ref)\n\t\tassert.Zero(t, plugin.URL)\n\t})\n\n\tt.Run(\"when refs and urls are both set to true returns plugins with both set\", func(t *testing.T) {\n\t\tplugins, err := List(conf, true, true)\n\t\tassert.Nil(t, err)\n\n\t\tplugin := plugins[0]\n\t\tassert.Equal(t, \"lua\", plugin.Name)\n\t\tassert.NotZero(t, plugin.Dir)\n\t\tassert.NotZero(t, plugin.Ref)\n\t\tassert.NotZero(t, plugin.URL)\n\t})\n}\n\nfunc TestNew(t *testing.T) {\n\ttestDataDir := t.TempDir()\n\tconf := config.Config{DataDir: testDataDir}\n\n\tt.Run(\"returns Plugin struct with Dir and Name fields set correctly\", func(t *testing.T) {\n\t\tplugin := New(conf, \"test-plugin\")\n\n\t\tassert.Equal(t, \"test-plugin\", plugin.Name)\n\t\tassert.Equal(t, filepath.Join(testDataDir, \"plugins\", \"test-plugin\"), plugin.Dir)\n\t})\n}\n\nfunc TestAdd(t *testing.T) {\n\ttestDataDir := t.TempDir()\n\n\tt.Run(\"when given an invalid plugin name prints an error\", func(t *testing.T) {\n\t\tinvalids := []string{\"plugin^name\", \"plugin%name\", \"plugin name\", \"PLUGIN_NAME\"}\n\n\t\tfor _, invalid := range invalids {\n\t\t\tt.Run(invalid, func(t *testing.T) {\n\t\t\t\terr := Add(config.Config{}, invalid, \"never-cloned\", \"\")\n\n\t\t\t\texpectedErrMsg := \"is invalid. Name may only contain lowercase letters, numbers, '_', and '-'\"\n\t\t\t\tif !strings.Contains(err.Error(), expectedErrMsg) {\n\t\t\t\t\tt.Errorf(\"Expected an error with message %v\", expectedErrMsg)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"when plugin with same name already exists prints an error\", func(t *testing.T) {\n\t\tconf := config.Config{DataDir: testDataDir}\n\n\t\t// Add plugin\n\t\trepoPath, err := repotest.GeneratePlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\t\tassert.Nil(t, err)\n\n\t\terr = Add(conf, testPluginName, repoPath, \"\")\n\t\tif err != nil {\n\t\t\tt.Fatal(\"Expected to be able to add plugin\")\n\t\t}\n\n\t\t// Add it again to trigger error\n\t\terr = Add(conf, testPluginName, repoPath, \"\")\n\n\t\tif err == nil {\n\t\t\tt.Fatal(\"expected error got nil\")\n\t\t}\n\n\t\texpectedErrMsg := \"Plugin named lua already added\"\n\t\tif !strings.Contains(err.Error(), expectedErrMsg) {\n\t\t\tt.Errorf(\"Expected an error with message %v\", expectedErrMsg)\n\t\t}\n\t})\n\n\tt.Run(\"when plugin name is valid but URL is invalid prints an error\", func(t *testing.T) {\n\t\tconf := config.Config{DataDir: testDataDir}\n\n\t\terr := Add(conf, \"foo\", \"foobar\", \"\")\n\n\t\tassert.ErrorContains(t, err, \"unable to clone plugin: repository not found\")\n\t})\n\n\tt.Run(\"when plugin name and URL are valid installs plugin\", func(t *testing.T) {\n\t\ttestDataDir := t.TempDir()\n\t\tconf := config.Config{DataDir: testDataDir}\n\t\tpluginPath, err := repotest.GeneratePlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\t\tassert.Nil(t, err)\n\n\t\terr = Add(conf, testPluginName, pluginPath, \"\")\n\n\t\tassert.Nil(t, err, \"Expected to be able to add plugin\")\n\n\t\t// Assert plugin directory contains Git repo with bin directory\n\t\tpluginDir := data.PluginDirectory(testDataDir, testPluginName)\n\n\t\t_, err = os.ReadDir(pluginDir + \"/.git\")\n\t\tassert.Nil(t, err)\n\n\t\tentries, err := os.ReadDir(pluginDir + \"/bin\")\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, 12, len(entries))\n\t})\n\n\tt.Run(\"when parameters are valid creates plugin download dir\", func(t *testing.T) {\n\t\ttestDataDir := t.TempDir()\n\t\tconf := config.Config{DataDir: testDataDir}\n\n\t\trepoPath, err := repotest.GeneratePlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\t\tassert.Nil(t, err)\n\n\t\terr = Add(conf, testPluginName, repoPath, \"\")\n\t\tassert.Nil(t, err)\n\n\t\t// Assert download dir exists\n\t\tdownloadDir := data.DownloadDirectory(testDataDir, testPluginName)\n\t\t_, err = os.Stat(downloadDir)\n\t\tassert.Nil(t, err)\n\t})\n}\n\nfunc TestRemove(t *testing.T) {\n\ttestDataDir := t.TempDir()\n\tconf := config.Config{DataDir: testDataDir}\n\n\trepoPath, err := repotest.GeneratePlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\tassert.Nil(t, err)\n\n\terr = Add(conf, testPluginName, repoPath, \"\")\n\tassert.Nil(t, err)\n\n\tt.Run(\"returns error when plugin with name does not exist\", func(t *testing.T) {\n\t\tvar stdout strings.Builder\n\t\tvar stderr strings.Builder\n\t\terr := Remove(conf, \"nonexistent\", &stdout, &stderr)\n\t\tassert.NotNil(t, err)\n\t\tassert.ErrorContains(t, err, \"No such plugin\")\n\t})\n\n\tt.Run(\"returns error when invalid plugin name is given\", func(t *testing.T) {\n\t\tvar stdout strings.Builder\n\t\tvar stderr strings.Builder\n\t\terr := Remove(conf, \"foo/bar/baz\", &stdout, &stderr)\n\t\tassert.NotNil(t, err)\n\t\texpectedErrMsg := \"is invalid. Name may only contain lowercase letters, numbers, '_', and '-'\"\n\t\tassert.ErrorContains(t, err, expectedErrMsg)\n\t})\n\n\tt.Run(\"removes plugin when passed name of installed plugin\", func(t *testing.T) {\n\t\tvar stdout strings.Builder\n\t\tvar stderr strings.Builder\n\t\terr := Remove(conf, testPluginName, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\tpluginDir := data.PluginDirectory(testDataDir, testPluginName)\n\t\t_, err = os.Stat(pluginDir)\n\t\tassert.NotNil(t, err)\n\t\tassert.True(t, os.IsNotExist(err))\n\t})\n\n\tt.Run(\"removes plugin download dir when passed name of installed plugin\", func(t *testing.T) {\n\t\tvar stdout strings.Builder\n\t\tvar stderr strings.Builder\n\t\terr := Add(conf, testPluginName, repoPath, \"\")\n\t\tassert.Nil(t, err)\n\n\t\terr = Remove(conf, testPluginName, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\n\t\tdownloadDir := data.DownloadDirectory(testDataDir, testPluginName)\n\t\t_, err = os.Stat(downloadDir)\n\t\tassert.NotNil(t, err)\n\t\tassert.True(t, os.IsNotExist(err))\n\t})\n}\n\nfunc TestUpdate(t *testing.T) {\n\ttestDataDir := t.TempDir()\n\tconf := config.Config{DataDir: testDataDir}\n\n\trepoPath, err := repotest.GeneratePlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\tassert.Nil(t, err)\n\tassert.Nil(t, Add(conf, testPluginName, repoPath, \"\"))\n\n\tnoPostUpdateCallbackPlugin := \"no-post-update\"\n\trepoPath, err = repotest.GeneratePlugin(\"dummy_plugin\", testDataDir, noPostUpdateCallbackPlugin)\n\tassert.Nil(t, err)\n\tassert.Nil(t, os.Remove(filepath.Join(repoPath, \"bin\", \"post-plugin-update\")))\n\tassert.Nil(t, Add(conf, noPostUpdateCallbackPlugin, repoPath, \"\"))\n\n\tbadPluginName := \"badplugin\"\n\tbadRepo := data.PluginDirectory(testDataDir, badPluginName)\n\terr = os.MkdirAll(badRepo, 0o777)\n\tassert.Nil(t, err)\n\n\ttests := []struct {\n\t\tdesc        string\n\t\tgivenConf   config.Config\n\t\tgivenName   string\n\t\tgivenRef    string\n\t\twantSomeRef bool\n\t\twantErrMsg  string\n\t}{\n\t\t{\n\t\t\tdesc:        \"returns error when plugin with name does not exist\",\n\t\t\tgivenConf:   conf,\n\t\t\tgivenName:   \"nonexistent\",\n\t\t\tgivenRef:    \"\",\n\t\t\twantSomeRef: false,\n\t\t\twantErrMsg:  \"no such plugin: nonexistent\",\n\t\t},\n\t\t{\n\t\t\tdesc:        \"returns error when plugin repo does not exist\",\n\t\t\tgivenConf:   conf,\n\t\t\tgivenName:   \"badplugin\",\n\t\t\tgivenRef:    \"\",\n\t\t\twantSomeRef: false,\n\t\t\twantErrMsg:  \"unable to open plugin Git repository: repository does not exist\",\n\t\t},\n\t\t{\n\t\t\tdesc:        \"updates plugin when plugin with name exists\",\n\t\t\tgivenConf:   conf,\n\t\t\tgivenName:   testPluginName,\n\t\t\tgivenRef:    \"\",\n\t\t\twantSomeRef: true,\n\t\t\twantErrMsg:  \"\",\n\t\t},\n\t\t{\n\t\t\tdesc:        \"updates plugin when plugin when post-plugin-update callback does not exist\",\n\t\t\tgivenConf:   conf,\n\t\t\tgivenName:   noPostUpdateCallbackPlugin,\n\t\t\tgivenRef:    \"\",\n\t\t\twantSomeRef: true,\n\t\t\twantErrMsg:  \"\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tvar blackhole strings.Builder\n\t\t\tplugin := New(conf, tt.givenName)\n\t\t\tupdatedToRef, err := plugin.Update(tt.givenConf, tt.givenRef, &blackhole, &blackhole)\n\n\t\t\tif tt.wantErrMsg == \"\" {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t\tassert.ErrorContains(t, err, tt.wantErrMsg)\n\t\t\t}\n\n\t\t\tif tt.wantSomeRef == true {\n\t\t\t\tassert.NotZero(t, updatedToRef)\n\t\t\t} else {\n\t\t\t\tassert.Zero(t, updatedToRef)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExists(t *testing.T) {\n\ttestDataDir := t.TempDir()\n\tconf := config.Config{DataDir: testDataDir}\n\t_, err := repotest.InstallPlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\tassert.Nil(t, err)\n\n\texistingPlugin := New(conf, testPluginName)\n\n\tt.Run(\"returns nil if plugin exists\", func(t *testing.T) {\n\t\terr := existingPlugin.Exists()\n\t\tassert.Nil(t, err)\n\t})\n\n\tt.Run(\"returns PluginMissing error when plugin missing\", func(t *testing.T) {\n\t\tmissingPlugin := New(conf, \"non-existent\")\n\t\terr := missingPlugin.Exists()\n\t\tassert.Equal(t, err, PluginMissing{plugin: \"non-existent\"})\n\t})\n}\n\nfunc TestPluginExists(t *testing.T) {\n\ttestDataDir := t.TempDir()\n\tpluginDir := data.PluginDirectory(testDataDir, testPluginName)\n\terr := os.MkdirAll(pluginDir, 0o777)\n\tif err != nil {\n\t\tt.Errorf(\"got %v, expected nil\", err)\n\t}\n\n\tt.Run(\"returns true when plugin exists\", func(t *testing.T) {\n\t\texists, err := PluginExists(testDataDir, testPluginName)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"got %v, expected nil\", err)\n\t\t}\n\n\t\tif exists != true {\n\t\t\tt.Error(\"got false, expected true\")\n\t\t}\n\t})\n\n\tt.Run(\"returns false when plugin path is file and not dir\", func(t *testing.T) {\n\t\tpluginName := \"file\"\n\t\tpluginDir := data.PluginDirectory(testDataDir, pluginName)\n\t\terr := touchFile(pluginDir)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"got %v, expected nil\", err)\n\t\t}\n\n\t\texists, err := PluginExists(testDataDir, pluginName)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"got %v, expected nil\", err)\n\t\t}\n\n\t\tif exists != false {\n\t\t\tt.Error(\"got false, expected true\")\n\t\t}\n\t})\n\n\tt.Run(\"returns false when plugin dir does not exist\", func(t *testing.T) {\n\t\texists, err := PluginExists(testDataDir, \"non-existent\")\n\t\tif err != nil {\n\t\t\tt.Errorf(\"got %v, expected nil\", err)\n\t\t}\n\n\t\tif exists != false {\n\t\t\tt.Error(\"got false, expected true\")\n\t\t}\n\t})\n}\n\nfunc TestValidatePluginName(t *testing.T) {\n\tt.Run(\"returns no error when plugin name is valid\", func(t *testing.T) {\n\t\terr := validatePluginName(testPluginName)\n\t\tassert.Nil(t, err)\n\t})\n\n\tinvalids := []string{\"plugin^name\", \"plugin%name\", \"plugin name\", \"PLUGIN_NAME\"}\n\n\tfor _, invalid := range invalids {\n\t\tt.Run(invalid, func(t *testing.T) {\n\t\t\terr := validatePluginName(invalid)\n\n\t\t\tif err == nil {\n\t\t\t\tt.Error(\"Expected an error\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRunCallback(t *testing.T) {\n\temptyEnv := map[string]string{}\n\n\ttestDataDir := t.TempDir()\n\tconf := config.Config{DataDir: testDataDir}\n\t_, err := repotest.InstallPlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\tassert.Nil(t, err)\n\n\tplugin := New(conf, testPluginName)\n\n\tt.Run(\"returns NoCallback error when callback with name not found\", func(t *testing.T) {\n\t\tvar stdout strings.Builder\n\t\tvar stderr strings.Builder\n\n\t\terr = plugin.RunCallback(\"non-existent\", []string{}, emptyEnv, &stdout, &stderr)\n\n\t\tassert.Equal(t, err.(NoCallbackError).Error(), \"Plugin named lua does not have a callback named non-existent\")\n\t})\n\n\tt.Run(\"passes argument to command\", func(t *testing.T) {\n\t\tvar stdout strings.Builder\n\t\tvar stderr strings.Builder\n\n\t\terr = plugin.RunCallback(\"debug\", []string{\"123\"}, emptyEnv, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, \"123\\n\", stdout.String())\n\t\tassert.Equal(t, \"\", stderr.String())\n\t})\n\n\tt.Run(\"passes arguments to command\", func(t *testing.T) {\n\t\tvar stdout strings.Builder\n\t\tvar stderr strings.Builder\n\n\t\terr = plugin.RunCallback(\"debug\", []string{\"123\", \"test string\"}, emptyEnv, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, \"123 test string\\n\", stdout.String())\n\t\tassert.Equal(t, \"\", stderr.String())\n\t})\n\n\tt.Run(\"passes env to command\", func(t *testing.T) {\n\t\tvar stdout strings.Builder\n\t\tvar stderr strings.Builder\n\n\t\terr = plugin.RunCallback(\"post-plugin-update\", []string{}, map[string]string{\"ASDF_PLUGIN_PREV_REF\": \"TEST\"}, &stdout, &stderr)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, \"plugin updated path= old git-ref=TEST new git-ref=\\n\", stdout.String())\n\t\tassert.Equal(t, \"\", stderr.String())\n\t})\n}\n\nfunc TestCallbackPath(t *testing.T) {\n\ttestDataDir := t.TempDir()\n\tconf := config.Config{DataDir: testDataDir}\n\t_, err := repotest.InstallPlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\tassert.Nil(t, err)\n\tplugin := New(conf, testPluginName)\n\n\tt.Run(\"returns callback path when callback exists\", func(t *testing.T) {\n\t\tpath, err := plugin.CallbackPath(\"install\")\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, filepath.Base(path), \"install\")\n\t\tassert.Equal(t, filepath.Base(filepath.Dir(filepath.Dir(path))), plugin.Name)\n\t\tassert.Equal(t, filepath.Base(filepath.Dir(filepath.Dir(filepath.Dir(path)))), \"plugins\")\n\t})\n\n\tt.Run(\"returns error when callback does not exist\", func(t *testing.T) {\n\t\tpath, err := plugin.CallbackPath(\"non-existent\")\n\t\tassert.Equal(t, err.(NoCallbackError).Error(), \"Plugin named lua does not have a callback named non-existent\")\n\t\tassert.Equal(t, path, \"\")\n\t})\n}\n\nfunc TestGetExtensionCommands(t *testing.T) {\n\ttestDataDir := t.TempDir()\n\tconf := config.Config{DataDir: testDataDir}\n\t_, err := repotest.InstallPlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\tassert.Nil(t, err)\n\tplugin := New(conf, testPluginName)\n\n\tt.Run(\"returns empty slice when no extension commands defined\", func(t *testing.T) {\n\t\tcommands, err := plugin.GetExtensionCommands()\n\t\tassert.Nil(t, err)\n\t\tassert.Empty(t, commands)\n\t})\n\n\tt.Run(\"returns slice of with default extension command if it is present\", func(t *testing.T) {\n\t\tassert.Nil(t, writeExtensionCommand(t, plugin, \"\", \"#!/usr/bin/env bash\\necho $1\"))\n\t\tcommands, err := plugin.GetExtensionCommands()\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, commands, []string{\"\"})\n\t})\n\n\tt.Run(\"returns slice of all extension commands when they are present\", func(t *testing.T) {\n\t\tassert.Nil(t, writeExtensionCommand(t, plugin, \"\", \"#!/usr/bin/env bash\\necho $1\"))\n\t\tassert.Nil(t, writeExtensionCommand(t, plugin, \"foobar\", \"#!/usr/bin/env bash\\necho $1\"))\n\n\t\tcommands, err := plugin.GetExtensionCommands()\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, commands, []string{\"\", \"foobar\"})\n\t})\n}\n\nfunc TestExtensionCommandPath(t *testing.T) {\n\ttestDataDir := t.TempDir()\n\tconf := config.Config{DataDir: testDataDir}\n\t_, err := repotest.InstallPlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\tassert.Nil(t, err)\n\tplugin := New(conf, testPluginName)\n\n\tt.Run(\"returns NoCallback error when callback with name not found\", func(t *testing.T) {\n\t\tpath, err := plugin.ExtensionCommandPath(\"non-existent\")\n\n\t\tassert.Equal(t, err.(NoCommandError).Error(), \"Plugin named lua does not have a extension command named non-existent\")\n\t\tassert.Equal(t, path, \"\")\n\t})\n\n\tt.Run(\"returns default extension command script when no name\", func(t *testing.T) {\n\t\tassert.Nil(t, writeExtensionCommand(t, plugin, \"\", \"#!/usr/bin/env bash\\necho $1\"))\n\t\tpath, err := plugin.ExtensionCommandPath(\"\")\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, filepath.Base(path), \"command\")\n\t})\n\n\tt.Run(\"passes arguments to command\", func(t *testing.T) {\n\t\tassert.Nil(t, writeExtensionCommand(t, plugin, \"debug\", \"#!/usr/bin/env bash\\necho $@\"))\n\t\tpath, err := plugin.ExtensionCommandPath(\"debug\")\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, filepath.Base(path), \"command-debug\")\n\t})\n}\n\nfunc writeExtensionCommand(t *testing.T, plugin Plugin, name, contents string) error {\n\tt.Helper()\n\tassert.Nil(t, os.MkdirAll(filepath.Join(plugin.Dir, \"lib\", \"commands\"), 0o777))\n\tfilename := \"command\"\n\tif name != \"\" {\n\t\tfilename = fmt.Sprintf(\"command-%s\", name)\n\t}\n\n\tpath := filepath.Join(plugin.Dir, \"lib\", \"commands\", filename)\n\terr := os.WriteFile(path, []byte(contents), 0o777)\n\treturn err\n}\n\nfunc TestLegacyFilenames(t *testing.T) {\n\ttestDataDir := t.TempDir()\n\tconf := config.Config{DataDir: testDataDir}\n\t_, err := repotest.InstallPlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\tassert.Nil(t, err)\n\tplugin := New(conf, testPluginName)\n\n\tt.Run(\"returns list of filenames when list-legacy-filenames callback is present\", func(t *testing.T) {\n\t\tfilenames, err := plugin.LegacyFilenames()\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, filenames, []string{\".dummy-version\", \".dummyrc\"})\n\t})\n\n\tt.Run(\"returns empty list when list-legacy-filenames callback not present\", func(t *testing.T) {\n\t\ttestPluginName := \"foobar\"\n\t\t_, err := repotest.InstallPlugin(\"dummy_plugin_no_download\", testDataDir, testPluginName)\n\t\tassert.Nil(t, err)\n\t\tplugin := New(conf, testPluginName)\n\n\t\tfilenames, err := plugin.LegacyFilenames()\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, filenames, []string{})\n\t})\n}\n\nfunc TestParseLegacyVersionFile(t *testing.T) {\n\ttestDataDir := t.TempDir()\n\tconf := config.Config{DataDir: testDataDir}\n\t_, err := repotest.InstallPlugin(\"dummy_plugin\", testDataDir, testPluginName)\n\tassert.Nil(t, err)\n\tplugin := New(conf, testPluginName)\n\n\tdata := []byte(\"dummy-1.2.3\")\n\tcurrentDir := t.TempDir()\n\tpath := filepath.Join(currentDir, \".dummy-version\")\n\terr = os.WriteFile(path, data, 0o666)\n\tassert.Nil(t, err)\n\n\tt.Run(\"returns file contents unchanged when parse-legacy-file callback not present\", func(t *testing.T) {\n\t\ttestPluginName := \"foobar\"\n\t\t_, err := repotest.InstallPlugin(\"dummy_plugin_no_download\", testDataDir, testPluginName)\n\t\tassert.Nil(t, err)\n\t\tplugin := New(conf, testPluginName)\n\n\t\tversions, err := plugin.ParseLegacyVersionFile(path)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, versions, []string{\"dummy-1.2.3\"})\n\t})\n\n\tt.Run(\"returns file contents parsed by parse-legacy-file callback when it is present\", func(t *testing.T) {\n\t\tversions, err := plugin.ParseLegacyVersionFile(path)\n\t\tassert.Nil(t, err)\n\t\tassert.Equal(t, versions, []string{\"1.2.3\"})\n\t})\n\n\tt.Run(\"returns error when passed file that doesn't exist\", func(t *testing.T) {\n\t\tversions, err := plugin.ParseLegacyVersionFile(\"non-existent-file\")\n\t\tassert.Error(t, err)\n\t\tassert.Empty(t, versions)\n\t})\n}\n\nfunc touchFile(name string) error {\n\tfile, err := os.OpenFile(name, os.O_RDONLY|os.O_CREATE, 0o644)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn file.Close()\n}\n"
