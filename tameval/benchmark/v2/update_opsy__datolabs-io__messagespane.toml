[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "datolabs-io/opsy"
sha = "34d0c4dd506970419e9238a3343710100422dd33"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/tui/components/messagespane/messagespane.go internal/tui/components/messagespane/messagespane_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/tui/components/messagespane/messagespane.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 98.0
mutation_kill_rate = nan
original_mutation_kill_rate = 45.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "internal/tui/components/messagespane/messagespane_test.go"
focal_file_path = "internal/tui/components/messagespane/messagespane.go"
test_file_url = "https://github.com/datolabs-io/opsy/blob/34d0c4dd506970419e9238a3343710100422dd33/internal/tui/components/messagespane/messagespane_test.go"
focal_file_url = "https://github.com/datolabs-io/opsy/blob/34d0c4dd506970419e9238a3343710100422dd33/internal/tui/components/messagespane/messagespane.go"
first_commit_date = "2025-02-19"
last_commit_date = "2025-03-01"
test_file_content = "package messagespane\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/datolabs-io/sredo/internal/agent\"\n\t\"github.com/datolabs-io/sredo/internal/thememanager\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// stripANSI removes ANSI color codes from a string.\nfunc stripANSI(str string) string {\n\tre := regexp.MustCompile(`\\x1b\\[[0-9;]*[a-zA-Z]`)\n\treturn re.ReplaceAllString(str, \"\")\n}\n\n// TestNew tests the creation of a new messages pane component.\nfunc TestNew(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t\tBase02: \"#111111\",\n\t\t\tBase03: \"#222222\",\n\t\t\tBase04: \"#333333\",\n\t\t},\n\t\tAccentColors: thememanager.AccentColors{\n\t\t\tAccent1: \"#FF0000\",\n\t\t\tAccent2: \"#00FF00\",\n\t\t},\n\t}\n\n\tm := New(\n\t\tWithTheme(theme),\n\t)\n\n\tassert.NotNil(t, m)\n\tassert.Equal(t, theme, m.theme)\n\tassert.NotNil(t, m.viewport)\n\tassert.Empty(t, m.messages)\n}\n\n// TestUpdate tests the update function of the messages pane component.\nfunc TestUpdate(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t\tBase02: \"#111111\",\n\t\t\tBase03: \"#222222\",\n\t\t\tBase04: \"#333333\",\n\t\t},\n\t}\n\tm := New(WithTheme(theme))\n\n\t// Test window size message\n\tnewModel, cmd := m.Update(tea.WindowSizeMsg{Width: 100, Height: 50})\n\tassert.NotNil(t, newModel)\n\tassert.Nil(t, cmd)\n\tassert.Equal(t, 94, newModel.maxWidth) // Width - 6 for padding\n\tassert.Equal(t, 50, newModel.maxHeight)\n\tassert.Equal(t, 94, newModel.viewport.Width)\n\tassert.Equal(t, 50, newModel.viewport.Height)\n\n\t// Test message handling\n\ttestMsg := agent.Message{\n\t\tMessage:   \"Test message\",\n\t\tTool:      \"\",\n\t\tTimestamp: time.Now(),\n\t}\n\tm, cmd = m.Update(testMsg)\n\tassert.Nil(t, cmd)\n\tassert.Len(t, m.messages, 1)\n\tassert.Equal(t, testMsg, m.messages[0])\n}\n\n// TestView tests the view function of the messages pane component.\nfunc TestView(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t\tBase02: \"#111111\",\n\t\t\tBase03: \"#222222\",\n\t\t\tBase04: \"#333333\",\n\t\t},\n\t\tAccentColors: thememanager.AccentColors{\n\t\t\tAccent1: \"#FF0000\",\n\t\t\tAccent2: \"#00FF00\",\n\t\t},\n\t}\n\n\tm := New(\n\t\tWithTheme(theme),\n\t)\n\n\t// Set dimensions to test rendering\n\tm, _ = m.Update(tea.WindowSizeMsg{Width: 100, Height: 50})\n\n\t// Test initial view (empty messages)\n\tview := stripANSI(m.View())\n\tassert.NotEmpty(t, view)\n\tassert.Contains(t, view, \"Messages\")\n\n\t// Add test messages\n\tnow := time.Now()\n\tm.Update(agent.Message{\n\t\tMessage:   \"Hello\",\n\t\tTool:      \"\",\n\t\tTimestamp: now,\n\t})\n\tm.Update(agent.Message{\n\t\tMessage:   \"Running git command\",\n\t\tTool:      \"Git\",\n\t\tTimestamp: now,\n\t})\n\n\t// Test view with messages\n\tview = stripANSI(m.View())\n\tassert.Contains(t, view, \"Messages\")\n\tassert.Contains(t, view, \"Sredo:\")\n\tassert.Contains(t, view, \"Sredo->Git:\")\n\tassert.Contains(t, view, \"Hello\")\n\tassert.Contains(t, view, \"Running git command\")\n}\n\n// TestInit tests the initialization of the messages pane component.\nfunc TestInit(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t},\n\t}\n\tm := New(WithTheme(theme))\n\tcmd := m.Init()\n\tassert.Nil(t, cmd)\n}\n\n// TestMessageSanitization tests the message sanitization functionality.\nfunc TestMessageSanitization(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t},\n\t}\n\tm := New(WithTheme(theme))\n\tm.Update(tea.WindowSizeMsg{Width: 100, Height: 50})\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"removes XML tags\",\n\t\t\tinput:    \"<tag>content</tag>\",\n\t\t\texpected: \"content\",\n\t\t},\n\t\t{\n\t\t\tname:     \"trims whitespace\",\n\t\t\tinput:    \"  message  \\n\\n\",\n\t\t\texpected: \"message\",\n\t\t},\n\t\t{\n\t\t\tname:     \"handles multiple tags\",\n\t\t\tinput:    \"<tag1>content1</tag1><tag2>content2</tag2>\",\n\t\t\texpected: \"content1content2\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tm.Update(agent.Message{\n\t\t\t\tMessage:   tc.input,\n\t\t\t\tTimestamp: time.Now(),\n\t\t\t})\n\t\t\tview := stripANSI(m.View())\n\t\t\tassert.Contains(t, view, tc.expected)\n\t\t\tassert.NotContains(t, view, \"<tag>\")\n\t\t})\n\t}\n}\n\n// TestLongMessageWrapping tests the wrapping of long messages.\nfunc TestLongMessageWrapping(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t},\n\t}\n\tm := New(WithTheme(theme))\n\n\t// Set a narrow width to force wrapping\n\tm.Update(tea.WindowSizeMsg{Width: 40, Height: 50})\n\n\tlongMessage := \"This is a very long message that should be wrapped to multiple lines when the width is limited\"\n\tm.Update(agent.Message{\n\t\tMessage:   longMessage,\n\t\tTimestamp: time.Now(),\n\t})\n\n\tview := stripANSI(m.View())\n\tlines := regexp.MustCompile(`\\n`).Split(view, -1)\n\n\t// Count lines containing parts of the message\n\tmessageLines := 0\n\tfor _, line := range lines {\n\t\tif strings.Contains(line, \"This\") || strings.Contains(line, \"long\") || strings.Contains(line, \"limited\") {\n\t\t\tmessageLines++\n\t\t}\n\t}\n\n\tassert.Greater(t, messageLines, 1, \"long message should be wrapped to multiple lines\")\n}\n\n// TestThemeChange tests the component's response to theme changes.\nfunc TestThemeChange(t *testing.T) {\n\tinitialTheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t\tBase04: \"#FFFFFF\",\n\t\t},\n\t\tAccentColors: thememanager.AccentColors{\n\t\t\tAccent1: \"#FF0000\",\n\t\t\tAccent2: \"#00FF00\",\n\t\t},\n\t}\n\n\tnewTheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#111111\",\n\t\t\tBase04: \"#EEEEEE\",\n\t\t},\n\t\tAccentColors: thememanager.AccentColors{\n\t\t\tAccent1: \"#FF1111\",\n\t\t\tAccent2: \"#11FF11\",\n\t\t},\n\t}\n\n\t// Create and setup first model\n\tm1 := New(WithTheme(initialTheme))\n\tm1.Update(tea.WindowSizeMsg{Width: 80, Height: 40})\n\tm1.Update(agent.Message{\n\t\tMessage:   \"Test message\",\n\t\tTimestamp: time.Now(),\n\t})\n\n\t// Create and setup second model\n\tm2 := New(WithTheme(newTheme))\n\tm2.Update(tea.WindowSizeMsg{Width: 80, Height: 40})\n\tm2.Update(agent.Message{\n\t\tMessage:   \"Test message\",\n\t\tTimestamp: time.Now(),\n\t})\n\n\t// Verify container styles are different\n\tassert.NotEqual(t,\n\t\tm1.containerStyle().GetBackground(),\n\t\tm2.containerStyle().GetBackground(),\n\t\t\"container styles should have different backgrounds\",\n\t)\n\n\t// Verify message styles are different\n\tassert.NotEqual(t,\n\t\tm1.messageStyle().GetForeground(),\n\t\tm2.messageStyle().GetForeground(),\n\t\t\"message styles should have different colors\",\n\t)\n\n\t// Verify styles match their themes\n\tassert.Equal(t,\n\t\tlipgloss.Color(initialTheme.BaseColors.Base01),\n\t\tm1.containerStyle().GetBackground(),\n\t\t\"container style should use Base01 color\",\n\t)\n\n\tassert.Equal(t,\n\t\tlipgloss.Color(initialTheme.BaseColors.Base04),\n\t\tm1.messageStyle().GetForeground(),\n\t\t\"message style should use Base04 color\",\n\t)\n\n\t// Verify content is identical\n\tstripped1 := stripANSI(m1.View())\n\tstripped2 := stripANSI(m2.View())\n\tassert.Equal(t, stripped1, stripped2, \"content should be same after stripping ANSI codes\")\n}\n\n// TestConcurrentAccess tests message handling with multiple updates.\nfunc TestConcurrentAccess(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t\tBase02: \"#111111\",\n\t\t\tBase03: \"#222222\",\n\t\t\tBase04: \"#333333\",\n\t\t},\n\t\tAccentColors: thememanager.AccentColors{\n\t\t\tAccent1: \"#FF0000\",\n\t\t\tAccent2: \"#00FF00\",\n\t\t},\n\t}\n\n\tm := New(WithTheme(theme))\n\n\t// Initialize viewport with window size\n\tm, _ = m.Update(tea.WindowSizeMsg{Width: 100, Height: 50})\n\n\t// Add messages sequentially with fixed timestamp\n\ttimestamp := time.Date(2024, 1, 1, 10, 43, 56, 0, time.UTC)\n\tfor i := 0; i < 10; i++ {\n\t\tmsg := agent.Message{\n\t\t\tMessage:   fmt.Sprintf(\"Message %d\", i),\n\t\t\tTimestamp: timestamp,\n\t\t}\n\t\tm, _ = m.Update(msg)\n\t}\n\n\t// Verify that all messages are in the model's messages slice\n\tassert.Equal(t, 10, len(m.messages), \"should have 10 messages\")\n\tfor i := 0; i < 10; i++ {\n\t\texpectedMessage := fmt.Sprintf(\"Message %d\", i)\n\t\tassert.Equal(t, expectedMessage, m.messages[i].Message, \"message %d should match\", i)\n\t}\n\n\t// Verify that the viewport content is not empty\n\tcontent := stripANSI(m.viewport.View())\n\tassert.NotEmpty(t, content, \"viewport content should not be empty\")\n}"
