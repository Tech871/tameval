[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Python"
python_cfg_file = "requirements.txt"

[repo_info]
repository = "sony/model_optimization"
sha = "0c4bc5984cea42c5cde2b05d4f3032596b054a4c"

[run_info]
docker_image = "python:3"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r requirements.txt && (pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=model_compression_toolkit/core/common/model_collector.py -m pytest -q --junit-xml=test_output.xml tests_pytest/common_tests/unit_tests/test_model_collector.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target model_compression_toolkit.core.common.model_collector --unit-test tests_pytest.common_tests.unit_tests.test_model_collector --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target model_compression_toolkit/core/common/model_collector.py --unit-test tests_pytest/common_tests/unit_tests/test_model_collector.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 22.0
original_coverage = 81.0
mutation_kill_rate = nan
original_mutation_kill_rate = 0.0
covered_lines = [ 16, 17, 19, 20, 21, 22, 23, 24, 26, 27, 28, 31, 58, 77, 117, 131, 139, 213,]
missed_lines = [ 46, 47, 48, 49, 53, 55, 69, 70, 72, 73, 74, 96, 101, 106, 111, 128, 154, 155, 156, 157, 158, 161, 162, 165, 166, 168, 169, 170, 173, 174, 176, 177, 179, 180, 181, 184, 185, 186, 188, 189, 190, 191, 194, 195, 196, 198, 203, 208, 225, 229, 231, 232, 237, 245, 247, 249, 252, 254, 255, 256, 257, 258, 259, 260, 263,]

[input_info]
test_file_path = "tests_pytest/common_tests/unit_tests/test_model_collector.py"
focal_file_path = "model_compression_toolkit/core/common/model_collector.py"
test_file_url = "https://github.com/sony/model_optimization/blob/0c4bc5984cea42c5cde2b05d4f3032596b054a4c/tests_pytest/common_tests/unit_tests/test_model_collector.py"
focal_file_url = "https://github.com/sony/model_optimization/blob/0c4bc5984cea42c5cde2b05d4f3032596b054a4c/model_compression_toolkit/core/common/model_collector.py"
first_commit_date = "2022-06-01"
last_commit_date = "2025-02-24"
test_file_content = "# Copyright 2025 Sony Semiconductor Israel, Inc. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\nimport pytest\nfrom unittest.mock import Mock\nimport numpy as np\nfrom numpy.testing import assert_array_equal\n\nfrom model_compression_toolkit.core import QuantizationErrorMethod\nfrom model_compression_toolkit.core.common import StatsCollector, NoStatsCollector, DEFAULTCONFIG, Graph, model_collector\nfrom model_compression_toolkit.core.common.graph.base_graph import OutTensor\nfrom model_compression_toolkit.core.common.graph.edge import Edge\nfrom model_compression_toolkit.core.common.hessian import HessianInfoService\nfrom model_compression_toolkit.core.common.model_collector import create_stats_collector_for_node, create_tensor2node, ModelCollector\nfrom tests_pytest._test_util.graph_builder_utils import build_node, DummyLayer, build_qc\n\n\n@pytest.fixture\ndef fw_impl_mock():\n    \"\"\"\n    Fixture to create a fake framework implementation with a mocked model_builder.\n    \"\"\"\n    fw_impl = Mock()\n    fw_impl.model_builder.return_value = (Mock(), None)\n    return fw_impl\n\n\n@pytest.fixture\ndef fw_info_mock():\n    \"\"\"\n    Fixture to create a fake framework info object with a predefined out_channel_axis_mapping.\n    \"\"\"\n    fw_info = Mock()\n    fw_info.out_channel_axis_mapping = {DummyLayer: 1}\n    return fw_info\n\n\nclass TestStatisticsCollectors:\n    def test_create_stats_collector_for_node_activation_enabled(self, fw_info_mock):\n        \"\"\"\n        Verify that for a node with activation quantization enabled,\n        create_stats_collector_for_node returns a StatsCollector instance.\n        \"\"\"\n        # Set up a fake node with activation quantization enabled and prior_info attributes.\n        node = Mock()\n        node.is_activation_quantization_enabled.return_value = True\n        node.type = DummyLayer\n        node.prior_info = Mock(min_output=-1, max_output=9)\n\n        collector = create_stats_collector_for_node(node, fw_info_mock)\n        assert isinstance(collector, StatsCollector)\n\n    def test_create_stats_collector_for_node_activation_disabled(self, fw_info_mock):\n        \"\"\"\n        Verify that for a node with activation quantization disabled,\n        create_stats_collector_for_node returns a NoStatsCollector instance.\n        \"\"\"\n        node = Mock()\n        node.is_activation_quantization_enabled.return_value = False\n        node.type = DummyLayer\n        # Even if prior_info exists, it should not be used.\n        node.prior_info = Mock(min_output=None, max_output=None)\n\n        collector = create_stats_collector_for_node(node, fw_info_mock)\n        assert isinstance(collector, NoStatsCollector)\n\n    def test_create_tensor2node_assigns_stats_collector(self, fw_info_mock):\n        \"\"\"\n        Verify that create_tensor2node assigns a new StatsCollector to a node when no valid collector exists.\n        \"\"\"\n        # Set up a fake graph and node.\n        graph = Mock()\n        node = Mock()\n        node.type = DummyLayer\n\n        # Simulate absence of an output stats collector.\n        graph.get_out_stats_collector = Mock(return_value=None)\n\n        create_tensor2node(graph, node, fw_info_mock)\n\n        # Verify that set_out_stats_collector_to_node was called with the node and a StatsCollector.\n        graph.set_out_stats_collector_to_node.assert_called_once()\n        args, _ = graph.set_out_stats_collector_to_node.call_args\n        assigned_node, assigned_collector = args\n        assert assigned_node is node\n        assert isinstance(assigned_collector, StatsCollector)\n\n\nclass TestModelCollectorInit:\n    def test_assigns_stats_collectors_to_nodes(self, fw_impl_mock, fw_info_mock):\n        \"\"\"\n        Verify that ModelCollector.__init__ assigns appropriate statistics collectors to nodes in the graph.\n        \"\"\"\n        # Create nodes with different activation quantization settings.\n        node1 = build_node('node1', output_shape=(None, 3, 14))\n        node1.is_activation_quantization_enabled = Mock(return_value=True)\n        node2 = build_node('node2', output_shape=(None, 2, 71))\n        node2.is_activation_quantization_enabled = Mock(return_value=False)\n        node3 = build_node('node3', output_shape=(None, 59))\n        node3.is_activation_quantization_enabled = Mock(return_value=True)\n\n        # Build a graph connecting the nodes.\n        graph = Graph('g',\n                      input_nodes=[node1],\n                      nodes=[node1, node2, node3],\n                      output_nodes=[OutTensor(node3, 0)],\n                      edge_list=[Edge(node1, node2, 0, 0), Edge(node2, node3, 0, 0)])\n        graph.set_out_stats_collector_to_node = Mock(wraps=graph.set_out_stats_collector_to_node)\n\n        # Simulate kernel attribute retrieval.\n        fw_info_mock.get_kernel_op_attributes.return_value = [None]\n\n        # Instantiate ModelCollector.\n        mc = ModelCollector(graph, fw_impl_mock, fw_info_mock, qc=DEFAULTCONFIG)\n\n        # Verify that stats collectors are correctly assigned.\n        graph.set_out_stats_collector_to_node.assert_called()\n        fw_impl_mock.model_builder.assert_called_once()\n        assert isinstance(graph.get_out_stats_collector(node1), StatsCollector)\n        assert isinstance(graph.get_out_stats_collector(node2), NoStatsCollector)\n        assert isinstance(graph.get_out_stats_collector(node3), StatsCollector)\n        assert isinstance(graph.get_in_stats_collector(node2), StatsCollector)\n        assert isinstance(graph.get_in_stats_collector(node3), NoStatsCollector)\n        assert mc.intermediate_output_tensors == [node1]\n        assert mc.model_outputs == [node3]\n        assert len(mc.stats_containers_list) == 2\n\n    def test_bias_correction_creates_tensor2node(self, monkeypatch, fw_impl_mock, fw_info_mock):\n        \"\"\"\n        Verify that when weights bias correction is enabled and a node has kernel weights to quantize,\n        create_tensor2node is invoked for each incoming node.\n        \"\"\"\n        # Set up nodes with quantization configurations for both activations and weights.\n        node1 = build_node('node1', output_shape=(None, 3, 14), qcs=[build_qc(4), build_qc(2)])\n        node1.is_activation_quantization_enabled = Mock(return_value=True)\n        node1.is_weights_quantization_enabled = Mock(return_value=True)\n        node2 = build_node('node2', output_shape=(None, 2, 71), qcs=[build_qc(4), build_qc(2)])\n        node2.is_activation_quantization_enabled = Mock(return_value=True)\n        node2.is_weights_quantization_enabled = Mock(return_value=True)\n        node3 = build_node('node3', output_shape=(None, 59), qcs=[build_qc(4), build_qc(2)])\n        node3.is_activation_quantization_enabled = Mock(return_value=True)\n        node3.is_weights_quantization_enabled = Mock(return_value=False)\n\n        # Build a graph connecting the nodes.\n        graph = Graph('g',\n                      input_nodes=[node1],\n                      nodes=[node1, node2, node3],\n                      output_nodes=[OutTensor(node3, 0)],\n                      edge_list=[Edge(node1, node2, 0, 0), Edge(node2, node3, 0, 0)])\n        graph.set_out_stats_collector_to_node = Mock(wraps=graph.set_out_stats_collector_to_node)\n\n        # Return a kernel attribute to trigger bias correction.\n        fw_info_mock.get_kernel_op_attributes.return_value = ['kernel']\n\n        qc = DEFAULTCONFIG\n\n        calls = []\n        # Define a fake function to record call arguments for create_tensor2node.\n        def fake_create_tensor2node(graph, node, fw_info):\n            calls.append((graph, node, fw_info))\n\n        # Patch create_tensor2node in the model_collector module.\n        monkeypatch.setattr(model_collector, \"create_tensor2node\", fake_create_tensor2node)\n\n        ModelCollector(graph, fw_impl_mock, fw_info_mock, qc=qc)\n\n        fw_impl_mock.model_builder.assert_called_once()\n        assert len(calls) == 1\n\n\nclass TestModelCollectorInfer:\n    @pytest.fixture(autouse=True)\n    def setup(self, fw_impl_mock, fw_info_mock):\n        \"\"\"\n        Fixture to set up a graph with three nodes, fake model inference outputs,\n        and a fake Hessian service for subsequent inference tests.\n        \"\"\"\n        input_shape = (1, 3, 14)\n        self.node1 = build_node('node1', output_shape=input_shape, qcs=[build_qc(4), build_qc(2)])\n        self.node1.is_activation_quantization_enabled = Mock(return_value=True)\n        self.node1.is_weights_quantization_enabled = Mock(return_value=True)\n        self.node2 = build_node('node2', output_shape=input_shape, qcs=[build_qc(4), build_qc(2)])\n        self.node2.is_activation_quantization_enabled = Mock(return_value=True)\n        self.node2.is_weights_quantization_enabled = Mock(return_value=True)\n        self.node3 = build_node('node3', output_shape=input_shape, qcs=[build_qc(4), build_qc(2)])\n        self.node3.is_activation_quantization_enabled = Mock(return_value=True)\n        self.node3.is_weights_quantization_enabled = Mock(return_value=False)\n\n        self.graph = Graph('g',\n                           input_nodes=[self.node1],\n                           nodes=[self.node1, self.node2, self.node3],\n                           output_nodes=[OutTensor(self.node3, 0)],\n                           edge_list=[Edge(self.node1, self.node2, 0, 0), Edge(self.node2, self.node3, 0, 0)])\n\n        # Simulate model inference outputs.\n        self.fake_output1 = np.random.randn(*input_shape)\n        self.fake_output2 = np.random.randn(*input_shape)\n        self.fake_output3 = np.random.randn(*input_shape)\n        fw_impl_mock.run_model_inference.return_value = [self.fake_output1, self.fake_output2, self.fake_output3]\n        fw_impl_mock.to_numpy.side_effect = lambda x: x\n\n        fw_info_mock.get_kernel_op_attributes.return_value = [None]\n\n        # Set up a fake Hessian service with a predetermined hessian result.\n        self.fake_hessian_info_service = Mock(spec_set=HessianInfoService)\n        self.fake_hessian_result = np.random.randn(*input_shape)\n        self.fake_hessian_info_service.fetch_hessian = Mock(\n            wraps=self.fake_hessian_info_service.fetch_hessian,\n            return_value={'node1': self.fake_hessian_result, 'node2': self.fake_hessian_result}\n        )\n\n        self.qc = DEFAULTCONFIG\n        self.infer_input = [np.random.randn(*input_shape)]\n\n    def test_infer_without_hessian(self, fw_impl_mock, fw_info_mock):\n        \"\"\"\n        Verify that ModelCollector.infer calls run_model_inference without fetching hessian data\n        when activation_error_method is not HMSE.\n        \"\"\"\n        self.qc.activation_error_method = QuantizationErrorMethod.MSE\n        mc = ModelCollector(self.graph, fw_impl_mock, fw_info_mock, qc=self.qc, hessian_info_service=self.fake_hessian_info_service)\n\n        mc.infer(self.infer_input)\n        # Check that inference runs without requiring gradients.\n        fw_impl_mock.run_model_inference.assert_called_once_with(mc.model, self.infer_input, requires_grad=False)\n        # Confirm that the Hessian service is not used.\n        mc.hessian_service.fetch_hessian.assert_not_called()\n\n    def test_infer_with_hessian(self, fw_impl_mock, fw_info_mock):\n        \"\"\"\n        Verify that ModelCollector.infer fetches hessian data when activation_error_method is HMSE.\n        \"\"\"\n        self.qc.activation_error_method = QuantizationErrorMethod.HMSE\n        mc = ModelCollector(self.graph, fw_impl_mock, fw_info_mock, qc=self.qc, hessian_info_service=self.fake_hessian_info_service)\n\n        mc.infer(self.infer_input)\n        # Check that inference runs with gradients enabled.\n        fw_impl_mock.run_model_inference.assert_called_once_with(mc.model, self.infer_input, requires_grad=True)\n        # Confirm that the Hessian data is fetched.\n        mc.hessian_service.fetch_hessian.assert_called_once()\n\n    def test_update_statistics_called(self, fw_impl_mock, fw_info_mock):\n        \"\"\"\n        Verify that update_statistics is called for each statistics container during inference.\n        \"\"\"\n        # Create a dummy stats container that always requires collection.\n        fake_stats_container = Mock(require_collection=lambda: True, update_statistics=Mock())\n        self.graph.get_out_stats_collector = Mock(return_value=fake_stats_container)\n        self.qc.activation_error_method = QuantizationErrorMethod.HMSE\n\n        mc = ModelCollector(self.graph, fw_impl_mock, fw_info_mock, qc=self.qc, hessian_info_service=self.fake_hessian_info_service)\n        mc.infer(self.infer_input)\n        # Check that update_statistics is called with the corresponding outputs and hessian data.\n        calls = fake_stats_container.update_statistics.call_args_list\n\n        assert_array_equal(calls[0][0][0], self.fake_output1)\n        assert_array_equal(calls[0][0][1], np.abs(self.fake_hessian_result))\n\n        assert_array_equal(calls[1][0][0], self.fake_output2)\n        assert_array_equal(calls[1][0][1], np.abs(self.fake_hessian_result))\n\n        assert calls[2][0][0] is self.fake_output3\n        assert calls[2][0][1] is None"
