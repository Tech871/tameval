[meta]
task = "repair"
scenario = "repair_duplicate_entity"

[lang_info]
lang = "Go"
go_version = "1.22"

[repo_info]
repository = "aaydin-tr/divisor"
sha = "be1010bf44bd1fcf47537b6a7423b664e5016985"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out core/ip-hash/ip-hash.go core/ip-hash/ip-hash_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting core/ip-hash/ip-hash.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 95.0
mutation_kill_rate = nan
original_mutation_kill_rate = 58.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "core/ip-hash/ip-hash_test.go"
focal_file_path = "core/ip-hash/ip-hash.go"
test_file_url = "https://github.com/aaydin-tr/divisor/blob/be1010bf44bd1fcf47537b6a7423b664e5016985/core/ip-hash/ip-hash_test.go"
focal_file_url = "https://github.com/aaydin-tr/divisor/blob/be1010bf44bd1fcf47537b6a7423b664e5016985/core/ip-hash/ip-hash.go"
first_commit_date = "2022-11-06"
last_commit_date = "2025-06-08"
test_file_content = "package ip_hash\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/aaydin-tr/divisor/mocks\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/valyala/fasthttp\"\n)\n\nfunc TestNewIPHash(t *testing.T) {\n\tfor _, ip := range mocks.TestCases {\n\t\tif ip.ExpectedServerCount == 0 {\n\t\t\tipHash := NewIPHash(&ip.Config, ip.ProxyFunc)\n\t\t\tassert.Nil(t, ipHash)\n\t\t} else {\n\t\t\tipHash := NewIPHash(&ip.Config, ip.ProxyFunc).(*IPHash)\n\t\t\tassert.Equal(t, ip.ExpectedServerCount, len(ipHash.serversMap))\n\t\t}\n\t}\n}\n\nfunc TestNewIPHash(t *testing.T) {\n\tfor _, ip := range mocks.TestCases {\n\t\tif ip.ExpectedServerCount == 0 {\n\t\t\tipHash := NewIPHash(&ip.Config, ip.ProxyFunc)\n\t\t\tassert.Nil(t, ipHash)\n\t\t} else {\n\t\t\tipHash := NewIPHash(&ip.Config, ip.ProxyFunc).(*IPHash)\n\t\t\tassert.Equal(t, ip.ExpectedServerCount, len(ipHash.serversMap))\n\t\t}\n\t}\n}\n\nfunc TestGet(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tbalancer := NewIPHash(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\tipHash := balancer.(*IPHash)\n\tproxy := ipHash.get(caseOne.Config.HashFunc([]byte{1, 2, 3}))\n\n\tassert.IsType(t, &mocks.MockProxy{}, proxy)\n}\n\nfunc TestGet(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tbalancer := NewIPHash(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\tipHash := balancer.(*IPHash)\n\tproxy := ipHash.get(caseOne.Config.HashFunc([]byte{1, 2, 3}))\n\n\tassert.IsType(t, &mocks.MockProxy{}, proxy)\n}\n\nfunc TestServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[1]\n\tbalancer := NewIPHash(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\tipHash := balancer.(*IPHash)\n\thandlerFunc := ipHash.Serve()\n\n\tctx := fasthttp.RequestCtx{\n\t\tRequest: *fasthttp.AcquireRequest(),\n\t}\n\n\tproxy := ipHash.get(caseOne.Config.HashFunc([]byte{1})).(*mocks.MockProxy)\n\tassert.False(t, proxy.IsCalled, \"expected Server func not be called, but it was called\")\n\thandlerFunc(&ctx)\n\tassert.True(t, proxy.IsCalled, \"expected Server func to be called, but it wasn't\")\n}\n\nfunc TestServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[1]\n\tbalancer := NewIPHash(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\tipHash := balancer.(*IPHash)\n\thandlerFunc := ipHash.Serve()\n\n\tctx := fasthttp.RequestCtx{\n\t\tRequest: *fasthttp.AcquireRequest(),\n\t}\n\n\tproxy := ipHash.get(caseOne.Config.HashFunc([]byte{1})).(*mocks.MockProxy)\n\tassert.False(t, proxy.IsCalled, \"expected Server func not be called, but it was called\")\n\thandlerFunc(&ctx)\n\tassert.True(t, proxy.IsCalled, \"expected Server func to be called, but it wasn't\")\n}\n\nfunc TestStats(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tbalancer := NewIPHash(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\tipHash := balancer.(*IPHash)\n\tstats := ipHash.Stats()\n\n\tfor i, backend := range caseOne.Config.Backends {\n\t\thash := ipHash.hashFunc([]byte(backend.Url + strconv.Itoa(i)))\n\t\ts := ipHash.serversMap[hash]\n\n\t\tassert.Equal(t, s.node.Addr, stats[i].Addr)\n\t\tassert.Equal(t, hash, stats[i].BackendHash)\n\t}\n}\n\nfunc TestStats(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tbalancer := NewIPHash(&caseOne.Config, caseOne.ProxyFunc)\n\tassert.NotNil(t, balancer)\n\n\tipHash := balancer.(*IPHash)\n\tstats := ipHash.Stats()\n\n\tfor i, backend := range caseOne.Config.Backends {\n\t\thash := ipHash.hashFunc([]byte(backend.Url + strconv.Itoa(i)))\n\t\ts := ipHash.serversMap[hash]\n\n\t\tassert.Equal(t, s.node.Addr, stats[i].Addr)\n\t\tassert.Equal(t, hash, stats[i].BackendHash)\n\t}\n}\n\nfunc TestHealthChecker(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tipHash := &IPHash{stopHealthChecker: make(chan bool)}\n\n\tipHash.isHostAlive = func(s string) bool {\n\t\tgo func() {\n\t\t\tipHash.stopHealthChecker <- true\n\t\t}()\n\t\treturn false\n\t}\n\tipHash.hashFunc = func(b []byte) uint32 {\n\t\treturn 0\n\t}\n\n\tcaseOne.Config.HealthCheckerTime = 1\n\tipHash.healthChecker(caseOne.Config.Backends)\n}\n\nfunc TestHealthChecker(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tipHash := &IPHash{stopHealthChecker: make(chan bool)}\n\n\tipHash.isHostAlive = func(s string) bool {\n\t\tgo func() {\n\t\t\tipHash.stopHealthChecker <- true\n\t\t}()\n\t\treturn false\n\t}\n\tipHash.hashFunc = func(b []byte) uint32 {\n\t\treturn 0\n\t}\n\n\tcaseOne.Config.HealthCheckerTime = 1\n\tipHash.healthChecker(caseOne.Config.Backends)\n}\n\nfunc TestRemoveOneServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tipHash := NewIPHash(&caseOne.Config, caseOne.ProxyFunc).(*IPHash)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(ipHash.serversMap))\n\tbackend := caseOne.Config.Backends[0]\n\tif b, ok := ipHash.serversMap[ipHash.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\tipHash.isHostAlive = func(s string) bool {\n\t\t\treturn false\n\t\t}\n\t\toldServerCount := ipHash.len\n\t\tipHash.healthCheck(backend, 0)\n\n\t\tassert.False(t, b.isHostAlive, \"expected isHostAlive equal to false, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, oldServerCount, ipHash.len, \"expected server to be removed after health check, but it did not.\")\n\t}\n\n}\n\nfunc TestRemoveOneServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tipHash := NewIPHash(&caseOne.Config, caseOne.ProxyFunc).(*IPHash)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(ipHash.serversMap))\n\tbackend := caseOne.Config.Backends[0]\n\tif b, ok := ipHash.serversMap[ipHash.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\tipHash.isHostAlive = func(s string) bool {\n\t\t\treturn false\n\t\t}\n\t\toldServerCount := ipHash.len\n\t\tipHash.healthCheck(backend, 0)\n\n\t\tassert.False(t, b.isHostAlive, \"expected isHostAlive equal to false, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, oldServerCount, ipHash.len, \"expected server to be removed after health check, but it did not.\")\n\t}\n\n}\n\nfunc TestRemoveAndAddServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tipHash := NewIPHash(&caseOne.Config, caseOne.ProxyFunc).(*IPHash)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(ipHash.serversMap))\n\tbackend := caseOne.Config.Backends[0]\n\tif b, ok := ipHash.serversMap[ipHash.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\tipHash.isHostAlive = func(s string) bool {\n\t\t\treturn false\n\t\t}\n\t\toldServerCount := ipHash.len\n\t\tipHash.healthCheck(backend, 0)\n\n\t\tassert.False(t, b.isHostAlive, \"expected isHostAlive equal to false, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, oldServerCount, ipHash.len, \"expected server to be removed after health check, but it did not.\")\n\t}\n\tif b, ok := ipHash.serversMap[ipHash.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\tb.isHostAlive = false\n\t\tipHash.isHostAlive = func(s string) bool {\n\t\t\treturn true\n\t\t}\n\n\t\toldServerCount := ipHash.len\n\t\tipHash.healthCheck(backend, 0)\n\n\t\tassert.True(t, b.isHostAlive, \"expected isHostAlive equal to true, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, ipHash.len, oldServerCount, \"expected server to be added after health check, but it did not.\")\n\n\t}\n}\n\nfunc TestRemoveAndAddServer(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tipHash := NewIPHash(&caseOne.Config, caseOne.ProxyFunc).(*IPHash)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(ipHash.serversMap))\n\tbackend := caseOne.Config.Backends[0]\n\tif b, ok := ipHash.serversMap[ipHash.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\tipHash.isHostAlive = func(s string) bool {\n\t\t\treturn false\n\t\t}\n\t\toldServerCount := ipHash.len\n\t\tipHash.healthCheck(backend, 0)\n\n\t\tassert.False(t, b.isHostAlive, \"expected isHostAlive equal to false, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, oldServerCount, ipHash.len, \"expected server to be removed after health check, but it did not.\")\n\t}\n\tif b, ok := ipHash.serversMap[ipHash.hashFunc([]byte(backend.Url+strconv.Itoa(0)))]; ok {\n\t\tb.isHostAlive = false\n\t\tipHash.isHostAlive = func(s string) bool {\n\t\t\treturn true\n\t\t}\n\n\t\toldServerCount := ipHash.len\n\t\tipHash.healthCheck(backend, 0)\n\n\t\tassert.True(t, b.isHostAlive, \"expected isHostAlive equal to true, but got %v\", b.isHostAlive)\n\t\tassert.GreaterOrEqual(t, ipHash.len, oldServerCount, \"expected server to be added after health check, but it did not.\")\n\n\t}\n}\n\nfunc TestRemmoveAllServers(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tipHash := NewIPHash(&caseOne.Config, caseOne.ProxyFunc).(*IPHash)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(ipHash.serversMap))\n\tfor i, backend := range caseOne.Config.Backends {\n\t\tif _, ok := ipHash.serversMap[ipHash.hashFunc([]byte(backend.Url+strconv.Itoa(i)))]; ok {\n\t\t\tipHash.isHostAlive = func(s string) bool {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\toldServerCount := ipHash.len\n\t\t\tif oldServerCount == 1 {\n\t\t\t\tassert.Panics(t, func() {\n\t\t\t\t\tipHash.healthCheck(backend, i)\n\t\t\t\t}, \"expected panic after remove all servers\")\n\n\t\t\t} else {\n\t\t\t\tipHash.healthCheck(backend, i)\n\t\t\t\tassert.GreaterOrEqual(t, oldServerCount, ipHash.len, \"expected server to be removed after health check, but it did not.\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestRemmoveAllServers(t *testing.T) {\n\tcaseOne := mocks.TestCases[0]\n\tipHash := NewIPHash(&caseOne.Config, caseOne.ProxyFunc).(*IPHash)\n\tassert.Equal(t, caseOne.ExpectedServerCount, len(ipHash.serversMap))\n\tfor i, backend := range caseOne.Config.Backends {\n\t\tif _, ok := ipHash.serversMap[ipHash.hashFunc([]byte(backend.Url+strconv.Itoa(i)))]; ok {\n\t\t\tipHash.isHostAlive = func(s string) bool {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\toldServerCount := ipHash.len\n\t\t\tif oldServerCount == 1 {\n\t\t\t\tassert.Panics(t, func() {\n\t\t\t\t\tipHash.healthCheck(backend, i)\n\t\t\t\t}, \"expected panic after remove all servers\")\n\n\t\t\t} else {\n\t\t\t\tipHash.healthCheck(backend, i)\n\t\t\t\tassert.GreaterOrEqual(t, oldServerCount, ipHash.len, \"expected server to be removed after health check, but it did not.\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestShutdown(t *testing.T) {\n\tt.Run(\"shutdown calls close on all proxies\", func(t *testing.T) {\n\t\tcaseOne := mocks.TestCases[0]\n\t\tipHash := NewIPHash(&caseOne.Config, caseOne.ProxyFunc).(*IPHash)\n\t\tassert.NotNil(t, ipHash)\n\t\tfor _, sm := range ipHash.serversMap {\n\t\t\tmockProxy := sm.node.Proxy.(*mocks.MockProxy)\n\t\t\tassert.False(t, mockProxy.CloseCalled, \"Proxy Close() should not be called before shutdown\")\n\t\t}\n\t\terr := ipHash.Shutdown()\n\t\tassert.NoError(t, err, \"Shutdown() should not return an error\")\n\t\tfor _, sm := range ipHash.serversMap {\n\t\t\tmockProxy := sm.node.Proxy.(*mocks.MockProxy)\n\t\t\tassert.True(t, mockProxy.CloseCalled, \"Proxy Close() should be called during shutdown\")\n\t\t}\n\t})\n\n\tt.Run(\"shutdown with no servers\", func(t *testing.T) {\n\t\temptyCase := mocks.TestCases[3]\n\t\temptyIPHash := NewIPHash(&emptyCase.Config, emptyCase.ProxyFunc)\n\t\tif emptyIPHash != nil {\n\t\t\terr := emptyIPHash.Shutdown()\n\t\t\tassert.NoError(t, err, \"Shutdown() should not return an error even with no servers\")\n\t\t}\n\t})\n\n\tt.Run(\"shutdown with actual health checker goroutine\", func(t *testing.T) {\n\t\tcaseOne := mocks.TestCases[0]\n\t\tcaseOne.Config.HealthCheckerTime = 100 * time.Millisecond\n\t\tipHash := NewIPHash(&caseOne.Config, caseOne.ProxyFunc).(*IPHash)\n\t\tassert.NotNil(t, ipHash)\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\terr := ipHash.Shutdown()\n\t\tassert.NoError(t, err, \"Shutdown() should not return an error\")\n\t\tfor _, sm := range ipHash.serversMap {\n\t\t\tmockProxy := sm.node.Proxy.(*mocks.MockProxy)\n\t\t\tassert.True(t, mockProxy.CloseCalled, \"Proxy Close() should be called during shutdown\")\n\t\t}\n\t\ttime.Sleep(150 * time.Millisecond)\n\t})\n}\n\nfunc TestShutdown(t *testing.T) {\n\tt.Run(\"shutdown calls close on all proxies\", func(t *testing.T) {\n\t\tcaseOne := mocks.TestCases[0]\n\t\tipHash := NewIPHash(&caseOne.Config, caseOne.ProxyFunc).(*IPHash)\n\t\tassert.NotNil(t, ipHash)\n\t\tfor _, sm := range ipHash.serversMap {\n\t\t\tmockProxy := sm.node.Proxy.(*mocks.MockProxy)\n\t\t\tassert.False(t, mockProxy.CloseCalled, \"Proxy Close() should not be called before shutdown\")\n\t\t}\n\t\terr := ipHash.Shutdown()\n\t\tassert.NoError(t, err, \"Shutdown() should not return an error\")\n\t\tfor _, sm := range ipHash.serversMap {\n\t\t\tmockProxy := sm.node.Proxy.(*mocks.MockProxy)\n\t\t\tassert.True(t, mockProxy.CloseCalled, \"Proxy Close() should be called during shutdown\")\n\t\t}\n\t})\n\n\tt.Run(\"shutdown with no servers\", func(t *testing.T) {\n\t\temptyCase := mocks.TestCases[3]\n\t\temptyIPHash := NewIPHash(&emptyCase.Config, emptyCase.ProxyFunc)\n\t\tif emptyIPHash != nil {\n\t\t\terr := emptyIPHash.Shutdown()\n\t\t\tassert.NoError(t, err, \"Shutdown() should not return an error even with no servers\")\n\t\t}\n\t})\n\n\tt.Run(\"shutdown with actual health checker goroutine\", func(t *testing.T) {\n\t\tcaseOne := mocks.TestCases[0]\n\t\tcaseOne.Config.HealthCheckerTime = 100 * time.Millisecond\n\t\tipHash := NewIPHash(&caseOne.Config, caseOne.ProxyFunc).(*IPHash)\n\t\tassert.NotNil(t, ipHash)\n\t\ttime.Sleep(50 * time.Millisecond)\n\t\terr := ipHash.Shutdown()\n\t\tassert.NoError(t, err, \"Shutdown() should not return an error\")\n\t\tfor _, sm := range ipHash.serversMap {\n\t\t\tmockProxy := sm.node.Proxy.(*mocks.MockProxy)\n\t\t\tassert.True(t, mockProxy.CloseCalled, \"Proxy Close() should be called during shutdown\")\n\t\t}\n\t\ttime.Sleep(150 * time.Millisecond)\n\t})\n}"
