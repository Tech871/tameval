[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Java"
java_builder = "Maven"
is_multi_module = true

[repo_info]
repository = "LearnLib/automatalib"
sha = "125bd7267571158b87da3e5dbe92f505ce1729a5"

[run_info]
docker_image = "maven:3.8.3-openjdk-17"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "mvn -Dmaven.repo.local=/.m2 -T 4 clean install"
test_run_command = "mvn clean -Dmaven.repo.local=/.m2 test -q -pl util -Dtest=WpMethodTestsIteratorTest && mvn jacoco:report -Djacoco.append=false"
mutation_run_command = "mvn -Dmaven.repo.local=/.m2 org.pitest:pitest-maven:mutationCoverage -pl util -DtargetClasses=**.WpMethodTestsIterator  -DtargetTests=**.WpMethodTestsIteratorTest  -DoutputFormats=XML"
coverage_report_path = "util/target/site/jacoco/jacoco.xml"
coverage_report_type = "jacoco"
mutation_report_path = "util/target/pit-reports/mutations.xml"
mutation_report_type = "pitest"

[coverage]
coverage = 91.0
original_coverage = 91.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = [ 76, 78, 79, 81, 83, 87, 92, 93, 97, 98, 101, 105, 106, 110, 115, 124, 126, 127, 128, 132, 137, 142, 143, 160, 162, 163, 164, 165, 166, 170, 177, 179, 181, 183, 184, 185, 188, 191, 196, 197,]
missed_lines = [ 61, 62, 88, 186,]

[input_info]
test_file_path = "util/src/test/java/net/automatalib/util/automaton/conformance/WpMethodTestsIteratorTest.java"
focal_file_path = "util/src/main/java/net/automatalib/util/automaton/conformance/WpMethodTestsIterator.java"
test_file_url = "https://github.com/LearnLib/automatalib/blob/125bd7267571158b87da3e5dbe92f505ce1729a5/util/src/test/java/net/automatalib/util/automaton/conformance/WpMethodTestsIteratorTest.java"
focal_file_url = "https://github.com/LearnLib/automatalib/blob/125bd7267571158b87da3e5dbe92f505ce1729a5/util/src/main/java/net/automatalib/util/automaton/conformance/WpMethodTestsIterator.java"
first_commit_date = "2023-10-10"
last_commit_date = "2025-01-16"
test_file_content = "/* Copyright (C) 2013-2025 TU Dortmund University\n * This file is part of AutomataLib <https://automatalib.net>.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.automatalib.util.automaton.conformance;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.stream.Collectors;\n\nimport net.automatalib.alphabet.Alphabet;\nimport net.automatalib.alphabet.impl.Alphabets;\nimport net.automatalib.automaton.UniversalDeterministicAutomaton;\nimport net.automatalib.automaton.fsa.impl.CompactDFA;\nimport net.automatalib.common.util.collection.IterableUtil;\nimport net.automatalib.common.util.collection.IteratorUtil;\nimport net.automatalib.common.util.comparison.CmpUtil;\nimport net.automatalib.util.automaton.cover.Covers;\nimport net.automatalib.util.automaton.equivalence.CharacterizingSets;\nimport net.automatalib.util.automaton.random.RandomAutomata;\nimport net.automatalib.word.Word;\nimport org.testng.Assert;\nimport org.testng.annotations.Test;\n\npublic class WpMethodTestsIteratorTest {\n\n    private final Alphabet<Integer> alphabet = Alphabets.integers(0, 5);\n    private final CompactDFA<Integer> dfa = RandomAutomata.randomDFA(new Random(42), 10, alphabet);\n\n\n\n    @Test\n    public void testIteratorWithMiddleParts() {\n\n        final int depth = 3;\n\n        final List<Word<Integer>> iteratorWords = IteratorUtil.list(new WpMethodTestsIterator<>(dfa, alphabet, depth));\n        final List<Word<Integer>> wpMethodWords = generateWpMethodTest(dfa,\n                                                                       alphabet,\n                                                                       IterableUtil.stream(IterableUtil.allTuples(\n                                                                                           alphabet,\n                                                                                           0,\n                                                                                           depth))\n                                                                                   .map(Word::fromList)\n                                                                                   .collect(Collectors.toList()));\n\n        checkTestWords(iteratorWords, wpMethodWords);\n    }\n\n    private <I extends Comparable<I>> void checkTestWords(List<Word<I>> actual, List<Word<I>> expected) {\n        actual.sort(CmpUtil.lexComparator());\n        expected.sort(CmpUtil.lexComparator());\n\n        Assert.assertEquals(actual, expected);\n\n    }\n\n    private <S, I> List<Word<I>> generateWpMethodTest(UniversalDeterministicAutomaton<S, I, ?, ?, ?> automaton,\n                                                      Collection<? extends I> inputs,\n                                                      List<Word<I>> middleParts) {\n\n        final List<Word<I>> stateCover = new ArrayList<>(automaton.size());\n        final List<Word<I>> transitionCover = new ArrayList<>(automaton.size() * inputs.size());\n        final List<Word<I>> characterizingSet = new ArrayList<>();\n\n        Covers.cover(automaton, inputs, stateCover, transitionCover);\n        CharacterizingSets.findCharacterizingSet(automaton, inputs, characterizingSet);\n\n        Assert.assertFalse(stateCover.isEmpty());\n        Assert.assertFalse(transitionCover.isEmpty());\n        Assert.assertFalse(characterizingSet.isEmpty());\n\n        final List<Word<I>> result = new ArrayList<>();\n\n        // Phase 1: state cover * middle part * global suffixes\n        for (Word<I> sc : stateCover) {\n            for (Word<I> mp : middleParts) {\n                for (Word<I> cs : characterizingSet) {\n                    result.add(Word.fromWords(sc, mp, cs));\n                }\n            }\n        }\n\n        // Phase 2: transitions (not in state cover) * middle part * local suffixes\n        transitionCover.removeAll(stateCover);\n\n        for (Word<I> prefix : transitionCover) {\n            for (Word<I> middle : middleParts) {\n                final Word<I> prefixWithMiddle = prefix.concat(middle);\n                final S s = automaton.getState(prefixWithMiddle);\n\n                final List<Word<I>> suffixes = new ArrayList<>();\n                CharacterizingSets.findCharacterizingSet(automaton, inputs, s, suffixes);\n                assert !suffixes.isEmpty();\n\n                for (Word<I> suffix : suffixes) {\n                    result.add(prefixWithMiddle.concat(suffix));\n                }\n            }\n        }\n\n        return result;\n    }\n}\n"
