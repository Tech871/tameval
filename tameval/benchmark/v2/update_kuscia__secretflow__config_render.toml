[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.22"

[repo_info]
repository = "secretflow/kuscia"
sha = "5386c4265acf18857c87aa008d13bb6fda2d828e"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/agent/middleware/plugins/hook/configrender/config_render.go pkg/agent/middleware/plugins/hook/configrender/config_render_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/agent/middleware/plugins/hook/configrender/config_render.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 57.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "pkg/agent/middleware/plugins/hook/configrender/config_render_test.go"
focal_file_path = "pkg/agent/middleware/plugins/hook/configrender/config_render.go"
test_file_url = "https://github.com/secretflow/kuscia/blob/5386c4265acf18857c87aa008d13bb6fda2d828e/pkg/agent/middleware/plugins/hook/configrender/config_render_test.go"
focal_file_url = "https://github.com/secretflow/kuscia/blob/5386c4265acf18857c87aa008d13bb6fda2d828e/pkg/agent/middleware/plugins/hook/configrender/config_render.go"
first_commit_date = "2023-06-14"
last_commit_date = "2025-02-19"
test_file_content = "// Copyright 2023 Ant Group Co., Ltd.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage configrender\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"text/template\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"google.golang.org/protobuf/encoding/protojson\"\n\t\"gopkg.in/yaml.v3\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\tkubefake \"k8s.io/client-go/kubernetes/fake\"\n\n\t\"github.com/secretflow/kuscia/pkg/agent/config\"\n\tpkgcontainer \"github.com/secretflow/kuscia/pkg/agent/container\"\n\t\"github.com/secretflow/kuscia/pkg/agent/middleware/hook\"\n\t\"github.com/secretflow/kuscia/pkg/agent/middleware/plugin\"\n\tresourcetest \"github.com/secretflow/kuscia/pkg/agent/resource/testing\"\n\t\"github.com/secretflow/kuscia/pkg/common\"\n\t\"github.com/secretflow/kuscia/pkg/utils/nlog\"\n\t\"github.com/secretflow/kuscia/pkg/utils/tls\"\n\t\"github.com/secretflow/kuscia/proto/api/v1alpha1/appconfig\"\n)\n\nfunc setupTestConfigRender(t *testing.T) *configRender {\n\tconfigYaml := `\nname: \"config-render\"\nconfig:\n`\n\tcfg := &config.PluginCfg{}\n\tassert.NoError(t, yaml.Unmarshal([]byte(configYaml), cfg))\n\n\tprivateKey, err := rsa.GenerateKey(rand.Reader, 1024)\n\tassert.NoError(t, err)\n\n\tencValue, err := tls.EncryptOAEP(&privateKey.PublicKey, []byte(`{\"user\": \"kuscia\", \"host\": \"localhost\"}`))\n\tassert.NoError(t, err)\n\n\tconfigmap := corev1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tNamespace: \"alice\",\n\t\t\tName:      \"domain-config\",\n\t\t},\n\t\tData: map[string]string{\n\t\t\t\"DB_INFO\": encValue,\n\t\t},\n\t}\n\tkubeClient := kubefake.NewSimpleClientset(&configmap)\n\tagentConfig := config.DefaultAgentConfig(common.DefaultKusciaHomePath)\n\tagentConfig.Namespace = \"alice\"\n\tagentConfig.DomainKey = privateKey\n\tdep := &plugin.Dependencies{\n\t\tAgentConfig: agentConfig,\n\t\tKubeClient:  kubeClient,\n\t}\n\n\tr := &configRender{}\n\tassert.Equal(t, hook.PluginType, r.Type())\n\tassert.NoError(t, r.Init(context.Background(), dep, cfg))\n\n\treturn r\n}\n\nfunc TestConfigRender_ExecHookWithMakeMountsContext(t *testing.T) {\n\trootDir := t.TempDir()\n\thostPath := filepath.Join(rootDir, \"test.conf\")\n\ttemplateData := \"{{.KEY_A}}-{{.KEY_B}}\"\n\tassert.NoError(t, os.WriteFile(hostPath, []byte(templateData), 0644))\n\n\tpod := &corev1.Pod{}\n\tpod.Annotations = map[string]string{\n\t\t\"kuscia.secretflow/config-template-volumes\": \"config-template\",\n\t}\n\tcontainer := corev1.Container{Name: \"test-container\"}\n\tpod.Spec.Containers = []corev1.Container{container}\n\n\tmount := corev1.VolumeMount{Name: \"config-template\", SubPath: \"test.conf\"}\n\n\tctx := &hook.MakeMountsContext{\n\t\tPod:           pod,\n\t\tContainer:     &container,\n\t\tHostPath:      &hostPath,\n\t\tMount:         &mount,\n\t\tEnvs:          []pkgcontainer.EnvVar{{Name: \"key_a\", Value: \"aaa\"}, {Name: \"key_b\", Value: \"bbb\"}},\n\t\tPodVolumesDir: rootDir,\n\t}\n\n\tcr := setupTestConfigRender(t)\n\tassert.Equal(t, true, cr.CanExec(ctx))\n\t_, err := cr.ExecHook(ctx)\n\tassert.NoError(t, err)\n\tassert.Equal(t, filepath.Join(rootDir, \"config-render\", container.Name, mount.Name, mount.SubPath), hostPath)\n\tassertFileContent(t, hostPath, \"aaa-bbb\")\n}\n\nfunc TestConfigRender_ExecHookWithSyncPodContext(t *testing.T) {\n\tpodConfig := &corev1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"config-template\",\n\t\t\tNamespace: \"test-namespace\",\n\t\t},\n\t\tData: map[string]string{\n\t\t\t\"config.yaml\": \"aa={{.AA}}\",\n\t\t},\n\t}\n\n\tpod := &corev1.Pod{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tUID:       \"abc\",\n\t\t\tName:      \"pod01\",\n\t\t\tNamespace: \"test-namespace\",\n\t\t\tAnnotations: map[string]string{\n\t\t\t\t\"kuscia.secretflow/config-template-volumes\": \"config-template\",\n\t\t\t},\n\t\t},\n\t\tSpec: corev1.PodSpec{\n\t\t\tContainers: []corev1.Container{\n\t\t\t\t{\n\t\t\t\t\tName:    \"ctr01\",\n\t\t\t\t\tCommand: []string{\"sleep 60\"},\n\t\t\t\t\tImage:   \"aa/bb:001\",\n\t\t\t\t\tEnv: []corev1.EnvVar{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName:  \"AA\",\n\t\t\t\t\t\t\tValue: \"BB\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tVolumes: []corev1.Volume{\n\t\t\t\t{\n\t\t\t\t\tName: \"config-template\",\n\t\t\t\t\tVolumeSource: corev1.VolumeSource{\n\t\t\t\t\t\tConfigMap: &corev1.ConfigMapVolumeSource{\n\t\t\t\t\t\t\tLocalObjectReference: corev1.LocalObjectReference{\n\t\t\t\t\t\t\t\tName: \"config-template\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\trm := resourcetest.FakeResourceManager(\"test-namespace\", podConfig)\n\n\tbkPod := pod.DeepCopy()\n\tbkPod.Namespace = \"bk-namespace\"\n\tctx := &hook.K8sProviderSyncPodContext{\n\t\tPod:             pod,\n\t\tBkPod:           bkPod,\n\t\tResourceManager: rm,\n\t}\n\n\tcr := setupTestConfigRender(t)\n\tassert.Equal(t, true, cr.CanExec(ctx))\n\t_, err := cr.ExecHook(ctx)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, 1, len(ctx.Configmaps))\n\tassert.Equal(t, \"aa=BB\", ctx.Configmaps[0].Data[\"config.yaml\"])\n}\n\nfunc TestConfigRender_renderConfigDirectory(t *testing.T) {\n\trootDir := t.TempDir()\n\ttemplateDir := filepath.Join(rootDir, \"template\")\n\ttemplateSubDir := filepath.Join(templateDir, \"sub\")\n\tassert.NoError(t, os.MkdirAll(templateSubDir, 0755))\n\tassert.NoError(t, os.WriteFile(filepath.Join(templateDir, \"a.conf\"), []byte(\"{{.KEY_A}}\"), 0644))\n\tassert.NoError(t, os.WriteFile(filepath.Join(templateSubDir, \"b.conf\"), []byte(\"{{.KEY_B}}\"), 0644))\n\n\tcr := setupTestConfigRender(t)\n\n\tdata := map[string]string{\n\t\t\"KEY_A\": \"aaa\",\n\t\t\"KEY_B\": \"bbb\",\n\t}\n\tassert.NoError(t, cr.renderConfigDirectory(templateDir, rootDir, data))\n\tassertFileContent(t, filepath.Join(rootDir, \"a.conf\"), \"aaa\")\n\tassertFileContent(t, filepath.Join(rootDir, \"sub\", \"b.conf\"), \"bbb\")\n}\n\nfunc assertFileContent(t *testing.T, file string, content string) {\n\tfileContent, err := os.ReadFile(file)\n\tassert.NoError(t, err)\n\tassert.Equal(t, content, string(fileContent))\n}\n\nfunc TestConfigFormat(t *testing.T) {\n\tt.Parallel()\n\tcr := setupTestConfigRender(t)\n\n\ttests := []struct {\n\t\ttemplateContent string\n\t\tformat          string\n\t}{\n\t\t{\n\t\t\ttemplateContent: `\n{\n\t\"task_id\": \"{{.TASK_ID}}\",\n\t\"task_cluster_define\": \"{{.TASK_CLUSTER_DEFINE}}\"\n}`,\n\t\t\tformat: \"json\",\n\t\t},\n\t\t{\n\t\t\ttemplateContent: `\ntask_id: \"{{.TASK_ID}}\"\ntask_cluster_define: \"{{.TASK_CLUSTER_DEFINE}}\"\n`,\n\t\t\tformat: \"yaml\",\n\t\t},\n\t}\n\n\ttaskClusterDefine := map[string]string{\n\t\t\"alice\": \"test.alice.svc\",\n\t\t\"bob\":   \"test.bob.svc\",\n\t}\n\ttaskInputConfigBytes, err := json.Marshal(taskClusterDefine)\n\tassert.NoError(t, err)\n\tenvs := map[string]string{\n\t\t\"TASK_ID\":             \"abc\",\n\t\t\"TASK_CLUSTER_DEFINE\": string(taskInputConfigBytes),\n\t}\n\tdata, err := cr.makeDataMap(map[string]string{}, envs)\n\tassert.NoError(t, err)\n\tt.Logf(\"%+v\", data)\n\n\tfor i, tt := range tests {\n\t\tt.Run(fmt.Sprintf(\"Test %d with %s format\", i, tt.format), func(t *testing.T) {\n\t\t\trootDir := t.TempDir()\n\n\t\t\ttemplateFile := filepath.Join(rootDir, \"template.conf\")\n\t\t\tassert.NoError(t, os.WriteFile(templateFile, []byte(tt.templateContent), 0644))\n\n\t\t\tconfigFile := filepath.Join(rootDir, \"file.conf\")\n\n\t\t\tassert.NoError(t, cr.renderConfigFile(templateFile, configFile, data))\n\n\t\t\tf, err := os.ReadFile(configFile)\n\t\t\tassert.NoError(t, err)\n\t\t\tconf := map[string]string{}\n\n\t\t\tswitch tt.format {\n\t\t\tcase \"json\":\n\t\t\t\tassert.NoError(t, json.Unmarshal(f, &conf))\n\t\t\tcase \"yaml\":\n\t\t\t\tassert.NoError(t, yaml.Unmarshal(f, &conf))\n\t\t\tdefault:\n\t\t\t\tt.Error(\"Invalid config format\", tt.format)\n\t\t\t}\n\n\t\t\tt.Logf(\"%+v\", conf)\n\n\t\t\ttaskClusterDefineConf := map[string]string{}\n\t\t\tassert.NoError(t, json.Unmarshal([]byte(conf[\"task_cluster_define\"]), &taskClusterDefineConf))\n\n\t\t\tassert.Equal(t, taskClusterDefine, taskClusterDefineConf)\n\t\t\tassert.Equal(t, \"abc\", conf[\"task_id\"])\n\t\t})\n\t}\n}\n\nfunc TestMergeDataMaps_WithJsonMap(t *testing.T) {\n\tt.Parallel()\n\tdst := buildStructMap(map[string]string{\n\t\t\"KEY1\": \"{\\\"xyz\\\":1}\",\n\t\t\"KEY2\": \"124\",\n\t})\n\n\tassert.Len(t, dst, 2)\n\tassert.Contains(t, dst, \"KEY1\")\n\tassert.Contains(t, dst, \"KEY2\")\n\n\tassert.Contains(t, dst[\"KEY1\"], \"xyz\")\n\tassert.Equal(t, dst[\"KEY1\"].(map[string]interface{})[\"xyz\"], float64(1))\n}\n\nfunc TestBuildStructMap_WithJsonArray(t *testing.T) {\n\tt.Parallel()\n\tdst := buildStructMap(map[string]string{\n\t\t\"KEY1\": \"[1,2,3]\",\n\t\t\"KEY2\": \"[\\\"1\\\"]\",\n\t})\n\n\tassert.Len(t, dst, 2)\n\tassert.Contains(t, dst, \"KEY1\")\n\tassert.Contains(t, dst, \"KEY2\")\n\n\tassert.Len(t, dst[\"KEY1\"], 3)\n\tassert.Len(t, dst[\"KEY2\"], 1)\n\tassert.Len(t, dst[\"KEY2\"], 1)\n\tassert.Equal(t, dst[\"KEY1\"], []interface{}{float64(1), float64(2), float64(3)})\n\tassert.Equal(t, dst[\"KEY2\"], []interface{}{\"1\"})\n}\n\nfunc TestBuildStructMap_WithJsonMapArray(t *testing.T) {\n\tt.Parallel()\n\tdst := buildStructMap(map[string]string{\n\t\t\"KEY3\": \"[{\\\"xyz\\\":\\\"1\\\"}]\",\n\t\t\"KEY4\": \"{\\\"xyz\\\":[\\\"2\\\"]}\",\n\t})\n\n\tassert.Len(t, dst, 2)\n\tassert.Contains(t, dst, \"KEY3\")\n\tassert.Contains(t, dst, \"KEY4\")\n\n\tassert.Len(t, dst[\"KEY3\"], 1)\n\tassert.NotNil(t, dst[\"KEY3\"].([]interface{})[0])\n\tassert.Contains(t, dst[\"KEY3\"].([]interface{})[0], \"xyz\")\n\tassert.Contains(t, dst[\"KEY3\"].([]interface{})[0].(map[string]interface{})[\"xyz\"], \"1\")\n\n\tassert.Contains(t, dst[\"KEY4\"], \"xyz\")\n\tassert.Equal(t, dst[\"KEY4\"].(map[string]interface{})[\"xyz\"], []interface{}{\"2\"})\n}\n\nfunc TestBuildStructMap_WithStruct(t *testing.T) {\n\tt.Parallel()\n\tcr := setupTestConfigRender(t)\n\n\tconfigTemplate := `\n\t{\n\t\t\"task_id\": \"{{.TASK_ID}}\",\n\t\t\"task_cluster_define\": \"{{.TASK_CLUSTER_DEFINE}}\",\n\t\t\"my_party\": \"{{{.TASK_CLUSTER_DEFINE.selfPartyIdx}}}\"\n\t}`\n\n\ttaskInputConfigBytes, err := protojson.MarshalOptions{EmitUnpopulated: true}.Marshal(&appconfig.ClusterDefine{\n\t\tSelfPartyIdx: 1,\n\t})\n\tassert.NoError(t, err)\n\tenvs := map[string]string{\n\t\t\"TASK_ID\":             \"abc\",\n\t\t\"TASK_CLUSTER_DEFINE\": string(taskInputConfigBytes),\n\t}\n\tdata, err := cr.makeDataMap(map[string]string{}, envs)\n\tassert.NoError(t, err)\n\tt.Logf(\"%+v\", data)\n\n\trootDir := t.TempDir()\n\n\ttemplateFile := filepath.Join(rootDir, \"template.conf\")\n\tassert.NoError(t, os.WriteFile(templateFile, []byte(configTemplate), 0644))\n\n\tconfigFile := filepath.Join(rootDir, \"file.conf\")\n\n\tassert.NoError(t, cr.renderConfigFile(templateFile, configFile, data))\n\n\tf, err := os.ReadFile(configFile)\n\tassert.NoError(t, err)\n\n\tvar conf interface{}\n\tassert.NoError(t, json.Unmarshal(f, &conf))\n\n\tt.Logf(\"Unmarshal config=%+v\", conf)\n\n\tr := conf.(map[string]interface{})\n\tassert.Equal(t, \"abc\", r[\"task_id\"])\n\tassert.Equal(t, \"1\", r[\"my_party\"])\n}\n\nfunc TestBuildStructMap_WithOrg(t *testing.T) {\n\tconfigTemplate := `\n\t{\n\t\t\"task_id\": \"{{.TASK_ID}}\",\n\t\t\"task_cluster_define\": \"{{.TASK_CLUSTER_DEFINE}}\",\n\t\t\"my_party\": \"{{.TASK_CLUSTER_DEFINE.selfPartyIdx}}\"\n\t}`\n\n\ttaskInputConfigBytes, err := protojson.MarshalOptions{EmitUnpopulated: true}.Marshal(&appconfig.ClusterDefine{\n\t\tSelfPartyIdx: 1,\n\t\tParties: []*appconfig.Party{\n\t\t\t{\n\t\t\t\tName: \"xyz\",\n\t\t\t},\n\t\t},\n\t})\n\tassert.NoError(t, err)\n\tnlog.Infof(\"byte=%s\", string(taskInputConfigBytes))\n\n\tvar value interface{}\n\tassert.NoError(t, json.Unmarshal(taskInputConfigBytes, &value))\n\n\tdata := make(map[string]interface{})\n\tdata[\"TASK_CLUSTER_DEFINE\"] = value\n\tdata[\"TASK_ID\"] = \"abc\"\n\n\ttmpl, err := template.New(\"test\").Option(defaultTemplateRenderOption).Parse(configTemplate)\n\tassert.NoError(t, err)\n\n\tvar buf bytes.Buffer\n\tassert.NoError(t, tmpl.Execute(&buf, data))\n\tnlog.Infof(buf.String())\n\n\tvar test interface{}\n\tassert.NoError(t, json.Unmarshal(buf.Bytes(), &test))\n\tassert.Equal(t, \"1\", test.(map[string]interface{})[\"my_party\"])\n\n\tconfigTemplate1 := `\n\t{\n\t\t\"task_id\": \"{{.TASK_ID}}\",\n\t\t\"task_cluster_define\": \"{{.TASK_CLUSTER_DEFINE}}\",\n\t\t\"my_party\": \"{{.TASK_CLUSTER_DEFINE.selfPartyIdx}}\",\n\t\t\"p1_name\": \"{{.TASK_CLUSTER_DEFINE.parties[0].name}}\"\n\t}`\n\n\t_, err = template.New(\"test\").Option(defaultTemplateRenderOption).Parse(configTemplate1)\n\tassert.Error(t, err)\n\n\tconfigTemplate2 := `\n\t{\n\t\t\"task_id\": \"{{.TASK_ID}}\",\n\t\t\"task_cluster_define\": \"{{.TASK_CLUSTER_DEFINE}}\",\n\t\t\"my_party\": \"{{.TASK_CLUSTER_DEFINE.selfPartyIdx}}\",\n\t\t\"p1_name\": \"{{.TASK_CLUSTER_DEFINE.parties[name=test].name}}\"\n\t}`\n\n\t_, err = template.New(\"test\").Option(defaultTemplateRenderOption).Parse(configTemplate2)\n\tassert.Error(t, err)\n}\n\nvar clusterDefine = `\n{\n\t\"parties\": [{\n\t\t\"name\": \"alice\",\n\t\t\"role\": \"\",\n\t\t\"services\": [{\n\t\t\t\"portName\": \"spu\",\n\t\t\t\"endpoints\": [\"secretflow-task-20240816114341-single-psi-0-spu.alice.svc\"]\n\t\t}, {\n\t\t\t\"portName\": \"fed\",\n\t\t\t\"endpoints\": [\"secretflow-task-20240816114341-single-psi-0-fed.alice.svc\"]\n\t\t}, {\n\t\t\t\"portName\": \"global\",\n\t\t\t\"endpoints\": [\"secretflow-task-20240816114341-single-psi-0-global.alice.svc:23321\"]\n\t\t}]\n\t}, {\n\t\t\"name\": \"bob\",\n\t\t\"role\": \"\",\n\t\t\"services\": [{\n\t\t\t\"portName\": \"spu\",\n\t\t\t\"endpoints\": [\"secretflow-task-20240816114341-single-psi-0-spu.bob.svc\"]\n\t\t}, {\n\t\t\t\"portName\": \"fed\",\n\t\t\t\"endpoints\": [\"secretflow-task-20240816114341-single-psi-0-fed.bob.svc\"]\n\t\t}, {\n\t\t\t\"portName\": \"global\",\n\t\t\t\"endpoints\": [\"secretflow-task-20240816114341-single-psi-0-global.bob.svc:20002\"]\n\t\t}]\n\t}],\n\t\"selfPartyIdx\": 1,\n\t\"selfEndpointIdx\": 0\n}\n`\n\nfunc TestRenderConfig_WithKusciaCM(t *testing.T) {\n\tt.Parallel()\n\tcr := setupTestConfigRender(t)\n\n\tconfigTemplate := `\n\t{\n\t\t\"db_info\": \"{{.DB_INFO}}\",\n\t\t\"db_info_user\": \"{{{.DB_INFO.user}}}\",\n\t\t\"db_info_host\": \"{{{.DB_INFO.host}}}\",\n\t   \"db_info_user_host\": \"{{{.DB_INFO.user}}}-{{{.DB_INFO.host}}}\",\n\t   \"db_info_user.host\": \"{{{.DB_INFO.user}}}.{{{.DB_INFO.host}}}\"\n\t}`\n\n\tdata := map[string]string{}\n\tgot, err := cr.renderConfig(configTemplate, data)\n\tassert.NoError(t, err)\n\n\toutput := map[string]string{}\n\terr = json.Unmarshal([]byte(got), &output)\n\tassert.NoError(t, err)\n\tassert.Equal(t, `{\"user\": \"kuscia\", \"host\": \"localhost\"}`, output[\"db_info\"])\n\tassert.Equal(t, \"kuscia\", output[\"db_info_user\"])\n\tassert.Equal(t, \"localhost\", output[\"db_info_host\"])\n\tassert.Equal(t, \"kuscia-localhost\", output[\"db_info_user_host\"])\n\tassert.Equal(t, \"kuscia.localhost\", output[\"db_info_user.host\"])\n\n\t// doesn't fetch from cm\n\tdata = map[string]string{\n\t\t\"DB_INFO\": `{\"user\": \"kuscia\", \"host\":\"localhost\"}`,\n\t}\n\tgot, err = cr.renderConfig(configTemplate, data)\n\terr = json.Unmarshal([]byte(got), &output)\n\tassert.NoError(t, err)\n\tassert.Equal(t, data[\"DB_INFO\"], output[\"db_info\"])\n\tassert.Equal(t, \"kuscia\", output[\"db_info_user\"])\n\tassert.Equal(t, \"localhost\", output[\"db_info_host\"])\n\tassert.Equal(t, \"kuscia-localhost\", output[\"db_info_user_host\"])\n\tassert.Equal(t, \"kuscia.localhost\", output[\"db_info_user.host\"])\n\n\tdata = map[string]string{\"TASK_CLUSTER_DEFINE\": clusterDefine}\n\tconfigTemplate = `\n\t{\n        \"self_endpoint\": \"{{{.TASK_CLUSTER_DEFINE.parties[.TASK_CLUSTER_DEFINE.selfPartyIdx].services[0].endpoints[0]}}}\"\n\t}`\n\tgot, _ = cr.renderConfig(configTemplate, data)\n\terr = json.Unmarshal([]byte(got), &output)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"secretflow-task-20240816114341-single-psi-0-spu.bob.svc\", output[\"self_endpoint\"])\n}"
