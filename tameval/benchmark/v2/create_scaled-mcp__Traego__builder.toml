[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.24.4"

[repo_info]
repository = "Traego/scaled-mcp"
sha = "53eccfe963832dc64cc9f82f559c0b8a01170c81"

[run_info]
docker_image = "golang:1.24.4"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/resources/builder.go pkg/resources/builder_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/resources/builder.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 81.0
original_coverage = 81.0
mutation_kill_rate = 100.0
original_mutation_kill_rate = 100.0
covered_lines = [ 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 40, 41, 42, 43, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 57, 58, 59, 60, 61, 64, 68, 69, 70, 71, 72, 73, 74, 75, 76, 79, 80, 81, 82, 83, 84, 85, 86, 87, 90, 91, 92, 93, 94, 95, 96, 97, 98, 123, 124, 125, 128, 129, 130, 131, 134, 135, 136, 137, 140, 141, 142, 143, 146, 147, 148, 149,]
missed_lines = [ 101, 102, 103, 104, 105, 106, 107, 108, 109, 112, 113, 114, 115, 116, 117, 118, 119, 120,]

[input_info]
test_file_path = "pkg/resources/builder_test.go"
focal_file_path = "pkg/resources/builder.go"
test_file_url = "https://github.com/Traego/scaled-mcp/blob/53eccfe963832dc64cc9f82f559c0b8a01170c81/pkg/resources/builder_test.go"
focal_file_url = "https://github.com/Traego/scaled-mcp/blob/53eccfe963832dc64cc9f82f559c0b8a01170c81/pkg/resources/builder.go"
first_commit_date = "2025-04-08"
last_commit_date = "2025-04-17"
test_file_content = "package resources\n\nimport (\n\t\"github.com/traego/scaled-mcp/pkg/protocol\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestNewTool(t *testing.T) {\n\ttoolName := \"test-tool\"\n\tbuilder := NewTool(toolName)\n\n\tif builder == nil {\n\t\tt.Fatal(\"NewTool returned nil\")\n\t}\n\n\ttool := builder.Build()\n\n\tif tool.Name != toolName {\n\t\tt.Errorf(\"Expected tool name to be %q, got %q\", toolName, tool.Name)\n\t}\n\n\tif tool.InputSchema.Type != \"object\" {\n\t\tt.Errorf(\"Expected input schema type to be 'object', got %q\", tool.InputSchema.Type)\n\t}\n\n\tif len(tool.InputSchema.Properties) != 0 {\n\t\tt.Errorf(\"Expected empty properties, got %d properties\", len(tool.InputSchema.Properties))\n\t}\n\n\tif len(tool.InputSchema.Required) != 0 {\n\t\tt.Errorf(\"Expected empty required fields, got %d required fields\", len(tool.InputSchema.Required))\n\t}\n}\n\nfunc TestWithDescription(t *testing.T) {\n\tdescription := \"Test tool description\"\n\ttool := NewTool(\"test-tool\").\n\t\tWithDescription(description).\n\t\tBuild()\n\n\tif tool.Description != description {\n\t\tt.Errorf(\"Expected description to be %q, got %q\", description, tool.Description)\n\t}\n}\n\nfunc TestWithInputs(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinputs   []ToolInput\n\t\texpected protocol.Tool\n\t}{\n\t\t{\n\t\t\tname:   \"Empty inputs\",\n\t\t\tinputs: []ToolInput{},\n\t\t\texpected: protocol.Tool{\n\t\t\t\tName: \"test-tool\",\n\t\t\t\tInputSchema: protocol.InputSchema{\n\t\t\t\t\tType:       \"object\",\n\t\t\t\t\tProperties: map[string]protocol.SchemaProperty{},\n\t\t\t\t\tRequired:   []string{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Single input\",\n\t\t\tinputs: []ToolInput{\n\t\t\t\t{\n\t\t\t\t\tName:        \"param1\",\n\t\t\t\t\tType:        \"string\",\n\t\t\t\t\tDescription: \"Parameter 1\",\n\t\t\t\t\tRequired:    true,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: protocol.Tool{\n\t\t\t\tName: \"test-tool\",\n\t\t\t\tInputSchema: protocol.InputSchema{\n\t\t\t\t\tType: \"object\",\n\t\t\t\t\tProperties: map[string]protocol.SchemaProperty{\n\t\t\t\t\t\t\"param1\": {\n\t\t\t\t\t\t\tType:        \"string\",\n\t\t\t\t\t\t\tDescription: \"Parameter 1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tRequired: []string{\"param1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Multiple inputs with defaults\",\n\t\t\tinputs: []ToolInput{\n\t\t\t\t{\n\t\t\t\t\tName:        \"param1\",\n\t\t\t\t\tType:        \"string\",\n\t\t\t\t\tDescription: \"Parameter 1\",\n\t\t\t\t\tRequired:    true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:        \"param2\",\n\t\t\t\t\tType:        \"integer\",\n\t\t\t\t\tDescription: \"Parameter 2\",\n\t\t\t\t\tRequired:    false,\n\t\t\t\t\tDefault:     42,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:        \"param3\",\n\t\t\t\t\tType:        \"boolean\",\n\t\t\t\t\tDescription: \"Parameter 3\",\n\t\t\t\t\tRequired:    false,\n\t\t\t\t\tDefault:     true,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: protocol.Tool{\n\t\t\t\tName: \"test-tool\",\n\t\t\t\tInputSchema: protocol.InputSchema{\n\t\t\t\t\tType: \"object\",\n\t\t\t\t\tProperties: map[string]protocol.SchemaProperty{\n\t\t\t\t\t\t\"param1\": {\n\t\t\t\t\t\t\tType:        \"string\",\n\t\t\t\t\t\t\tDescription: \"Parameter 1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"param2\": {\n\t\t\t\t\t\t\tType:        \"integer\",\n\t\t\t\t\t\t\tDescription: \"Parameter 2\",\n\t\t\t\t\t\t\tDefault:     42,\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"param3\": {\n\t\t\t\t\t\t\tType:        \"boolean\",\n\t\t\t\t\t\t\tDescription: \"Parameter 3\",\n\t\t\t\t\t\t\tDefault:     true,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tRequired: []string{\"param1\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\t// Set the name to match the expected tool\n\t\t\ttc.expected.Name = \"test-tool\"\n\n\t\t\ttool := NewTool(\"test-tool\").\n\t\t\t\tWithInputs(tc.inputs).\n\t\t\t\tBuild()\n\n\t\t\t// Check the properties\n\t\t\tif !reflect.DeepEqual(tool.InputSchema.Properties, tc.expected.InputSchema.Properties) {\n\t\t\t\tt.Errorf(\"Properties don't match\\nExpected: %+v\\nGot: %+v\",\n\t\t\t\t\ttc.expected.InputSchema.Properties, tool.InputSchema.Properties)\n\t\t\t}\n\n\t\t\t// Check the required fields\n\t\t\tif !reflect.DeepEqual(tool.InputSchema.Required, tc.expected.InputSchema.Required) {\n\t\t\t\tt.Errorf(\"Required fields don't match\\nExpected: %+v\\nGot: %+v\",\n\t\t\t\t\ttc.expected.InputSchema.Required, tool.InputSchema.Required)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWithString(t *testing.T) {\n\tparamName := \"string-param\"\n\tparamDesc := \"String parameter description\"\n\n\ttool := NewTool(\"test-tool\").\n\t\tWithString(paramName).\n\t\tDescription(paramDesc).\n\t\tAdd().\n\t\tBuild()\n\n\t// Check if the parameter was added correctly\n\tprop, exists := tool.InputSchema.Properties[paramName]\n\tif !exists {\n\t\tt.Fatalf(\"Parameter %q was not added to the tool\", paramName)\n\t}\n\n\tif prop.Type != \"string\" {\n\t\tt.Errorf(\"Expected parameter type to be 'string', got %q\", prop.Type)\n\t}\n\n\tif prop.Description != paramDesc {\n\t\tt.Errorf(\"Expected parameter description to be %q, got %q\", paramDesc, prop.Description)\n\t}\n}\n\nfunc TestWithInteger(t *testing.T) {\n\tparamName := \"int-param\"\n\tparamDesc := \"Integer parameter description\"\n\n\ttool := NewTool(\"test-tool\").\n\t\tWithInteger(paramName).\n\t\tDescription(paramDesc).\n\t\tAdd().\n\t\tBuild()\n\n\t// Check if the parameter was added correctly\n\tprop, exists := tool.InputSchema.Properties[paramName]\n\tif !exists {\n\t\tt.Fatalf(\"Parameter %q was not added to the tool\", paramName)\n\t}\n\n\tif prop.Type != \"integer\" {\n\t\tt.Errorf(\"Expected parameter type to be 'integer', got %q\", prop.Type)\n\t}\n\n\tif prop.Description != paramDesc {\n\t\tt.Errorf(\"Expected parameter description to be %q, got %q\", paramDesc, prop.Description)\n\t}\n}\n\nfunc TestWithBoolean(t *testing.T) {\n\tparamName := \"bool-param\"\n\tparamDesc := \"Boolean parameter description\"\n\n\ttool := NewTool(\"test-tool\").\n\t\tWithBoolean(paramName).\n\t\tDescription(paramDesc).\n\t\tAdd().\n\t\tBuild()\n\n\t// Check if the parameter was added correctly\n\tprop, exists := tool.InputSchema.Properties[paramName]\n\tif !exists {\n\t\tt.Fatalf(\"Parameter %q was not added to the tool\", paramName)\n\t}\n\n\tif prop.Type != \"boolean\" {\n\t\tt.Errorf(\"Expected parameter type to be 'boolean', got %q\", prop.Type)\n\t}\n\n\tif prop.Description != paramDesc {\n\t\tt.Errorf(\"Expected parameter description to be %q, got %q\", paramDesc, prop.Description)\n\t}\n}\n\nfunc TestParameterBuilder_Required(t *testing.T) {\n\tparamName := \"required-param\"\n\n\ttool := NewTool(\"test-tool\").\n\t\tWithString(paramName).\n\t\tRequired().\n\t\tAdd().\n\t\tBuild()\n\n\t// Check if the parameter is in the required list\n\tfound := false\n\tfor _, req := range tool.InputSchema.Required {\n\t\tif req == paramName {\n\t\t\tfound = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif !found {\n\t\tt.Errorf(\"Parameter %q was not added to the required list\", paramName)\n\t}\n}\n\nfunc TestParameterBuilder_Default(t *testing.T) {\n\tparamName := \"default-param\"\n\tdefaultValue := \"default-value\"\n\n\ttool := NewTool(\"test-tool\").\n\t\tWithString(paramName).\n\t\tDefault(defaultValue).\n\t\tAdd().\n\t\tBuild()\n\n\t// Check if the parameter has the default value\n\tprop, exists := tool.InputSchema.Properties[paramName]\n\tif !exists {\n\t\tt.Fatalf(\"Parameter %q was not added to the tool\", paramName)\n\t}\n\n\tif prop.Default != defaultValue {\n\t\tt.Errorf(\"Expected default value to be %q, got %v\", defaultValue, prop.Default)\n\t}\n}\n\nfunc TestComplexToolDefinition(t *testing.T) {\n\t// Test a complex tool definition using both WithInputs and individual parameter methods\n\ttool := NewTool(\"complex-tool\").\n\t\tWithDescription(\"A complex tool with multiple parameters\").\n\t\tWithInputs([]ToolInput{\n\t\t\t{\n\t\t\t\tName:        \"input1\",\n\t\t\t\tType:        \"string\",\n\t\t\t\tDescription: \"First input parameter\",\n\t\t\t\tRequired:    true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:        \"input2\",\n\t\t\t\tType:        \"integer\",\n\t\t\t\tDescription: \"Second input parameter\",\n\t\t\t\tDefault:     100,\n\t\t\t},\n\t\t}).\n\t\tWithString(\"input3\").\n\t\tDescription(\"Third input parameter\").\n\t\tAdd().\n\t\tWithBoolean(\"input4\").\n\t\tRequired().\n\t\tDescription(\"Fourth input parameter\").\n\t\tAdd().\n\t\tBuild()\n\n\t// Check the number of parameters\n\tif len(tool.InputSchema.Properties) != 4 {\n\t\tt.Errorf(\"Expected 4 parameters, got %d\", len(tool.InputSchema.Properties))\n\t}\n\n\t// Check required parameters\n\texpectedRequired := []string{\"input1\", \"input4\"}\n\tif len(tool.InputSchema.Required) != len(expectedRequired) {\n\t\tt.Errorf(\"Expected %d required parameters, got %d\",\n\t\t\tlen(expectedRequired), len(tool.InputSchema.Required))\n\t}\n\n\t// Check each parameter exists\n\tparams := []string{\"input1\", \"input2\", \"input3\", \"input4\"}\n\tfor _, param := range params {\n\t\tif _, exists := tool.InputSchema.Properties[param]; !exists {\n\t\t\tt.Errorf(\"Parameter %q was not added to the tool\", param)\n\t\t}\n\t}\n\n\t// Check types\n\texpectedTypes := map[string]string{\n\t\t\"input1\": \"string\",\n\t\t\"input2\": \"integer\",\n\t\t\"input3\": \"string\",\n\t\t\"input4\": \"boolean\",\n\t}\n\n\tfor param, expectedType := range expectedTypes {\n\t\tif tool.InputSchema.Properties[param].Type != expectedType {\n\t\t\tt.Errorf(\"Parameter %q: expected type %q, got %q\",\n\t\t\t\tparam, expectedType, tool.InputSchema.Properties[param].Type)\n\t\t}\n\t}\n\n\t// Check default values\n\tif tool.InputSchema.Properties[\"input2\"].Default != 100 {\n\t\tt.Errorf(\"Parameter input2: expected default value 100, got %v\",\n\t\t\ttool.InputSchema.Properties[\"input2\"].Default)\n\t}\n}\n"
