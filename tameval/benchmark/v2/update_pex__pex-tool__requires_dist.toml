[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Python"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "pex-tool/pex"
sha = "17bd416647eaca978e538408f1ec21813ab26335"

[run_info]
docker_image = "python:3"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r docs-requirements.txt && (pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=pex/resolve/lockfile/requires_dist.py -m pytest -q --junit-xml=test_output.xml tests/resolve/lockfile/test_requires_dist.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target pex.resolve.lockfile.requires_dist --unit-test tests.resolve.lockfile.test_requires_dist --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target pex/resolve/lockfile/requires_dist.py --unit-test tests/resolve/lockfile/test_requires_dist.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 29.0
original_coverage = 78.0
mutation_kill_rate = nan
original_mutation_kill_rate = 18.0
covered_lines = [ 3, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 40, 43, 44, 45, 46, 93, 94, 95, 96, 97, 98, 101, 113, 114, 119, 120, 126, 127, 133, 151, 155, 156, 157, 189, 210, 217, 243, 252, 255, 265, 285,]
missed_lines = [ 20, 36, 38, 54, 57, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 79, 115, 116, 122, 123, 129, 130, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 152, 165, 166, 167, 168, 169, 176, 177, 178, 179, 180, 187, 199, 200, 201, 202, 203, 205, 213, 214, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 238, 240, 245, 246, 247, 248, 249, 257, 258, 259, 260, 261, 262, 273, 276, 277, 278, 280, 281, 282, 293, 296, 299, 300, 301, 302, 303, 304, 306, 307, 308, 309, 311, 314, 315, 316, 318,]

[input_info]
test_file_path = "tests/resolve/lockfile/test_requires_dist.py"
focal_file_path = "pex/resolve/lockfile/requires_dist.py"
test_file_url = "https://github.com/pex-tool/pex/blob/17bd416647eaca978e538408f1ec21813ab26335/tests/resolve/lockfile/test_requires_dist.py"
focal_file_url = "https://github.com/pex-tool/pex/blob/17bd416647eaca978e538408f1ec21813ab26335/pex/resolve/lockfile/requires_dist.py"
first_commit_date = "2024-12-09"
last_commit_date = "2025-02-15"
test_file_content = "# Copyright 2024 Pex project contributors.\n# Licensed under the Apache License, Version 2.0 (see LICENSE).\n\nfrom __future__ import absolute_import\n\nfrom pex.dist_metadata import Requirement\nfrom pex.pep_440 import Version\nfrom pex.pep_503 import ProjectName\nfrom pex.resolve.locked_resolve import Artifact, LockedRequirement, LockedResolve\nfrom pex.resolve.lockfile import requires_dist\nfrom pex.resolve.resolved_requirement import Fingerprint, Pin\nfrom pex.sorted_tuple import SortedTuple\n\nreq = Requirement.parse\n\n\ndef locked_req(\n    project_name,  # type: str\n    version,  # type: str\n    *requirements  # type: str\n):\n    # type: (...) -> LockedRequirement\n    return LockedRequirement.create(\n        pin=Pin(project_name=ProjectName(project_name), version=Version(version)),\n        artifact=Artifact.from_url(\n            \"https://artifact.store/{project_name}-{version}-py2.py3-none-any.whl\".format(\n                project_name=project_name, version=version\n            ),\n            fingerprint=Fingerprint(algorithm=\"md5\", hash=\"abcd0123\"),\n        ),\n        requires_dists=map(req, requirements),\n    )\n\n\ndef locked_resolve(*locked_requirements):\n    # type: (*LockedRequirement) -> LockedResolve\n    return LockedResolve(locked_requirements=SortedTuple(locked_requirements))\n\n\ndef test_remove_unused_requires_dist_noop():\n    # type: () -> None\n\n    locked_resolve_with_no_extras = locked_resolve(\n        locked_req(\"foo\", \"1.0\", \"bar\", \"baz\"),\n        locked_req(\"bar\", \"1.0\"),\n        locked_req(\"baz\", \"1.0\"),\n    )\n    assert locked_resolve_with_no_extras == requires_dist.remove_unused_requires_dist(\n        locked_resolve_with_no_extras\n    )\n\n\ndef test_remove_unused_requires_dist_simple():\n    # type: () -> None\n\n    assert locked_resolve(\n        locked_req(\"foo\", \"1.0\", \"bar\", \"spam\"),\n        locked_req(\"bar\", \"1.0\"),\n        locked_req(\"spam\", \"1.0\"),\n    ) == requires_dist.remove_unused_requires_dist(\n        locked_resolve(\n            locked_req(\"foo\", \"1.0\", \"bar\", \"baz; extra == 'tests'\", \"spam\"),\n            locked_req(\"bar\", \"1.0\"),\n            locked_req(\"spam\", \"1.0\"),\n        ),\n    )\n\n\ndef test_remove_unused_requires_dist_mixed_extras():\n    # type: () -> None\n\n    assert locked_resolve(\n        locked_req(\"foo\", \"1.0\", \"bar; extra == 'extra1'\", \"spam\"),\n        locked_req(\"bar\", \"1.0\"),\n        locked_req(\"spam\", \"1.0\"),\n    ) == requires_dist.remove_unused_requires_dist(\n        locked_resolve(\n            locked_req(\"foo\", \"1.0\", \"bar; extra == 'extra1'\", \"baz; extra == 'tests'\", \"spam\"),\n            locked_req(\"bar\", \"1.0\"),\n            locked_req(\"spam\", \"1.0\"),\n        ),\n    )\n\n\ndef test_remove_unused_requires_dist_mixed_markers():\n    # type: () -> None\n\n    assert locked_resolve(\n        locked_req(\n            \"foo\",\n            \"1.0\",\n            \"bar; extra == 'extra1'\",\n            \"baz; extra == 'tests' or python_version > '3.11'\",\n            \"spam\",\n        ),\n        locked_req(\"bar\", \"1.0\"),\n        locked_req(\"baz\", \"1.0\"),\n        locked_req(\"spam\", \"1.0\"),\n    ) == requires_dist.remove_unused_requires_dist(\n        locked_resolve(\n            locked_req(\n                \"foo\",\n                \"1.0\",\n                \"bar; extra == 'extra1'\",\n                \"baz; extra == 'tests' or python_version > '3.11'\",\n                \"spam\",\n            ),\n            locked_req(\"bar\", \"1.0\"),\n            locked_req(\"baz\", \"1.0\"),\n            locked_req(\"spam\", \"1.0\"),\n        ),\n    ), (\n        \"The python_version marker clause might evaluate to true, which should be enough to retain \"\n        \"the baz dep even though the 'tests' extra is never activated.\"\n    )\n\n    assert locked_resolve(\n        locked_req(\n            \"foo\",\n            \"1.0\",\n            \"bar; extra == 'extra1'\",\n            \"spam\",\n        ),\n        locked_req(\"bar\", \"1.0\"),\n        locked_req(\"spam\", \"1.0\"),\n    ) == requires_dist.remove_unused_requires_dist(\n        locked_resolve(\n            locked_req(\n                \"foo\",\n                \"1.0\",\n                \"bar; extra == 'extra1'\",\n                \"baz; extra == 'tests' and python_version > '3.11'\",\n                \"spam\",\n            ),\n            locked_req(\"bar\", \"1.0\"),\n            locked_req(\"spam\", \"1.0\"),\n        ),\n    ), \"The 'tests' extra is never active; so the baz dep should never be reached.\"\n\n\ndef test_remove_unused_requires_dist_complex_markers():\n    # type: () -> None\n\n    assert locked_resolve(\n        locked_req(\n            \"foo\",\n            \"1.0\",\n            \"bar; python_version < '3' and (extra == 'docs' or python_version >= '3')\",\n            \"spam\",\n        ),\n        locked_req(\"bar\", \"1.0\"),\n        locked_req(\"spam\", \"1.0\"),\n    ) == requires_dist.remove_unused_requires_dist(\n        locked_resolve(\n            locked_req(\n                \"foo\",\n                \"1.0\",\n                \"bar; python_version < '3' and (extra == 'docs' or python_version >= '3')\",\n                \"baz; python_version == '3.11.*' and (extra == 'admin' or extra == 'docs')\",\n                \"spam\",\n            ),\n            locked_req(\"bar\", \"1.0\"),\n            locked_req(\"spam\", \"1.0\"),\n        ),\n    )\n\n\ndef test_remove_unused_requires_dist_not_present_due_to_other_markers():\n    # type: () -> None\n\n    assert locked_resolve(\n        locked_req(\"foo\", \"1.0\", \"bar\", \"spam\"),\n        locked_req(\"bar\", \"1.0\"),\n        locked_req(\"spam\", \"1.0\"),\n    ) == requires_dist.remove_unused_requires_dist(\n        locked_resolve(\n            locked_req(\n                \"foo\",\n                \"1.0\",\n                \"bar\",\n                \"baz; python_version < '3'\",\n                \"spam\",\n            ),\n            locked_req(\"bar\", \"1.0\"),\n            locked_req(\"spam\", \"1.0\"),\n        ),\n    ), (\n        \"Here we simulate a lock where baz is not present in the lock since the lock was for \"\n        \"Python 3. We expect the lack of a locked baz to not trip up the elision process.\"\n    )"
