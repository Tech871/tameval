[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.24.2"

[repo_info]
repository = "KevoDB/kevo"
sha = "a0bcddabc1700e19208bd8adb99211654de65bc8"

[run_info]
docker_image = "golang:1.24.2"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/common/iterator/composite/hierarchical.go pkg/common/iterator/composite/hierarchical_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/common/iterator/composite/hierarchical.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 84.0
original_coverage = 84.0
mutation_kill_rate = 59.0
original_mutation_kill_rate = 59.0
covered_lines = [ 29, 30, 31, 32, 33, 36, 37, 38, 39, 40, 41, 42, 43, 46, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64, 69, 70, 71, 72, 73, 74, 77, 78, 79, 80, 87, 88, 89, 90, 91, 92, 93, 94, 97, 98, 99, 100, 101, 102, 103, 104, 105, 108, 109, 110, 116, 117, 118, 119, 120, 121, 125, 126, 127, 128, 141, 142, 143, 144, 147, 151, 152, 153, 154, 160, 161, 162, 163, 167, 168, 169, 170, 174, 178, 179, 180, 181, 185, 189, 190, 191, 192, 193, 194, 197, 198, 199, 200, 201, 208, 212, 213, 214, 217, 218, 219, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 239, 240, 241, 242, 243, 248, 249, 254, 255, 256, 257, 258, 259, 260, 261, 262, 266, 267, 268, 269, 270, 271, 282, 283, 284, 285, 288,]
missed_lines = [ 65, 66, 81, 82, 83, 111, 112, 129, 130, 134, 135, 136, 155, 156, 157, 171, 172, 173, 182, 183, 184, 202, 203, 204, 275, 276, 277,]

[input_info]
test_file_path = "pkg/common/iterator/composite/hierarchical_test.go"
focal_file_path = "pkg/common/iterator/composite/hierarchical.go"
test_file_url = "https://github.com/KevoDB/kevo/blob/a0bcddabc1700e19208bd8adb99211654de65bc8/pkg/common/iterator/composite/hierarchical_test.go"
focal_file_url = "https://github.com/KevoDB/kevo/blob/a0bcddabc1700e19208bd8adb99211654de65bc8/pkg/common/iterator/composite/hierarchical.go"
first_commit_date = "2025-04-20"
last_commit_date = "2025-04-22"
test_file_content = "package composite\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/KevoDB/kevo/pkg/common/iterator\"\n)\n\n// mockIterator is a simple in-memory iterator for testing\ntype mockIterator struct {\n\tpairs []struct {\n\t\tkey, value []byte\n\t}\n\tindex     int\n\ttombstone int // index of entry that should be a tombstone, -1 if none\n}\n\nfunc newMockIterator(data map[string]string, tombstone string) *mockIterator {\n\tm := &mockIterator{\n\t\tpairs:     make([]struct{ key, value []byte }, 0, len(data)),\n\t\tindex:     -1,\n\t\ttombstone: -1,\n\t}\n\n\t// Collect keys for sorting\n\tkeys := make([]string, 0, len(data))\n\tfor k := range data {\n\t\tkeys = append(keys, k)\n\t}\n\n\t// Sort keys\n\tfor i := 0; i < len(keys)-1; i++ {\n\t\tfor j := i + 1; j < len(keys); j++ {\n\t\t\tif keys[i] > keys[j] {\n\t\t\t\tkeys[i], keys[j] = keys[j], keys[i]\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add sorted key-value pairs\n\tfor i, k := range keys {\n\t\tm.pairs = append(m.pairs, struct{ key, value []byte }{\n\t\t\tkey:   []byte(k),\n\t\t\tvalue: []byte(data[k]),\n\t\t})\n\t\tif k == tombstone {\n\t\t\tm.tombstone = i\n\t\t}\n\t}\n\n\treturn m\n}\n\nfunc (m *mockIterator) SeekToFirst() {\n\tif len(m.pairs) > 0 {\n\t\tm.index = 0\n\t} else {\n\t\tm.index = -1\n\t}\n}\n\nfunc (m *mockIterator) SeekToLast() {\n\tif len(m.pairs) > 0 {\n\t\tm.index = len(m.pairs) - 1\n\t} else {\n\t\tm.index = -1\n\t}\n}\n\nfunc (m *mockIterator) Seek(target []byte) bool {\n\tfor i, p := range m.pairs {\n\t\tif bytes.Compare(p.key, target) >= 0 {\n\t\t\tm.index = i\n\t\t\treturn true\n\t\t}\n\t}\n\tm.index = -1\n\treturn false\n}\n\nfunc (m *mockIterator) Next() bool {\n\tif m.index >= 0 && m.index < len(m.pairs)-1 {\n\t\tm.index++\n\t\treturn true\n\t}\n\tm.index = -1\n\treturn false\n}\n\nfunc (m *mockIterator) Key() []byte {\n\tif m.index >= 0 && m.index < len(m.pairs) {\n\t\treturn m.pairs[m.index].key\n\t}\n\treturn nil\n}\n\nfunc (m *mockIterator) Value() []byte {\n\tif m.index >= 0 && m.index < len(m.pairs) {\n\t\tif m.index == m.tombstone {\n\t\t\treturn nil // tombstone\n\t\t}\n\t\treturn m.pairs[m.index].value\n\t}\n\treturn nil\n}\n\nfunc (m *mockIterator) Valid() bool {\n\treturn m.index >= 0 && m.index < len(m.pairs)\n}\n\nfunc (m *mockIterator) IsTombstone() bool {\n\treturn m.Valid() && m.index == m.tombstone\n}\n\nfunc TestHierarchicalIterator_SeekToFirst(t *testing.T) {\n\t// Create mock iterators\n\titer1 := newMockIterator(map[string]string{\n\t\t\"a\": \"v1a\",\n\t\t\"c\": \"v1c\",\n\t\t\"e\": \"v1e\",\n\t}, \"\")\n\n\titer2 := newMockIterator(map[string]string{\n\t\t\"b\": \"v2b\",\n\t\t\"c\": \"v2c\", // Should be hidden by iter1's \"c\"\n\t\t\"d\": \"v2d\",\n\t}, \"\")\n\n\t// Create hierarchical iterator with iter1 being newer than iter2\n\thierIter := NewHierarchicalIterator([]iterator.Iterator{iter1, iter2})\n\n\t// Test SeekToFirst\n\thierIter.SeekToFirst()\n\tif !hierIter.Valid() {\n\t\tt.Fatal(\"Expected iterator to be valid after SeekToFirst\")\n\t}\n\n\t// Should be at \"a\" from iter1\n\tif string(hierIter.Key()) != \"a\" {\n\t\tt.Errorf(\"Expected key 'a', got '%s'\", string(hierIter.Key()))\n\t}\n\tif string(hierIter.Value()) != \"v1a\" {\n\t\tt.Errorf(\"Expected value 'v1a', got '%s'\", string(hierIter.Value()))\n\t}\n\n\t// Test order of keys is merged correctly\n\texpected := []struct {\n\t\tkey, value string\n\t}{\n\t\t{\"a\", \"v1a\"},\n\t\t{\"b\", \"v2b\"},\n\t\t{\"c\", \"v1c\"}, // From iter1, not iter2\n\t\t{\"d\", \"v2d\"},\n\t\t{\"e\", \"v1e\"},\n\t}\n\n\tfor i, exp := range expected {\n\t\tif !hierIter.Valid() {\n\t\t\tt.Fatalf(\"Iterator should be valid at position %d\", i)\n\t\t}\n\n\t\tif string(hierIter.Key()) != exp.key {\n\t\t\tt.Errorf(\"Position %d: Expected key '%s', got '%s'\", i, exp.key, string(hierIter.Key()))\n\t\t}\n\n\t\tif string(hierIter.Value()) != exp.value {\n\t\t\tt.Errorf(\"Position %d: Expected value '%s', got '%s'\", i, exp.value, string(hierIter.Value()))\n\t\t}\n\n\t\tif i < len(expected)-1 {\n\t\t\tif !hierIter.Next() {\n\t\t\t\tt.Fatalf(\"Next() should return true at position %d\", i)\n\t\t\t}\n\t\t}\n\t}\n\n\t// After all elements, Next should return false\n\tif hierIter.Next() {\n\t\tt.Error(\"Expected Next() to return false after all elements\")\n\t}\n}\n\nfunc TestHierarchicalIterator_SeekToLast(t *testing.T) {\n\t// Create mock iterators\n\titer1 := newMockIterator(map[string]string{\n\t\t\"a\": \"v1a\",\n\t\t\"c\": \"v1c\",\n\t\t\"e\": \"v1e\",\n\t}, \"\")\n\n\titer2 := newMockIterator(map[string]string{\n\t\t\"b\": \"v2b\",\n\t\t\"d\": \"v2d\",\n\t\t\"f\": \"v2f\",\n\t}, \"\")\n\n\t// Create hierarchical iterator with iter1 being newer than iter2\n\thierIter := NewHierarchicalIterator([]iterator.Iterator{iter1, iter2})\n\n\t// Test SeekToLast\n\thierIter.SeekToLast()\n\tif !hierIter.Valid() {\n\t\tt.Fatal(\"Expected iterator to be valid after SeekToLast\")\n\t}\n\n\t// Should be at \"f\" from iter2\n\tif string(hierIter.Key()) != \"f\" {\n\t\tt.Errorf(\"Expected key 'f', got '%s'\", string(hierIter.Key()))\n\t}\n\tif string(hierIter.Value()) != \"v2f\" {\n\t\tt.Errorf(\"Expected value 'v2f', got '%s'\", string(hierIter.Value()))\n\t}\n}\n\nfunc TestHierarchicalIterator_Seek(t *testing.T) {\n\t// Create mock iterators\n\titer1 := newMockIterator(map[string]string{\n\t\t\"a\": \"v1a\",\n\t\t\"c\": \"v1c\",\n\t\t\"e\": \"v1e\",\n\t}, \"\")\n\n\titer2 := newMockIterator(map[string]string{\n\t\t\"b\": \"v2b\",\n\t\t\"d\": \"v2d\",\n\t\t\"f\": \"v2f\",\n\t}, \"\")\n\n\t// Create hierarchical iterator with iter1 being newer than iter2\n\thierIter := NewHierarchicalIterator([]iterator.Iterator{iter1, iter2})\n\n\t// Test Seek\n\ttests := []struct {\n\t\ttarget      string\n\t\texpectValid bool\n\t\texpectKey   string\n\t\texpectValue string\n\t}{\n\t\t{\"a\", true, \"a\", \"v1a\"},  // Exact match from iter1\n\t\t{\"b\", true, \"b\", \"v2b\"},  // Exact match from iter2\n\t\t{\"c\", true, \"c\", \"v1c\"},  // Exact match from iter1\n\t\t{\"c1\", true, \"d\", \"v2d\"}, // Between c and d\n\t\t{\"x\", false, \"\", \"\"},     // Beyond last key\n\t\t{\"\", true, \"a\", \"v1a\"},   // Before first key\n\t}\n\n\tfor i, test := range tests {\n\t\tfound := hierIter.Seek([]byte(test.target))\n\t\tif found != test.expectValid {\n\t\t\tt.Errorf(\"Test %d: Seek(%s) returned %v, expected %v\",\n\t\t\t\ti, test.target, found, test.expectValid)\n\t\t}\n\n\t\tif test.expectValid {\n\t\t\tif string(hierIter.Key()) != test.expectKey {\n\t\t\t\tt.Errorf(\"Test %d: Seek(%s) key is '%s', expected '%s'\",\n\t\t\t\t\ti, test.target, string(hierIter.Key()), test.expectKey)\n\t\t\t}\n\t\t\tif string(hierIter.Value()) != test.expectValue {\n\t\t\t\tt.Errorf(\"Test %d: Seek(%s) value is '%s', expected '%s'\",\n\t\t\t\t\ti, test.target, string(hierIter.Value()), test.expectValue)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestHierarchicalIterator_Tombstone(t *testing.T) {\n\t// Create mock iterators with tombstone\n\titer1 := newMockIterator(map[string]string{\n\t\t\"a\": \"v1a\",\n\t\t\"c\": \"v1c\",\n\t}, \"c\") // c is a tombstone in iter1\n\n\titer2 := newMockIterator(map[string]string{\n\t\t\"b\": \"v2b\",\n\t\t\"c\": \"v2c\", // This should be hidden by iter1's tombstone\n\t\t\"d\": \"v2d\",\n\t}, \"\")\n\n\t// Create hierarchical iterator with iter1 being newer than iter2\n\thierIter := NewHierarchicalIterator([]iterator.Iterator{iter1, iter2})\n\n\t// Test that the tombstone is correctly identified\n\thierIter.SeekToFirst() // Should be at \"a\"\n\tif hierIter.IsTombstone() {\n\t\tt.Error(\"Key 'a' should not be a tombstone\")\n\t}\n\n\thierIter.Next() // Should be at \"b\"\n\tif hierIter.IsTombstone() {\n\t\tt.Error(\"Key 'b' should not be a tombstone\")\n\t}\n\n\thierIter.Next() // Should be at \"c\" (which is a tombstone in iter1)\n\tif !hierIter.IsTombstone() {\n\t\tt.Error(\"Key 'c' should be a tombstone\")\n\t}\n\n\tif hierIter.Value() != nil {\n\t\tt.Error(\"Tombstone value should be nil\")\n\t}\n\n\thierIter.Next() // Should be at \"d\"\n\tif hierIter.IsTombstone() {\n\t\tt.Error(\"Key 'd' should not be a tombstone\")\n\t}\n}\n\nfunc TestHierarchicalIterator_CompositeInterface(t *testing.T) {\n\t// Create mock iterators\n\titer1 := newMockIterator(map[string]string{\"a\": \"1\"}, \"\")\n\titer2 := newMockIterator(map[string]string{\"b\": \"2\"}, \"\")\n\n\t// Create the composite iterator\n\thierIter := NewHierarchicalIterator([]iterator.Iterator{iter1, iter2})\n\n\t// Test CompositeIterator interface methods\n\tif hierIter.NumSources() != 2 {\n\t\tt.Errorf(\"Expected NumSources() to return 2, got %d\", hierIter.NumSources())\n\t}\n\n\tsources := hierIter.GetSourceIterators()\n\tif len(sources) != 2 {\n\t\tt.Errorf(\"Expected GetSourceIterators() to return 2 sources, got %d\", len(sources))\n\t}\n\n\t// Verify that the sources are correct\n\tif sources[0] != iter1 || sources[1] != iter2 {\n\t\tt.Error(\"Source iterators don't match the original iterators\")\n\t}\n}\n"
