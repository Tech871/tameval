[meta]
task = "repair"
scenario = "repair_invalid_constructor"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "authzed/spicedb"
sha = "449c43d3c8dbb72defa98dfd097392c2fa137870"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/middleware/consistency/consistency.go pkg/middleware/consistency/consistency_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/middleware/consistency/consistency.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 66.0
mutation_kill_rate = nan
original_mutation_kill_rate = 63.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "pkg/middleware/consistency/consistency_test.go"
focal_file_path = "pkg/middleware/consistency/consistency.go"
test_file_url = "https://github.com/authzed/spicedb/blob/449c43d3c8dbb72defa98dfd097392c2fa137870/pkg/middleware/consistency/consistency_test.go"
focal_file_url = "https://github.com/authzed/spicedb/blob/449c43d3c8dbb72defa98dfd097392c2fa137870/pkg/middleware/consistency/consistency.go"
first_commit_date = "2022-01-26"
last_commit_date = "2025-07-08"
test_file_content = "package consistency\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/grpc/codes\"\n\n\tv1 \"github.com/authzed/authzed-go/proto/authzed/api/v1\"\n\t\"github.com/authzed/grpcutil\"\n\n\t\"github.com/authzed/spicedb/internal/datastore/proxy/proxy_test\"\n\t\"github.com/authzed/spicedb/internal/datastore/revisions\"\n\t\"github.com/authzed/spicedb/pkg/cursor\"\n\t\"github.com/authzed/spicedb/pkg/datastore\"\n\tdispatch \"github.com/authzed/spicedb/pkg/proto/dispatch/v1\"\n\t\"github.com/authzed/spicedb/pkg/zedtoken\"\n)\n\nvar (\n\tzero      = revisions.NewForTransactionID(0)\n\toptimized = revisions.NewForTransactionID(100)\n\texact     = revisions.NewForTransactionID(123)\n\thead      = revisions.NewForTransactionID(145)\n)\n\nfunc TestAddRevisionToContextNoneSupplied(t *testing.T) {\n\trequire := require.New(t)\n\n\tds := &proxy_test.MockDatastore{}\n\tds.On(\"OptimizedRevision\").Return(optimized, nil).Once()\n\n\tupdated := ContextWithHandle(t.Context())\n\terr := AddRevisionToContext(updated, &v1.ReadRelationshipsRequest{}, ds, \"somelabel\")\n\trequire.NoError(err)\n\n\trev, _, err := RevisionFromContext(updated)\n\trequire.NoError(err)\n\n\trequire.True(optimized.Equal(rev))\n\tds.AssertExpectations(t)\n}\n\nfunc TestAddRevisionToContextMinimizeLatency(t *testing.T) {\n\trequire := require.New(t)\n\n\tds := &proxy_test.MockDatastore{}\n\tds.On(\"OptimizedRevision\").Return(optimized, nil).Once()\n\n\tupdated := ContextWithHandle(t.Context())\n\terr := AddRevisionToContext(updated, &v1.ReadRelationshipsRequest{\n\t\tConsistency: &v1.Consistency{\n\t\t\tRequirement: &v1.Consistency_MinimizeLatency{\n\t\t\t\tMinimizeLatency: true,\n\t\t\t},\n\t\t},\n\t}, ds, \"somelabel\")\n\trequire.NoError(err)\n\n\trev, _, err := RevisionFromContext(updated)\n\trequire.NoError(err)\n\n\trequire.True(optimized.Equal(rev))\n\tds.AssertExpectations(t)\n}\n\nfunc TestAddRevisionToContextFullyConsistent(t *testing.T) {\n\trequire := require.New(t)\n\n\tds := &proxy_test.MockDatastore{}\n\tds.On(\"HeadRevision\").Return(head, nil).Once()\n\n\tupdated := ContextWithHandle(t.Context())\n\terr := AddRevisionToContext(updated, &v1.ReadRelationshipsRequest{\n\t\tConsistency: &v1.Consistency{\n\t\t\tRequirement: &v1.Consistency_FullyConsistent{\n\t\t\t\tFullyConsistent: true,\n\t\t\t},\n\t\t},\n\t}, ds, \"somelabel\")\n\trequire.NoError(err)\n\n\trev, _, err := RevisionFromContext(updated)\n\trequire.NoError(err)\n\n\trequire.True(head.Equal(rev))\n\tds.AssertExpectations(t)\n}\n\nfunc TestAddRevisionToContextAtLeastAsFresh(t *testing.T) {\n\trequire := require.New(t)\n\n\tds := &proxy_test.MockDatastore{}\n\tds.On(\"OptimizedRevision\").Return(optimized, nil).Once()\n\tds.On(\"RevisionFromString\", exact.String()).Return(exact, nil).Once()\n\n\tupdated := ContextWithHandle(t.Context())\n\terr := AddRevisionToContext(updated, &v1.ReadRelationshipsRequest{\n\t\tConsistency: &v1.Consistency{\n\t\t\tRequirement: &v1.Consistency_AtLeastAsFresh{\n\t\t\t\tAtLeastAsFresh: zedtoken.MustNewFromRevision(exact),\n\t\t\t},\n\t\t},\n\t}, ds, \"somelabel\")\n\trequire.NoError(err)\n\n\trev, _, err := RevisionFromContext(updated)\n\trequire.NoError(err)\n\n\trequire.True(exact.Equal(rev))\n\tds.AssertExpectations(t)\n}\n\nfunc TestAddRevisionToContextAtValidExactSnapshot(t *testing.T) {\n\trequire := require.New(t)\n\n\tds := &proxy_test.MockDatastore{}\n\tds.On(\"CheckRevision\", exact).Return(nil).Times(1)\n\tds.On(\"RevisionFromString\", exact.String()).Return(exact, nil).Once()\n\n\tupdated := ContextWithHandle(t.Context())\n\terr := AddRevisionToContext(updated, &v1.ReadRelationshipsRequest{\n\t\tConsistency: &v1.Consistency{\n\t\t\tRequirement: &v1.Consistency_AtExactSnapshot{\n\t\t\t\tAtExactSnapshot: zedtoken.MustNewFromRevision(exact),\n\t\t\t},\n\t\t},\n\t}, ds, \"somelabel\")\n\trequire.NoError(err)\n\n\trev, _, err := RevisionFromContext(updated)\n\trequire.NoError(err)\n\n\trequire.True(exact.Equal(rev))\n\tds.AssertExpectations(t)\n}\n\nfunc TestAddRevisionToContextAtInvalidExactSnapshot(t *testing.T) {\n\trequire := require.New(t)\n\n\tds := &proxy_test.MockDatastore{}\n\tds.On(\"CheckRevision\", zero).Return(datastore.NewInvalidRevisionErr(zero, datastore.RevisionStale)).Times(1)\n\tds.On(\"RevisionFromString\", zero.String()).Return(zero, nil).Once()\n\n\tupdated := ContextWithHandle(t.Context())\n\terr := AddRevisionToContext(updated, &v1.ReadRelationshipsRequest{\n\t\tConsistency: &v1.Consistency{\n\t\t\tRequirement: &v1.Consistency_AtExactSnapshot{\n\t\t\t\tAtExactSnapshot: zedtoken.MustNewFromRevision(zero),\n\t\t\t},\n\t\t},\n\t}, ds, \"somelabel\")\n\trequire.Error(err)\n\tgrpcutil.RequireStatus(t, codes.OutOfRange, err)\n\tds.AssertExpectations(t)\n}\n\nfunc TestAddRevisionToContextNoConsistencyAPI(t *testing.T) {\n\trequire := require.New(t)\n\n\tupdated := ContextWithHandle(t.Context())\n\n\t_, _, err := RevisionFromContext(updated)\n\trequire.Error(err)\n}\n\nfunc TestAddRevisionToContextWithCursor(t *testing.T) {\n\trequire := require.New(t)\n\n\tds := &proxy_test.MockDatastore{}\n\tds.On(\"CheckRevision\", optimized).Return(nil).Times(1)\n\tds.On(\"RevisionFromString\", optimized.String()).Return(optimized, nil).Once()\n\tcursor, err := cursor.EncodeFromDispatchCursor(&dispatch.Cursor{}, \"somehash\", optimized, nil)\n\trequire.NoError(err)\n\tupdated := ContextWithHandle(t.Context())\n\terr = AddRevisionToContext(updated, &v1.LookupResourcesRequest{\n\t\tConsistency: &v1.Consistency{\n\t\t\tRequirement: &v1.Consistency_AtExactSnapshot{\n\t\t\t\tAtExactSnapshot: zedtoken.MustNewFromRevision(exact),\n\t\t\t},\n\t\t},\n\t\tOptionalCursor: cursor,\n\t}, ds, \"somelabel\")\n\trequire.NoError(err)\n\trev, _, err := RevisionFromContext(updated)\n\trequire.NoError(err)\n\n\trequire.True(optimized.Equal(rev))\n\tds.AssertExpectations(t)\n}\n\nfunc TestAddRevisionToContextAtMalformedExactSnapshot(t *testing.T) {\n\terr := AddRevisionToContext(ContextWithHandle(t.Context()), &v1.LookupResourcesRequest{\n\t\tConsistency: &v1.Consistency{\n\t\t\tRequirement: &v1.Consistency_AtExactSnapshot{\n\t\t\t\tAtExactSnapshot: &v1.ZedToken{Token: \"blah\"},\n\t\t\t},\n\t\t},\n\t}, nil, \"\")\n\trequire.Error(t, err)\n\tgrpcutil.RequireStatus(t, codes.InvalidArgument, err)\n}\n\nfunc TestAddRevisionToContextMalformedAtLeastAsFreshSnapshot(t *testing.T) {\n\tds := &proxy_test.MockDatastore{}\n\tds.On(\"OptimizedRevision\").Return(optimized, nil).Once()\n\n\terr := AddRevisionToContext(ContextWithHandle(t.Context()), &v1.LookupResourcesRequest{\n\t\tConsistency: &v1.Consistency{\n\t\t\tRequirement: &v1.Consistency_AtLeastAsFresh{\n\t\t\t\tAtLeastAsFresh: &v1.ZedToken{Token: \"blah\"},\n\t\t\t},\n\t\t},\n\t}, ds, \"\")\n\trequire.Error(t, err)\n\tgrpcutil.RequireStatus(t, codes.InvalidArgument, err)\n}\n\nfunc TestRevisionFromContextMissingConsistency(t *testing.T) {\n\tupdated := ContextWithHandle(t.Context())\n\t_, _, err := RevisionFromContext(updated)\n\trequire.Error(t, err)\n\tgrpcutil.RequireStatus(t, codes.Internal, err)\n\trequire.ErrorContains(t, err, \"consistency middleware did not inject revision\")\n}\n\nfunc TestRewriteDatastoreError(t *testing.T) {\n\terr := rewriteDatastoreError(errors.New(\"foobar\"))\n\trequire.Error(t, err)\n\tgrpcutil.RequireStatus(t, codes.Internal, err)\n\trequire.ErrorContains(t, err, \"foobar\")\n\n\terr = rewriteDatastoreError(datastore.NewInvalidRevisionErr(zero, datastore.RevisionStale))\n\trequire.Error(t, err)\n\tgrpcutil.RequireStatus(t, codes.OutOfRange, err)\n\trequire.ErrorContains(t, err, \"invalid revision\")\n\n\terr = rewriteDatastoreError(datastore.NewReadonlyErr())\n\trequire.Error(t, err)\n\tgrpcutil.RequireStatus(t, codes.Unavailable, err)\n\trequire.ErrorContains(t, err, \"service read-only\")\n\trev1 := revisions.NewForTransactionID()\n\trev2 := revisions.NewForTransactionID(\"123\")\n\trev3 := revisions.NewForTransactionID(123, \"extra\")\n\tcursor1, _ := cursor.EncodeFromDispatchCursor(&dispatch.Cursor{}, \"somehash\", optimized, \"\", \"extra\")\n\ttoken1 := zedtoken.MustNewFromRevision()\n\ttoken2 := zedtoken.MustNewFromRevision(\"invalid\")\n}"
