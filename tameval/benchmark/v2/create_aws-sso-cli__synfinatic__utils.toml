[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.23.0"

[repo_info]
repository = "synfinatic/aws-sso-cli"
sha = "7bd3daa96362d3ec107ffa9f1714f4808e089051"
bench_version = 1

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/utils/utils.go internal/utils/utils_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/utils/utils.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 96.0
original_coverage = 96.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = [ 36, 37, 38, 45, 46, 47, 48, 49, 50, 55, 57, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 81, 82, 83, 84, 85, 86, 87, 88, 92, 93, 94, 97, 98, 99, 100, 102, 106, 107, 108, 109, 111, 115, 116, 117, 118, 121, 122, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 142, 143, 144, 145, 149, 150, 151, 152, 153, 154, 158, 159, 160, 161, 162, 164, 165, 166, 167, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 183, 187, 188, 189, 190, 191, 195, 196, 197, 198, 199, 200, 201, 202, 203, 207, 208, 209, 210, 211, 213, 217, 218, 219, 220, 221, 222,]
missed_lines = [ 51, 52, 139, 140, 141,]

[input_info]
test_file_path = "internal/utils/utils_test.go"
focal_file_path = "internal/utils/utils.go"
test_file_url = "https://github.com/synfinatic/aws-sso-cli/blob/7bd3daa96362d3ec107ffa9f1714f4808e089051/internal/utils/utils_test.go"
focal_file_url = "https://github.com/synfinatic/aws-sso-cli/blob/7bd3daa96362d3ec107ffa9f1714f4808e089051/internal/utils/utils.go"
first_commit_date = "2022-05-03"
last_commit_date = "2025-01-23"
test_file_content = "package utils\n\n/*\n * AWS SSO CLI\n * Copyright (c) 2021-2025 Aaron Turner  <synfinatic at gmail dot com>\n *\n * This program is free software: you can redistribute it\n * and/or modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or with the authors permission any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/suite\"\n)\n\ntype UtilsTestSuite struct {\n\tsuite.Suite\n}\n\nfunc TestUtilsSuite(t *testing.T) {\n\ts := &UtilsTestSuite{}\n\tsuite.Run(t, s)\n}\n\nfunc (suite *UtilsTestSuite) TestParseRoleARN() {\n\tt := suite.T()\n\tt.Parallel()\n\n\ta, r, err := ParseRoleARN(\"arn:aws:iam::11111:role/Foo\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, int64(11111), a)\n\tassert.Equal(t, \"Foo\", r)\n\n\ta, r, err = ParseRoleARN(\"000000011111:Foo\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, int64(11111), a)\n\tassert.Equal(t, \"Foo\", r)\n\n\t_, _, err = ParseRoleARN(\"\")\n\tassert.Error(t, err)\n\n\t_, _, err = ParseRoleARN(\"arnFoo\")\n\tassert.Error(t, err)\n\n\t_, _, err = ParseRoleARN(\"arn:aws:iam::a:role/Foo\")\n\tassert.Error(t, err)\n\n\t_, _, err = ParseRoleARN(\"arn:aws:iam::000000011111:role\")\n\tassert.Error(t, err)\n\n\t_, _, err = ParseRoleARN(\"aws:iam:000000011111:role/Foo\")\n\tassert.Error(t, err)\n\n\t_, _, err = ParseRoleARN(\"invalid:arn:aws:iam::000000011111:role/Foo\")\n\tassert.Error(t, err)\n\n\t_, _, err = ParseRoleARN(\"arn:aws:iam::000000011111:role/Foo/Bar\")\n\tassert.Error(t, err)\n\n\t_, _, err = ParseRoleARN(\"arn:aws:iam::-000000011111:role/Foo\")\n\tassert.Error(t, err)\n\n\t// ParseUserARN is just ParseRoleARN...\n\ta, r, err = ParseUserARN(\"arn:aws:iam::22222:user/Foo\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, int64(22222), a)\n\tassert.Equal(t, \"Foo\", r)\n}\n\nfunc (suite *UtilsTestSuite) TestMakeRoleARN() {\n\tt := suite.T()\n\tt.Parallel()\n\n\tassert.Equal(t, \"arn:aws:iam::000000011111:role/Foo\", MakeRoleARN(11111, \"Foo\"))\n\tassert.Equal(t, \"arn:aws:iam::000000711111:role/Foo\", MakeRoleARN(711111, \"Foo\"))\n\tassert.Equal(t, \"arn:aws:iam::000000000000:role/\", MakeRoleARN(0, \"\"))\n\n\tassert.Panics(t, func() { MakeRoleARN(-1, \"foo\") })\n}\n\nfunc (suite *UtilsTestSuite) TestMakeUserARN() {\n\tt := suite.T()\n\tt.Parallel()\n\n\tassert.Equal(t, \"arn:aws:iam::000000011111:user/Foo\", MakeUserARN(11111, \"Foo\"))\n\tassert.Equal(t, \"arn:aws:iam::000000711111:user/Foo\", MakeUserARN(711111, \"Foo\"))\n\tassert.Equal(t, \"arn:aws:iam::000000000000:user/\", MakeUserARN(0, \"\"))\n\n\tassert.Panics(t, func() { MakeUserARN(-1, \"foo\") })\n}\n\nfunc (suite *UtilsTestSuite) TestMakeRoleARNs() {\n\tt := suite.T()\n\tt.Parallel()\n\n\tassert.Equal(t, \"arn:aws:iam::000000011111:role/Foo\", MakeRoleARNs(\"11111\", \"Foo\"))\n\tassert.Equal(t, \"arn:aws:iam::000000711111:role/Foo\", MakeRoleARNs(\"711111\", \"Foo\"))\n\tassert.Equal(t, \"arn:aws:iam::000000711111:role/Foo\", MakeRoleARNs(\"000711111\", \"Foo\"))\n\tassert.Equal(t, \"arn:aws:iam::000000000000:role/\", MakeRoleARNs(\"0\", \"\"))\n\n\tassert.Panics(t, func() { MakeRoleARNs(\"asdfasfdo\", \"foo\") })\n}\n\nfunc (suite *UtilsTestSuite) TestEnsureDirExists() {\n\tt := suite.T()\n\tt.Parallel()\n\n\tdefer os.RemoveAll(\"./does_not_exist_dir\")\n\tassert.NoError(t, EnsureDirExists(\"./testdata/role_tags.yaml\"))\n\tassert.NoError(t, EnsureDirExists(\"./does_not_exist_dir/bar/baz/foo.yaml\"))\n\n\tf, _ := os.OpenFile(\"./does_not_exist_dir/foo.yaml\", os.O_WRONLY|os.O_CREATE, 0644)\n\tfmt.Fprintf(f, \"data\")\n\tf.Close()\n\tassert.Error(t, EnsureDirExists(\"./does_not_exist_dir/foo.yaml/bar\"))\n\n\t_ = os.MkdirAll(\"./does_not_exist_dir/invalid\", 0000)\n\tassert.Error(t, EnsureDirExists(\"./does_not_exist_dir/invalid/foo\"))\n\n\tassert.Error(t, EnsureDirExists(\"/foo/bar\"))\n}\n\nfunc (suite *UtilsTestSuite) TestGetHomePath() {\n\tt := suite.T()\n\tt.Parallel()\n\n\tassert.Equal(t, \"/\", GetHomePath(\"/\"))\n\tassert.Equal(t, \".\", GetHomePath(\".\"))\n\tassert.Equal(t, \"/foo/bar\", GetHomePath(\"/foo/bar\"))\n\tassert.Equal(t, \"/foo/bar\", GetHomePath(\"/foo////bar\"))\n\tassert.Equal(t, \"/bar\", GetHomePath(\"/foo/../bar\"))\n\thome, _ := os.UserHomeDir()\n\tx := filepath.Join(home, \"foo/bar\")\n\tassert.Equal(t, x, GetHomePath(\"~/foo/bar\"))\n}\n\nfunc (suite *UtilsTestSuite) TestAccountToString() {\n\tt := suite.T()\n\tt.Parallel()\n\n\ta, err := AccountIdToString(0)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"000000000000\", a)\n\n\ta, err = AccountIdToString(11111)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"000000011111\", a)\n\n\ta, err = AccountIdToString(999999999999)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"999999999999\", a)\n\n\t_, err = AccountIdToString(-1)\n\tassert.Error(t, err)\n\n\t_, err = AccountIdToString(-19999)\n\tassert.Error(t, err)\n\n\t_, err = AccountIdToString(1000000000000)\n\tassert.Error(t, err)\n}\n\nfunc (suite *UtilsTestSuite) TestAccountToInt64() {\n\tt := suite.T()\n\tt.Parallel()\n\n\t_, err := AccountIdToInt64(\"\")\n\tassert.Error(t, err)\n\n\ta, err := AccountIdToInt64(\"12345\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, int64(12345), a)\n\n\ta, err = AccountIdToInt64(\"0012345\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, int64(12345), a)\n\n\t_, err = AccountIdToInt64(\"0012345678912123344455323423423423424\")\n\tassert.Error(t, err)\n\n\t_, err = AccountIdToInt64(\"abdcefgi\")\n\tassert.Error(t, err)\n\n\t_, err = AccountIdToInt64(\"-1\")\n\tassert.Error(t, err)\n}\n\nfunc (suite *UtilsTestSuite) TestParseTimeString() {\n\tt := suite.T()\n\tt.Parallel()\n\n\tx, e := ParseTimeString(\"1970-01-01T00:00:00Z\")\n\tassert.NoError(t, e)\n\tassert.Equal(t, int64(0), x)\n\n\t_, e = ParseTimeString(\"00:00:00 +0000 GMT\")\n\tassert.Error(t, e)\n}\n\nfunc (suite *UtilsTestSuite) TestTimeRemain() {\n\tt := suite.T()\n\tt.Parallel()\n\n\tx, e := TimeRemain(0, false)\n\tassert.NoError(t, e)\n\tassert.Equal(t, \"Expired\", x)\n\n\td, _ := time.ParseDuration(\"5m1s\")\n\tfuture := time.Now().Add(d)\n\tx, e = TimeRemain(future.Unix(), true)\n\tassert.NoError(t, e)\n\tassert.Equal(t, \"     5m\", x)\n\n\tx, e = TimeRemain(future.Unix(), false)\n\tassert.NoError(t, e)\n\tassert.Equal(t, \"5m\", x)\n\n\td, _ = time.ParseDuration(\"5h5m1s\")\n\tfuture = time.Now().Add(d)\n\tx, e = TimeRemain(future.Unix(), true)\n\tassert.NoError(t, e)\n\tassert.Equal(t, \" 5h  5m\", x)\n\n\tx, e = TimeRemain(future.Unix(), false)\n\tassert.NoError(t, e)\n\tassert.Equal(t, \"5h5m\", x)\n\n\t// truncate down to < 1min\n\td, _ = time.ParseDuration(\"55s\")\n\tfuture = time.Now().Add(d)\n\tx, e = TimeRemain(future.Unix(), true)\n\tassert.NoError(t, e)\n\tassert.Equal(t, \"   < 1m\", x)\n\n\td, _ = time.ParseDuration(\"25s\")\n\tfuture = time.Now().Add(d)\n\tx, e = TimeRemain(future.Unix(), true)\n\tassert.NoError(t, e)\n\tassert.Equal(t, \"   < 1m\", x)\n}\n\nfunc TestStrListContains(t *testing.T) {\n\tt.Parallel()\n\tx := []string{\"yes\", \"no\"}\n\tassert.True(t, StrListContains(\"yes\", x))\n\tassert.False(t, StrListContains(\"nope\", x))\n}\n\nfunc TestIsRemoteHost(t *testing.T) {\n\tos.Setenv(\"SSH_TTY\", \"FOOBAR\")\n\tassert.True(t, IsRemoteHost())\n\n\tos.Unsetenv(\"SSH_TTY\")\n\tassert.False(t, IsRemoteHost())\n}\n"
