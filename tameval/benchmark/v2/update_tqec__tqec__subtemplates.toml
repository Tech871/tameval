[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "tqec/tqec"
sha = "3c0db694339614f537772a7bf6a183c8ffcb78a7"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r requirements.txt && pip install -r requirements-dev.txt && (pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=src/tqec/templates/subtemplates.py -m pytest -q --junit-xml=test_output.xml src/tqec/templates/subtemplates_test.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target src.tqec.templates.subtemplates --unit-test src.tqec.templates.subtemplates_test --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target src/tqec/templates/subtemplates.py --unit-test src/tqec/templates/subtemplates_test.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 56.0
original_coverage = 87.0
mutation_kill_rate = 99.0
original_mutation_kill_rate = 99.0
covered_lines = [ 2, 4, 5, 6, 8, 9, 11, 13, 16, 17, 84, 85, 87, 89, 90, 95, 96, 101, 106, 112, 113, 115, 116, 119, 122, 190, 191, 195, 196, 197, 198, 199, 202, 203, 206, 207, 208, 217, 228, 229, 234, 235, 236, 237, 239, 240, 243, 244, 265, 266, 268, 321, 322, 331,]
missed_lines = [ 91, 97, 102, 107, 270, 271, 272, 278, 279, 280, 286, 287, 290, 291, 299, 300, 301, 305, 306, 310, 311, 315, 316, 324, 325, 328, 381, 388, 391, 392, 394, 398, 399, 400, 401, 403, 404, 405, 406, 408, 410, 412, 413,]

[input_info]
test_file_path = "src/tqec/templates/subtemplates_test.py"
focal_file_path = "src/tqec/templates/subtemplates.py"
test_file_url = "https://github.com/tqec/tqec/blob/3c0db694339614f537772a7bf6a183c8ffcb78a7/src/tqec/templates/subtemplates_test.py"
focal_file_url = "https://github.com/tqec/tqec/blob/3c0db694339614f537772a7bf6a183c8ffcb78a7/src/tqec/templates/subtemplates.py"
first_commit_date = "2024-09-11"
last_commit_date = "2025-08-12"
test_file_content = "import itertools\n\nimport numpy\nimport numpy.typing as npt\nimport pytest\n\nfrom tqec.templates.base import Template\nfrom tqec.templates.layout import LayoutTemplate\nfrom tqec.templates.qubit import QubitSpatialCubeTemplate, QubitTemplate\nfrom tqec.templates.subtemplates import (\n    get_spatially_distinct_3d_subtemplates,\n    get_spatially_distinct_subtemplates,\n)\nfrom tqec.utils.position import BlockPosition2D\n\n_TEMPLATES_TO_TEST = [\n    QubitTemplate(),\n    QubitSpatialCubeTemplate(),\n    LayoutTemplate(\n        {BlockPosition2D(0, 0): QubitTemplate(), BlockPosition2D(1, 1): QubitTemplate()}\n    ),\n]\n_VALUES_OF_K_TO_TEST = [1, 10]\n_VALUES_OF_MANHATTAN_RADIUS_TO_TEST = [0, 1, 3]\n\n\n@pytest.mark.filterwarnings(\"ignore:Instantiating Qubit4WayJunctionTemplate\")\n@pytest.mark.parametrize(\n    \"template,k,r,avoid_zero_plaquettes\",\n    itertools.product(\n        _TEMPLATES_TO_TEST,\n        _VALUES_OF_K_TO_TEST,\n        _VALUES_OF_MANHATTAN_RADIUS_TO_TEST,\n        [True, False],\n    ),\n)\ndef test_get_spatially_distinct_subtemplates(\n    template: Template, k: int, r: int, avoid_zero_plaquettes: bool\n) -> None:\n    instantiation = template.instantiate(k)\n    n, m = instantiation.shape\n    unique_subtemplates = get_spatially_distinct_subtemplates(\n        instantiation, r, avoid_zero_plaquettes\n    )\n\n    # Check that the radius is correctly recovered.\n    assert unique_subtemplates.manhattan_radius == r\n\n    # Try to reconstruct the template instantiation from the computed sub-templates.\n    instantiation_reconstruction: npt.NDArray[numpy.int_] = numpy.zeros(\n        (n + 2 * r, m + 2 * r), dtype=numpy.int_\n    )\n    # The below line is not strictly needed, but makes type checkers happy with\n    # type inference. See https://numpy.org/doc/stable/reference/typing.html#d-arrays\n    # for more information on why this should be done.\n    subtemplate_indices_list: list[list[int]] = unique_subtemplates.subtemplate_indices.tolist()\n    for i, row in enumerate(subtemplate_indices_list):\n        for j, subtemplate_index in enumerate(row):\n            if subtemplate_index == 0:\n                continue\n            subtemplate = unique_subtemplates.subtemplates[subtemplate_index]\n            ir_subarray = instantiation_reconstruction[\n                i : i + 2 * r + 1,\n                j : j + 2 * r + 1,\n            ]\n            # Try to superimpose `subtemplate` on `ir_subarray`.\n            # Any non-zero entry in `ir_subarray` should exactly match with the\n            # corresponding entry in `subtemplate`. Any zero entry can be\n            # overridden by anything.\n            nzx, nzy = ir_subarray.nonzero()\n            numpy.testing.assert_array_equal(subtemplate[nzx, nzy], ir_subarray[nzx, nzy])\n            instantiation_reconstruction[\n                i : i + 2 * r + 1,\n                j : j + 2 * r + 1,\n            ] = subtemplate\n    # `instantiation` should now be exactly reconstructed in the inner part of\n    # `instantiation_reconstruction`.\n    numpy.testing.assert_array_equal(\n        instantiation,\n        instantiation_reconstruction[r : r + n, r : r + m],\n    )\n    # The borders of `instantiation_reconstruction` should be filled with zeros.\n    top_border = instantiation_reconstruction[:r, :]\n    bottom_border = instantiation_reconstruction[r + n :, :]\n    left_border = instantiation_reconstruction[:, :r]\n    right_border = instantiation_reconstruction[:, r + m :]\n    for border in [top_border, bottom_border, left_border, right_border]:\n        numpy.testing.assert_array_equal(border, numpy.zeros_like(border))\n\n\n_TEMPLATE_PAIRS_TO_TEST = [\n    (QubitTemplate(), QubitSpatialCubeTemplate()),\n    (\n        LayoutTemplate(\n            {\n                BlockPosition2D(0, 0): QubitTemplate(),\n                BlockPosition2D(1, 1): QubitSpatialCubeTemplate(),\n            }\n        ),\n        LayoutTemplate(\n            {\n                BlockPosition2D(0, 0): QubitSpatialCubeTemplate(),\n                BlockPosition2D(1, 1): QubitTemplate(),\n            }\n        ),\n    ),\n]\n\n\n@pytest.mark.filterwarnings(\"ignore:Instantiating Qubit4WayJunctionTemplate\")\n@pytest.mark.parametrize(\n    \"templates,k,r,avoid_zero_plaquettes\",\n    itertools.product(\n        _TEMPLATE_PAIRS_TO_TEST,\n        _VALUES_OF_K_TO_TEST,\n        _VALUES_OF_MANHATTAN_RADIUS_TO_TEST,\n        [True, False],\n    ),\n)\ndef test_get_spatially_distinct_3d_subtemplates(\n    templates: tuple[Template, ...],\n    k: int,\n    r: int,\n    avoid_zero_plaquettes: bool,\n) -> None:\n    instantiations = tuple(t.instantiate(k) for t in templates)\n    instantiation_3d = numpy.stack(instantiations, axis=2)\n    unique_3d_subtemplates = get_spatially_distinct_3d_subtemplates(\n        instantiations, r, avoid_zero_plaquettes\n    )\n    # Check that the radius is correctly recovered.\n    assert unique_3d_subtemplates.manhattan_radius == r\n\n    # Try to reconstruct the templates instantiation from the computed sub-templates.\n    n, m, t = instantiation_3d.shape\n    instantiation_reconstruction: npt.NDArray[numpy.int_] = numpy.zeros(\n        (n + 2 * r, m + 2 * r, t), dtype=numpy.int_\n    )\n    # The below line is not strictly needed, but makes type checkers happy with\n    # type inference. See https://numpy.org/doc/stable/reference/typing.html#d-arrays\n    # for more information on why this should be done.\n    subtemplate_indices_list: list[list[list[int]]] = (\n        unique_3d_subtemplates.subtemplate_indices.tolist()\n    )\n    for i, row in enumerate(subtemplate_indices_list):\n        for j, subtemplate_index_arr in enumerate(row):\n            if all(subti == 0 for subti in subtemplate_index_arr):\n                continue\n            subt_index_tup = tuple(subtemplate_index_arr)\n            subtemplate = unique_3d_subtemplates.subtemplates[subt_index_tup]\n            ir_subarray = instantiation_reconstruction[i : i + 2 * r + 1, j : j + 2 * r + 1, :]\n            # Try to superimpose `subtemplate` on `ir_subarray`.\n            # Any non-zero entry in `ir_subarray` should exactly match with the\n            # corresponding entry in `subtemplate`. Any zero entry can be\n            # overridden by anything.\n            nzx, nzy, nzt = ir_subarray.nonzero()\n            numpy.testing.assert_array_equal(subtemplate[nzx, nzy, nzt], ir_subarray[nzx, nzy, nzt])\n            instantiation_reconstruction[i : i + 2 * r + 1, j : j + 2 * r + 1, :] = subtemplate\n    # `instantiation` should now be exactly reconstructed in the inner part of\n    # `instantiation_reconstruction`.\n    numpy.testing.assert_array_equal(\n        instantiation_3d,\n        instantiation_reconstruction[r : r + n, r : r + m, :],\n    )\n    # The borders of `instantiation_reconstruction` should be filled with zeros.\n    top_border = instantiation_reconstruction[:r, :, :]\n    bottom_border = instantiation_reconstruction[r + n :, :, :]\n    left_border = instantiation_reconstruction[:, :r, :]\n    right_border = instantiation_reconstruction[:, r + m :, :]\n    for border in [top_border, bottom_border, left_border, right_border]:\n        numpy.testing.assert_array_equal(border, numpy.zeros_like(border))"
