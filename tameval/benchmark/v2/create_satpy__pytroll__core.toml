[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "pytroll/satpy"
sha = "0beea130092f3270ae1af8a87644d47971acbbc4"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "(pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=satpy/composites/core.py -m pytest -q --junit-xml=test_output.xml satpy/tests/compositor_tests/test_core.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target satpy.composites.core --unit-test satpy.tests.compositor_tests.test_core --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target satpy/composites/core.py --unit-test satpy/tests/compositor_tests/test_core.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 69.0
original_coverage = 84.0
mutation_kill_rate = 100.0
original_mutation_kill_rate = 100.0
covered_lines = [ 18, 20, 21, 22, 24, 25, 26, 28, 29, 30, 32, 34, 35, 37, 40, 44, 48, 62, 65, 66, 67, 68, 70, 71, 79, 88, 93, 98, 107, 117, 120, 126, 151, 152, 153, 154, 155, 157, 175, 178, 179, 181, 182, 183, 185, 187, 188, 189, 192, 193, 195, 196, 199, 200, 202, 204, 205, 215, 216, 217, 220, 221, 223, 225, 227, 228, 240, 243, 246, 251, 252, 253, 255, 257, 258, 261, 262, 264, 265, 266, 267, 268, 271, 274, 275, 276, 277, 278, 279, 282, 285, 286, 293, 294, 295, 299, 318, 336, 342, 343, 344, 345, 346, 348, 350, 353, 354, 355, 356, 357, 358, 359, 361, 365, 368, 370, 378, 379, 381, 382, 384, 386, 388, 389, 392, 393, 394, 395, 400, 402, 403, 404, 405, 406, 411, 412, 415, 417, 424, 425, 430, 432, 434, 435, 437, 439, 441, 444, 445, 446, 448, 449, 451, 452, 453, 455, 456, 460, 461, 464, 466, 467, 469, 470, 471, 472, 474, 477, 478, 479, 481, 482, 484, 487, 489, 490, 491, 492, 493, 498, 499, 500, 501, 504, 506, 512, 515, 522, 525,]
missed_lines = [ 73, 74, 75, 76, 77, 86, 90, 91, 95, 96, 100, 101, 102, 103, 105, 108, 109, 111, 112, 113, 114, 115, 118, 121, 122, 123, 124, 176, 197, 270, 287, 289, 290, 296, 300, 301, 303, 304, 305, 306, 307, 309, 310, 311, 312, 313, 314, 315, 319, 320, 322, 323, 328, 329, 330, 331, 332, 333, 351, 385, 387, 390, 396, 397, 398, 407, 408, 410, 413, 414, 462, 480, 495, 502, 503, 507, 509, 510, 511, 517, 518, 519, 527, 532, 533, 534,]

[input_info]
test_file_path = "satpy/tests/compositor_tests/test_core.py"
focal_file_path = "satpy/composites/core.py"
test_file_url = "https://github.com/pytroll/satpy/blob/0beea130092f3270ae1af8a87644d47971acbbc4/satpy/tests/compositor_tests/test_core.py"
focal_file_url = "https://github.com/pytroll/satpy/blob/0beea130092f3270ae1af8a87644d47971acbbc4/satpy/composites/core.py"
first_commit_date = "2025-06-23"
last_commit_date = "2025-06-23"
test_file_content = "#!/usr/bin/env python\n# Copyright (c) 2018-2025 Satpy developers\n#\n# This file is part of satpy.\n#\n# satpy is free software: you can redistribute it and/or modify it under the\n# terms of the GNU General Public License as published by the Free Software\n# Foundation, either version 3 of the License, or (at your option) any later\n# version.\n#\n# satpy is distributed in the hope that it will be useful, but WITHOUT ANY\n# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n# A PARTICULAR PURPOSE.  See the GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along with\n# satpy.  If not, see <http://www.gnu.org/licenses/>.\n\n\"\"\"Tests for compositor core functionality.\"\"\"\n\nimport unittest\nfrom unittest import mock\n\nimport dask.array as da\nimport numpy as np\nimport pytest\nimport xarray as xr\nfrom pyresample import AreaDefinition\n\nclass TestMatchDataArrays:\n    \"\"\"Test the utility method 'match_data_arrays'.\"\"\"\n\n    def _get_test_ds(self, shape=(50, 100), dims=(\"y\", \"x\")):\n        \"\"\"Get a fake DataArray.\"\"\"\n        data = da.random.random(shape, chunks=25)\n        area = AreaDefinition(\n            \"test\", \"test\", \"test\",\n            {\"proj\": \"eqc\", \"lon_0\": 0.0,\n             \"lat_0\": 0.0},\n            shape[dims.index(\"x\")], shape[dims.index(\"y\")],\n            (-20037508.34, -10018754.17, 20037508.34, 10018754.17))\n        attrs = {\"area\": area}\n        return xr.DataArray(data, dims=dims, attrs=attrs)\n\n    def test_mult_ds_diff_area(self):\n        \"\"\"Test that datasets with different areas fail.\"\"\"\n        from satpy.composites.core import CompositeBase, IncompatibleAreas\n        ds1 = self._get_test_ds()\n        ds2 = self._get_test_ds()\n        ds2.attrs[\"area\"] = AreaDefinition(\n            \"test\", \"test\", \"test\",\n            {\"proj\": \"eqc\", \"lon_0\": 0.0,\n             \"lat_0\": 0.0},\n            100, 50,\n            (-30037508.34, -20018754.17, 10037508.34, 18754.17))\n        comp = CompositeBase(\"test_comp\")\n        with pytest.raises(IncompatibleAreas):\n            comp.match_data_arrays((ds1, ds2))\n\n    def test_mult_ds_diff_size(self):\n        \"\"\"Test that datasets with different sizes fail.\"\"\"\n        from satpy.composites.core import CompositeBase, IncompatibleAreas\n\n        # x is 50 in this one, 100 in ds2\n        # y is 100 in this one, 50 in ds2\n        ds1 = self._get_test_ds(shape=(50, 100), dims=(\"x\", \"y\"))\n        ds2 = self._get_test_ds(shape=(3, 50, 100), dims=(\"bands\", \"y\", \"x\"))\n        comp = CompositeBase(\"test_comp\")\n        with pytest.raises(IncompatibleAreas):\n            comp.match_data_arrays((ds1, ds2))\n\n    def test_nondimensional_coords(self):\n        \"\"\"Test the removal of non-dimensional coordinates when compositing.\"\"\"\n        from satpy.composites.core import CompositeBase\n        ds = self._get_test_ds(shape=(2, 2))\n        ds[\"acq_time\"] = (\"y\", [0, 1])\n        comp = CompositeBase(\"test_comp\")\n        ret_datasets = comp.match_data_arrays([ds, ds])\n        assert \"acq_time\" not in ret_datasets[0].coords\n\nclass TestInlineComposites(unittest.TestCase):\n    \"\"\"Test inline composites.\"\"\"\n\nclass TestSingleBandCompositor(unittest.TestCase):\n    \"\"\"Test the single-band compositor.\"\"\"\n\n    def setUp(self):\n        \"\"\"Create test data.\"\"\"\n        from satpy.composites.core import SingleBandCompositor\n        self.comp = SingleBandCompositor(name=\"test\")\n\n        all_valid = np.ones((2, 2))\n        self.all_valid = xr.DataArray(all_valid, dims=[\"y\", \"x\"])\n\n    def test_call(self):\n        \"\"\"Test calling the compositor.\"\"\"\n        # Dataset with extra attributes\n        all_valid = self.all_valid\n        all_valid.attrs[\"sensor\"] = \"foo\"\n        attrs = {\n            \"foo\": \"bar\",\n            \"resolution\": 333,\n            \"units\": \"K\",\n            \"sensor\": {\"fake_sensor1\", \"fake_sensor2\"},\n            \"calibration\": \"BT\",\n            \"wavelength\": 10.8\n        }\n        self.comp.attrs[\"resolution\"] = None\n        res = self.comp([all_valid], **attrs)\n        # Verify attributes\n        assert res.attrs.get(\"sensor\") == \"foo\"\n        assert \"foo\" in res.attrs\n        assert res.attrs.get(\"foo\") == \"bar\"\n        assert \"units\" in res.attrs\n        assert \"calibration\" in res.attrs\n        assert \"modifiers\" not in res.attrs\n        assert res.attrs[\"wavelength\"] == 10.8\n        assert res.attrs[\"resolution\"] == 333\n\nclass TestGenericCompositor(unittest.TestCase):\n    \"\"\"Test generic compositor.\"\"\"\n\n    def setUp(self):\n        \"\"\"Create test data.\"\"\"\n        from satpy.composites.core import GenericCompositor\n        self.comp = GenericCompositor(name=\"test\")\n        self.comp2 = GenericCompositor(name=\"test2\", common_channel_mask=False)\n\n        all_valid = np.ones((1, 2, 2))\n        self.all_valid = xr.DataArray(all_valid, dims=[\"bands\", \"y\", \"x\"])\n        first_invalid = np.reshape(np.array([np.nan, 1., 1., 1.]), (1, 2, 2))\n        self.first_invalid = xr.DataArray(first_invalid,\n                                          dims=[\"bands\", \"y\", \"x\"])\n        second_invalid = np.reshape(np.array([1., np.nan, 1., 1.]), (1, 2, 2))\n        self.second_invalid = xr.DataArray(second_invalid,\n                                           dims=[\"bands\", \"y\", \"x\"])\n        wrong_shape = np.reshape(np.array([1., 1., 1.]), (1, 3, 1))\n        self.wrong_shape = xr.DataArray(wrong_shape, dims=[\"bands\", \"y\", \"x\"])\n\n    def test_masking(self):\n        \"\"\"Test masking in generic compositor.\"\"\"\n        # Single channel\n        res = self.comp([self.all_valid])\n        np.testing.assert_allclose(res.data, 1., atol=1e-9)\n        # Three channels, one value invalid\n        res = self.comp([self.all_valid, self.all_valid, self.first_invalid])\n        correct = np.reshape(np.array([np.nan, 1., 1., 1.]), (2, 2))\n        for i in range(3):\n            np.testing.assert_almost_equal(res.data[i, :, :], correct)\n        # Three channels, two values invalid\n        res = self.comp([self.all_valid, self.first_invalid, self.second_invalid])\n        correct = np.reshape(np.array([np.nan, np.nan, 1., 1.]), (2, 2))\n        for i in range(3):\n            np.testing.assert_almost_equal(res.data[i, :, :], correct)\n\n    @mock.patch(\"satpy.composites.core.GenericCompositor._get_sensors\")\n    @mock.patch(\"satpy.composites.core.combine_metadata\")\n    @mock.patch(\"satpy.composites.core.check_times\")\n    @mock.patch(\"satpy.composites.core.GenericCompositor.match_data_arrays\")\n    def test_call_with_mock(self, match_data_arrays, check_times, combine_metadata, get_sensors):\n        \"\"\"Test calling generic compositor.\"\"\"\n        from satpy.composites.core import IncompatibleAreas\n        combine_metadata.return_value = dict()\n        get_sensors.return_value = \"foo\"\n        # One dataset, no mode given\n        res = self.comp([self.all_valid])\n        assert res.shape[0] == 1\n        assert res.attrs[\"mode\"] == \"L\"\n        match_data_arrays.assert_not_called()\n        # This compositor has been initialized without common masking, so the\n        # masking shouldn't have been called\n        projectables = [self.all_valid, self.first_invalid, self.second_invalid]\n        match_data_arrays.return_value = projectables\n        res = self.comp2(projectables)\n        match_data_arrays.assert_called_once()\n        match_data_arrays.reset_mock()\n        # Dataset for alpha given, so shouldn't be masked\n        projectables = [self.all_valid, self.all_valid]\n        match_data_arrays.return_value = projectables\n        res = self.comp(projectables)\n        match_data_arrays.assert_called_once()\n        match_data_arrays.reset_mock()\n        # When areas are incompatible, masking shouldn't happen\n        match_data_arrays.side_effect = IncompatibleAreas()\n        with pytest.raises(IncompatibleAreas):\n            self.comp([self.all_valid, self.wrong_shape])\n        match_data_arrays.assert_called_once()\n\n    def test_deprecation_warning(self):\n        \"\"\"Test deprecation warning for dcprecated composite recipes.\"\"\"\n        warning_message = \"foo is a deprecated composite. Use composite bar instead.\"\n        self.comp.attrs[\"deprecation_warning\"] = warning_message\n        with pytest.warns(UserWarning, match=warning_message):\n            self.comp([self.all_valid])\n\nclass TestAddBands(unittest.TestCase):\n    \"\"\"Test case for the `add_bands` function.\"\"\"\n\n    def test_add_bands_p_l(self):\n        \"\"\"Test adding bands.\"\"\"\n        from satpy.composites.core import add_bands\n\n        # P(RGBA) + L -> RGBA\n        data = xr.DataArray(da.ones((1, 3, 3)), dims=(\"bands\", \"y\", \"x\"),\n                            coords={\"bands\": [\"P\"]},\n                            attrs={\"mode\": \"P\"})\n        new_bands = xr.DataArray(da.array([\"L\"]), dims=(\"bands\"),\n                                 coords={\"bands\": [\"L\"]})\n        with pytest.raises(NotImplementedError):\n            add_bands(data, new_bands)\n\ndef _check_add_band_results(res, res_bands, dtype):\n    assert res.attrs[\"mode\"] == \"\".join(res_bands)\n    np.testing.assert_array_equal(res.bands, res_bands)\n    np.testing.assert_array_equal(res.coords[\"bands\"], res_bands)\n    assert res.dtype == dtype\n\nclass TestEnhance2Dataset(unittest.TestCase):\n    \"\"\"Test the enhance2dataset utility.\"\"\"\n\n    @mock.patch(\"satpy.enhancements.enhancer.get_enhanced_image\")\n    def test_enhance_p_to_rgb(self, get_enhanced_image):\n        \"\"\"Test enhancing a paletted dataset in RGB mode.\"\"\"\n        from trollimage.xrimage import XRImage\n        img = XRImage(xr.DataArray(np.ones((1, 20, 20)) * 2, dims=(\"bands\", \"y\", \"x\"), coords={\"bands\": [\"P\"]}))\n        img.palette = ((0, 0, 0), (4, 4, 4), (8, 8, 8))\n        get_enhanced_image.return_value = img\n\n        from satpy.composites.core import enhance2dataset\n        dataset = xr.DataArray(np.ones((1, 20, 20)))\n        res = enhance2dataset(dataset, convert_p=True)\n        assert res.attrs[\"mode\"] == \"RGB\"\n\n    @mock.patch(\"satpy.enhancements.enhancer.get_enhanced_image\")\n    def test_enhance_p_to_rgba(self, get_enhanced_image):\n        \"\"\"Test enhancing a paletted dataset in RGBA mode.\"\"\"\n        from trollimage.xrimage import XRImage\n        img = XRImage(xr.DataArray(np.ones((1, 20, 20)) * 2, dims=(\"bands\", \"y\", \"x\"), coords={\"bands\": [\"P\"]}))\n        img.palette = ((0, 0, 0, 255), (4, 4, 4, 255), (8, 8, 8, 255))\n        get_enhanced_image.return_value = img\n\n        from satpy.composites.core import enhance2dataset\n        dataset = xr.DataArray(np.ones((1, 20, 20)))\n        res = enhance2dataset(dataset, convert_p=True)\n        assert res.attrs[\"mode\"] == \"RGBA\"\n\nclass TestInferMode(unittest.TestCase):\n    \"\"\"Test the infer_mode utility.\"\"\"\n\n    def test_bands_coords_is_used(self):\n        \"\"\"Test that the `bands` coord is used.\"\"\"\n        from satpy.composites.core import GenericCompositor\n        arr = xr.DataArray(np.ones((1, 5, 5)), dims=(\"bands\", \"x\", \"y\"), coords={\"bands\": [\"P\"]})\n        assert GenericCompositor.infer_mode(arr) == \"P\"\n\n        arr = xr.DataArray(np.ones((3, 5, 5)), dims=(\"bands\", \"x\", \"y\"), coords={\"bands\": [\"Y\", \"Cb\", \"Cr\"]})\n        assert GenericCompositor.infer_mode(arr) == \"YCbCr\"\n"
