[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.22"

[repo_info]
repository = "cadence-workflow/cadence"
sha = "6d4ff3b9586899afadea49387fa6cfe75b0d00aa"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out common/reconciliation/fetcher/timer.go common/reconciliation/fetcher/timer_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting common/reconciliation/fetcher/timer.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 90.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "common/reconciliation/fetcher/timer_test.go"
focal_file_path = "common/reconciliation/fetcher/timer.go"
test_file_url = "https://github.com/cadence-workflow/cadence/blob/6d4ff3b9586899afadea49387fa6cfe75b0d00aa/common/reconciliation/fetcher/timer_test.go"
focal_file_url = "https://github.com/cadence-workflow/cadence/blob/6d4ff3b9586899afadea49387fa6cfe75b0d00aa/common/reconciliation/fetcher/timer.go"
first_commit_date = "2021-01-05"
last_commit_date = "2025-03-22"
test_file_content = "// The MIT License (MIT)\n//\n// Copyright (c) 2017-2020 Uber Technologies Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\npackage fetcher\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n\n\t\"github.com/uber/cadence/common/pagination\"\n\t\"github.com/uber/cadence/common/persistence\"\n\t\"github.com/uber/cadence/common/reconciliation/entity\"\n)\n\nfunc TestTimerIterator(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tretryer := persistence.NewMockRetryer(ctrl)\n\tretryer.EXPECT().GetTimerIndexTasks(gomock.Any(), gomock.Any()).\n\t\tReturn(&persistence.GetTimerIndexTasksResponse{}, nil).\n\t\tTimes(1)\n\n\titerator := TimerIterator(\n\t\tcontext.Background(),\n\t\tretryer,\n\t\ttime.Now(),\n\t\ttime.Now(),\n\t\t10,\n\t)\n\trequire.NotNil(t, iterator)\n}\n\nfunc TestGetUserTimers(t *testing.T) {\n\tfixedTimestamp, err := time.Parse(time.RFC3339, \"2023-12-12T22:08:41Z\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse timestamp: %v\", err)\n\t}\n\n\tpageSize := 10\n\tminTimestamp := fixedTimestamp.Add(-time.Hour)\n\tmaxTimestamp := fixedTimestamp\n\tnonNilToken := []byte(\"non-nil-token\")\n\n\ttestCases := []struct {\n\t\tname          string\n\t\tsetupMock     func(ctrl *gomock.Controller) *persistence.MockRetryer\n\t\ttoken         pagination.PageToken\n\t\texpectedPage  pagination.Page\n\t\texpectedError error\n\t}{\n\t\t{\n\t\t\tname: \"Success\",\n\t\t\tsetupMock: func(ctrl *gomock.Controller) *persistence.MockRetryer {\n\t\t\t\tmockRetryer := persistence.NewMockRetryer(ctrl)\n\t\t\t\ttimerTasks := []*persistence.TimerTaskInfo{\n\t\t\t\t\t{\n\t\t\t\t\t\tDomainID:            \"testDomainID\",\n\t\t\t\t\t\tWorkflowID:          \"testWorkflowID\",\n\t\t\t\t\t\tRunID:               \"testRunID\",\n\t\t\t\t\t\tVisibilityTimestamp: fixedTimestamp,\n\t\t\t\t\t\tTaskType:            persistence.TaskTypeUserTimer,\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tmockRetryer.EXPECT().\n\t\t\t\t\tGetTimerIndexTasks(gomock.Any(), &persistence.GetTimerIndexTasksRequest{\n\t\t\t\t\t\tMinTimestamp:  minTimestamp,\n\t\t\t\t\t\tMaxTimestamp:  maxTimestamp,\n\t\t\t\t\t\tBatchSize:     pageSize,\n\t\t\t\t\t\tNextPageToken: nil,\n\t\t\t\t\t}).\n\t\t\t\t\tReturn(&persistence.GetTimerIndexTasksResponse{\n\t\t\t\t\t\tTimers:        timerTasks,\n\t\t\t\t\t\tNextPageToken: nil,\n\t\t\t\t\t}, nil)\n\n\t\t\t\tmockRetryer.EXPECT().GetShardID().Return(123)\n\n\t\t\t\treturn mockRetryer\n\t\t\t},\n\t\t\ttoken: nil,\n\t\t\texpectedPage: pagination.Page{\n\t\t\t\tEntities: []pagination.Entity{\n\t\t\t\t\t&entity.Timer{\n\t\t\t\t\t\tShardID:             123,\n\t\t\t\t\t\tDomainID:            \"testDomainID\",\n\t\t\t\t\t\tWorkflowID:          \"testWorkflowID\",\n\t\t\t\t\t\tRunID:               \"testRunID\",\n\t\t\t\t\t\tTaskType:            persistence.TaskTypeUserTimer,\n\t\t\t\t\t\tVisibilityTimestamp: fixedTimestamp,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Non-nil Pagination Token Provided\",\n\t\t\tsetupMock: func(ctrl *gomock.Controller) *persistence.MockRetryer {\n\t\t\t\tmockRetryer := persistence.NewMockRetryer(ctrl)\n\n\t\t\t\tmockRetryer.EXPECT().\n\t\t\t\t\tGetTimerIndexTasks(gomock.Any(), &persistence.GetTimerIndexTasksRequest{\n\t\t\t\t\t\tMinTimestamp:  minTimestamp,\n\t\t\t\t\t\tMaxTimestamp:  maxTimestamp,\n\t\t\t\t\t\tBatchSize:     pageSize,\n\t\t\t\t\t\tNextPageToken: nonNilToken,\n\t\t\t\t\t}).\n\t\t\t\t\tReturn(&persistence.GetTimerIndexTasksResponse{\n\t\t\t\t\t\tTimers:        nil,\n\t\t\t\t\t\tNextPageToken: nonNilToken,\n\t\t\t\t\t}, nil)\n\n\t\t\t\treturn mockRetryer\n\t\t\t},\n\t\t\ttoken: nonNilToken,\n\t\t\texpectedPage: pagination.Page{\n\t\t\t\tEntities:     nil,\n\t\t\t\tCurrentToken: nonNilToken,\n\t\t\t\tNextToken:    nonNilToken,\n\t\t\t},\n\t\t\texpectedError: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"Invalid Timer Causes Error\",\n\t\t\tsetupMock: func(ctrl *gomock.Controller) *persistence.MockRetryer {\n\t\t\t\tmockRetryer := persistence.NewMockRetryer(ctrl)\n\n\t\t\t\tinvalidTimer := &persistence.TimerTaskInfo{\n\t\t\t\t\tDomainID:            \"\", // Invalid as it's empty\n\t\t\t\t\tWorkflowID:          \"testWorkflowID\",\n\t\t\t\t\tRunID:               \"testRunID\",\n\t\t\t\t\tVisibilityTimestamp: fixedTimestamp,\n\t\t\t\t\tTaskType:            persistence.TaskTypeUserTimer,\n\t\t\t\t}\n\n\t\t\t\tmockRetryer.EXPECT().\n\t\t\t\t\tGetTimerIndexTasks(gomock.Any(), &persistence.GetTimerIndexTasksRequest{\n\t\t\t\t\t\tMinTimestamp:  minTimestamp,\n\t\t\t\t\t\tMaxTimestamp:  maxTimestamp,\n\t\t\t\t\t\tBatchSize:     pageSize,\n\t\t\t\t\t\tNextPageToken: nil,\n\t\t\t\t\t}).\n\t\t\t\t\tReturn(&persistence.GetTimerIndexTasksResponse{\n\t\t\t\t\t\tTimers:        []*persistence.TimerTaskInfo{invalidTimer},\n\t\t\t\t\t\tNextPageToken: nil,\n\t\t\t\t\t}, nil)\n\n\t\t\t\tmockRetryer.EXPECT().GetShardID().Return(123)\n\n\t\t\t\treturn mockRetryer\n\t\t\t},\n\t\t\ttoken:         nil,\n\t\t\texpectedPage:  pagination.Page{},\n\t\t\texpectedError: fmt.Errorf(\"empty DomainID\"),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tdefer ctrl.Finish()\n\n\t\t\tmockRetryer := tc.setupMock(ctrl)\n\n\t\t\tfetchFn := getUserTimers(mockRetryer, minTimestamp, maxTimestamp, pageSize)\n\t\t\tpage, err := fetchFn(context.Background(), tc.token)\n\n\t\t\tif tc.expectedError != nil {\n\t\t\t\trequire.Error(t, err)\n\t\t\t\trequire.EqualError(t, err, tc.expectedError.Error(), \"Error should match\")\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err, \"No error is expected\")\n\t\t\t}\n\n\t\t\trequire.Equal(t, tc.expectedPage, page, \"Page should match\")\n\t\t})\n\t}\n}"
