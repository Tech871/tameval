[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "XanaduAI/MrMustard"
sha = "a4e85ddf1df86333ecb8014f36d30e4437cbe4d4"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "(pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=mrmustard/physics/triples.py -m pytest -q --junit-xml=test_output.xml tests/test_physics/test_triples.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target mrmustard.physics.triples --unit-test tests.test_physics.test_triples --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target mrmustard/physics/triples.py --unit-test tests/test_physics/test_triples.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 64.0
original_coverage = 72.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = [ 19, 21, 23, 25, 26, 27, 29, 36, 43, 47, 50, 54, 62, 73, 74, 75, 77, 80, 102, 125, 139, 143, 145, 146, 147, 149, 152, 192, 223, 248, 292, 323, 356, 368, 369, 370, 372, 374, 381, 382, 384, 392, 404, 405, 406, 408, 410, 417, 418, 420, 423, 448, 462, 466, 467, 469, 470, 472, 479, 480, 482, 485, 499, 503, 504, 506, 507, 508, 510, 517, 518, 519, 521, 524, 571, 581, 582, 584, 585, 586, 588, 596, 611, 612, 613, 615, 616, 618, 619, 620, 622, 631, 632, 634, 637, 650, 651, 652, 654, 660, 661, 662, 663, 672, 673, 675, 678, 690, 691, 692, 694, 695, 697, 701, 702, 704, 707, 717, 719, 720, 721, 722, 725, 754, 755, 756, 758, 761, 812, 831, 832, 834, 839, 844, 847, 848, 861, 862, 863, 865, 868, 901, 914, 915, 916, 918, 919, 921, 923, 931, 932, 934, 937, 949, 951, 953, 957, 958, 959, 960, 961, 962, 963, 964, 967, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1004,]
missed_lines = [ 40, 92, 93, 95, 96, 97, 99, 114, 116, 118, 119, 120, 122, 168, 173, 176, 177, 179, 180, 184, 189, 206, 207, 208, 210, 211, 213, 217, 218, 220, 233, 234, 236, 238, 239, 240, 245, 259, 260, 261, 262, 263, 270, 271, 277, 278, 279, 283, 284, 305, 306, 307, 308, 311, 317, 318, 320, 337, 341, 343, 344, 345, 346, 348, 436, 438, 439, 441, 442, 443, 445, 538, 542, 543, 545, 546, 547, 549, 553, 560, 564, 565, 566, 568, 778, 779, 780, 782, 783, 784, 785, 801, 802, 804, 876, 877, 879, 891, 892, 893,]

[input_info]
test_file_path = "tests/test_physics/test_triples.py"
focal_file_path = "mrmustard/physics/triples.py"
test_file_url = "https://github.com/XanaduAI/MrMustard/blob/a4e85ddf1df86333ecb8014f36d30e4437cbe4d4/tests/test_physics/test_triples.py"
focal_file_url = "https://github.com/XanaduAI/MrMustard/blob/a4e85ddf1df86333ecb8014f36d30e4437cbe4d4/mrmustard/physics/triples.py"
first_commit_date = "2024-02-13"
last_commit_date = "2025-07-31"
test_file_content = "# Copyright 2023 Xanadu Quantum Technologies Inc.\n\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n\n#     http://www.apache.org/licenses/LICENSE-2.0\n\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests the Bargmann triples.\"\"\"\n\nimport numpy as np\nimport pytest\n\nfrom mrmustard import math, settings\nfrom mrmustard.physics import triples\nfrom mrmustard.physics.ansatz import PolyExpAnsatz\n\n\nclass TestTriples:\n    r\"\"\"\n    Tests the Bargmann triples.\n    \"\"\"\n\n    def test_incompatible_shapes(self):\n        if math.backend_name == \"jax\":\n            error = ValueError\n            match = \"Incompatible shapes for broadcasting\"\n        else:\n            error = ValueError\n            match = \"shape mismatch\"\n\n        with pytest.raises(error, match=match):\n            triples.coherent_state_Abc([1, 2], [3, 4, 5])\n\n        with pytest.raises(error, match=match):\n            triples.coherent_state_Abc([1, 2], [3, 4, 5])\n\n        with pytest.raises(error, match=match):\n            triples.squeezed_vacuum_state_Abc([1, 2], [3, 4, 5])\n\n        with pytest.raises(error, match=match):\n            triples.displaced_squeezed_vacuum_state_Abc([1, 2], [3, 4, 5], 6, 7)\n\n    @pytest.mark.parametrize(\"n_modes\", [1, 3])\n    def test_vacuum_state_Abc(self, n_modes):\n        A, b, c = triples.vacuum_state_Abc(n_modes)\n\n        assert math.allclose(A, math.zeros((n_modes, n_modes)))\n        assert math.allclose(b, math.zeros(n_modes))\n        assert math.allclose(c, 1.0)\n\n    def test_coherent_state_Abc(self):\n        A1, b1, c1 = triples.coherent_state_Abc(0.1, 0.2)\n        assert math.allclose(A1, math.zeros((1, 1)))\n        assert math.allclose(b1, [0.1 + 0.2j])\n        assert math.allclose(c1, 0.97530991)\n\n        A2, b2, c2 = triples.coherent_state_Abc(0.1, [0.2, 0.3])\n        assert math.allclose(A2, math.zeros((2, 1, 1)))\n        assert math.allclose(b2, [[0.1 + 0.2j], [0.1 + 0.3j]])\n        assert math.allclose(c2, [0.97530991 + 0.0j, 0.95122942 + 0.0j])\n\n        A3, b3, c3 = triples.coherent_state_Abc(0.1)\n        assert math.allclose(A3, math.zeros((1, 1)))\n        assert math.allclose(b3, [0.1])\n        assert math.allclose(c3, 0.9950124791926823)\n\n    def test_squeezed_vacuum_state_Abc(self):\n        A1, b1, c1 = triples.squeezed_vacuum_state_Abc(0.1, 0.2)\n        assert math.allclose(A1, [[-0.09768127 - 0.01980097j]])\n        assert math.allclose(b1, math.zeros(1))\n        assert math.allclose(c1, 0.9975072676192522)\n\n        A2, b2, c2 = triples.squeezed_vacuum_state_Abc(0.1, [0.2, 0.3])\n        assert math.allclose(A2, [[[-0.09768127 - 0.01980097j]], [[-0.09521647 - 0.02945391j]]])\n        assert math.allclose(b2, math.zeros((2, 1)))\n        assert math.allclose(c2, [0.99750727, 0.99750727])\n\n        A3, b3, c3 = triples.squeezed_vacuum_state_Abc(0.1)\n        assert math.allclose(A3, [[-0.09966799]])\n        assert math.allclose(b3, math.zeros(1))\n        assert math.allclose(c3, 0.9975072676192522)\n\n    def test_displaced_squeezed_vacuum_state_Abc(self):\n        A1, b1, c1 = triples.displaced_squeezed_vacuum_state_Abc(0.1, 0.2, 0.3, 0.4)\n        assert math.allclose(A1, [[-0.26831668 - 0.11344247j]])\n        assert math.allclose(b1, [0.14952016 + 0.15768091j])\n        assert math.allclose(c1, 0.95557745 + 0.00675411j)\n\n        A2, b2, c2 = triples.displaced_squeezed_vacuum_state_Abc(0.1, 0.2, 0.3, [0.4, 0.5])\n        assert math.allclose(A2, [[[-0.26831668 - 0.11344247j]], [[-0.25565087 - 0.13966271j]]])\n        assert math.allclose(b2, [[0.14952016 + 0.15768091j], [0.15349763 + 0.1628361j]])\n        assert math.allclose(c2, [0.95557745 + 0.00675411j, 0.95489408 + 0.00688296j])\n\n        A3, b3, c3 = triples.displaced_squeezed_vacuum_state_Abc([0.1, 0.2])\n        A3_correct, b3_correct, c3_correct = triples.coherent_state_Abc([0.1, 0.2])\n        assert math.allclose(A3, A3_correct)\n        assert math.allclose(b3, b3_correct)\n        assert math.allclose(c3, c3_correct)\n\n    def test_thermal_state_Abc(self):\n        A1, b1, c1 = triples.thermal_state_Abc(0.1)\n        assert math.allclose(A1, [[0, 0.09090909], [0.09090909, 0]])\n        assert math.allclose(b1, math.zeros(2))\n        assert math.allclose(c1, 1 / (0.1 + 1))\n\n        A2, b2, c2 = triples.thermal_state_Abc([0.1, 0.2])\n        assert math.allclose(\n            A2,\n            [\n                [[0.0 + 0.0j, 0.09090909 + 0.0j], [0.09090909 + 0.0j, 0.0 + 0.0j]],\n                [[0.0 + 0.0j, 0.16666667 + 0.0j], [0.16666667 + 0.0j, 0.0 + 0.0j]],\n            ],\n        )\n        assert math.allclose(b2, math.zeros((2, 2)))\n        assert math.allclose(c2, [1 / (0.1 + 1), 1 / (0.2 + 1)])\n\n    def test_rotation_gate_Abc(self):\n        A1, b1, c1 = triples.rotation_gate_Abc(0.1)\n        assert math.allclose(A1, [[0, 0.99500417 + 0.09983342j], [0.99500417 + 0.09983342j, 0]])\n        assert math.allclose(b1, math.zeros(2))\n        assert math.allclose(c1, 1.0)\n\n        A2, b2, c2 = triples.rotation_gate_Abc([0.1, 0.2])\n        g1 = 0.99500417 + 0.09983342j\n        g2 = 0.98006658 + 0.19866933j\n        assert math.allclose(A2, [[[0, g1], [g1, 0]], [[0, g2], [g2, 0]]])\n        assert math.allclose(b2, math.zeros((2, 2)))\n        assert math.allclose(c2, math.ones(2))\n\n    def test_displacement_gate_Abc(self):\n        A1, b1, c1 = triples.displacement_gate_Abc(0.1, 0.1)\n        assert math.allclose(A1, [[0, 1], [1, 0]])\n        assert math.allclose(b1, [0.1 + 0.1j, -0.1 + 0.1j])\n        assert math.allclose(c1, 0.990049833749168)\n\n        A2, b2, c2 = triples.displacement_gate_Abc([0.1, 0.2], 0.1)\n        assert math.allclose(\n            A2,\n            [\n                [[0.0 + 0.0j, 1.0 + 0.0j], [1.0 + 0.0j, 0.0 + 0.0j]],\n                [[0.0 + 0.0j, 1.0 + 0.0j], [1.0 + 0.0j, 0.0 + 0.0j]],\n            ],\n        )\n        assert math.allclose(b2, [[0.1 + 0.1j, -0.1 + 0.1j], [0.2 + 0.1j, -0.2 + 0.1j]])\n        assert math.allclose(c2, [0.99004983 + 0.0j, 0.97530991 + 0.0j])\n\n        A3, b3, c3 = triples.displacement_gate_Abc(x=[0.1, 0.2])\n        assert math.allclose(\n            A3,\n            [\n                [[0.0 + 0.0j, 1.0 + 0.0j], [1.0 + 0.0j, 0.0 + 0.0j]],\n                [[0.0 + 0.0j, 1.0 + 0.0j], [1.0 + 0.0j, 0.0 + 0.0j]],\n            ],\n        )\n        assert math.allclose(b3, [[0.1 + 0.0j, -0.1 + 0.0j], [0.2 + 0.0j, -0.2 + 0.0j]])\n        assert math.allclose(c3, [0.99501248 + 0.0j, 0.98019867 + 0.0j])\n\n    def test_squeezing_gate_Abc(self):\n        A1, b1, c1 = triples.squeezing_gate_Abc(0.1, 0.2)\n        assert math.allclose(\n            A1,\n            [\n                [-0.09768127 - 1.98009738e-02j, 0.99502075],\n                [0.99502075, 0.09768127 - 0.01980097j],\n            ],\n        )\n        assert math.allclose(b1, math.zeros(2))\n        assert math.allclose(c1, 0.9975072676192522)\n\n        A2, b2, c2 = triples.squeezing_gate_Abc([0.1, 0.3], 0.2)\n        assert math.allclose(\n            A2,\n            [\n                [\n                    [-0.09768127 - 0.01980097j, 0.99502075 + 0.0j],\n                    [0.99502075 + 0.0j, 0.09768127 - 0.01980097j],\n                ],\n                [\n                    [-0.28550576 - 0.05787488j, 0.95662791 + 0.0j],\n                    [0.95662791 + 0.0j, 0.28550576 - 0.05787488j],\n                ],\n            ],\n        )\n        assert math.allclose(b2, math.zeros((2, 2)))\n        assert math.allclose(c2, [0.99750727 + 0.0j, 0.97807357 + 0.0j])\n\n        A3, b3, c3 = triples.squeezing_gate_Abc(0.1)\n        assert math.allclose(\n            A3,\n            [\n                [-0.09966799 + 0.0j, 0.99502075 + 0.0j],\n                [0.99502075 + 0.0j, 0.09966799 + 0.0j],\n            ],\n        )\n        assert math.allclose(b3, math.zeros(2))\n        assert math.allclose(c3, 0.9975072676192522)\n\n    def test_beamsplitter_gate_Abc(self):\n        A1, b1, c1 = triples.beamsplitter_gate_Abc(0.1, 0.2)\n        A_exp = [\n            [0, 0, 0.99500417, -0.0978434 + 0.01983384j],\n            [0.0, 0, 0.0978434 + 0.01983384j, 0.99500417],\n            [0.99500417, 0.0978434 + 0.01983384j, 0, 0],\n            [-0.0978434 + 0.01983384j, 0.99500417, 0, 0],\n        ]\n        assert math.allclose(A1, A_exp)\n        assert math.allclose(b1, math.zeros(4))\n        assert math.allclose(c1, 1)\n\n        A2, b2, c2 = triples.beamsplitter_gate_Abc(0.1, [0.2, 0.2])\n        A = [\n            [\n                [0, 0, 0.99500417, -0.0978434 + 0.01983384j],\n                [0, 0, 0.0978434 + 0.01983384j, 0.99500417],\n                [0.99500417, 0.0978434 + 0.01983384j, 0, 0],\n                [-0.0978434 + 0.01983384j, 0.99500417, 0, 0],\n            ],\n            [\n                [0, 0, 0.99500417, -0.0978434 + 0.01983384j],\n                [0, 0, 0.0978434 + 0.01983384j, 0.99500417],\n                [0.99500417, 0.0978434 + 0.01983384j, 0, 0],\n                [-0.0978434 + 0.01983384j, 0.99500417, 0, 0],\n            ],\n        ]\n\n        assert math.allclose(A2, A)\n        assert math.allclose(b2, math.zeros((2, 4)))\n        assert math.allclose(c2, math.ones(2))\n\n        A3, b3, c3 = triples.beamsplitter_gate_Abc(0.1)\n        A_exp = [\n            [0, 0, 9.95004165e-01, -9.98334166e-02],\n            [0.0, 0, 9.98334166e-02, 9.95004165e-01],\n            [9.95004165e-01, 9.98334166e-02, 0, 0],\n            [-9.98334166e-02, 9.95004165e-01, 0, 0],\n        ]\n        assert math.allclose(A3, A_exp)\n        assert math.allclose(b3, math.zeros(4))\n        assert math.allclose(c3, 1)\n\n    def test_identity_Abc(self):\n        A1, b1, c1 = triples.identity_Abc(1)\n        assert math.allclose(A1, [[0, 1], [1, 0]])\n        assert math.allclose(b1, [0, 0])\n        assert math.allclose(c1, 1)\n\n        A2, b2, c2 = triples.identity_Abc(2)\n        assert math.allclose(A2, [[0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0], [0, 1, 0, 0]])\n        assert math.allclose(b2, [0, 0, 0, 0])\n        assert math.allclose(c2, 1)\n\n    def test_attenuator_Abc(self):\n        A1, b1, c1 = triples.attenuator_Abc(0.1)\n        e = 0.31622777\n        assert math.allclose(A1, [[0, e, 0, 0], [e, 0, 0, 0.9], [0, 0, 0, e], [0, 0.9, e, 0]])\n        assert math.allclose(b1, math.zeros(4))\n        assert math.allclose(c1, 1.0)\n\n        A2, b2, c2 = triples.attenuator_Abc([0.1, 1])\n        e = 0.31622777\n        assert math.allclose(\n            A2,\n            [\n                [[0.0, e, 0.0, 0.0], [e, 0.0, 0.0, 0.9], [0.0, 0.0, 0.0, e], [0.0, 0.9, e, 0.0]],\n                [\n                    [0.0, 1.0, 0.0, 0.0],\n                    [1.0, 0.0, 0.0, 0.0],\n                    [0.0, 0.0, 0.0, 1.0],\n                    [0.0, 0.0, 1.0, 0.0],\n                ],\n            ],\n        )\n        assert math.allclose(b2, math.zeros((2, 4)))\n        assert math.allclose(c2, math.ones(2))\n\n    def test_attenuator_Abc_error(self):\n        if math.backend_name == \"jax\":\n            import equinox as eqx  # noqa: PLC0415\n\n            with pytest.raises(eqx.EquinoxRuntimeError, match=\"greater than `1`\"):\n                triples.attenuator_Abc(2)\n        else:\n            with pytest.raises(ValueError, match=\"greater than `1`\"):\n                triples.attenuator_Abc(2)\n\n        if math.backend_name == \"jax\":\n            with pytest.raises(eqx.EquinoxRuntimeError, match=\"less than `0`\"):\n                triples.attenuator_Abc(-2)\n        else:\n            with pytest.raises(ValueError, match=\"less than `0`\"):\n                triples.attenuator_Abc(-2)\n\n    def test_amplifier_Abc(self):\n        A1, b1, c1 = triples.amplifier_Abc(2)\n        assert math.allclose(\n            A1,\n            [\n                [0, 0.70710678, 0.5, 0],\n                [0.70710678, 0, 0, 0],\n                [0.5, 0, 0, 0.70710678],\n                [0.0, 0, 0.70710678, 0],\n            ],\n        )\n        assert math.allclose(b1, math.zeros(4))\n        assert math.allclose(c1, 0.5)\n\n        A2, b2, c2 = triples.amplifier_Abc([2, 1])\n        assert math.allclose(\n            A2,\n            [\n                [\n                    [0, 0.70710678, 0.5, 0],\n                    [0.70710678, 0, 0, 0],\n                    [0.5, 0, 0, 0.70710678],\n                    [0, 0, 0.70710678, 0],\n                ],\n                [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]],\n            ],\n        )\n        assert math.allclose(b2, math.zeros((2, 4)))\n        assert math.allclose(c2, [0.5, 1])\n\n    def test_amplifier_Abc_error(self):\n        if math.backend_name == \"jax\":\n            import equinox as eqx  # noqa: PLC0415\n\n            with pytest.raises(eqx.EquinoxRuntimeError, match=\"smaller than\"):\n                triples.amplifier_Abc(0.1)\n        else:\n            with pytest.raises(ValueError, match=\"smaller than\"):\n                triples.amplifier_Abc(0.1)\n\n    def test_fock_damping_Abc(self):\n        A1, b1, c1 = triples.fock_damping_Abc(0.5)\n        assert math.allclose(\n            A1,\n            [\n                [0, 0.60653065],\n                [0.60653065, 0],\n            ],\n        )\n        assert math.allclose(b1, math.zeros(2))\n        assert math.allclose(c1, 1)\n\n    def test_displacement_gate_s_parametrized_Abc(self):\n        A1, b1, c1 = triples.displacement_map_s_parametrized_Abc(s=0, n_modes=1)\n        A1_correct = math.astensor([[0, -0.5, -1, 0], [-0.5, 0, 0, 1], [-1, 0, 0, 1], [0, 1, 1, 0]])\n        assert math.allclose(A1, A1_correct[[0, 3, 1, 2], :][:, [0, 3, 1, 2]])\n        assert math.allclose(b1, math.zeros(4))\n        assert math.allclose(c1, 1.0)\n\n        A2, b2, c2 = triples.displacement_map_s_parametrized_Abc(s=1, n_modes=1)\n        A2_correct = math.astensor([[0, 0, -1, 0], [0, 0, 0, 1], [-1, 0, 0, 1], [0, 1, 1, 0]])\n        assert math.allclose(A2, A2_correct[[0, 3, 1, 2], :][:, [0, 3, 1, 2]])\n        assert math.allclose(b2, math.zeros(4))\n        assert math.allclose(c2, 1.0)\n\n        A3, b3, c3 = triples.displacement_map_s_parametrized_Abc(s=-1, n_modes=1)\n        A3_correct = math.astensor([[0, -1, -1, 0], [-1, 0, 0, 1], [-1, 0, 0, 1], [0, 1, 1, 0]])\n        assert math.allclose(A3, A3_correct[[0, 3, 1, 2], :][:, [0, 3, 1, 2]])\n        assert math.allclose(b3, math.zeros(4))\n        assert math.allclose(c3, 1.0)\n\n    @pytest.mark.parametrize(\"eta\", [0.0, 0.1, 0.5, 0.9, 1.0])\n    def test_attenuator_kraus_Abc(self, eta):\n        B = PolyExpAnsatz(*triples.attenuator_kraus_Abc(eta))\n        Att = PolyExpAnsatz(*triples.attenuator_Abc(eta))\n        assert B.contract(B, [0, 1, 2], [3, 4, 2], [0, 1, 3, 4]) == Att\n\n    def test_gaussian_random_noise_Abc(self):\n        A, b, c = triples.gaussian_random_noise_Abc(np.eye(2))\n        A_by_hand = math.astensor(\n            [\n                [0.0, 0.5, 0.5, 0.0],\n                [0.5, 0.0, 0.0, 0.5],\n                [0.5, 0.0, 0.0, 0.5],\n                [0.0, 0.5, 0.5, 0.0],\n            ],\n        )\n        b_by_hand = math.zeros(4)\n        c_by_hand = 0.5\n\n        assert math.allclose(A, A_by_hand)\n        assert math.allclose(b, b_by_hand)\n        assert math.allclose(c, c_by_hand)\n\n    def test_XY_to_channel_Abc(self):\n        # Creating an attenuator object and testing its Abc triple\n        eta = settings.rng.random()\n        X = math.sqrt(eta) * math.eye(2)\n        Y = settings.HBAR / 2 * (1 - eta) * math.eye(2)\n\n        A, b, c = triples.XY_to_channel_Abc(X, Y)\n\n        A_by_hand = math.block(\n            [\n                math.astensor([[0, math.sqrt(eta), 0, 0]]),\n                math.astensor([[math.sqrt(eta), 0, 0, 1 - eta]]),\n                math.astensor([[0, 0, 0, math.sqrt(eta)]]),\n                math.astensor([[0, 1 - eta, math.sqrt(eta), 0]]),\n            ],\n        )\n        assert math.allclose(A, A_by_hand)\n        assert math.allclose(b, math.zeros((4,)))\n        assert b.shape == (4,)\n        assert math.allclose(c, 1.0)\n\n    def test_XY_to_channel_Abc_batched(self):\n        eta = settings.rng.random(2)[:, None, None]\n        X = math.sqrt(eta) * math.eye(2)[None, :, :]\n        # Now X has shape (2, 2, 2)\n        Y = settings.HBAR / 2 * (1 - eta) * math.eye(2)[None, :, :]\n\n        A, b, c = triples.XY_to_channel_Abc(X, Y)\n\n        A_by_hand = (\n            math.sqrt(eta)\n            * math.astensor(\n                [[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]],\n                dtype=math.complex128,\n            )[None, :, :]\n            + (1 - eta)\n            * math.astensor(\n                [[0, 0, 0, 0], [0, 0, 0, 1], [0, 0, 0, 0], [0, 1, 0, 0]],\n                dtype=math.complex128,\n            )[None, :, :]\n        )\n\n        assert math.allclose(A, A_by_hand)\n        assert math.allclose(b, math.zeros((2, 4)))\n        assert math.allclose(c, math.astensor([1.0, 1.0], dtype=math.complex128))\n        assert c.shape == (2,)"
