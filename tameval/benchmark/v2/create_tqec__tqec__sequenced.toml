[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "tqec/tqec"
sha = "3c0db694339614f537772a7bf6a183c8ffcb78a7"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r requirements.txt && pip install -r requirements-dev.txt && (pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=src/tqec/compile/blocks/layers/composed/sequenced.py -m pytest -q --junit-xml=test_output.xml src/tqec/compile/blocks/layers/composed/sequenced_test.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target src.tqec.compile.blocks.layers.composed.sequenced --unit-test src.tqec.compile.blocks.layers.composed.sequenced_test --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target src/tqec/compile/blocks/layers/composed/sequenced.py --unit-test src/tqec/compile/blocks/layers/composed/sequenced_test.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 91.0
original_coverage = 91.0
mutation_kill_rate = 31.0
original_mutation_kill_rate = 31.0
covered_lines = [ 0, 2, 3, 5, 7, 8, 9, 10, 11, 12, 15, 16, 36, 37, 38, 40, 41, 43, 45, 46, 47, 52, 53, 55, 57, 58, 59, 60, 65, 66, 67, 79, 82, 84, 85, 88, 93, 96, 97, 98, 101, 102, 104, 105, 106, 109, 110, 112, 113, 115, 116, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 130, 131, 137, 138, 141, 142, 143, 149, 150, 156, 157, 159, 162, 163, 168, 169, 170, 171,]
missed_lines = [ 68, 73, 74, 75, 76, 77, 132, 164,]

[input_info]
test_file_path = "src/tqec/compile/blocks/layers/composed/sequenced_test.py"
focal_file_path = "src/tqec/compile/blocks/layers/composed/sequenced.py"
test_file_url = "https://github.com/tqec/tqec/blob/3c0db694339614f537772a7bf6a183c8ffcb78a7/src/tqec/compile/blocks/layers/composed/sequenced_test.py"
focal_file_url = "https://github.com/tqec/tqec/blob/3c0db694339614f537772a7bf6a183c8ffcb78a7/src/tqec/compile/blocks/layers/composed/sequenced.py"
first_commit_date = "2025-03-12"
last_commit_date = "2025-07-25"
test_file_content = "import pytest\nimport stim\n\nfrom tqec.circuit.schedule.circuit import ScheduledCircuit\nfrom tqec.compile.blocks.enums import SpatialBlockBorder, TemporalBlockBorder\nfrom tqec.compile.blocks.layers.atomic.plaquettes import PlaquetteLayer\nfrom tqec.compile.blocks.layers.atomic.raw import RawCircuitLayer\nfrom tqec.compile.blocks.layers.composed.repeated import RepeatedLayer\nfrom tqec.compile.blocks.layers.composed.sequenced import SequencedLayers\nfrom tqec.plaquette.plaquette import Plaquettes\nfrom tqec.plaquette.rpng.rpng import RPNGDescription\nfrom tqec.plaquette.rpng.translators.default import DefaultRPNGTranslator\nfrom tqec.templates._testing import FixedTemplate\nfrom tqec.templates.qubit import QubitSpatialCubeTemplate, QubitTemplate\nfrom tqec.utils.exceptions import TQECError\nfrom tqec.utils.frozendefaultdict import FrozenDefaultDict\nfrom tqec.utils.scale import LinearFunction, PhysicalQubitScalable2D\n\n_TRANSLATOR = DefaultRPNGTranslator()\n_EMPTY_PLAQUETTE = _TRANSLATOR.translate(RPNGDescription.empty())\n\n\n@pytest.fixture(name=\"plaquette_layer\")\ndef plaquette_layer_fixture() -> PlaquetteLayer:\n    return PlaquetteLayer(\n        QubitTemplate(),\n        Plaquettes(FrozenDefaultDict({}, default_value=_EMPTY_PLAQUETTE)),\n    )\n\n\n@pytest.fixture(name=\"plaquette_layer2\")\ndef plaquette_layer2_fixture() -> PlaquetteLayer:\n    return PlaquetteLayer(\n        QubitSpatialCubeTemplate(),\n        Plaquettes(FrozenDefaultDict({}, default_value=_EMPTY_PLAQUETTE)),\n    )\n\n\n@pytest.fixture(name=\"non_empty_plaquette_layer\")\ndef non_empty_plaquette_layer_fixture() -> PlaquetteLayer:\n    return PlaquetteLayer(\n        FixedTemplate([[1]]),\n        Plaquettes(\n            FrozenDefaultDict(\n                {1: _TRANSLATOR.translate(RPNGDescription.from_string(\"-x1- -x2- -x3- -x4-\"))},\n                default_value=_EMPTY_PLAQUETTE,\n            )\n        ),\n    )\n\n\n@pytest.fixture(name=\"raw_circuit_layer\")\ndef raw_circuit_layer_fixture() -> RawCircuitLayer:\n    return RawCircuitLayer(\n        lambda k: ScheduledCircuit.from_circuit(stim.Circuit()),\n        PhysicalQubitScalable2D(LinearFunction(4, 5), LinearFunction(4, 5)),\n        LinearFunction(0, 0),\n    )\n\n\n@pytest.fixture(name=\"raw_circuit_fixed_size_layer\")\ndef raw_circuit_fixed_size_layer_fixture() -> RawCircuitLayer:\n    return RawCircuitLayer(\n        lambda k: ScheduledCircuit.from_circuit(stim.Circuit()),\n        PhysicalQubitScalable2D(LinearFunction(0, 1), LinearFunction(0, 1)),\n        LinearFunction(0, 0),\n    )\n\n\ndef test_creation(plaquette_layer: PlaquetteLayer, raw_circuit_layer: RawCircuitLayer) -> None:\n    # Invalid sequences due to duration < 1\n    err_regex = \".*expected to have at least one layer.*\"\n    with pytest.raises(TQECError, match=err_regex):\n        SequencedLayers([])\n\n    SequencedLayers([plaquette_layer for _ in range(10)])\n    SequencedLayers(\n        [\n            plaquette_layer,\n            RepeatedLayer(raw_circuit_layer, LinearFunction(2, 0)),\n            plaquette_layer,\n        ]\n    )\n    SequencedLayers(\n        [\n            SequencedLayers([plaquette_layer, raw_circuit_layer, plaquette_layer]),\n            RepeatedLayer(raw_circuit_layer, LinearFunction(2, 0)),\n        ]\n    )\n\n\ndef test_schedule(plaquette_layer: PlaquetteLayer) -> None:\n    assert SequencedLayers([plaquette_layer for _ in range(10)]).schedule == tuple(\n        LinearFunction(0, 1) for _ in range(10)\n    )\n    assert SequencedLayers(\n        [\n            plaquette_layer,\n            RepeatedLayer(plaquette_layer, LinearFunction(2, 0)),\n            plaquette_layer,\n        ]\n    ).schedule == (LinearFunction(0, 1), LinearFunction(2, 0), LinearFunction(0, 1))\n    assert SequencedLayers(\n        [\n            SequencedLayers([plaquette_layer, plaquette_layer, plaquette_layer]),\n            RepeatedLayer(plaquette_layer, LinearFunction(2, 0)),\n        ]\n    ).schedule == (LinearFunction(0, 3), LinearFunction(2, 0))\n\n\ndef test_scalable_timesteps(plaquette_layer: PlaquetteLayer) -> None:\n    assert SequencedLayers(\n        [plaquette_layer for _ in range(10)]\n    ).scalable_timesteps == LinearFunction(0, 10)\n    assert SequencedLayers(\n        [\n            plaquette_layer,\n            RepeatedLayer(plaquette_layer, LinearFunction(2, 0)),\n            plaquette_layer,\n        ]\n    ).scalable_timesteps == LinearFunction(2, 2)\n    assert SequencedLayers(\n        [\n            SequencedLayers([plaquette_layer, plaquette_layer, plaquette_layer]),\n            RepeatedLayer(plaquette_layer, LinearFunction(2, 0)),\n        ]\n    ).scalable_timesteps == LinearFunction(2, 3)\n\n\n@pytest.mark.parametrize(\"borders\", [(border,) for border in SpatialBlockBorder])\ndef test_with_spatial_borders_trimmed(\n    borders: tuple[SpatialBlockBorder, ...], plaquette_layer: PlaquetteLayer\n) -> None:\n    layer = SequencedLayers([plaquette_layer for _ in range(5)])\n    trimmed_layer = layer.with_spatial_borders_trimmed(borders)\n    trimmed_internal_layer = plaquette_layer.with_spatial_borders_trimmed(borders)\n    assert all(\n        internal_layer == trimmed_internal_layer for internal_layer in trimmed_layer.layer_sequence\n    )\n\n\ndef test_with_temporal_borders_replaced_none(\n    plaquette_layer: PlaquetteLayer,\n    plaquette_layer2: PlaquetteLayer,\n    raw_circuit_layer: RawCircuitLayer,\n) -> None:\n    layer = SequencedLayers([plaquette_layer, plaquette_layer2, raw_circuit_layer])\n    assert layer.with_temporal_borders_replaced({}) == layer\n    assert layer.with_temporal_borders_replaced(\n        {TemporalBlockBorder.Z_NEGATIVE: None}\n    ) == SequencedLayers([plaquette_layer2, raw_circuit_layer])\n    assert layer.with_temporal_borders_replaced(\n        {TemporalBlockBorder.Z_POSITIVE: None}\n    ) == SequencedLayers([plaquette_layer, plaquette_layer2])\n    assert (\n        layer.with_temporal_borders_replaced(\n            {TemporalBlockBorder.Z_NEGATIVE: None, TemporalBlockBorder.Z_POSITIVE: None}\n        )\n        == plaquette_layer2\n    )\n    # Shorter to cover one edge-case:\n    assert (\n        SequencedLayers([plaquette_layer, raw_circuit_layer]).with_temporal_borders_replaced(\n            {TemporalBlockBorder.Z_NEGATIVE: None, TemporalBlockBorder.Z_POSITIVE: None}\n        )\n        is None\n    )\n\n\ndef test_with_temporal_borders_replaced(\n    plaquette_layer: PlaquetteLayer,\n    plaquette_layer2: PlaquetteLayer,\n    raw_circuit_layer: RawCircuitLayer,\n) -> None:\n    layer = SequencedLayers([plaquette_layer, plaquette_layer2, raw_circuit_layer])\n\n    assert layer.with_temporal_borders_replaced({}) == layer\n    for replacement in [plaquette_layer, plaquette_layer2, raw_circuit_layer]:\n        assert layer.with_temporal_borders_replaced(\n            {TemporalBlockBorder.Z_NEGATIVE: replacement}\n        ) == SequencedLayers([replacement, plaquette_layer2, raw_circuit_layer])\n        assert layer.with_temporal_borders_replaced(\n            {TemporalBlockBorder.Z_POSITIVE: replacement}\n        ) == SequencedLayers([plaquette_layer, plaquette_layer2, replacement])\n        assert layer.with_temporal_borders_replaced(\n            {\n                TemporalBlockBorder.Z_NEGATIVE: replacement,\n                TemporalBlockBorder.Z_POSITIVE: replacement,\n            }\n        ) == SequencedLayers([replacement, plaquette_layer2, replacement])\n    assert layer.with_temporal_borders_replaced(\n        {\n            TemporalBlockBorder.Z_NEGATIVE: None,\n            TemporalBlockBorder.Z_POSITIVE: plaquette_layer2,\n        }\n    ) == SequencedLayers([plaquette_layer2, plaquette_layer2])\n\n\ndef test_to_sequenced_layer_with_schedule(plaquette_layer: PlaquetteLayer) -> None:\n    layer = SequencedLayers([RepeatedLayer(plaquette_layer, LinearFunction(2, 0)), plaquette_layer])\n    assert (\n        layer.to_sequenced_layer_with_schedule((LinearFunction(2, 0), LinearFunction(0, 1)))\n        == layer\n    )\n    err_regex = (\n        \"^.*The provided schedule has a duration of .* but the \"\n        \"instance to transform has a duration of .*$\"\n    )\n    with pytest.raises(TQECError, match=err_regex):\n        layer.to_sequenced_layer_with_schedule((LinearFunction(0, 1), LinearFunction(1, 0)))\n    with pytest.raises(NotImplementedError):\n        layer.to_sequenced_layer_with_schedule((LinearFunction(0, 1), LinearFunction(2, 0)))\n\n\ndef test_scalable_num_moments(\n    plaquette_layer: PlaquetteLayer, non_empty_plaquette_layer: PlaquetteLayer\n) -> None:\n    # Empty layer, repeated 10 times\n    assert SequencedLayers(\n        [plaquette_layer for _ in range(10)]\n    ).scalable_num_moments == LinearFunction(0, 0)\n    # Non empty layer, repeated 10 times\n    assert non_empty_plaquette_layer.scalable_num_moments.is_constant()\n    layer_num_moments = non_empty_plaquette_layer.scalable_num_moments.offset\n    assert SequencedLayers(\n        [non_empty_plaquette_layer for _ in range(10)]\n    ).scalable_num_moments == LinearFunction(0, 10 * layer_num_moments)\n    # A mix of empty and non-empty\n    assert SequencedLayers(\n        [\n            plaquette_layer,\n            plaquette_layer,\n            non_empty_plaquette_layer,\n            plaquette_layer,\n            non_empty_plaquette_layer,\n        ]\n    ).scalable_num_moments == LinearFunction(0, 2 * layer_num_moments)\n"
