[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Go"
go_version = "1.24.4"

[repo_info]
repository = "vmware/pinniped"
sha = "e20c5beb47391281e19d13b1e22c5fd42f577686"

[run_info]
docker_image = "golang:1.24.4"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/admissionpluginconfig/admissionpluginconfig.go internal/admissionpluginconfig/admissionpluginconfig_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/admissionpluginconfig/admissionpluginconfig.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 75.0
original_coverage = 92.0
mutation_kill_rate = 69.0
original_mutation_kill_rate = 86.0
covered_lines = [ 60, 61, 62, 63, 64, 65, 66, 67, 69, 70, 71, 72, 73, 74, 75, 76, 80, 81, 82, 83, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 104, 105, 106, 107, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 126,]
missed_lines = [ 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 47, 48, 49, 50, 51, 52,]

[input_info]
test_file_path = "internal/admissionpluginconfig/admissionpluginconfig_test.go"
focal_file_path = "internal/admissionpluginconfig/admissionpluginconfig.go"
test_file_url = "https://github.com/vmware/pinniped/blob/e20c5beb47391281e19d13b1e22c5fd42f577686/internal/admissionpluginconfig/admissionpluginconfig_test.go"
focal_file_url = "https://github.com/vmware/pinniped/blob/e20c5beb47391281e19d13b1e22c5fd42f577686/internal/admissionpluginconfig/admissionpluginconfig.go"
first_commit_date = "2024-05-10"
last_commit_date = "2025-03-17"
test_file_content = "// Copyright 2024-2025 the Pinniped contributors. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\npackage admissionpluginconfig\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\tadmissionregistrationv1 \"k8s.io/api/admissionregistration/v1\"\n\tappsv1 \"k8s.io/api/apps/v1\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/apiserver/pkg/server/options\"\n\t\"k8s.io/client-go/discovery\"\n\tkubernetesfake \"k8s.io/client-go/kubernetes/fake\"\n\tk8stesting \"k8s.io/client-go/testing\"\n)\n\n\nfunc TestConfigureAdmissionPlugins(t *testing.T) {\n\tcoreResources := &metav1.APIResourceList{\n\t\tGroupVersion: corev1.SchemeGroupVersion.String(),\n\t\tAPIResources: []metav1.APIResource{\n\t\t\t{Name: \"pods\", Namespaced: true, Kind: \"Pod\"},\n\t\t},\n\t}\n\n\tappsResources := &metav1.APIResourceList{\n\t\tGroupVersion: appsv1.SchemeGroupVersion.String(),\n\t\tAPIResources: []metav1.APIResource{\n\t\t\t{Name: \"deployments\", Namespaced: true, Kind: \"Deployment\"},\n\t\t\t{Name: \"deployments/scale\", Namespaced: true, Kind: \"Scale\", Group: \"apps\", Version: \"v1\"},\n\t\t},\n\t}\n\n\tnewStyleAdmissionResourcesWithValidatingAdmissionPolicies := &metav1.APIResourceList{\n\t\tGroupVersion: admissionregistrationv1.SchemeGroupVersion.String(),\n\t\tAPIResources: []metav1.APIResource{\n\t\t\t{Name: \"validatingwebhookconfigurations\", Kind: \"ValidatingWebhookConfiguration\"},\n\t\t\t{Name: \"validatingadmissionpolicies\", Kind: \"ValidatingAdmissionPolicy\"},\n\t\t},\n\t}\n\n\tnewStyleAdmissionResourcesWithValidatingAdmissionPoliciesAtOlderAPIVersion := &metav1.APIResourceList{\n\t\tGroupVersion: admissionregistrationv1.SchemeGroupVersion.Group + \"/v1beta1\",\n\t\tAPIResources: []metav1.APIResource{\n\t\t\t{Name: \"validatingwebhookconfigurations\", Kind: \"ValidatingWebhookConfiguration\"},\n\t\t\t{Name: \"validatingadmissionpolicies\", Kind: \"ValidatingAdmissionPolicy\"},\n\t\t},\n\t}\n\n\toldStyleAdmissionResourcesWithoutValidatingAdmissionPolicies := &metav1.APIResourceList{\n\t\tGroupVersion: admissionregistrationv1.SchemeGroupVersion.String(),\n\t\tAPIResources: []metav1.APIResource{\n\t\t\t{Name: \"validatingwebhookconfigurations\", Kind: \"ValidatingWebhookConfiguration\"},\n\t\t},\n\t}\n\n\ttests := []struct {\n\t\tname                  string\n\t\tdisabledPlugins       []string\n\t\tavailableAPIResources []*metav1.APIResourceList\n\t\tdiscoveryErr          error\n\t\twantErr               string\n\t\twantDisabledPlugins   []string\n\t}{\n\t\t{\n\t\t\tname: \"when there is a ValidatingAdmissionPolicy resource and nil disabled list, then we do not change the plugin configuration\",\n\t\t\tavailableAPIResources: []*metav1.APIResourceList{\n\t\t\t\tcoreResources,\n\t\t\t\tnewStyleAdmissionResourcesWithValidatingAdmissionPolicies,\n\t\t\t\tappsResources,\n\t\t\t},\n\t\t\tdisabledPlugins:     nil,\n\t\t\twantDisabledPlugins: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"when there is a ValidatingAdmissionPolicy resource and empty disabled list, then we do not change the plugin configuration\",\n\t\t\tavailableAPIResources: []*metav1.APIResourceList{\n\t\t\t\tcoreResources,\n\t\t\t\tnewStyleAdmissionResourcesWithValidatingAdmissionPolicies,\n\t\t\t\tappsResources,\n\t\t\t},\n\t\t\tdisabledPlugins:     []string{},\n\t\t\twantDisabledPlugins: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"when there is no ValidatingAdmissionPolicy resource, as there would not be in an old Kubernetes cluster, then we disable that admission plugin\",\n\t\t\tavailableAPIResources: []*metav1.APIResourceList{\n\t\t\t\tcoreResources,\n\t\t\t\toldStyleAdmissionResourcesWithoutValidatingAdmissionPolicies,\n\t\t\t\tappsResources,\n\t\t\t},\n\t\t\tdisabledPlugins:     nil,\n\t\t\twantDisabledPlugins: []string{\"ValidatingAdmissionPolicy\"},\n\t\t},\n\t\t{\n\t\t\tname: \"when there is only an older version of ValidatingAdmissionPolicy resource, as there would be in an old Kubernetes cluster with the feature flag enabled, then we disable that plugin (because the admission code wants to watch v1)\",\n\t\t\tavailableAPIResources: []*metav1.APIResourceList{\n\t\t\t\tcoreResources,\n\t\t\t\tnewStyleAdmissionResourcesWithValidatingAdmissionPoliciesAtOlderAPIVersion,\n\t\t\t\tappsResources,\n\t\t\t},\n\t\t\tdisabledPlugins:     []string{},\n\t\t\twantDisabledPlugins: []string{\"ValidatingAdmissionPolicy\"},\n\t\t},\n\t\t{\n\t\t\tname:                  \"when there is no ValidatingAdmissionPolicy resource, and the ValidatingAdmissionPolicy plugin was explicitly disabled, then do not perform discovery, and just disable it\",\n\t\t\tavailableAPIResources: []*metav1.APIResourceList{},\n\t\t\tdiscoveryErr:          errors.New(\"total error from API discovery client\"),\n\t\t\tdisabledPlugins:       []string{\"MutatingAdmissionWebhook\", \"ValidatingAdmissionPolicy\"},\n\t\t\twantDisabledPlugins:   []string{\"MutatingAdmissionWebhook\", \"ValidatingAdmissionPolicy\"},\n\t\t},\n\t\t{\n\t\t\tname: \"when there is no ValidatingAdmissionPolicy resource, and the ValidatingAdmissionPolicy plugin was not explicitly disabled, still disable it\",\n\t\t\tavailableAPIResources: []*metav1.APIResourceList{\n\t\t\t\tcoreResources,\n\t\t\t\toldStyleAdmissionResourcesWithoutValidatingAdmissionPolicies,\n\t\t\t\tappsResources,\n\t\t\t},\n\t\t\tdisabledPlugins:     []string{\"MutatingAdmissionWebhook\", \"NamespaceLifecycle\"},\n\t\t\twantDisabledPlugins: []string{\"MutatingAdmissionWebhook\", \"NamespaceLifecycle\", \"ValidatingAdmissionPolicy\"},\n\t\t},\n\t\t{\n\t\t\tname:                \"when there is a total error returned by discovery\",\n\t\t\tdiscoveryErr:        errors.New(\"total error from API discovery client\"),\n\t\t\twantErr:             \"failed looking up availability of ValidatingAdmissionPolicy resource: failed to perform k8s API discovery: total error from API discovery client\",\n\t\t\twantDisabledPlugins: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"when there is a partial error returned by discovery which does include the group of interest, then we cannot ignore the error, because we could not discover anything about that group\",\n\t\t\tavailableAPIResources: []*metav1.APIResourceList{\n\t\t\t\tcoreResources,\n\t\t\t\toldStyleAdmissionResourcesWithoutValidatingAdmissionPolicies,\n\t\t\t\tappsResources,\n\t\t\t},\n\t\t\tdiscoveryErr: &discovery.ErrGroupDiscoveryFailed{Groups: map[schema.GroupVersion]error{\n\t\t\t\tschema.GroupVersion{Group: \"someGroup\", Version: \"v1\"}:                    errors.New(\"fake error for someGroup\"),\n\t\t\t\tschema.GroupVersion{Group: \"admissionregistration.k8s.io\", Version: \"v1\"}: errors.New(\"fake error for admissionregistration\"),\n\t\t\t}},\n\t\t\twantErr:             \"failed looking up availability of ValidatingAdmissionPolicy resource: unable to retrieve the complete list of server APIs: admissionregistration.k8s.io/v1: fake error for admissionregistration, someGroup/v1: fake error for someGroup\",\n\t\t\twantDisabledPlugins: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"when there is a partial error returned by discovery on an new-style cluster which does not include the group of interest, then we can ignore the error and use the default plugins\",\n\t\t\tavailableAPIResources: []*metav1.APIResourceList{\n\t\t\t\tcoreResources,\n\t\t\t\tnewStyleAdmissionResourcesWithValidatingAdmissionPolicies,\n\t\t\t\tappsResources,\n\t\t\t},\n\t\t\tdiscoveryErr: &discovery.ErrGroupDiscoveryFailed{Groups: map[schema.GroupVersion]error{\n\t\t\t\tschema.GroupVersion{Group: \"someGroup\", Version: \"v1\"}:      errors.New(\"fake error for someGroup\"),\n\t\t\t\tschema.GroupVersion{Group: \"someOtherGroup\", Version: \"v1\"}: errors.New(\"fake error for someOtherGroup\"),\n\t\t\t}},\n\t\t\twantDisabledPlugins: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"when there is a partial error returned by discovery on an old-style cluster which does not include the group of interest, then we can ignore the error and customize the plugins\",\n\t\t\tavailableAPIResources: []*metav1.APIResourceList{\n\t\t\t\tcoreResources,\n\t\t\t\toldStyleAdmissionResourcesWithoutValidatingAdmissionPolicies,\n\t\t\t\tappsResources,\n\t\t\t},\n\t\t\tdiscoveryErr: &discovery.ErrGroupDiscoveryFailed{Groups: map[schema.GroupVersion]error{\n\t\t\t\tschema.GroupVersion{Group: \"someGroup\", Version: \"v1\"}:      errors.New(\"fake error for someGroup\"),\n\t\t\t\tschema.GroupVersion{Group: \"someOtherGroup\", Version: \"v1\"}: errors.New(\"fake error for someOtherGroup\"),\n\t\t\t}},\n\t\t\twantDisabledPlugins: []string{\"ValidatingAdmissionPolicy\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tkubeClient := kubernetesfake.NewSimpleClientset()\n\t\t\tkubeClient.Resources = tt.availableAPIResources\n\n\t\t\t// Unfortunately, kubernetesfake.NewSimpleClientset() does not support using reactors to\n\t\t\t// cause discovery to return errors. Instead, we will make our own fake implementation of the\n\t\t\t// discovery client's interface and only mock the parts that we need for this test.\n\t\t\tdiscoveryClient := newFakeDiscoveryClient(kubeClient)\n\n\t\t\tif tt.discoveryErr != nil {\n\t\t\t\tkubeClient.PrependReactor(\n\t\t\t\t\t\"get\",\n\t\t\t\t\t\"resource\",\n\t\t\t\t\tfunc(a k8stesting.Action) (bool, runtime.Object, error) {\n\t\t\t\t\t\treturn true, nil, tt.discoveryErr\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t}\n\n\t\t\topts := &options.RecommendedOptions{\n\t\t\t\tAdmission: options.NewAdmissionOptions(),\n\t\t\t}\n\t\t\t// Sanity checks on opts before we use it.\n\t\t\trequire.Empty(t, opts.Admission.DisablePlugins)\n\n\t\t\t// Call the function under test.\n\t\t\terr := configureAdmissionPlugins(discoveryClient, opts, tt.disabledPlugins)\n\n\t\t\tif tt.wantErr == \"\" {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t} else {\n\t\t\t\trequire.EqualError(t, err, tt.wantErr)\n\t\t\t}\n\n\t\t\t// Check the expected side effects of the function under test, if any.\n\t\t\trequire.Equal(t, tt.wantDisabledPlugins, opts.Admission.DisablePlugins)\n\t\t})\n\t}\n}\n\ntype fakeDiscoveryClient struct {\n\tfakeClientSet *kubernetesfake.Clientset\n}\n\nvar _ discovery.ServerResourcesInterface = &fakeDiscoveryClient{}\n\nfunc newFakeDiscoveryClient(fakeClientSet *kubernetesfake.Clientset) *fakeDiscoveryClient {\n\treturn &fakeDiscoveryClient{\n\t\tfakeClientSet: fakeClientSet,\n\t}\n}\n\n// This is the only function from the discovery.DiscoveryInterface that we care to fake for this test.\n// The rest of the functions are here only to satisfy the interface.\nfunc (f *fakeDiscoveryClient) ServerPreferredResources() ([]*metav1.APIResourceList, error) {\n\taction := k8stesting.ActionImpl{\n\t\tVerb:     \"get\",\n\t\tResource: schema.GroupVersionResource{Resource: \"resource\"},\n\t}\n\t// Wire in actions just enough that we can cause errors for the test when we want them.\n\t// Ignoring the first return value because we don't need it for this test.\n\t_, err := f.fakeClientSet.Invokes(action, nil)\n\t// Still return the \"partial\" results even where there was an error, similar enough to how the real API works.\n\treturn f.fakeClientSet.Resources, err\n}\n\nfunc (f *fakeDiscoveryClient) ServerResourcesForGroupVersion(_ string) (*metav1.APIResourceList, error) {\n\treturn nil, nil\n}\n\nfunc (f *fakeDiscoveryClient) ServerGroupsAndResources() ([]*metav1.APIGroup, []*metav1.APIResourceList, error) {\n\treturn nil, nil, nil\n}\n\nfunc (f *fakeDiscoveryClient) ServerPreferredNamespacedResources() ([]*metav1.APIResourceList, error) {\n\treturn nil, nil\n}\n"
