[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Python"
python_version = "3.11"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "LLMP-io/Legion"
sha = "ba7764e32f6e9ff9b93439ee62df5da5d26608f9"

[run_info]
docker_image = "python:3.11"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r requirements.txt && (pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=legion/graph/channels.py -m pytest -q --junit-xml=test_output.xml tests/graph/test_channels.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target legion.graph.channels --unit-test tests.graph.test_channels --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target legion/graph/channels.py --unit-test tests/graph/test_channels.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 79.0
original_coverage = 79.0
mutation_kill_rate = 85.0
original_mutation_kill_rate = 85.0
covered_lines = [ 0, 1, 2, 15, 17, 19, 21, 24, 25, 26, 27, 29, 35, 38, 47, 48, 49, 52, 54, 55, 57, 59, 60, 62, 64, 66, 69, 73, 77, 89, 90, 103, 104, 106, 108, 109, 111, 112, 116, 117, 121, 122, 126, 127, 131, 134, 135, 136, 138, 140, 142, 144, 145, 146, 148, 153, 155, 160, 162, 163, 165, 168, 169, 170, 171, 173, 174, 176, 180, 181, 182, 183, 184, 185, 187, 188, 189, 190, 191, 193, 194, 200, 201, 202, 203, 205, 208, 209, 210, 212, 213, 215, 216, 217, 218, 220, 221, 222, 224, 225, 230, 231, 232, 234, 237, 238, 239, 240, 242, 244, 246, 257, 259, 261, 262, 264, 265, 266, 268, 270, 271, 273, 274, 276, 277, 278, 280, 282, 283, 284, 285, 286, 288, 290, 293, 294, 295, 296, 297, 299, 301, 302, 304, 305, 307, 309, 310, 312, 313, 314, 316, 317, 323, 324, 325, 326, 328, 331, 340, 341, 342, 344, 345, 346, 347, 348, 350, 352, 355, 356, 359, 360, 361, 362, 363, 365, 367, 369, 370, 371, 372, 374, 376, 377, 378, 379, 381, 385, 392, 393, 395, 397, 398, 400, 402, 403, 412, 413, 414, 415, 416, 417, 418, 420, 423, 432, 433, 434, 435, 436, 438, 440, 441, 443, 445, 446, 448, 450, 451, 453, 454, 455, 456, 458, 460, 462, 464, 466, 470, 471, 473, 475, 476, 478, 480, 481, 483, 485, 487, 488, 490, 491, 499, 500, 501, 502, 503, 504, 506, 509, 524, 525, 526, 527, 528, 530, 532, 534, 535, 536, 538, 539, 540, 542, 544, 548, 549, 550, 551, 552, 553, 555, 557, 559, 561, 563, 564, 565, 566, 568, 570, 571, 572, 574, 575, 577, 579, 580, 582, 584, 585, 592, 593, 594, 595, 596, 599, 602, 610, 611, 613, 621, 622, 623, 625, 633, 635, 637, 638, 640, 648, 654, 662, 663, 664, 665, 667, 670, 678, 691, 729, 743, 755, 772, 782, 807, 821, 831, 841,]
missed_lines = [ 67, 70, 74, 78, 79, 80, 81, 82, 83, 84, 85, 86, 91, 92, 93, 95, 96, 97, 98, 99, 100, 114, 119, 124, 129, 150, 151, 178, 248, 249, 251, 252, 254, 255, 291, 353, 357, 383, 387, 388, 389, 390, 468, 545, 546, 672, 673, 674, 675, 676, 687, 688, 689, 710, 711, 713, 714, 716, 717, 719, 720, 727, 741, 751, 752, 753, 768, 769, 770, 780, 791, 792, 794, 795, 796, 798, 799, 800, 801, 802, 803, 804, 805, 819, 829, 839, 843, 844, 845,]

[input_info]
test_file_path = "tests/graph/test_channels.py"
focal_file_path = "legion/graph/channels.py"
test_file_url = "https://github.com/LLMP-io/Legion/blob/ba7764e32f6e9ff9b93439ee62df5da5d26608f9/tests/graph/test_channels.py"
focal_file_url = "https://github.com/LLMP-io/Legion/blob/ba7764e32f6e9ff9b93439ee62df5da5d26608f9/legion/graph/channels.py"
first_commit_date = "2025-01-07"
last_commit_date = "2025-01-08"
test_file_content = "from datetime import datetime\nfrom typing import List\n\nimport pytest\n\nfrom legion.graph.channel_manager import ChannelManager\nfrom legion.graph.channels import (\n    AggregatorChannel,\n    BarrierChannel,\n    BroadcastChannel,\n    ChannelMetadata,\n    LastValue,\n    MessageChannel,\n    SharedMemory,\n    SharedState,\n    ValueSequence,\n)\n\n\ndef test_channel_metadata():\n    \"\"\"Test channel metadata functionality\"\"\"\n    channel = LastValue(type_hint=str)\n    metadata = channel.metadata\n\n    assert isinstance(metadata, ChannelMetadata)\n    assert isinstance(metadata.created_at, datetime)\n    assert metadata.version == 0\n    assert metadata.type_hint == \"str\"\n\ndef test_last_value_channel():\n    \"\"\"Test LastValue channel functionality\"\"\"\n    channel = LastValue(type_hint=str)\n\n    # Test initial state\n    assert channel.get() is None\n    assert channel.metadata.version == 0\n\n    # Test value setting\n    channel.set(\"test\")\n    assert channel.get() == \"test\"\n    assert channel.metadata.version == 1\n\n    # Test type validation\n    with pytest.raises(TypeError):\n        channel.set(123)\n\n    # Test checkpointing\n    checkpoint = channel.checkpoint()\n    assert isinstance(checkpoint, dict)\n    assert checkpoint[\"value\"] == \"test\"\n\n    # Test restoration\n    new_channel = LastValue(type_hint=str)\n    new_channel.restore(checkpoint)\n    assert new_channel.get() == \"test\"\n    assert new_channel.metadata.version == checkpoint[\"metadata\"][\"version\"]\n\ndef test_value_sequence_channel():\n    \"\"\"Test ValueSequence channel functionality\"\"\"\n    channel = ValueSequence(type_hint=int, max_size=3)\n\n    # Test initial state\n    assert channel.get() == []\n    assert channel.metadata.version == 0\n\n    # Test append\n    channel.append(1)\n    channel.append(2)\n    assert channel.get() == [1, 2]\n    assert channel.metadata.version == 2\n\n    # Test max size\n    channel.append(3)\n    channel.append(4)\n    assert channel.get() == [2, 3, 4]  # First value should be dropped\n\n    # Test bulk set\n    channel.set([5, 6])\n    assert channel.get() == [5, 6]\n\n    # Test type validation\n    with pytest.raises(TypeError):\n        channel.append(\"invalid\")\n\n    # Test checkpointing\n    checkpoint = channel.checkpoint()\n    assert isinstance(checkpoint, dict)\n    assert checkpoint[\"values\"] == [5, 6]\n    assert checkpoint[\"max_size\"] == 3\n\n    # Test restoration\n    new_channel = ValueSequence(type_hint=int)\n    new_channel.restore(checkpoint)\n    assert new_channel.get() == [5, 6]\n\ndef test_shared_state_channel():\n    \"\"\"Test SharedState channel functionality\"\"\"\n    channel = SharedState()\n\n    # Test initial state\n    assert channel.get() == {}\n    assert channel.metadata.version == 0\n\n    # Test state setting\n    initial_state = {\"key\": \"value\"}\n    channel.set(initial_state)\n    assert channel.get() == initial_state\n    assert channel.metadata.version == 1\n\n    # Test state update\n    channel.update({\"new_key\": \"new_value\"})\n    assert channel.get() == {\"key\": \"value\", \"new_key\": \"new_value\"}\n    assert channel.metadata.version == 2\n\n    # Test type validation\n    with pytest.raises(TypeError):\n        channel.set([])  # Must be dict\n\n    # Test checkpointing\n    checkpoint = channel.checkpoint()\n    assert isinstance(checkpoint, dict)\n    assert checkpoint[\"state\"] == {\"key\": \"value\", \"new_key\": \"new_value\"}\n\n    # Test restoration\n    new_channel = SharedState()\n    new_channel.restore(checkpoint)\n    assert new_channel.get() == {\"key\": \"value\", \"new_key\": \"new_value\"}\n\ndef test_channel_isolation():\n    \"\"\"Test that channels maintain proper isolation\"\"\"\n    # Test LastValue isolation\n    lv1 = LastValue(type_hint=str)\n    lv2 = LastValue(type_hint=str)\n    lv1.set(\"test\")\n    assert lv2.get() is None\n\n    # Test ValueSequence isolation\n    vs1 = ValueSequence(type_hint=int)\n    vs2 = ValueSequence(type_hint=int)\n    vs1.append(1)\n    assert vs2.get() == []\n\n    # Test SharedState isolation\n    ss1 = SharedState()\n    ss2 = SharedState()\n    ss1.set({\"key\": \"value\"})\n    assert ss2.get() == {}\n\nclass TestMessageChannel:\n    def test_init(self):\n        channel = MessageChannel[str](str, capacity=5)\n        assert channel.available_capacity == 5\n        assert not channel.is_full\n\n        unlimited_channel = MessageChannel[int](int)\n        assert unlimited_channel.available_capacity is None\n        assert not unlimited_channel.is_full\n\n    def test_push_pop(self):\n        channel = MessageChannel[str](str, capacity=3)\n\n        # Test pushing\n        assert channel.push(\"msg1\")\n        assert channel.push(\"msg2\")\n        assert channel.push(\"msg3\")\n        assert not channel.push(\"msg4\")  # Should fail, at capacity\n\n        # Test popping\n        assert channel.pop() == \"msg1\"\n        assert channel.pop() == \"msg2\"\n        assert channel.pop() == \"msg3\"\n        assert channel.pop() is None\n\n    def test_batch_operations(self):\n        channel = MessageChannel[int](int, capacity=5)\n\n        # Test batch push\n        messages = [1, 2, 3, 4, 5, 6]\n        assert channel.push_batch(messages) == 5  # Only 5 should be pushed\n        assert len(channel.get()) == 5\n        assert channel.is_full\n\n        # Test batch pop\n        popped = channel.pop_batch(3)\n        assert popped == [1, 2, 3]\n        assert len(channel.get()) == 2\n        assert not channel.is_full\n\n        # Test pushing after batch pop\n        assert channel.push(4)\n        assert len(channel.get()) == 3\n\n    def test_clear(self):\n        channel = MessageChannel[str](str)\n        channel.push(\"msg1\")\n        channel.push(\"msg2\")\n\n        assert len(channel.get()) == 2\n        channel.clear()\n        assert len(channel.get()) == 0\n\n    def test_type_validation(self):\n        channel = MessageChannel[str](str)\n\n        with pytest.raises(TypeError):\n            channel.push(123)\n\n        with pytest.raises(TypeError):\n            channel.push_batch([123, \"valid\", 456])\n\n    def test_checkpoint_restore(self):\n        channel = MessageChannel[int](int, capacity=3)\n        channel.push(1)\n        channel.push(2)\n\n        checkpoint = channel.checkpoint()\n\n        new_channel = MessageChannel[int](int)\n        new_channel.restore(checkpoint)\n\n        assert new_channel.get() == [1, 2]\n        assert new_channel.available_capacity == 1\n\nclass TestBarrierChannel:\n    def test_init(self):\n        # Test valid initialization\n        channel = BarrierChannel(contributor_count=3)\n        assert channel.remaining_contributors == 3\n        assert not channel.is_triggered()\n        assert len(channel.current_contributors) == 0\n\n        # Test invalid initialization\n        with pytest.raises(ValueError):\n            BarrierChannel(contributor_count=0)\n\n    def test_contribution(self):\n        channel = BarrierChannel(contributor_count=2)\n\n        # First contribution\n        assert not channel.contribute(\"node1\")\n        assert channel.remaining_contributors == 1\n        assert len(channel.current_contributors) == 1\n        assert \"node1\" in channel.current_contributors\n\n        # Same contributor again\n        assert not channel.contribute(\"node1\")\n        assert channel.remaining_contributors == 1\n        assert len(channel.current_contributors) == 1\n\n        # Second contributor triggers\n        assert channel.contribute(\"node2\")\n        assert channel.remaining_contributors == 0\n        assert channel.is_triggered()\n        assert len(channel.current_contributors) == 2\n\n    def test_timeout(self):\n        channel = BarrierChannel(contributor_count=2, timeout=0.1)\n\n        # Add first contribution\n        assert not channel.contribute(\"node1\")\n        assert channel.remaining_contributors == 1\n\n        # Wait for timeout\n        import time\n        time.sleep(0.2)\n\n        # Check timeout reset\n        assert not channel.is_triggered()\n        assert channel.remaining_contributors == 2\n        assert len(channel.current_contributors) == 0\n\n    def test_reset(self):\n        channel = BarrierChannel(contributor_count=2)\n\n        # Add contributions and trigger\n        assert not channel.contribute(\"node1\")\n        assert channel.contribute(\"node2\")\n        assert channel.is_triggered()\n\n        # Reset and verify state\n        channel.reset()\n        assert not channel.is_triggered()\n        assert channel.remaining_contributors == 2\n        assert len(channel.current_contributors) == 0\n\n    def test_checkpoint_restore(self):\n        channel = BarrierChannel(contributor_count=3, timeout=1.0)\n\n        # Add some contributions\n        channel.contribute(\"node1\")\n        channel.contribute(\"node2\")\n\n        # Create checkpoint\n        checkpoint = channel.checkpoint()\n\n        # Create new channel and restore\n        new_channel = BarrierChannel(contributor_count=1)  # Different count\n        new_channel.restore(checkpoint)\n\n        # Verify restored state\n        assert new_channel.remaining_contributors == 1\n        assert len(new_channel.current_contributors) == 2\n        assert \"node1\" in new_channel.current_contributors\n        assert \"node2\" in new_channel.current_contributors\n        assert new_channel._timeout == 1.0\n\nclass TestBroadcastChannel:\n    def test_init(self):\n        channel = BroadcastChannel[str](str, history_size=5)\n        assert channel.subscriber_count == 0\n        assert len(channel.history) == 0\n        assert channel.get() is None\n\n        unlimited_channel = BroadcastChannel[int](int)\n        assert unlimited_channel.subscriber_count == 0\n        assert len(unlimited_channel.history) == 0\n\n    def test_subscription(self):\n        channel = BroadcastChannel[str](str)\n\n        # Test subscribe\n        channel.subscribe(\"sub1\")\n        assert channel.subscriber_count == 1\n        assert \"sub1\" in channel.subscribers\n\n        # Test duplicate subscription\n        channel.subscribe(\"sub1\")\n        assert channel.subscriber_count == 1\n\n        # Test multiple subscribers\n        channel.subscribe(\"sub2\")\n        assert channel.subscriber_count == 2\n        assert \"sub2\" in channel.subscribers\n\n        # Test unsubscribe\n        channel.unsubscribe(\"sub1\")\n        assert channel.subscriber_count == 1\n        assert \"sub1\" not in channel.subscribers\n        assert \"sub2\" in channel.subscribers\n\n        # Test unsubscribe non-existent\n        channel.unsubscribe(\"non-existent\")\n        assert channel.subscriber_count == 1\n\n    def test_broadcasting(self):\n        channel = BroadcastChannel[str](str)\n\n        # Test single broadcast\n        channel.broadcast(\"msg1\")\n        assert channel.get() == \"msg1\"\n        assert channel.history == [\"msg1\"]\n\n        # Test multiple broadcasts\n        channel.broadcast(\"msg2\")\n        channel.broadcast(\"msg3\")\n        assert channel.get() == \"msg3\"\n        assert channel.history == [\"msg1\", \"msg2\", \"msg3\"]\n\n    def test_history_limit(self):\n        channel = BroadcastChannel[int](int, history_size=2)\n\n        # Fill history\n        channel.broadcast(1)\n        channel.broadcast(2)\n        assert channel.history == [1, 2]\n\n        # Exceed limit\n        channel.broadcast(3)\n        assert channel.history == [2, 3]\n        assert channel.get() == 3\n\n    def test_clear_history(self):\n        channel = BroadcastChannel[str](str)\n\n        channel.broadcast(\"msg1\")\n        channel.broadcast(\"msg2\")\n        assert len(channel.history) == 2\n\n        channel.clear_history()\n        assert len(channel.history) == 0\n        assert channel.get() == \"msg2\"  # Current value remains\n\n    def test_type_validation(self):\n        channel = BroadcastChannel[str](str)\n\n        with pytest.raises(TypeError):\n            channel.broadcast(123)\n\n    def test_checkpoint_restore(self):\n        channel = BroadcastChannel[int](int, history_size=3)\n\n        # Setup state\n        channel.subscribe(\"sub1\")\n        channel.subscribe(\"sub2\")\n        channel.broadcast(1)\n        channel.broadcast(2)\n\n        # Create checkpoint\n        checkpoint = channel.checkpoint()\n\n        # Create new channel and restore\n        new_channel = BroadcastChannel[int](int)\n        new_channel.restore(checkpoint)\n\n        # Verify restored state\n        assert new_channel.subscriber_count == 2\n        assert \"sub1\" in new_channel.subscribers\n        assert \"sub2\" in new_channel.subscribers\n        assert new_channel.history == [1, 2]\n        assert new_channel.get() == 2\n\nclass TestAggregatorChannel:\n    def test_init(self):\n        # Test with default reducer\n        channel = AggregatorChannel[int](int)\n        assert channel.window_size is None\n        assert channel.get() is None\n        assert len(channel.window) == 0\n\n        # Test with custom reducer and window\n        def sum_reducer(values: List[int]) -> int:\n            return sum(values)\n\n        channel = AggregatorChannel[int](int, reducer=sum_reducer, window_size=3)\n        assert channel.window_size == 3\n        assert channel.get() is None\n\n    def test_default_reducer(self):\n        channel = AggregatorChannel[str](str)\n\n        # Test single value\n        channel.contribute(\"first\")\n        assert channel.get() == \"first\"\n\n        # Test multiple values\n        channel.contribute(\"second\")\n        assert channel.get() == \"second\"  # Default reducer uses last value\n\n    def test_custom_reducer(self):\n        def avg_reducer(values: List[float]) -> float:\n            return sum(values) / len(values)\n\n        channel = AggregatorChannel[float](float, reducer=avg_reducer)\n\n        channel.contribute(1.0)\n        assert channel.get() == 1.0\n\n        channel.contribute(2.0)\n        assert channel.get() == 1.5\n\n        channel.contribute(3.0)\n        assert channel.get() == 2.0\n\n    def test_window_management(self):\n        def sum_reducer(values: List[int]) -> int:\n            return sum(values)\n\n        channel = AggregatorChannel[int](int, reducer=sum_reducer, window_size=2)\n\n        # Fill window\n        channel.contribute(1)\n        assert channel.get() == 1\n        assert channel.window == [1]\n\n        channel.contribute(2)\n        assert channel.get() == 3\n        assert channel.window == [1, 2]\n\n        # Exceed window size\n        channel.contribute(3)\n        assert channel.get() == 5  # 2 + 3\n        assert channel.window == [2, 3]\n\n    def test_reducer_error_handling(self):\n        def faulty_reducer(values: List[int]) -> int:\n            raise ValueError(\"Reducer error\")\n\n        channel = AggregatorChannel[int](int, reducer=faulty_reducer)\n\n        # Should fallback to last value on reducer error\n        channel.contribute(1)\n        assert channel.get() == 1\n\n        channel.contribute(2)\n        assert channel.get() == 2\n\n    def test_clear(self):\n        channel = AggregatorChannel[int](int)\n\n        channel.contribute(1)\n        channel.contribute(2)\n        assert len(channel.window) == 2\n\n        channel.clear()\n        assert len(channel.window) == 0\n        assert channel.get() is None\n\n    def test_set_value(self):\n        def sum_reducer(values: List[int]) -> int:\n            return sum(values)\n\n        channel = AggregatorChannel[int](int, reducer=sum_reducer)\n\n        # Add some values\n        channel.contribute(1)\n        channel.contribute(2)\n        assert channel.get() == 3\n\n        # Set single value\n        channel.set(5)\n        assert channel.get() == 5\n        assert channel.window == [5]\n\n    def test_type_validation(self):\n        channel = AggregatorChannel[str](str)\n\n        with pytest.raises(TypeError):\n            channel.contribute(123)\n\n        with pytest.raises(TypeError):\n            channel.set(123)\n\n    def test_checkpoint_restore(self):\n        def sum_reducer(values: List[int]) -> int:\n            return sum(values)\n\n        channel = AggregatorChannel[int](int, reducer=sum_reducer, window_size=3)\n\n        # Setup state\n        channel.contribute(1)\n        channel.contribute(2)\n\n        # Create checkpoint\n        checkpoint = channel.checkpoint()\n\n        # Create new channel and restore\n        new_channel = AggregatorChannel[int](int, reducer=sum_reducer)\n        new_channel.restore(checkpoint)\n\n        # Verify restored state\n        assert new_channel.window == [1, 2]\n        assert new_channel.window_size == 3\n        assert new_channel.get() == 3  # Result recomputed with restored reducer\n\nclass TestChannelManager:\n    \"\"\"Test cases for ChannelManager\"\"\"\n\n    def test_channel_type_registration(self):\n        \"\"\"Test channel type registration\"\"\"\n        manager = ChannelManager()\n\n        # Test registration\n        manager.register_channel_type(\"last_value\", LastValue)\n        assert \"last_value\" in manager.get_registered_types()\n\n        # Test duplicate registration\n        with pytest.raises(ValueError):\n            manager.register_channel_type(\"last_value\", LastValue)\n\n    def test_channel_creation(self):\n        \"\"\"Test channel creation\"\"\"\n        manager = ChannelManager()\n        manager.register_channel_type(\"last_value\", LastValue)\n\n        # Test creation with auto-generated ID\n        channel1 = manager.create_channel(\"last_value\", type_hint=str)\n        assert channel1.id in manager.get_active_channels()\n\n        # Test creation with custom ID\n        channel2 = manager.create_channel(\"last_value\", channel_id=\"custom_id\", type_hint=int)\n        assert channel2.id == \"custom_id\"\n        assert channel2.id in manager.get_active_channels()\n\n        # Test creation with unknown type\n        with pytest.raises(ValueError):\n            manager.create_channel(\"unknown_type\")\n\n    def test_channel_lifecycle(self):\n        \"\"\"Test channel lifecycle management\"\"\"\n        manager = ChannelManager()\n        manager.register_channel_type(\"last_value\", LastValue)\n\n        # Create channel\n        channel = manager.create_channel(\"last_value\")\n        channel_id = channel.id\n\n        # Get channel\n        assert manager.get_channel(channel_id) == channel\n        assert manager.get_channel(\"unknown\") is None\n\n        # Delete channel\n        manager.delete_channel(channel_id)\n        assert channel_id not in manager.get_active_channels()\n        assert manager.get_channel(channel_id) is None\n\n        # Delete non-existent channel (should not raise)\n        manager.delete_channel(\"unknown\")\n\n    def test_error_handling(self):\n        \"\"\"Test error handling\"\"\"\n        manager = ChannelManager()\n        manager.register_channel_type(\"last_value\", LastValue)\n        channel = manager.create_channel(\"last_value\")\n\n        # Test error handler registration\n        errors = []\n        def error_handler(e: Exception):\n            errors.append(e)\n\n        manager.register_error_handler(channel.id, error_handler)\n\n        # Test error handling\n        error = ValueError(\"Test error\")\n        manager.update_metrics(channel.id, error)\n        assert len(errors) == 1\n        assert isinstance(errors[0], ValueError)\n\n        # Test registration for unknown channel\n        with pytest.raises(ValueError):\n            manager.register_error_handler(\"unknown\", error_handler)\n\n    def test_performance_metrics(self):\n        \"\"\"Test performance metrics tracking\"\"\"\n        manager = ChannelManager()\n        manager.register_channel_type(\"last_value\", LastValue)\n        channel = manager.create_channel(\"last_value\")\n\n        # Initial metrics\n        metrics = manager.get_metrics(channel.id)\n        assert metrics[\"update_count\"] == 0\n        assert metrics[\"error_count\"] == 0\n        assert metrics[\"last_update\"] is None\n\n        # Update metrics\n        manager.update_metrics(channel.id)\n        metrics = manager.get_metrics(channel.id)\n        assert metrics[\"update_count\"] == 1\n        assert metrics[\"last_update\"] is not None\n\n        # Update with error\n        manager.update_metrics(channel.id, ValueError())\n        metrics = manager.get_metrics(channel.id)\n        assert metrics[\"error_count\"] == 1\n\n        # Get metrics for unknown channel\n        assert manager.get_metrics(\"unknown\") is None\n\n    def test_debug_mode(self):\n        \"\"\"Test debug mode\"\"\"\n        manager = ChannelManager()\n        manager.register_channel_type(\"last_value\", LastValue)\n        channel = manager.create_channel(\"last_value\")\n\n        def failing_handler(e: Exception):\n            raise RuntimeError(\"Handler error\")\n\n        manager.register_error_handler(channel.id, failing_handler)\n\n        # Test without debug mode\n        manager.set_debug_mode(False)\n        manager.update_metrics(channel.id, ValueError())  # Should not raise or print\n\n        # Test with debug mode\n        manager.set_debug_mode(True)\n        manager.update_metrics(channel.id, ValueError())  # Should print error message\n\n    def test_clear(self):\n        \"\"\"Test clearing all channels and metrics\"\"\"\n        manager = ChannelManager()\n        manager.register_channel_type(\"last_value\", LastValue)\n\n        # Create multiple channels\n        channel1 = manager.create_channel(\"last_value\")\n        channel2 = manager.create_channel(\"last_value\")\n\n        def error_handler(e: Exception):\n            pass\n\n        manager.register_error_handler(channel1.id, error_handler)\n\n        # Clear everything\n        manager.clear()\n        assert len(manager.get_active_channels()) == 0\n        assert manager.get_metrics(channel1.id) is None\n        assert manager.get_metrics(channel2.id) is None\n\nclass TestSharedMemory:\n    \"\"\"Test SharedMemory channel\"\"\"\n\n    def test_init(self):\n        \"\"\"Test initialization\"\"\"\n        channel = SharedMemory(str)\n        assert channel.get() is None\n\n    def test_set_get(self):\n        \"\"\"Test setting and getting values\"\"\"\n        channel = SharedMemory(dict)\n        value = {\"key\": \"value\"}\n\n        channel.set(value)\n        assert channel.get() == value\n\n    def test_type_validation(self):\n        \"\"\"Test type validation\"\"\"\n        channel = SharedMemory(int)\n\n        with pytest.raises(TypeError):\n            channel.set(\"invalid\")\n\n    def test_clear(self):\n        \"\"\"Test clearing value\"\"\"\n        channel = SharedMemory(list)\n        value = [1, 2, 3]\n\n        channel.set(value)\n        assert channel.get() == value\n\n        channel.clear()\n        assert channel.get() is None\n\n    def test_checkpoint_restore(self):\n        \"\"\"Test checkpointing and restoring\"\"\"\n        channel = SharedMemory(dict)\n        value = {\"key\": \"value\"}\n\n        channel.set(value)\n        checkpoint = channel.checkpoint()\n\n        new_channel = SharedMemory(dict)\n        new_channel.restore(checkpoint)\n\n        assert new_channel.get() == value\n\n        # Test invalid checkpoint type\n        with pytest.raises(ValueError):\n            new_channel.restore({\"type\": \"invalid\"})\n"
