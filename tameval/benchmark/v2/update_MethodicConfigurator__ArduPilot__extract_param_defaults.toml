[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "ArduPilot/MethodicConfigurator"
sha = "8f14cac0abb19c133ba74e6693d4efb6385cb8f0"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "(pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=ardupilot_methodic_configurator/extract_param_defaults.py -m pytest -q --junit-xml=test_output.xml tests/test_extract_param_defaults.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target ardupilot_methodic_configurator.extract_param_defaults --unit-test tests.test_extract_param_defaults --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target ardupilot_methodic_configurator/extract_param_defaults.py --unit-test tests/test_extract_param_defaults.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 80.0
original_coverage = 95.0
mutation_kill_rate = 76.0
original_mutation_kill_rate = 87.0
covered_lines = [ 15, 16, 17, 18, 20, 21, 22, 24, 25, 26, 27, 28, 29, 32, 33, 34, 41, 48, 55, 62, 69, 76, 81, 82, 85, 96, 97, 99, 103, 104, 106, 107, 108, 109, 110, 111, 112, 114, 117, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 149, 151, 152, 153, 154, 177, 188, 190, 193, 204, 207, 219, 220, 221, 222, 223, 224, 225, 228, 247, 248, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 266, 270, 271, 272, 274, 275, 276, 277, 278, 279, 280, 283, 290,]
missed_lines = [ 100, 101, 150, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 173, 174, 284, 285, 286, 287, 291,]

[input_info]
test_file_path = "tests/test_extract_param_defaults.py"
focal_file_path = "ardupilot_methodic_configurator/extract_param_defaults.py"
test_file_url = "https://github.com/ArduPilot/MethodicConfigurator/blob/8f14cac0abb19c133ba74e6693d4efb6385cb8f0/tests/test_extract_param_defaults.py"
focal_file_url = "https://github.com/ArduPilot/MethodicConfigurator/blob/8f14cac0abb19c133ba74e6693d4efb6385cb8f0/ardupilot_methodic_configurator/extract_param_defaults.py"
first_commit_date = "2024-12-02"
last_commit_date = "2025-02-21"
test_file_content = "#!/usr/bin/python3\n\n\"\"\"\nTests for the extract_param_defaults.py file.\n\nExtracts parameter default values from an ArduPilot .bin log file.\n\nSPDX-FileCopyrightText: 2024-2025 Amilcar do Carmo Lucas <amilcar.lucas@iav.de>\n\nSPDX-License-Identifier: GPL-3.0-or-later\n\"\"\"\n\nimport unittest\nfrom unittest.mock import MagicMock, Mock, patch\n\nimport pytest\n\nfrom ardupilot_methodic_configurator.extract_param_defaults import (\n    MAVLINK_COMPID_MAX,\n    MAVLINK_SYSID_MAX,\n    NO_DEFAULT_VALUES_MESSAGE,\n    extract_parameter_values,\n    mavproxy_sort,\n    missionplanner_sort,\n    output_params,\n    parse_arguments,\n    sort_params,\n)\n\n\n@pytest.fixture\ndef mock_print() -> Mock:\n    with patch(\"builtins.print\") as mock:\n        yield mock\n\n\nclass TestArgParseParameters(unittest.TestCase):  # pylint: disable=missing-class-docstring\n    def test_command_line_arguments_combinations(self) -> None:\n        # Check the 'format' and 'sort' default parameters\n        args = parse_arguments([\"dummy.bin\"])\n        assert args.format == \"missionplanner\"\n        assert args.sort == \"missionplanner\"\n\n        # Check the 'format' and 'sort' parameters to see if 'sort' can be explicitly overwritten\n        args = parse_arguments([\"-s\", \"none\", \"dummy.bin\"])\n        assert args.format == \"missionplanner\"\n        assert args.sort == \"none\"\n\n        # Check the 'format' and 'sort' parameters to see if 'sort' can be implicitly overwritten (mavproxy)\n        args = parse_arguments([\"-f\", \"mavproxy\", \"dummy.bin\"])\n        assert args.format == \"mavproxy\"\n        assert args.sort == \"mavproxy\"\n\n        # Check the 'format' and 'sort' parameters to see if 'sort' can be implicitly overwritten (qgcs)\n        args = parse_arguments([\"-f\", \"qgcs\", \"dummy.bin\"])\n        assert args.format == \"qgcs\"\n        assert args.sort == \"qgcs\"\n\n        # Check the 'format' and 'sort' parameters\n        args = parse_arguments([\"-f\", \"mavproxy\", \"-s\", \"none\", \"dummy.bin\"])\n        assert args.format == \"mavproxy\"\n        assert args.sort == \"none\"\n\n        # Assert that a SystemExit is raised when --sysid is used without --format set to qgcs\n        with pytest.raises(SystemExit) as excinfo:\n            parse_arguments([\"-f\", \"mavproxy\", \"-i\", \"7\", \"dummy.bin\"])\n        assert str(excinfo.value) == \"--sysid parameter is only relevant if --format is qgcs\"\n\n        # Assert that a SystemExit is raised when --compid is used without --format set to qgcs\n        with pytest.raises(SystemExit) as excinfo:\n            parse_arguments([\"-f\", \"missionplanner\", \"-c\", \"3\", \"dummy.bin\"])\n        assert str(excinfo.value) == \"--compid parameter is only relevant if --format is qgcs\"\n\n        # Assert that a valid sysid and compid are parsed correctly\n        args = parse_arguments([\"-f\", \"qgcs\", \"-i\", \"7\", \"-c\", \"3\", \"dummy.bin\"])\n        assert args.format == \"qgcs\"\n        assert args.sort == \"qgcs\"\n        assert args.sysid == 7\n        assert args.compid == 3\n\n\nclass TestExtractParameterDefaultValues(unittest.TestCase):  # pylint: disable=missing-class-docstring\n    @patch(\"ardupilot_methodic_configurator.extract_param_defaults.mavutil.mavlink_connection\")\n    def test_logfile_does_not_exist(self, mock_mavlink_connection) -> None:\n        # Mock the mavlink connection to raise an exception\n        mock_mavlink_connection.side_effect = Exception(\"Test exception\")\n\n        # Call the function with a dummy logfile path\n        with pytest.raises(SystemExit) as cm:\n            extract_parameter_values(\"dummy.bin\")\n\n        # Check the error message\n        assert str(cm.value) == \"Error opening the dummy.bin logfile: Test exception\"\n\n    @patch(\"ardupilot_methodic_configurator.extract_param_defaults.mavutil.mavlink_connection\")\n    def test_extract_parameter_default_values(self, mock_mavlink_connection) -> None:\n        # Mock the mavlink connection and the messages it returns\n        mock_mlog = MagicMock()\n        mock_mavlink_connection.return_value = mock_mlog\n        mock_mlog.recv_match.side_effect = [\n            MagicMock(Name=\"PARAM1\", Default=1.1),\n            MagicMock(Name=\"PARAM2\", Default=2.0),\n            None,  # End of messages\n        ]\n\n        # Call the function with a dummy logfile path\n        defaults = extract_parameter_values(\"dummy.bin\")\n\n        # Check if the defaults dictionary contains the correct parameters and values\n        assert defaults == {\"PARAM1\": 1.1, \"PARAM2\": 2.0}\n\n    @patch(\"ardupilot_methodic_configurator.extract_param_defaults.mavutil.mavlink_connection\")\n    def test_no_parameters(self, mock_mavlink_connection) -> None:\n        # Mock the mavlink connection to return no parameter messages\n        mock_mlog = MagicMock()\n        mock_mavlink_connection.return_value = mock_mlog\n        mock_mlog.recv_match.return_value = None  # No PARM messages\n\n        # Call the function with a dummy logfile path and assert SystemExit is raised with the correct message\n        with pytest.raises(SystemExit) as cm:\n            extract_parameter_values(\"dummy.bin\")\n        assert str(cm.value) == NO_DEFAULT_VALUES_MESSAGE\n\n    @patch(\"ardupilot_methodic_configurator.extract_param_defaults.mavutil.mavlink_connection\")\n    def test_no_parameter_defaults(self, mock_mavlink_connection) -> None:\n        # Mock the mavlink connection to simulate no parameter default values in the .bin file\n        mock_mlog = MagicMock()\n        mock_mavlink_connection.return_value = mock_mlog\n        mock_mlog.recv_match.return_value = None  # No PARM messages\n\n        # Call the function with a dummy logfile path and assert SystemExit is raised with the correct message\n        with pytest.raises(SystemExit) as cm:\n            extract_parameter_values(\"dummy.bin\")\n        assert str(cm.value) == NO_DEFAULT_VALUES_MESSAGE\n\n    @patch(\"ardupilot_methodic_configurator.extract_param_defaults.mavutil.mavlink_connection\")\n    def test_invalid_parameter_name(self, mock_mavlink_connection) -> None:\n        # Mock the mavlink connection to simulate an invalid parameter name\n        mock_mlog = MagicMock()\n        mock_mavlink_connection.return_value = mock_mlog\n        mock_mlog.recv_match.return_value = MagicMock(Name=\"INVALID_NAME%\", Default=1.0)\n\n        # Call the function with a dummy logfile path\n        with pytest.raises(SystemExit):\n            extract_parameter_values(\"dummy.bin\")\n\n    @patch(\"ardupilot_methodic_configurator.extract_param_defaults.mavutil.mavlink_connection\")\n    def test_long_parameter_name(self, mock_mavlink_connection) -> None:\n        # Mock the mavlink connection to simulate a too long parameter name\n        mock_mlog = MagicMock()\n        mock_mavlink_connection.return_value = mock_mlog\n        mock_mlog.recv_match.return_value = MagicMock(Name=\"TOO_LONG_PARAMETER_NAME\", Default=1.0)\n\n        # Call the function with a dummy logfile path\n        with pytest.raises(SystemExit):\n            extract_parameter_values(\"dummy.bin\")\n\n\nclass TestSortFunctions(unittest.TestCase):  # pylint: disable=missing-class-docstring\n    def test_missionplanner_sort(self) -> None:\n        # Define a list of parameter names\n        params = [\"PARAM_GROUP1_PARAM1\", \"PARAM_GROUP2_PARAM2\", \"PARAM_GROUP1_PARAM2\"]\n\n        # Sort the parameters using the missionplanner_sort function\n        sorted_params = sorted(params, key=missionplanner_sort)\n\n        # Check if the parameters were sorted correctly\n        assert sorted_params == [\"PARAM_GROUP1_PARAM1\", \"PARAM_GROUP1_PARAM2\", \"PARAM_GROUP2_PARAM2\"]\n\n        # Test with a parameter name that doesn't contain an underscore\n        params = [\"PARAM1\", \"PARAM3\", \"PARAM2\"]\n        sorted_params = sorted(params, key=missionplanner_sort)\n        assert sorted_params == [\"PARAM1\", \"PARAM2\", \"PARAM3\"]\n\n    def test_mavproxy_sort(self) -> None:\n        # Define a list of parameter names\n        params = [\"PARAM_GROUP1_PARAM1\", \"PARAM_GROUP2_PARAM2\", \"PARAM_GROUP1_PARAM2\"]\n\n        # Sort the parameters using the mavproxy_sort function\n        sorted_params = sorted(params, key=mavproxy_sort)\n\n        # Check if the parameters were sorted correctly\n        assert sorted_params == [\"PARAM_GROUP1_PARAM1\", \"PARAM_GROUP1_PARAM2\", \"PARAM_GROUP2_PARAM2\"]\n\n        # Test with a parameter name that doesn't contain an underscore\n        params = [\"PARAM1\", \"PARAM3\", \"PARAM2\"]\n        sorted_params = sorted(params, key=mavproxy_sort)\n        assert sorted_params == [\"PARAM1\", \"PARAM2\", \"PARAM3\"]\n\n\n@pytest.mark.usefixtures(\"mock_print\")\nclass TestOutputParams(unittest.TestCase):  # pylint: disable=missing-class-docstring\n    @patch(\"builtins.print\")\n    def test_output_params(self, mock_print_) -> None:\n        # Prepare a dummy defaults dictionary\n        defaults = {\"PARAM2\": 1.0, \"PARAM1\": 2.0}\n\n        # Call the function with the dummy dictionary, 'missionplanner' format type\n        output_params(defaults, \"missionplanner\")\n\n        # Check if the print function was called with the correct parameters\n        expected_calls = [unittest.mock.call(\"PARAM2,1\"), unittest.mock.call(\"PARAM1,2\")]\n        mock_print_.assert_has_calls(expected_calls, any_order=False)\n\n    @patch(\"builtins.print\")\n    def test_output_params_missionplanner_non_numeric(self, mock_print_) -> None:\n        # Prepare a dummy defaults dictionary\n        defaults = {\"PARAM1\": \"non-numeric\"}\n\n        # Call the function with the dummy dictionary, 'missionplanner' format type\n        output_params(defaults, \"missionplanner\")\n\n        # Check if the print function was called with the correct parameters\n        expected_calls = [unittest.mock.call(\"PARAM1,non-numeric\")]\n        mock_print_.assert_has_calls(expected_calls, any_order=False)\n\n    @patch(\"builtins.print\")\n    def test_output_params_mavproxy(self, mock_print_) -> None:\n        # Prepare a dummy defaults dictionary\n        defaults = {\"PARAM2\": 2.0, \"PARAM1\": 1.0}\n\n        # Call the function with the dummy dictionary, 'mavproxy' format type and 'mavproxy' sort type\n        defaults = sort_params(defaults, \"mavproxy\")\n        output_params(defaults, \"mavproxy\")\n\n        # Check if the print function was called with the correct parameters\n        expected_calls = [\n            unittest.mock.call(\"%-15s %.6f\" % (\"PARAM1\", 1.0)),  # pylint: disable=consider-using-f-string\n            unittest.mock.call(\"%-15s %.6f\" % (\"PARAM2\", 2.0)),  # pylint: disable=consider-using-f-string\n        ]\n        mock_print_.assert_has_calls(expected_calls, any_order=False)\n\n    @patch(\"builtins.print\")\n    def test_output_params_qgcs(self, mock_print_) -> None:\n        # Prepare a dummy defaults dictionary\n        defaults = {\"PARAM2\": 2.0, \"PARAM1\": 1.0}\n\n        # Call the function with the dummy dictionary, 'qgcs' format type and 'qgcs' sort type\n        defaults = sort_params(defaults, \"qgcs\")\n        output_params(defaults, \"qgcs\")\n\n        # Check if the print function was called with the correct parameters\n        expected_calls = [\n            unittest.mock.call(\"\\n# # Vehicle-Id Component-Id Name Value Type\\n\"),\n            unittest.mock.call(\"%u %u %-15s %.6f %u\" % (1, 1, \"PARAM1\", 1.0, 9)),  # pylint: disable=consider-using-f-string\n            unittest.mock.call(\"%u %u %-15s %.6f %u\" % (1, 1, \"PARAM2\", 2.0, 9)),  # pylint: disable=consider-using-f-string\n        ]\n        mock_print_.assert_has_calls(expected_calls, any_order=False)\n\n    @patch(\"builtins.print\")\n    def test_output_params_qgcs_2_4(self, mock_print_) -> None:\n        # Prepare a dummy defaults dictionary\n        defaults = {\"PARAM2\": 2.0, \"PARAM1\": 1.0}\n\n        # Call the function with the dummy dictionary, 'qgcs' format type and 'qgcs' sort type\n        defaults = sort_params(defaults, \"qgcs\")\n        output_params(defaults, \"qgcs\", 2, 4)\n\n        # Check if the print function was called with the correct parameters\n        expected_calls = [\n            unittest.mock.call(\"\\n# # Vehicle-Id Component-Id Name Value Type\\n\"),\n            unittest.mock.call(\"%u %u %-15s %.6f %u\" % (2, 4, \"PARAM1\", 1.0, 9)),  # pylint: disable=consider-using-f-string\n            unittest.mock.call(\"%u %u %-15s %.6f %u\" % (2, 4, \"PARAM2\", 2.0, 9)),  # pylint: disable=consider-using-f-string\n        ]\n        mock_print_.assert_has_calls(expected_calls, any_order=False)\n\n    @patch(\"builtins.print\")\n    def test_output_params_qgcs_SYSID_THISMAV(self, mock_print_) -> None:  # noqa: N802, pylint: disable=invalid-name\n        # Prepare a dummy defaults dictionary\n        defaults = {\"PARAM2\": 2.0, \"PARAM1\": 1.0, \"SYSID_THISMAV\": 3.0}\n\n        # Call the function with the dummy dictionary, 'qgcs' format type and 'qgcs' sort type\n        defaults = sort_params(defaults, \"qgcs\")\n        output_params(defaults, \"qgcs\", -1, 7)\n\n        # Check if the print function was called with the correct parameters\n        expected_calls = [\n            unittest.mock.call(\"\\n# # Vehicle-Id Component-Id Name Value Type\\n\"),\n            unittest.mock.call(\"%u %u %-15s %.6f %u\" % (3, 7, \"PARAM1\", 1.0, 9)),  # pylint: disable=consider-using-f-string\n            unittest.mock.call(\"%u %u %-15s %.6f %u\" % (3, 7, \"PARAM2\", 2.0, 9)),  # pylint: disable=consider-using-f-string\n            unittest.mock.call(\"%u %u %-15s %.6f %u\" % (3, 7, \"SYSID_THISMAV\", 3.0, 9)),  # pylint: disable=consider-using-f-string\n        ]\n        mock_print_.assert_has_calls(expected_calls, any_order=False)\n\n    def test_output_params_qgcs_SYSID_INVALID(self) -> None:  # noqa: N802, pylint: disable=invalid-name\n        # Prepare a dummy defaults dictionary\n        defaults = {\"PARAM2\": 2.0, \"PARAM1\": 1.0, \"SYSID_THISMAV\": -1.0}\n\n        # Assert that a SystemExit is raised with the correct message when an invalid sysid is used\n        defaults = sort_params(defaults, \"qgcs\")\n        with pytest.raises(SystemExit) as cm:\n            output_params(defaults, \"qgcs\", -1, 7)\n        assert str(cm.value) == \"Invalid system ID parameter -1 must not be negative\"\n\n        # Assert that a SystemExit is raised with the correct message when an invalid sysid is used\n        with pytest.raises(SystemExit) as cm:\n            output_params(defaults, \"qgcs\", MAVLINK_SYSID_MAX + 2, 7)\n        assert str(cm.value) == f\"Invalid system ID parameter 16777218 must be smaller than {MAVLINK_SYSID_MAX}\"\n\n    def test_output_params_qgcs_COMPID_INVALID(self) -> None:  # noqa: N802, pylint: disable=invalid-name\n        # Prepare a dummy defaults dictionary\n        defaults = {\"PARAM2\": 2.0, \"PARAM1\": 1.0}\n\n        # Assert that a SystemExit is raised with the correct message when an invalid compid is used\n        defaults = sort_params(defaults, \"qgcs\")\n        with pytest.raises(SystemExit) as cm:\n            output_params(defaults, \"qgcs\", -1, -3)\n        assert str(cm.value) == \"Invalid component ID parameter -3 must not be negative\"\n\n        # Assert that a SystemExit is raised with the correct message when an invalid compid is used\n        with pytest.raises(SystemExit) as cm:\n            output_params(defaults, \"qgcs\", 1, MAVLINK_COMPID_MAX + 3)\n        assert str(cm.value) == f\"Invalid component ID parameter 259 must be smaller than {MAVLINK_COMPID_MAX}\"\n\n    @patch(\"builtins.print\")\n    def test_output_params_integer(self, mock_print_) -> None:\n        # Prepare a dummy defaults dictionary with an integer value\n        defaults = {\"PARAM1\": 1.01, \"PARAM2\": 2.00}\n\n        # Call the function with the dummy dictionary, 'missionplanner' format type and 'missionplanner' sort type\n        defaults = sort_params(defaults, \"missionplanner\")\n        output_params(defaults, \"missionplanner\")\n\n        # Check if the print function was called with the correct parameters\n        expected_calls = [unittest.mock.call(\"PARAM1,1.01\"), unittest.mock.call(\"PARAM2,2\")]\n        mock_print_.assert_has_calls(expected_calls, any_order=False)\n\n\nif __name__ == \"__main__\":\n    unittest.main()"
