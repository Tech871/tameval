[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Java"
java_builder = "Maven"
is_multi_module = true

[repo_info]
repository = "cucumber/cucumber-jvm"
sha = "953adf561d12439ee5d6596c2aec241381580107"

[run_info]
docker_image = "maven:3.8.3-openjdk-17"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "mvn -Dmaven.repo.local=/.m2 -T 4 clean install"
test_run_command = "mvn clean -Dmaven.repo.local=/.m2 test -q -pl cucumber-core -Dtest=IncrementingUuidGeneratorTest && mvn jacoco:report -Djacoco.append=false"
mutation_run_command = "mvn -Dmaven.repo.local=/.m2 org.pitest:pitest-maven:mutationCoverage -pl cucumber-core -DtargetClasses=**.IncrementingUuidGenerator  -DtargetTests=**.IncrementingUuidGeneratorTest  -DoutputFormats=XML"
coverage_report_path = "cucumber-core/target/site/jacoco/jacoco.xml"
coverage_report_type = "jacoco"
mutation_report_path = "cucumber-core/target/pit-reports/mutations.xml"
mutation_report_type = "pitest"

[coverage]
coverage = 0
original_coverage = 100.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "cucumber-core/src/test/java/io/cucumber/core/eventbus/IncrementingUuidGeneratorTest.java"
focal_file_path = "cucumber-core/src/main/java/io/cucumber/core/eventbus/IncrementingUuidGenerator.java"
test_file_url = "https://github.com/cucumber/cucumber-jvm/blob/953adf561d12439ee5d6596c2aec241381580107/cucumber-core/src/test/java/io/cucumber/core/eventbus/IncrementingUuidGeneratorTest.java"
focal_file_url = "https://github.com/cucumber/cucumber-jvm/blob/953adf561d12439ee5d6596c2aec241381580107/cucumber-core/src/main/java/io/cucumber/core/eventbus/IncrementingUuidGenerator.java"
first_commit_date = "2023-04-06"
last_commit_date = "2024-10-09"
test_file_content = "package io.cucumber.core.eventbus;\n\nimport io.cucumber.core.exception.CucumberException;\nimport org.hamcrest.Matchers;\nimport org.junit.jupiter.api.Test;\n\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.net.URISyntaxException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nclass IncrementingUuidGeneratorTest {\n\n    public static final String CLASSLOADER_ID_FIELD_NAME = \"classloaderId\";\n\n    /**\n     * Example of generated values (same epochTime, same sessionId, same\n     * classloaderId, different counter value):\n     * \"87273d64-5500-83e3-8000-000000000000\"\n     * \"87273d64-5500-83e3-8000-000000000001\"\n     * \"87273d64-5500-83e3-8000-000000000002\"\n     * \"87273d64-5500-83e3-8000-000000000003\"\n     * \"87273d64-5500-83e3-8000-000000000004\"\n     * \"87273d64-5500-83e3-8000-000000000005\"\n     * \"87273d64-5500-83e3-8000-000000000006\"\n     * \"87273d64-5500-83e3-8000-000000000007\"\n     * \"87273d64-5500-83e3-8000-000000000008\"\n     * \"87273d64-5500-83e3-8000-000000000009\"\n     */\n    @Test\n    void generates_different_non_null_uuids() {\n        // Given\n        UuidGenerator generator = new IncrementingUuidGenerator();\n\n        // When\n        List<UUID> uuids = IntStream.rangeClosed(1, 10)\n                .mapToObj(i -> generator.generateId())\n                .collect(Collectors.toList());\n\n        // Then\n        checkUuidProperties(uuids);\n    }\n\n    /**\n     * Example of generated values (same epochTime, different sessionId, * same\n     * classloaderId, same counter value):\n     * \"87273c5d-8500-88b6-8000-000000000000\"\n     * \"87273c5d-8501-88b6-8000-000000000000\"\n     * \"87273c5d-8502-88b6-8000-000000000000\"\n     * \"87273c5d-8503-88b6-8000-000000000000\"\n     * \"87273c5d-8504-88b6-8000-000000000000\"\n     * \"87273c5d-8505-88b6-8000-000000000000\"\n     * \"87273c5d-8506-88b6-8000-000000000000\"\n     * \"87273c5d-8507-88b6-8000-000000000000\"\n     * \"87273c5d-8508-88b6-8000-000000000000\"\n     * \"87273c5d-8509-88b6-8000-000000000000\"\n     */\n    @Test\n    void same_thread_generates_different_UuidGenerators() {\n        // Given/When\n        List<UUID> uuids = IntStream.rangeClosed(1, 10)\n                .mapToObj(i -> new IncrementingUuidGenerator().generateId())\n                .collect(Collectors.toList());\n\n        // Then\n        checkUuidProperties(uuids);\n    }\n\n    /**\n     * Example of values generated using different classloaders (same epochTime,\n     * same sessionId, different classloaderId, same counter value):\n     * \"87273a9d-9a00-8bf7-8000-000000000000\"\n     * \"87273a9d-9c00-844e-8000-000000000000\"\n     * \"87273a9d-9e00-89ad-8000-000000000000\"\n     * \"87273a9d-a000-8fd9-8000-000000000000\"\n     * \"87273a9d-a100-8a48-8000-000000000000\"\n     * \"87273a9d-a400-8322-8000-000000000000\"\n     * \"87273a9d-a600-872c-8000-000000000000\"\n     * \"87273a9d-a700-88c9-8000-000000000000\"\n     * \"87273a9d-a900-8eb4-8000-000000000000\"\n     * \"87273a9d-ab00-898c-8000-000000000000\"\n     */\n    @Test\n    void different_classloaders_generators() {\n        // Given/When\n        List<UUID> uuids = IntStream.rangeClosed(1, 10)\n                .mapToObj(i -> getUuidGeneratorFromOtherClassloader(i).generateId())\n                .collect(Collectors.toList());\n\n        // Then\n        checkUuidProperties(uuids);\n    }\n\n    @Test\n    void raises_exception_when_out_of_range() {\n        // Given\n        IncrementingUuidGenerator generator = new IncrementingUuidGenerator();\n        generator.counter.set(IncrementingUuidGenerator.MAX_COUNTER_VALUE - 1);\n\n        // When\n        CucumberException cucumberException = assertThrows(CucumberException.class, generator::generateId);\n\n        // Then\n        assertThat(cucumberException.getMessage(),\n            Matchers.containsString(\"Out of IncrementingUuidGenerator capacity\"));\n    }\n\n    @Test\n    void version_overflow() {\n        // Given\n        IncrementingUuidGenerator.sessionCounter.set(IncrementingUuidGenerator.MAX_SESSION_ID - 1);\n\n        // When\n        CucumberException cucumberException = assertThrows(CucumberException.class, IncrementingUuidGenerator::new);\n\n        // Then\n        assertThat(cucumberException.getMessage(),\n            Matchers.containsString(\"Out of IncrementingUuidGenerator capacity\"));\n    }\n\n    private static void checkUuidProperties(List<UUID> uuids) {\n        // all UUIDs are non-null\n        assertTrue(uuids.stream().filter(Objects::isNull).findFirst().isEmpty());\n\n        // UUID version is always 8\n        List<Integer> versions = uuids.stream().map(UUID::version).distinct().collect(Collectors.toList());\n        assertEquals(1, versions.size());\n        assertEquals(8, versions.get(0));\n\n        // UUID variants is always 2\n        List<Integer> variants = uuids.stream().map(UUID::variant).distinct().collect(Collectors.toList());\n        assertEquals(1, variants.size());\n        assertEquals(2, variants.get(0));\n\n        // all UUIDs are distinct\n        assertEquals(uuids.size(), uuids.stream().distinct().count());\n\n        // all UUIDs are ordered\n        assertEquals(uuids.stream()\n                .map(IncrementingUuidGeneratorTest::removeClassloaderId)\n                .collect(Collectors.toList()),\n            uuids.stream()\n                    .map(IncrementingUuidGeneratorTest::removeClassloaderId)\n                    .sorted()\n                    .collect(Collectors.toList()));\n    }\n\n    /**\n     * Create a copy of the UUID without the random part to allow comparison.\n     */\n    private static UUID removeClassloaderId(UUID uuid) {\n        return new UUID(uuid.getMostSignificantBits() & 0xfffffffffffff000L, uuid.getLeastSignificantBits());\n    }\n\n    /**\n     * Create a copy of the UUID without the epoch-time part to allow\n     * comparison.\n     */\n    private static UUID removeEpochTime(UUID uuid) {\n        return new UUID(uuid.getMostSignificantBits() & 0x0ffffffL, uuid.getLeastSignificantBits());\n    }\n\n    /**\n     * Check that classloaderId collision rate is lower than a given threshold\n     * when using multiple classloaders. This should not be mistaken with the\n     * UUID collision rate. Note: this test takes about 20 seconds.\n     */\n    @Test\n    void classloaderid_collision_rate_lower_than_two_percents_with_ten_classloaders()\n            throws NoSuchFieldException, IllegalAccessException {\n        double collisionRateWhenUsingTenClassloaders;\n        List<Double> collisionRatesWhenUsingTenClassloaders = new ArrayList<>();\n        do {\n            // When I compute the classloaderId collision rate with multiple\n            // classloaders\n            Set<Long> classloaderIds = new HashSet<>();\n            List<Integer> stats = new ArrayList<>();\n            while (stats.size() < 100) {\n                if (!classloaderIds\n                        .add(getStaticFieldValue(getUuidGeneratorFromOtherClassloader(null),\n                            CLASSLOADER_ID_FIELD_NAME))) {\n                    stats.add(classloaderIds.size() + 1);\n                    classloaderIds.clear();\n                }\n            }\n\n            // Then the classloaderId collision rate for 10 classloaders is less\n            // than 2%\n            collisionRateWhenUsingTenClassloaders = stats.stream()\n                    .filter(x -> x < 10).count() * 100 / (double) stats.size();\n            collisionRatesWhenUsingTenClassloaders.add(collisionRateWhenUsingTenClassloaders);\n        } while (collisionRateWhenUsingTenClassloaders > 2 && collisionRatesWhenUsingTenClassloaders.size() < 10);\n        assertTrue(collisionRateWhenUsingTenClassloaders <= 2,\n            \"all retries exceed the expected collision rate : \" + collisionRatesWhenUsingTenClassloaders);\n    }\n\n    @Test\n    void same_classloaderId_leads_to_same_uuid_when_ignoring_epoch_time() {\n        // Given the two generator have the same classloaderId\n        UuidGenerator generator1 = getUuidGeneratorFromOtherClassloader(255);\n        UuidGenerator generator2 = getUuidGeneratorFromOtherClassloader(255);\n\n        // When the UUID are generated\n        UUID uuid1 = generator1.generateId();\n        UUID uuid2 = generator2.generateId();\n\n        // Then the UUID are the same\n        assertEquals(removeEpochTime(uuid1), removeEpochTime(uuid2));\n    }\n\n    @Test\n    void different_classloaderId_leads_to_different_uuid_when_ignoring_epoch_time() {\n        // Given the two generator have the different classloaderId\n        UuidGenerator generator1 = getUuidGeneratorFromOtherClassloader(1);\n        UuidGenerator generator2 = getUuidGeneratorFromOtherClassloader(2);\n\n        // When the UUID are generated\n        UUID uuid1 = generator1.generateId();\n        UUID uuid2 = generator2.generateId();\n\n        // Then the UUID are the same\n        assertNotEquals(removeEpochTime(uuid1), removeEpochTime(uuid2));\n    }\n\n    @Test\n    void setClassloaderId_keeps_only_12_bits() throws NoSuchFieldException, IllegalAccessException {\n        // When the classloaderId is defined with a value higher than 0xfff (12\n        // bits)\n        IncrementingUuidGenerator.setClassloaderId(0xfffffABC);\n\n        // Then the classloaderId is truncated to 12 bits\n        assertEquals(0x0ABC, getStaticFieldValue(new IncrementingUuidGenerator(), CLASSLOADER_ID_FIELD_NAME));\n    }\n\n    @Test\n    void setClassloaderId_keeps_values_under_12_bits_unmodified() throws NoSuchFieldException, IllegalAccessException {\n        // When the classloaderId is defined with a value lower than 0xfff (12\n        // bits)\n        IncrementingUuidGenerator.setClassloaderId(0x0123);\n\n        // Then the classloaderId value is left unmodified\n        assertEquals(0x0123, getStaticFieldValue(new IncrementingUuidGenerator(), CLASSLOADER_ID_FIELD_NAME));\n    }\n\n    private Long getStaticFieldValue(UuidGenerator generator, String fieldName)\n            throws NoSuchFieldException, IllegalAccessException {\n        // The Field cannot be cached because the IncrementingUuidGenerator\n        // class is different at each call (because it was loaded by a\n        // different classloader).\n        Field declaredField = generator.getClass().getDeclaredField(fieldName);\n        declaredField.setAccessible(true);\n        return (Long) declaredField.get(null);\n    }\n\n    private static void setClassloaderId(Class<?> generatorClass, int value)\n            throws IllegalAccessException, NoSuchMethodException, InvocationTargetException {\n        // The Method cannot be cached because the IncrementingUuidGenerator\n        // class is different at each call (because it was loaded by a\n        // different classloader).\n        Method method = generatorClass.getDeclaredMethod(\"setClassloaderId\", int.class);\n        method.setAccessible(true);\n        method.invoke(null, value);\n    }\n\n    /**\n     * Create a fresh new IncrementingUuidGenerator from a fresh new\n     * classloader, and return a new instance.\n     * \n     * @param  classloaderId the classloader unique identifier, or null if the\n     *                       default classloader id generator must be used\n     * @return               a new IncrementingUuidGenerator instance\n     */\n    private static UuidGenerator getUuidGeneratorFromOtherClassloader(Integer classloaderId) {\n        try {\n            Class<?> aClass = new NonCachingClassLoader().findClass(IncrementingUuidGenerator.class.getName());\n            if (classloaderId != null) {\n                setClassloaderId(aClass, classloaderId);\n            }\n            return (UuidGenerator) aClass.getConstructor().newInstance();\n        } catch (Exception e) {\n            throw new RuntimeException(\"could not instantiate \" + IncrementingUuidGenerator.class.getSimpleName(), e);\n        }\n    }\n\n    /**\n     * A classloader which does not cache the class definition. Thus, when the\n     * Class loaded using #findClass will have different static fields.\n     */\n    private static class NonCachingClassLoader extends ClassLoader {\n\n        public NonCachingClassLoader() {\n        }\n\n        @Override\n        protected Class<?> findClass(String name) {\n            byte[] classBytes = loadClassBytesFromDisk(name);\n            return defineClass(name, classBytes, 0, classBytes.length);\n        }\n\n        private byte[] loadClassBytesFromDisk(String className) {\n            try {\n                return Files.readAllBytes(Path.of(Objects.requireNonNull(NonCachingClassLoader.class\n                        .getResource(className.replaceFirst(\".+\\\\.\", \"\") + \".class\")).toURI()));\n            } catch (IOException e) {\n                throw new RuntimeException(\"Unable to read file from disk\");\n            } catch (URISyntaxException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}"
