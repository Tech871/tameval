[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "kmbhm1/supabase-pydantic"
sha = "0a62448b7c42eef16ec885ccedaebe42a51f9fbf"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r requirements.txt && (pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=supabase_pydantic/util/sorting.py -m pytest -q --junit-xml=test_output.xml tests/unit/test_sorting.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target supabase_pydantic.util.sorting --unit-test tests.unit.test_sorting --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target supabase_pydantic/util/sorting.py --unit-test tests/unit/test_sorting.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 95.0
original_coverage = 95.0
mutation_kill_rate = 89.0
original_mutation_kill_rate = 89.0
covered_lines = [ 0, 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 14, 16, 19, 21, 23, 32, 33, 34, 35, 40, 42, 43, 44, 47, 50, 51, 53, 54, 56, 59, 61, 62, 64, 65, 66, 67, 68, 70, 73, 75, 76, 79, 81, 82, 83, 84, 85, 88, 90, 91, 94, 96, 97, 99, 102, 104, 105, 107, 108, 109, 110, 111, 113, 114, 116, 118, 121, 123, 124, 125, 126, 128, 131, 133, 134, 136, 137, 138, 139, 140, 142, 144, 147, 149, 152, 154, 155, 158, 160, 161, 162, 163, 166, 169, 171, 172, 176, 177, 178, 179, 180, 181, 184, 185, 186, 190, 192, 197, 198, 207, 208, 209, 210, 211, 213, 214, 215, 216, 217, 218, 220, 224, 225, 226, 227, 230, 232, 235, 237, 238, 239, 241, 243, 244, 245, 246, 247, 249, 251, 252, 256, 262, 266, 269, 271, 272, 274, 276, 279, 281, 282, 283, 287, 288, 289, 292, 293, 294, 297, 301, 302, 306, 315, 316, 318, 319, 322, 323, 326, 329, 331,]
missed_lines = [ 28, 31, 36, 37, 253, 254, 263, 284, 285, 298,]

[input_info]
test_file_path = "tests/unit/test_sorting.py"
focal_file_path = "supabase_pydantic/util/sorting.py"
test_file_url = "https://github.com/kmbhm1/supabase-pydantic/blob/0a62448b7c42eef16ec885ccedaebe42a51f9fbf/tests/unit/test_sorting.py"
focal_file_url = "https://github.com/kmbhm1/supabase-pydantic/blob/0a62448b7c42eef16ec885ccedaebe42a51f9fbf/supabase_pydantic/util/sorting.py"
first_commit_date = "2024-07-19"
last_commit_date = "2025-05-22"
test_file_content = "import subprocess\nfrom math import inf\nfrom unittest.mock import Mock, patch\n\nimport pytest\n\nfrom supabase_pydantic.util.constants import RelationType\nfrom supabase_pydantic.util.dataclasses import ColumnInfo, ConstraintInfo, ForeignKeyInfo, RelationshipInfo, TableInfo\nfrom supabase_pydantic.util.sorting import (\n    build_dependency_graph,\n    format_with_ruff,\n    generate_seed_data,\n    pick_random_foreign_key,\n    reorganize_tables_by_relationships,\n    separate_tables_list_by_type,\n    sort_tables_by_in_degree,\n    sort_tables_for_insert,\n    topological_sort,\n    total_possible_combinations,\n    unique_data_rows,\n)\n\n\ndef test_format_with_ruff_failure_fails_silently(mocker, capsys):\n    \"\"\"Test run_isort handles CalledProcessError correctly.\"\"\"\n    error_output = 'An error occurred'\n    mocker.patch('subprocess.run', side_effect=subprocess.CalledProcessError(1, 'isort', stderr=error_output))\n\n    format_with_ruff('non_existent_file.py')\n    out, err = capsys.readouterr()\n    assert error_output in out\n    assert error_output not in err\n\n\ndef test_build_dependency_graph():\n    table_a = TableInfo(name='A')\n    table_b = TableInfo(\n        name='B',\n        foreign_keys=[\n            ForeignKeyInfo(foreign_table_name='A', constraint_name='foo', column_name='id', foreign_column_name='baz')\n        ],\n    )\n    table_c = TableInfo(\n        name='C',\n        foreign_keys=[\n            ForeignKeyInfo(foreign_table_name='B', constraint_name='foo', column_name='id', foreign_column_name='baz')\n        ],\n    )\n    table_d = TableInfo(\n        name='D',\n        foreign_keys=[\n            ForeignKeyInfo(foreign_table_name='A', constraint_name='foo', column_name='id', foreign_column_name='baz')\n        ],\n    )\n\n    tables = [table_a, table_b, table_c, table_d]\n\n    graph, in_degree = build_dependency_graph(tables)\n\n    expected_graph = {'A': ['B', 'D'], 'B': ['C']}\n\n    expected_in_degree = {'A': 0, 'B': 1, 'C': 1, 'D': 1}\n\n    assert graph == expected_graph\n    assert in_degree == expected_in_degree\n\n\ndef test_topological_sort():\n    table_a = TableInfo(name='A')\n    table_b = TableInfo(\n        name='B',\n        foreign_keys=[\n            ForeignKeyInfo(foreign_table_name='A', constraint_name='foo', column_name='id', foreign_column_name='baz')\n        ],\n    )\n    table_c = TableInfo(\n        name='C',\n        foreign_keys=[\n            ForeignKeyInfo(foreign_table_name='B', constraint_name='foo', column_name='id', foreign_column_name='baz')\n        ],\n    )\n    table_d = TableInfo(\n        name='D',\n        foreign_keys=[\n            ForeignKeyInfo(foreign_table_name='A', constraint_name='foo', column_name='id', foreign_column_name='baz')\n        ],\n    )\n\n    tables = [table_a, table_b, table_c, table_d]\n\n    in_degree, graph = topological_sort(tables)\n\n    expected_graph = {'A': ['B', 'D'], 'B': ['C']}\n\n    expected_in_degree = {'A': 0, 'B': 1, 'C': 1, 'D': 1}\n\n    assert graph == expected_graph\n    assert in_degree == expected_in_degree\n\n\ndef test_sort_tables_by_in_degree():\n    in_degree = {'A': 0, 'B': 1, 'C': 2, 'D': 1}\n\n    sorted_tables = sort_tables_by_in_degree(in_degree)\n\n    expected_sorted_tables = ['A', 'B', 'D', 'C']\n\n    assert sorted_tables == expected_sorted_tables\n\n\ndef test_reorganize_tables_by_relationships_no_reordering_needed():\n    sorted_tables = ['A', 'B', 'C']\n    relationships = [\n        RelationshipInfo(table_name='B', related_table_name='A', relation_type=RelationType.ONE_TO_MANY),\n        RelationshipInfo(table_name='C', related_table_name='B', relation_type=RelationType.ONE_TO_ONE),\n    ]\n\n    result = reorganize_tables_by_relationships(sorted_tables, relationships)\n\n    # No reordering needed because foreign tables are already before the dependent tables\n    expected_result = ['A', 'B', 'C']\n    assert result == expected_result\n\n\ndef test_reorganize_tables_by_relationships_reordering_needed():\n    sorted_tables = ['A', 'B', 'C']\n    relationships = [\n        RelationshipInfo(table_name='A', related_table_name='B', relation_type=RelationType.ONE_TO_MANY),\n        RelationshipInfo(table_name='B', related_table_name='C', relation_type=RelationType.ONE_TO_ONE),\n    ]\n\n    result = reorganize_tables_by_relationships(sorted_tables, relationships)\n\n    # Reordering needed: \"C\" should come before \"B\" and \"B\" before \"A\"\n    expected_result = ['C', 'B', 'A']\n    assert result == expected_result\n\n\ndef test_reorganize_tables_by_relationships_many_to_many_ignored():\n    sorted_tables = ['A', 'B', 'C']\n    relationships = [\n        RelationshipInfo(table_name='A', related_table_name='B', relation_type=RelationType.MANY_TO_MANY),\n        RelationshipInfo(table_name='B', related_table_name='C', relation_type=RelationType.ONE_TO_ONE),\n    ]\n\n    result = reorganize_tables_by_relationships(sorted_tables, relationships)\n\n    # MANY_TO_MANY relationship should be ignored, so no reordering based on A-B\n    expected_result = ['A', 'C', 'B']\n    assert result == expected_result\n\n\ndef test_reorganize_tables_by_relationships_complex_case():\n    sorted_tables = ['A', 'B', 'C', 'D']\n    relationships = [\n        RelationshipInfo(table_name='B', related_table_name='A', relation_type=RelationType.ONE_TO_ONE),\n        RelationshipInfo(table_name='C', related_table_name='B', relation_type=RelationType.ONE_TO_ONE),\n        RelationshipInfo(table_name='D', related_table_name='A', relation_type=RelationType.ONE_TO_ONE),\n    ]\n\n    result = reorganize_tables_by_relationships(sorted_tables, relationships)\n\n    # Expected reordering based on relationships\n    expected_result = ['A', 'B', 'C', 'D']\n    assert result == expected_result\n\n\ndef test_separate_tables_list_by_type_mixed():\n    tables = [\n        TableInfo(name='A', table_type='BASE_TABLE'),\n        TableInfo(name='B', table_type='VIEW'),\n        TableInfo(name='C', table_type='BASE_TABLE'),\n        TableInfo(name='D', table_type='VIEW'),\n    ]\n    table_list = ['A', 'B', 'C', 'D']\n\n    base_tables, views = separate_tables_list_by_type(tables, table_list)\n\n    assert base_tables == ['A', 'C']\n    assert views == ['B', 'D']\n\n\ndef test_separate_tables_list_by_type_all_views():\n    tables = [TableInfo(name='A', table_type='VIEW'), TableInfo(name='B', table_type='VIEW')]\n    table_list = ['A', 'B']\n\n    base_tables, views = separate_tables_list_by_type(tables, table_list)\n\n    assert base_tables == []\n    assert views == ['A', 'B']\n\n\ndef test_separate_tables_list_by_type_all_base_tables():\n    tables = [TableInfo(name='A', table_type='BASE_TABLE'), TableInfo(name='B', table_type='BASE_TABLE')]\n    table_list = ['A', 'B']\n\n    base_tables, views = separate_tables_list_by_type(tables, table_list)\n\n    assert base_tables == ['A', 'B']\n    assert views == []\n\n\ndef test_separate_tables_list_by_type_table_not_found():\n    tables = [TableInfo(name='A', table_type='BASE_TABLE'), TableInfo(name='B', table_type='VIEW')]\n    table_list = ['A', 'B', 'C']  # \"C\" is not in tables\n\n    base_tables, views = separate_tables_list_by_type(tables, table_list)\n\n    assert base_tables == ['A']\n    assert views == ['B']\n\n\ndef test_sort_tables_for_insert_simple():\n    tables = [\n        TableInfo(name='A', table_type='BASE_TABLE'),\n        TableInfo(\n            name='B',\n            table_type='BASE_TABLE',\n            foreign_keys=[\n                ForeignKeyInfo(\n                    foreign_table_name='A', constraint_name='foo', column_name='id', foreign_column_name='baz'\n                )\n            ],\n        ),\n        TableInfo(\n            name='C',\n            table_type='BASE_TABLE',\n            foreign_keys=[\n                ForeignKeyInfo(\n                    foreign_table_name='B', constraint_name='foo', column_name='id', foreign_column_name='baz'\n                )\n            ],\n        ),\n        TableInfo(name='D', table_type='VIEW'),\n    ]\n\n    base_tables, views = sort_tables_for_insert(tables)\n\n    # \"C\" depends on \"B\", and \"B\" depends on \"A\", so the order should be A, B, C\n    assert base_tables == ['A', 'B', 'C']\n    assert views == ['D']\n\n\ndef test_sort_tables_for_insert_complex():\n    tables = [\n        TableInfo(name='A', table_type='BASE_TABLE'),\n        TableInfo(\n            name='B',\n            table_type='BASE_TABLE',\n            foreign_keys=[\n                ForeignKeyInfo(\n                    foreign_table_name='A', constraint_name='foo', column_name='id', foreign_column_name='baz'\n                )\n            ],\n        ),\n        TableInfo(\n            name='C',\n            table_type='BASE_TABLE',\n            foreign_keys=[\n                ForeignKeyInfo(\n                    foreign_table_name='B', constraint_name='foo', column_name='id', foreign_column_name='baz'\n                )\n            ],\n        ),\n        TableInfo(\n            name='D',\n            table_type='BASE_TABLE',\n            relationships=[\n                RelationshipInfo(table_name='D', related_table_name='A', relation_type=RelationType.ONE_TO_ONE)\n            ],\n        ),\n        TableInfo(name='E', table_type='VIEW'),\n    ]\n\n    base_tables, views = sort_tables_for_insert(tables)\n\n    # Expected order should consider foreign keys and relationships\n    assert base_tables == ['A', 'D', 'B', 'C']\n    assert views == ['E']\n\n\n# Test case for generate_seed_data\n@patch('random.random', return_value=0.5)  # Control the number of rows\n@patch('random.choice', side_effect=lambda x: x[0])  # Control choice function\n@patch(\n    'supabase_pydantic.util.fake.generate_fake_data',\n    side_effect=lambda datatype, nullable, max_length, name: f'fake_{name}',\n)\ndef test_generate_seed_data(mock_generate_fake_data, mock_choice, mock_random):\n    # Define the columns and foreign keys\n    columns_a = [\n        ColumnInfo(name='id', post_gres_datatype='integer', datatype='int4', primary=True),\n        ColumnInfo(name='name', post_gres_datatype='text', datatype='str', is_unique=False),\n    ]\n\n    columns_b = [\n        ColumnInfo(name='id', post_gres_datatype='integer', datatype='int4', primary=True),\n        ColumnInfo(name='a_id', post_gres_datatype='integer', datatype='int4', is_foreign_key=True),\n    ]\n\n    foreign_keys_b = [\n        ForeignKeyInfo(column_name='a_id', foreign_table_name='A', foreign_column_name='id', constraint_name='foo')\n    ]\n\n    # Define the tables\n    table_a = TableInfo(name='A', columns=columns_a)\n    table_b = TableInfo(name='B', columns=columns_b, foreign_keys=foreign_keys_b)\n\n    tables = [table_a, table_b]\n\n    # Call the function\n    seed_data = generate_seed_data(tables)\n\n    # Expected seed data structure\n    expected_seed_data = {\n        'A': [['id', 'name'], ['fake_id', 'fake_name'], ['fake_id', 'fake_name']],\n        'B': [['id', 'a_id'], ['fake_id', 'fake_id'], ['fake_id', 'fake_id']],\n    }\n\n    # assert seed_data == expected_seed_data\n    assert seed_data.keys() == expected_seed_data.keys()\n    assert seed_data['A'][0] == expected_seed_data['A'][0]\n    assert seed_data['B'][0] == expected_seed_data['B'][0]\n\n    for i in range(1, len(seed_data['A'])):\n        assert str(seed_data['A'][i][0]).isnumeric() or seed_data['A'][i][0] == 'NULL'\n        assert str(seed_data['A'][i][1]).isalpha or seed_data['A'][i][0] == 'NULL'\n\n    for i in range(1, len(seed_data['B'])):\n        assert str(seed_data['B'][i][0]).isnumeric() or seed_data['B'][i][0] == 'NULL'\n        assert str(seed_data['B'][i][1]).isnumeric() or seed_data['B'][i][1] == 'NULL'\n\n\n@pytest.fixture\ndef table_with_unique_columns():\n    return TableInfo(\n        name='C',\n        columns=[\n            ColumnInfo(\n                name='id',\n                user_defined_values=['1', '2', '3'],\n                is_unique=True,\n                datatype='int4',\n                post_gres_datatype='integer',\n            ),\n            ColumnInfo(\n                name='type', user_defined_values=['A', 'B'], is_unique=True, datatype='str', post_gres_datatype='text'\n            ),\n        ],\n    )\n\n\n@pytest.fixture\ndef table_with_infinite_possible_values():\n    return TableInfo(\n        name='A',\n        columns=[\n            ColumnInfo(\n                name='id', user_defined_values=None, is_unique=True, datatype='int4', post_gres_datatype='integer'\n            ),\n        ],\n    )\n\n\n@pytest.fixture\ndef table_with_no_unique_constraints():\n    return TableInfo(\n        name='B',\n        columns=[\n            ColumnInfo(\n                name='id',\n                user_defined_values=['1', '2', '3'],\n                is_unique=False,\n                datatype='int4',\n                post_gres_datatype='integer',\n            )\n        ],\n    )\n\n\n# Test for pick_random_foreign_key\ndef test_pick_random_foreign_key():\n    # Mock the remember_fn\n    remember_fn = Mock()\n\n    # Create mock foreign key info\n    fk_info = ForeignKeyInfo(\n        constraint_name='fk_constraint',\n        column_name='fk_column',\n        foreign_table_name='foreign_table',\n        foreign_column_name='foreign_column',\n        foreign_table_schema='public',\n    )\n    table_info = TableInfo(name='table', foreign_keys=[fk_info])\n\n    # Set up the remember_fn to return a list of values for the foreign key\n    remember_fn.return_value = {1, 2, 3, 4}\n\n    # Test that a valid foreign key value is returned\n    result = pick_random_foreign_key('fk_column', table_info, remember_fn)\n    assert result in {1, 2, 3, 4}, 'Expected one of the foreign key values to be returned'\n\n    # Test for a column without a foreign key\n    result = pick_random_foreign_key('non_existing_column', table_info, remember_fn)\n    assert result == 'NULL', \"Expected 'NULL' when no foreign key is found\"\n\n    # Test when remember_fn raises KeyError\n    remember_fn.side_effect = KeyError\n    result = pick_random_foreign_key('fk_column', table_info, remember_fn)\n    assert result == 'NULL', \"Expected 'NULL' when remember_fn raises KeyError\"\n\n\n# Test for total_possible_combinations\ndef test_total_possible_combinations():\n    # Test case where table has unique constraint with user-defined values\n    column_info_1 = ColumnInfo(\n        name='id', is_unique=True, user_defined_values=[1, 2, 3], datatype='int4', post_gres_datatype='integer'\n    )\n    column_info_2 = ColumnInfo(\n        name='type', datatype='str', post_gres_datatype='text', is_unique=True, user_defined_values=['a', 'b']\n    )\n    constraint = ConstraintInfo(raw_constraint_type='u', constraint_name='unique_constraint', constraint_definition='')\n    table_info = TableInfo(name='table', columns=[column_info_1, column_info_2], constraints=[constraint])\n\n    result = total_possible_combinations(table_info)\n    expected = float(3 * 2)  # 3 options for column 1, 2 options for column 2\n    assert result == expected, f'Expected {expected} but got {result}'\n\n    # Test case where table has a unique constraint but no user-defined values\n    column_info_3 = ColumnInfo(name='foo', is_unique=True, datatype='int4', post_gres_datatype='integer')\n    table_info_no_values = TableInfo(name='test', columns=[column_info_3])\n\n    result = total_possible_combinations(table_info_no_values)\n    assert result == inf, \"Expected 'inf' when a unique column has no user-defined values\"\n\n    # Test case where table has no unique constraint\n    column_info_4 = ColumnInfo(name='bar', is_unique=False, datatype='int4', post_gres_datatype='integer')\n    table_info_no_unique = TableInfo(name='test', columns=[column_info_4])\n\n    result = total_possible_combinations(table_info_no_unique)\n    assert result == inf, \"Expected 'inf' when the table has no unique constraint\"\n\n\ndef test_unique_data_rows_no_unique_constraints():\n    table = TableInfo(\n        name='test_table',\n        columns=[ColumnInfo(name='id', datatype='int4', post_gres_datatype='integer', is_unique=False)],\n        constraints=[],\n    )\n    result = unique_data_rows(table, remember_fn=Mock())\n    assert result == []\n\n\ndef test_unique_data_rows_finite_combinations():\n    table = TableInfo(\n        name='test_table',\n        columns=[\n            ColumnInfo(\n                name='id',\n                datatype='int4',\n                post_gres_datatype='integer',\n                is_unique=True,\n                user_defined_values=['1', '2', '3'],\n            ),\n            ColumnInfo(\n                name='name',\n                datatype='str',\n                post_gres_datatype='text',\n                is_unique=True,\n                user_defined_values=['Alice', 'Bob'],\n            ),\n        ],\n        constraints=[\n            ConstraintInfo(\n                raw_constraint_type='u',\n                constraint_name='unique_constraint',\n                constraint_definition='',\n                columns=['id', 'name'],\n            )\n        ],\n    )\n    result = unique_data_rows(table, remember_fn=Mock())\n    assert len(result) == 6  # Since there are 6 possible unique combinations\n\n\ndef test_unique_data_rows_infinite_combinations():\n    table = TableInfo(\n        name='test_table',\n        columns=[\n            ColumnInfo(\n                name='id', datatype='int4', post_gres_datatype='integer', is_unique=True, user_defined_values=[]\n            ),\n            ColumnInfo(name='name', datatype='str', post_gres_datatype='text', is_unique=True, user_defined_values=[]),\n        ],\n        constraints=[\n            ConstraintInfo(\n                raw_constraint_type='u',\n                constraint_name='unique_constraint',\n                constraint_definition='',\n                columns=['id', 'name'],\n            )\n        ],\n    )\n    result = unique_data_rows(table, remember_fn=Mock())\n    assert len(result) > 0  # Should generate some rows even with infinite possibilities\n\n\ndef test_unique_data_rows_with_foreign_keys():\n    table = TableInfo(\n        name='test_table',\n        columns=[\n            ColumnInfo(name='id', datatype='int4', post_gres_datatype='integer', is_unique=True, is_foreign_key=True),\n            ColumnInfo(\n                name='name',\n                datatype='str',\n                post_gres_datatype='text',\n                is_unique=True,\n                user_defined_values=['Alice', 'Bob'],\n            ),\n        ],\n        constraints=[\n            ConstraintInfo(\n                raw_constraint_type='u',\n                constraint_name='unique_constraint',\n                constraint_definition='',\n                columns=['id', 'name'],\n            )\n        ],\n    )\n    with patch('supabase_pydantic.util.sorting.pick_random_foreign_key', return_value=1):\n        result = unique_data_rows(table, remember_fn=Mock())\n    assert len(result) == 2  # Should generate 2 rows, one for each name\n"
