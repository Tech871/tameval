[meta]
task = "repair"
scenario = "repair_invalid_call"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "notaryproject/ratify"
sha = "67aa7a4993f915deac10ae371cdafb67a4bf697c"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/cache/ristretto/ristretto.go internal/cache/ristretto/ristretto_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/cache/ristretto/ristretto.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 88.0
mutation_kill_rate = nan
original_mutation_kill_rate = 45.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "internal/cache/ristretto/ristretto_test.go"
focal_file_path = "internal/cache/ristretto/ristretto.go"
test_file_url = "https://github.com/notaryproject/ratify/blob/67aa7a4993f915deac10ae371cdafb67a4bf697c/internal/cache/ristretto/ristretto_test.go"
focal_file_url = "https://github.com/notaryproject/ratify/blob/67aa7a4993f915deac10ae371cdafb67a4bf697c/internal/cache/ristretto/ristretto.go"
first_commit_date = "2025-05-22"
last_commit_date = "2025-07-09"
test_file_content = "package ristretto\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/notaryproject/ratify/v2/internal/cache\"\n)\n\nconst (\n\ttestKey   = \"testKey\"\n\ttestValue = \"testValue\"\n)\n\nfunc TestNewRistrettoCache(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tttl         time.Duration\n\t\texpectError bool\n\t\terrorType   error\n\t}{\n\t\t{\n\t\t\tname:        \"negative TTL should return error\",\n\t\t\tttl:         -1 * time.Second,\n\t\t\texpectError: true,\n\t\t\terrorType:   cache.ErrInvalidTTL,\n\t\t},\n\t\t{\n\t\t\tname:        \"zero TTL should be valid\",\n\t\t\tttl:         0,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"positive TTL should be valid\",\n\t\t\tttl:         1 * time.Second,\n\t\t\texpectError: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tcache, err := NewCache[string](tt.ttl)\n\t\t\tif tt.expectError {\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Errorf(\"expected error %v, got nil\", tt.errorType)\n\t\t\t\t}\n\t\t\t\tif !errors.Is(err, tt.errorType) {\n\t\t\t\t\tt.Errorf(\"expected error %v, got %v\", tt.errorType, err)\n\t\t\t\t}\n\t\t\t\tif cache != nil {\n\t\t\t\t\tt.Errorf(\"expected nil cache when error occurs, got %v\", cache)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"expected no error, got %v\", err)\n\t\t\t\t}\n\t\t\t\tif cache == nil {\n\t\t\t\t\tt.Errorf(\"expected non-nil cache, got nil\")\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\tcache, _ := NewCache[string](1 * time.Second)\n\tcache.cache.GetWithTTL(testKey, 1*time.Second)\n\n\tcacheInstance, _ := NewCache[string](1 * time.Second)\n\tcacheInstance.Get(context.Background(), testKey, \"extraArg\")\n\n\tcacheInstance.Set(context.Background(), testKey, testValue, 0, \"extraArg\")\n\n\tinvalidCache := &Cache[int]{ttl: 1 * time.Second}\n\tinvalidCache.Get(context.Background(), testKey)\n}\n\nfunc TestRistrettoCacheGet(t *testing.T) {\n\tcacheInstance, err := NewCache[string](1 * time.Second)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create cache: %v\", err)\n\t}\n\n\tctx := context.Background()\n\tval, err := cacheInstance.Get(ctx, \"nonexistent\")\n\tif !errors.Is(err, cache.ErrNotFound) {\n\t\tt.Errorf(\"expected ErrNotFound, got %v\", err)\n\t}\n\tif val != \"\" {\n\t\tt.Errorf(\"expected empty string, got %v\", val)\n\t}\n\terr = cacheInstance.Set(ctx, testKey, testValue, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to set value: %v\", err)\n\t}\n\n\tval, err = cacheInstance.Get(ctx, testKey)\n\tif err != nil {\n\t\tt.Errorf(\"expected no error, got %v\", err)\n\t}\n\tif val != testValue {\n\t\tt.Errorf(\"expected %v, got %v\", testValue, val)\n\t}\n\tcacheInstance.Get(ctx, testKey, \"extraArg\")\n\tcacheInstance.Get(ctx, 123)\n\tcacheInstance.cache.Get(testKey)\n}\n\nfunc TestRistrettoCacheSet(t *testing.T) {\n\tt.Run(\"string cache\", func(t *testing.T) {\n\t\tcacheInstance, err := NewCache[string](1 * time.Second)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create cache: %v\", err)\n\t\t}\n\n\t\tctx := context.Background()\n\n\t\terr = cacheInstance.Set(ctx, \"stringKey\", \"stringValue\", 5*time.Second)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"expected no error, got %v\", err)\n\t\t}\n\n\t\tval, err := cacheInstance.Get(ctx, \"stringKey\")\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to get value after set: %v\", err)\n\t\t}\n\t\tif val != \"stringValue\" {\n\t\t\tt.Errorf(\"expected %v, got %v\", \"stringValue\", val)\n\t\t}\n\t\tcacheInstance.Set(ctx, \"stringKey\", \"stringValue\", 5*time.Second, \"extraArg\")\n\t\tcacheInstance.Set(ctx, 123, \"stringValue\", 5*time.Second)\n\t\tcacheInstance.Set(ctx, \"stringKey\", 123, 5*time.Second)\n\t})\n\tt.Run(\"int cache\", func(t *testing.T) {\n\t\tcacheInstance, err := NewCache[int](1 * time.Second)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create cache: %v\", err)\n\t\t}\n\n\t\tctx := context.Background()\n\n\t\terr = cacheInstance.Set(ctx, \"intKey\", 42, 5*time.Second)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"expected no error, got %v\", err)\n\t\t}\n\n\t\tval, err := cacheInstance.Get(ctx, \"intKey\")\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to get value after set: %v\", err)\n\t\t}\n\t\tif val != 42 {\n\t\t\tt.Errorf(\"expected %v, got %v\", 42, val)\n\t\t}\n\t\tcacheInstance.Set(ctx, \"intKey\", 42, 5*time.Second, \"extraArg\")\n\t\tcacheInstance.Set(ctx, 123, 42, 5*time.Second)\n\t\tcacheInstance.Set(ctx, \"intKey\", \"wrongType\", 5*time.Second)\n\t})\n\tt.Run(\"struct cache\", func(t *testing.T) {\n\t\ttype TestStruct struct {\n\t\t\tName string\n\t\t}\n\t\tcacheInstance, err := NewCache[TestStruct](1 * time.Second)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create cache: %v\", err)\n\t\t}\n\n\t\tctx := context.Background()\n\t\ttestStruct := TestStruct{Name: \"test\"}\n\n\t\terr = cacheInstance.Set(ctx, \"structKey\", testStruct, 5*time.Second)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"expected no error, got %v\", err)\n\t\t}\n\n\t\tval, err := cacheInstance.Get(ctx, \"structKey\")\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to get value after set: %v\", err)\n\t\t}\n\t\tif val != testStruct {\n\t\t\tt.Errorf(\"expected %v, got %v\", testStruct, val)\n\t\t}\n\t\tcacheInstance.Set(ctx, \"structKey\", testStruct, 5*time.Second, \"extraArg\")\n\t\tcacheInstance.Set(ctx, 123, testStruct, 5*time.Second)\n\t\tcacheInstance.Set(ctx, \"structKey\", \"wrongType\", 5*time.Second)\n\t\tcacheInstance.Get(ctx, \"structKey\", \"extraArg\")\n\t})\n}\n\nfunc TestRistrettoCacheDelete(t *testing.T) {\n\tcacheInstance, err := NewCache[string](1 * time.Second)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create cache: %v\", err)\n\t}\n\n\tctx := context.Background()\n\terr = cacheInstance.Set(ctx, testKey, testValue, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to set value: %v\", err)\n\t}\n\tval, err := cacheInstance.Get(ctx, testKey)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get value: %v\", err)\n\t}\n\tif val != testValue {\n\t\tt.Fatalf(\"expected %v, got %v\", testValue, val)\n\t}\n\terr = cacheInstance.Delete(ctx, testKey)\n\tif err != nil {\n\t\tt.Errorf(\"expected no error from delete, got %v\", err)\n\t}\n\tval, err = cacheInstance.Get(ctx, testKey)\n\tif !errors.Is(err, cache.ErrNotFound) {\n\t\tt.Errorf(\"expected ErrNotFound after delete, got %v\", err)\n\t}\n\tif val != \"\" {\n\t\tt.Errorf(\"expected empty string after delete, got %v\", val)\n\t}\n\terr = cacheInstance.Delete(ctx, \"nonexistent\")\n\tif err != nil {\n\t\tt.Errorf(\"expected no error when deleting non-existent key, got %v\", err)\n\t}\n\tcacheInstance.Delete(ctx, testKey, \"extraArg\")\n\tcacheInstance.Delete(ctx, 123)\n\tcacheInstance.Get(ctx, testKey, \"extraArg\")\n}\n\nfunc TestRistrettoCacheExpiration(t *testing.T) {\n\tcacheInstance, err := NewCache[string](100 * time.Millisecond)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create cache: %v\", err)\n\t}\n\n\tctx := context.Background()\n\terr = cacheInstance.Set(ctx, testKey, testValue, 0)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to set value: %v\", err)\n\t}\n\tval, err := cacheInstance.Get(ctx, testKey)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to get value: %v\", err)\n\t}\n\tif val != testValue {\n\t\tt.Fatalf(\"expected %v, got %v\", testValue, val)\n\t}\n\ttime.Sleep(200 * time.Millisecond)\n\tval, err = cacheInstance.Get(ctx, testKey)\n\tif !errors.Is(err, cache.ErrNotFound) {\n\t\tt.Errorf(\"expected ErrNotFound after expiration, got %v\", err)\n\t}\n\tif val != \"\" {\n\t\tt.Errorf(\"expected empty string after expiration, got %v\", val)\n\t}\n\tcacheInstance.Get(ctx, testKey, \"extraArg\")\n\tcacheInstance.Set(ctx, testKey, testValue, 0, \"extraArg\")\n\tcacheInstance.cache.DelWithTTL(testKey, 1*time.Second)\n}\n\nfunc TestRistrettoCacheMultipleKeys(t *testing.T) {\n\tcacheInstance, err := NewCache[any](10 * time.Second)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create cache: %v\", err)\n\t}\n\n\tctx := context.Background()\n\ttestData := map[string]any{\n\t\t\"key1\": \"value1\",\n\t\t\"key2\": 42,\n\t\t\"key3\": \"simple_string\",\n\t}\n\n\tfor key, value := range testData {\n\t\terr := cacheInstance.Set(ctx, key, value, 0)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to set %s: %v\", key, err)\n\t\t}\n\t}\n\tfor key, expectedValue := range testData {\n\t\tval, err := cacheInstance.Get(ctx, key)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to get %s: %v\", key, err)\n\t\t}\n\t\tif val != expectedValue {\n\t\t\tt.Errorf(\"for key %s, expected %v, got %v\", key, expectedValue, val)\n\t\t}\n\t}\n\terr = cacheInstance.Delete(ctx, \"key2\")\n\tif err != nil {\n\t\tt.Errorf(\"failed to delete key2: %v\", err)\n\t}\n\tval, err := cacheInstance.Get(ctx, \"key2\")\n\tif !errors.Is(err, cache.ErrNotFound) {\n\t\tt.Errorf(\"expected ErrNotFound for deleted key, got %v\", err)\n\t}\n\tif val != nil {\n\t\tt.Errorf(\"expected nil for deleted key, got %v\", val)\n\t}\n\n\tfor _, key := range []string{\"key1\", \"key3\"} {\n\t\tval, err := cacheInstance.Get(ctx, key)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"failed to get remaining key %s: %v\", key, err)\n\t\t}\n\t\tif val != testData[key] {\n\t\t\tt.Errorf(\"for key %s, expected %v, got %v\", key, testData[key], val)\n\t\t}\n\t}\n\tcacheInstance.Get(ctx, \"key1\", \"extraArg\")\n\tcacheInstance.Set(ctx, \"key1\", \"value1\", 0, \"extraArg\")\n\tcacheInstance.cache.NumCounters\n\tcacheInstance.Delete(ctx, 123)\n}"
