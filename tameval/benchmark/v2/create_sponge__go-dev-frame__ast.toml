[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.23.0"

[repo_info]
repository = "go-dev-frame/sponge"
sha = "e72bb7443479d95928a16711696af6523999a717"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/goast/ast.go pkg/goast/ast_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/goast/ast.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 77.0
original_coverage = 77.0
mutation_kill_rate = 34.0
original_mutation_kill_rate = 34.0
covered_lines = [ 63, 64, 65, 72, 73, 74, 78, 82, 83, 84, 85, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 106, 107, 108, 114, 117, 120, 121, 122, 123, 124, 125, 126, 129, 130, 131, 132, 135, 140, 141, 142, 143, 144, 145, 146, 152, 153, 154, 155, 156, 157, 158, 161, 162, 163, 166, 167, 171, 172, 176, 179, 184, 185, 186, 187, 188, 189, 190, 193, 194, 195, 196, 197, 198, 199, 204, 207, 208, 209, 210, 211, 212, 213, 214, 216, 217, 218, 219, 220, 222, 223, 224, 225, 226, 228, 229, 230, 231, 232, 234, 239, 240, 241, 242, 243, 248, 252, 253, 254, 255, 262, 273, 274, 279, 280, 281, 282, 283, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 301, 302, 303, 304, 305, 308, 309, 310, 311, 312, 313, 314, 315, 319, 330, 331, 336, 337, 338, 339, 340, 345, 346, 347, 348, 349, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 367, 368, 369, 370, 371, 372, 373, 374, 377, 378, 379, 380, 381, 382, 387, 398, 399, 404, 405, 406, 407, 408, 413, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 435, 436, 437, 438, 439, 440, 441, 442, 445, 446, 447, 448, 449, 450, 454, 466, 467, 472, 473, 474, 475, 476, 481, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 527, 528, 529, 530, 531, 532, 533, 537, 547, 548, 553, 554, 555, 556, 557, 562, 568, 569, 570, 571, 576, 577, 578, 579, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 605, 606, 607, 608, 609, 612, 613, 614, 615, 616, 617, 618, 619, 620, 622, 623, 624, 625, 626, 629, 642, 643, 644, 645, 646, 647, 649, 650, 651, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 666, 683, 684, 689, 690, 691, 692, 693, 698, 699, 700, 701, 702, 704, 705, 709, 713, 714, 715, 716, 721, 722, 723, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 745, 746, 747, 748, 751, 752, 753, 754, 755, 758, 759, 760, 761, 762, 763, 764, 765, 767, 768, 769, 770, 771, 775, 778, 779, 780, 781, 782, 783, 784, 785, 788, 789, 790, 791, 792, 793, 794, 795, 801, 802, 803, 807, 808, 809, 810, 811, 812,]
missed_lines = [ 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 67, 68, 69, 75, 76, 77, 86, 87, 88, 136, 137, 138, 147, 148, 168, 169, 170, 173, 174, 175, 180, 181, 182, 200, 201, 202, 245, 246, 247, 256, 257, 258, 259, 260, 275, 276, 277, 284, 285, 332, 333, 334, 341, 342, 400, 401, 402, 409, 410, 414, 415, 416, 417, 430, 431, 432, 468, 469, 470, 477, 478, 482, 483, 484, 485, 497, 498, 499, 520, 521, 522, 523, 524, 549, 550, 551, 558, 559, 563, 564, 565, 566, 572, 573, 580, 581, 582, 583, 584, 585, 586, 600, 601, 685, 686, 687, 694, 695, 706, 707, 710, 711, 717, 718, 719, 720, 786, 787, 796, 797, 804, 805, 806,]

[input_info]
test_file_path = "pkg/goast/ast_test.go"
focal_file_path = "pkg/goast/ast.go"
test_file_url = "https://github.com/go-dev-frame/sponge/blob/e72bb7443479d95928a16711696af6523999a717/pkg/goast/ast_test.go"
focal_file_url = "https://github.com/go-dev-frame/sponge/blob/e72bb7443479d95928a16711696af6523999a717/pkg/goast/ast.go"
first_commit_date = "2025-04-06"
last_commit_date = "2025-04-06"
test_file_content = "package goast\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestParseGoFile(t *testing.T) {\n\tastInfos, err := ParseFile(\"ast.go\")\n\tassert.NoError(t, err)\n\tassert.Greater(t, len(astInfos), 10)\n}\n\nfunc TestParseGoCode(t *testing.T) {\n\tvar src = `\npackage main\n\nimport \"fmt\"\nimport \"strings\"\nimport (\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/spf13/viper\"\n)\n\nconst (\n\tpi = 3.14\n\tlanguage = \"Go\"\n)\n\nvar (\n\tversion = \"v1.0.0\"\n\trepo  = \"sponge\"\n)\n\ntype User struct {\n\tName string\n\tAge  int\n}\n\nfunc (u *User) SayHello() {\n\tfmt.Println(\"Hello, my name is\", u.Name)\n}\n\nfunc main() {\n\tfmt.Println(pi)\n\tfmt.Println(language)\n\tfmt.Println(version)\n\n\tuser:=&User{Name:\"Tom\",Age:20}\n\tfmt.Println(user.Name)\n\tfmt.Println(user.Age)\n\tuser.SayHello()\n}\n`\n\n\tastInfos, err := ParseGoCode(\"\", []byte(src))\n\tassert.NoError(t, err)\n\tfor _, info := range astInfos {\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"name\", info.Names)\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"comment\", info.Comment)\n\t\tfmt.Printf(\"    %-20s: %s\\n\\n\\n\", \"body\", info.Body)\n\t}\n}\n\nfunc TestParseImportGroup(t *testing.T) {\n\tbody := `\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t//\"github.com/spf13/viper\"\n\tapiV1   \"yourModuleName/api/v1\"\n\t// api v2\n\tapiV2   \"yourModuleName/api/v2\"\n)\n`\n\n\timportInfos, err := ParseImportGroup(body)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfor _, ii := range importInfos {\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"name\", ii.Path)\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"alias\", ii.Alias)\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"comment\", ii.Comment)\n\t\tfmt.Printf(\"    %-20s: %s\\n\\n\\n\", \"body\", ii.Body)\n\t}\n}\n\nfunc TestParseConstGroup(t *testing.T) {\n\tbody := `\n// pi constant\nconst pi = 3.14\n\nconst (\n\t// Version number\n\tversion = \"v1.0.0\"\n)\n\nconst (\n\t// Development language\n\tlanguage = \"Go\"\n\n\t// database type\n\tdbDriver = \"mysql\"\n)\n`\n\n\tconstInfos, err := ParseConstGroup(body)\n\tif err != nil {\n\t\tassert.NotNil(t, err)\n\t\treturn\n\t}\n\tfor _, ci := range constInfos {\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"name\", ci.Name)\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"value\", ci.Value)\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"comment\", ci.Comment)\n\t\tfmt.Printf(\"    %-20s: %s\\n\\n\\n\", \"body\", ci.Body)\n\t}\n}\n\nfunc TestParseVarGroup(t *testing.T) {\n\tbody := `\nvar (\n\t// Version number\n\tversion = \"v1.0.0\"\n\n\t// Author\n\tauthor  = \"name\"\n\n\t// Repository\n\trepo  = \"sponge\"\n\n\t// Function variable\n\tf1 = func() {\n\t\tfmt.Println(\"hello\")\n\t}\n)\n`\n\n\tvarInfos, err := ParseVarGroup(body)\n\tif err != nil {\n\t\tassert.NotNil(t, err)\n\t\treturn\n\t}\n\tfor _, vi := range varInfos {\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"name\", vi.Name)\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"value\", vi.Value)\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"comment\", vi.Comment)\n\t\tfmt.Printf(\"    %-20s: %s\\n\\n\\n\", \"body\", vi.Body)\n\t}\n}\n\nfunc TestParseTypeGroup(t *testing.T) {\n\tbody := `\ntype (\n\t// Struct type\n\tts struct {\n\t\tname string\n\t}\n\n\t// Function type\n\ttfn func(name string) bool\n\n\t// Interface type\n\tiFace interface {}\n\n\t// Channel type\n\tch chan int\n\n\t// Map type\n\tm map[string]bool\n\n\t// Slice type\n\tslice []int\n)\n`\n\n\ttypeInfos, err := ParseTypeGroup(body)\n\tif err != nil {\n\t\tassert.NotNil(t, err)\n\t\treturn\n\t}\n\n\tfor _, ti := range typeInfos {\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"type\", ti.Type)\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"name\", ti.Name)\n\t\tfmt.Printf(\"    %-20s: %s\\n\", \"comment\", ti.Comment)\n\t\tfmt.Printf(\"    %-20s: %s\\n\\n\\n\", \"body\", ti.Body)\n\t}\n}\n\nfunc TestParseInterface(t *testing.T) {\n\tbody := `\ntype GreeterDao interface {\n\t// get by id\n\tCreate(ctx context.Context, table *model.Greeter) error\n\t// delete by id\n\tDeleteByID(ctx context.Context, id uint64) error\n\t// update by id\n\tUpdateByID(ctx context.Context, table *model.Greeter) error\n\tUserExampleDao\n}\n\ntype UserExampleDao interface {\n\t// get by id\n\tCreate(ctx context.Context, table *model.UserExample) error\n\t// update by id\n\tUpdateByID(ctx context.Context, table *model.UserExample) error\n}\n`\n\n\tinterfaceInfos, err := ParseInterface(body)\n\tif err != nil {\n\t\tassert.NotNil(t, err)\n\t\treturn\n\t}\n\tfor _, info := range interfaceInfos {\n\t\tfmt.Printf(\"%-20s     : %s\\n\", \"name\", info.Name)\n\t\tfmt.Printf(\"%-20s     : %s\\n\", \"comment\", info.Comment)\n\t\tfor _, mi := range info.MethodInfos {\n\t\t\tfmt.Printf(\"    %-20s: %s\\n\", \"method name\", mi.Name)\n\t\t\tfmt.Printf(\"    %-20s: %s\\n\", \"comment\", mi.Comment)\n\t\t\tfmt.Printf(\"    %-20s: %s\\n\", \"body\", mi.Body)\n\t\t\tfmt.Printf(\"    %-20v: %t\\n\\n\\n\", \"embedded\", mi.IsIdent)\n\t\t}\n\t}\n}\n\nfunc TestParseStructMethods(t *testing.T) {\n\tsrc := `\npackage demo\n\ntype userHandler struct {\n\tserver userV1.UserServer\n}\n\n// Create a record\nfunc (h *userHandler) Create(ctx context.Context, req *userV1.CreateUserRequest) (*userV1.CreateUserReply, error) {\n\treturn h.server.Create(ctx, req)\n}\n\n// DeleteByID delete a record by id\nfunc (h *userHandler) DeleteByID(ctx context.Context, req *userV1.DeleteUserByIDRequest) (*userV1.DeleteUserByIDReply, error) {\n\treturn h.server.DeleteByID(ctx, req)\n}\n\n// UpdateByID update a record by id\nfunc (h *userHandler) UpdateByID(ctx context.Context, req *userV1.UpdateUserByIDRequest) (*userV1.UpdateUserByIDReply, error) {\n\treturn h.server.UpdateByID(ctx, req)\n}\n\ntype greeterHandler struct {\n\tserver greeterV1.GreeterServer\n}\n\n// Create a record\nfunc (h *greeterHandler) Create(ctx context.Context, req *greeterV1.CreateGreeterRequest) (*greeterV1.CreateGreeterReply, error) {\n\treturn h.server.Create(ctx, req)\n}\n\n// DeleteByID delete a record by id\nfunc (h *greeterHandler) DeleteByID(ctx context.Context, req *greeterV1.DeleteGreeterByIDRequest) (*greeterV1.DeleteGreeterByIDReply, error) {\n\treturn h.server.DeleteByID(ctx, req)\n}\n`\n\tastInfos, err := ParseGoCode(\"\", []byte(src))\n\tif err != nil {\n\t\tassert.NotNil(t, err)\n\t\treturn\n\t}\n\n\tmethods := ParseStructMethods(astInfos)\n\tfor structName, methodInfos := range methods {\n\t\tfmt.Printf(\"%-20s     : %s\\n\", \"name\", structName)\n\t\tfor _, mi := range methodInfos {\n\t\t\tfmt.Printf(\"    %-20s: %s\\n\", \"method name\", mi.Name)\n\t\t\tfmt.Printf(\"    %-20s: %s\\n\", \"comment\", mi.Comment)\n\t\t\tfmt.Printf(\"    %-20s: %s\\n\\n\\n\", \"body\", mi.Body)\n\t\t}\n\t}\n}\n\nfunc TestParseStruct(t *testing.T) {\n\tbody := `\npackage goast\n\n// AstInfo is the information of a code block.\ntype AstInfo struct {\n\tKind string\n\n\t// Names is the name of the code block, such as \"func Name\", \"type Names\", \"const Names\", \"var Names\", \"import Paths\".\n\t// If Type is \"func\", a standalone function without a receiver has a single name.\n\t// If the function is a method belonging to a struct, it has two names: the first\n\t// represents the function name, and the second represents the struct name.\n\tNames []string // todo add name\n\n\t// User information\n\tUser struct {\n\t\tName string\n\t\tAge string\n\t}\n\n\t// embedded struct\n\t*Address\n\t// embedded struct2\n\tAddress\n\n\treader interface {}\n\twriter any\n\tsayMap map[string]string\n\tch1 chan int\n\tch2 chan *Address\n}\n\n// Address is address\ntype Address struct {\n\tState    string\n\t// Addr is address\n\tAddr string\n}\n`\n\tstructInfos, err := ParseStruct(body)\n\tif err != nil {\n\t\tt.Error(err)\n\t\treturn\n\t}\n\tfor name, structInfo := range structInfos {\n\t\tfmt.Printf(\"%-20s     : %s\\n\", \"struct name\", name)\n\t\tfmt.Printf(\"%-20s     : %s\\n\", \"struct comment\", structInfo.Comment)\n\t\tfor _, field := range structInfo.Fields {\n\t\t\tfmt.Printf(\"    %-20s: %s\\n\", \"name\", field.Name)\n\t\t\tfmt.Printf(\"    %-20s: %s\\n\", \"type\", field.Type)\n\t\t\tfmt.Printf(\"    %-20s: %s\\n\", \"comment\", field.Comment)\n\t\t\tfmt.Printf(\"    %-20s: %s\\n\\n\", \"body\", field.Body)\n\t\t}\n\t\tfmt.Printf(\"\\n\\n\\n\")\n\t}\n}\n"
