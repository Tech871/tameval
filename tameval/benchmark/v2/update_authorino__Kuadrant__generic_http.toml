[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.23.8"

[repo_info]
repository = "Kuadrant/authorino"
sha = "21d456d60269371848937208af54a83145957450"

[run_info]
docker_image = "golang:1.23.8"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/evaluators/metadata/generic_http.go pkg/evaluators/metadata/generic_http_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/evaluators/metadata/generic_http.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 56.0
mutation_kill_rate = nan
original_mutation_kill_rate = 64.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "pkg/evaluators/metadata/generic_http_test.go"
focal_file_path = "pkg/evaluators/metadata/generic_http.go"
test_file_url = "https://github.com/Kuadrant/authorino/blob/21d456d60269371848937208af54a83145957450/pkg/evaluators/metadata/generic_http_test.go"
focal_file_url = "https://github.com/Kuadrant/authorino/blob/21d456d60269371848937208af54a83145957450/pkg/evaluators/metadata/generic_http.go"
first_commit_date = "2022-03-28"
last_commit_date = "2025-06-17"
test_file_content = "package metadata\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\tgojson \"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\tmock_auth \"github.com/kuadrant/authorino/pkg/auth/mocks\"\n\t\"github.com/kuadrant/authorino/pkg/httptest\"\n\t\"github.com/kuadrant/authorino/pkg/json\"\n\t\"github.com/kuadrant/authorino/pkg/oauth2\"\n\n\tenvoy_auth \"github.com/envoyproxy/go-control-plane/envoy/service/auth/v3\"\n\t\"github.com/golang/mock/gomock\"\n\t\"gotest.tools/assert\"\n)\n\nconst (\n\ttestHttpMetadataServerHost string = \"127.0.0.1:9005\"\n\ttestOAuth2ServerHost       string = \"127.0.0.1:9011\"\n)\n\nfunc TestGenericHttpCallWithGET(t *testing.T) {\n\textHttpMetadataServer := httptest.NewHttpServerMock(testHttpMetadataServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/metadata\": httptest.NewHttpServerMockResponseFuncJSON(`{\"foo\":\"bar\"}`),\n\t})\n\tdefer extHttpMetadataServer.Close()\n\n\tctx := context.TODO()\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tendpoint := \"http://\" + testHttpMetadataServerHost + \"/metadata\"\n\n\tpipelineMock := mock_auth.NewMockAuthPipeline(ctrl)\n\tpipelineMock.EXPECT().GetAuthorizationJSON().Return(genericHttpAuthDataMock())\n\n\tsharedCredsMock := mock_auth.NewMockAuthCredentials(ctrl)\n\thttpRequestMock, _ := http.NewRequest(\"GET\", endpoint, nil)\n\tsharedCredsMock.EXPECT().BuildRequestWithCredentials(ctx, endpoint, \"GET\", \"secret\", nil).Return(httpRequestMock, nil)\n\n\tmetadata := &GenericHttp{\n\t\tEndpoint:        endpoint,\n\t\tMethod:          \"GET\",\n\t\tSharedSecret:    \"secret\",\n\t\tAuthCredentials: sharedCredsMock,\n\t}\n\n\tobj, err := metadata.Call(pipelineMock, ctx)\n\n\tassert.NilError(t, err)\n\n\tobjJSON := obj.(map[string]interface{})\n\tassert.Equal(t, objJSON[\"foo\"], \"bar\")\n}\n\nfunc TestGenericHttpCallWithPOST(t *testing.T) {\n\textHttpMetadataServer := httptest.NewHttpServerMock(testHttpMetadataServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/metadata\": httptest.NewHttpServerMockResponseFuncJSON(`{\"foo\":\"bar\"}`),\n\t})\n\tdefer extHttpMetadataServer.Close()\n\n\tctx := context.TODO()\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tendpoint := \"http://\" + testHttpMetadataServerHost + \"/metadata\"\n\n\tpipelineMock := mock_auth.NewMockAuthPipeline(ctrl)\n\tpipelineMock.EXPECT().GetAuthorizationJSON().Return(genericHttpAuthDataMock())\n\n\tsharedCredsMock := mock_auth.NewMockAuthCredentials(ctrl)\n\trequestBody := bytes.NewBuffer([]byte(\"user=mock\"))\n\thttpRequestMock, _ := http.NewRequest(\"POST\", endpoint, requestBody)\n\tsharedCredsMock.EXPECT().BuildRequestWithCredentials(ctx, endpoint, \"POST\", \"secret\", requestBody).Return(httpRequestMock, nil)\n\n\tmetadata := &GenericHttp{\n\t\tEndpoint:        endpoint,\n\t\tMethod:          \"POST\",\n\t\tParameters:      []json.JSONProperty{{Name: \"user\", Value: &json.JSONValue{Pattern: \"auth.identity.user\"}}},\n\t\tContentType:     \"application/x-www-form-urlencoded\",\n\t\tSharedSecret:    \"secret\",\n\t\tAuthCredentials: sharedCredsMock,\n\t}\n\n\tobj, err := metadata.Call(pipelineMock, ctx)\n\n\tassert.NilError(t, err)\n\n\tobjJSON := obj.(map[string]interface{})\n\tassert.Equal(t, objJSON[\"foo\"], \"bar\")\n}\n\nfunc TestGenericHttpCallWithStaticBody(t *testing.T) {\n\textHttpMetadataServer := httptest.NewHttpServerMock(testHttpMetadataServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/metadata\": httptest.NewHttpServerMockResponseFuncJSON(`{\"foo\":\"bar\"}`),\n\t})\n\tdefer extHttpMetadataServer.Close()\n\n\tctx := context.TODO()\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tendpoint := \"http://\" + testHttpMetadataServerHost + \"/metadata\"\n\n\tpipelineMock := mock_auth.NewMockAuthPipeline(ctrl)\n\tpipelineMock.EXPECT().GetAuthorizationJSON().Return(genericHttpAuthDataMock())\n\n\tsharedCredsMock := mock_auth.NewMockAuthCredentials(ctrl)\n\trequestBody := bytes.NewBuffer([]byte(`{\"foo\":\"bar\"}`))\n\thttpRequestMock, _ := http.NewRequest(\"POST\", endpoint, requestBody)\n\tsharedCredsMock.EXPECT().BuildRequestWithCredentials(ctx, endpoint, \"POST\", \"secret\", requestBody).Return(httpRequestMock, nil)\n\n\tmetadata := &GenericHttp{\n\t\tEndpoint:        endpoint,\n\t\tMethod:          \"POST\",\n\t\tBody:            &json.JSONValue{Static: `{\"foo\":\"bar\"}`},\n\t\tContentType:     \"application/json\",\n\t\tSharedSecret:    \"secret\",\n\t\tAuthCredentials: sharedCredsMock,\n\t}\n\n\tobj, err := metadata.Call(pipelineMock, ctx)\n\n\tassert.NilError(t, err)\n\n\tobjJSON := obj.(map[string]interface{})\n\tassert.Equal(t, objJSON[\"foo\"], \"bar\")\n}\n\nfunc TestGenericHttpCallWithDynamicBody(t *testing.T) {\n\textHttpMetadataServer := httptest.NewHttpServerMock(testHttpMetadataServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/metadata\": httptest.NewHttpServerMockResponseFuncJSON(`{\"foo\":\"bar\"}`),\n\t})\n\tdefer extHttpMetadataServer.Close()\n\n\tctx := context.TODO()\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tendpoint := \"http://\" + testHttpMetadataServerHost + \"/metadata\"\n\n\tpipelineMock := mock_auth.NewMockAuthPipeline(ctrl)\n\tpipelineMock.EXPECT().GetAuthorizationJSON().Return(genericHttpAuthDataMock())\n\n\tsharedCredsMock := mock_auth.NewMockAuthCredentials(ctrl)\n\trequestBody := bytes.NewBuffer([]byte(`{\"foo\":\"bar\",\"user\":{\"name\":\"mock\"}}`))\n\thttpRequestMock, _ := http.NewRequest(\"POST\", endpoint, requestBody)\n\tsharedCredsMock.EXPECT().BuildRequestWithCredentials(ctx, endpoint, \"POST\", \"secret\", requestBody).Return(httpRequestMock, nil)\n\n\tmetadata := &GenericHttp{\n\t\tEndpoint:        endpoint,\n\t\tMethod:          \"POST\",\n\t\tBody:            &json.JSONValue{Pattern: `\\{\"foo\":\"bar\",\"user\":\\{\"name\":\"{auth.identity.user}\"\\}\\}`},\n\t\tContentType:     \"application/json\",\n\t\tSharedSecret:    \"secret\",\n\t\tAuthCredentials: sharedCredsMock,\n\t}\n\n\tobj, err := metadata.Call(pipelineMock, ctx)\n\n\tassert.NilError(t, err)\n\n\tobjJSON := obj.(map[string]interface{})\n\tassert.Equal(t, objJSON[\"foo\"], \"bar\")\n}\n\nfunc TestGenericHttpCallWithURLPlaceholders(t *testing.T) {\n\textHttpMetadataServer := httptest.NewHttpServerMock(testHttpMetadataServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/metadata?p=some-origin\": httptest.NewHttpServerMockResponseFuncJSON(`{\"foo\":\"bar\"}`),\n\t})\n\tdefer extHttpMetadataServer.Close()\n\n\tctx := context.TODO()\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tendpointWithPlaceholders := \"http://\" + testHttpMetadataServerHost + \"/metadata?p={context.request.http.headers.x-origin}\"\n\tendpoint := \"http://\" + testHttpMetadataServerHost + \"/metadata?p=some-origin\"\n\n\tpipelineMock := mock_auth.NewMockAuthPipeline(ctrl)\n\tpipelineMock.EXPECT().GetAuthorizationJSON().Return(genericHttpAuthDataMock())\n\n\tsharedCredsMock := mock_auth.NewMockAuthCredentials(ctrl)\n\thttpRequestMock, _ := http.NewRequest(\"GET\", endpoint, nil)\n\tsharedCredsMock.EXPECT().BuildRequestWithCredentials(ctx, endpoint, \"GET\", \"secret\", nil).Return(httpRequestMock, nil)\n\n\tmetadata := &GenericHttp{\n\t\tEndpoint:        endpointWithPlaceholders,\n\t\tMethod:          \"GET\",\n\t\tSharedSecret:    \"secret\",\n\t\tAuthCredentials: sharedCredsMock,\n\t}\n\n\tobj, err := metadata.Call(pipelineMock, ctx)\n\n\tassert.NilError(t, err)\n\n\tobjJSON := obj.(map[string]interface{})\n\tassert.Equal(t, objJSON[\"foo\"], \"bar\")\n}\n\nfunc TestGenericHttpCallWithCustomHeaders(t *testing.T) {\n\textHttpMetadataServer := httptest.NewHttpServerMock(testHttpMetadataServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/metadata\": httptest.NewHttpServerMockResponseFuncJSON(`{\"foo\":\"bar\"}`),\n\t})\n\tdefer extHttpMetadataServer.Close()\n\n\tctx := context.TODO()\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tendpoint := \"http://\" + testHttpMetadataServerHost + \"/metadata\"\n\n\tpipelineMock := mock_auth.NewMockAuthPipeline(ctrl)\n\tpipelineMock.EXPECT().GetAuthorizationJSON().Return(genericHttpAuthDataMock())\n\n\tsharedCredsMock := mock_auth.NewMockAuthCredentials(ctrl)\n\thttpRequestMock, _ := http.NewRequest(\"GET\", endpoint, nil)\n\tsharedCredsMock.EXPECT().BuildRequestWithCredentials(ctx, endpoint, \"GET\", \"\", nil).Return(httpRequestMock, nil)\n\n\tmetadata := &GenericHttp{\n\t\tEndpoint: endpoint,\n\t\tMethod:   \"GET\",\n\t\tHeaders: []json.JSONProperty{\n\t\t\t{Name: \"X-Requested-By\", Value: &json.JSONValue{Static: \"authorino\"}},\n\t\t\t{Name: \"Content-Type\", Value: &json.JSONValue{Static: \"to-be-overwritten\"}},\n\t\t},\n\t\tAuthCredentials: sharedCredsMock,\n\t}\n\n\t_, err := metadata.Call(pipelineMock, ctx)\n\n\tassert.NilError(t, err)\n\tassert.Equal(t, httpRequestMock.Header.Get(\"X-Requested-By\"), \"authorino\")\n\tassert.Equal(t, httpRequestMock.Header.Get(\"Content-Type\"), \"text/plain\")\n}\n\nfunc TestGenericHttpWithInvalidJSONResponse(t *testing.T) {\n\textHttpMetadataServer := httptest.NewHttpServerMock(testHttpMetadataServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/metadata\": httptest.NewHttpServerMockResponseFuncJSON(`{not a valid JSON`),\n\t})\n\tdefer extHttpMetadataServer.Close()\n\n\tctx := context.TODO()\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tendpoint := \"http://\" + testHttpMetadataServerHost + \"/metadata\"\n\n\tpipelineMock := mock_auth.NewMockAuthPipeline(ctrl)\n\tpipelineMock.EXPECT().GetAuthorizationJSON().Return(genericHttpAuthDataMock())\n\n\tmetadata := &GenericHttp{\n\t\tEndpoint: endpoint,\n\t\tMethod:   \"GET\",\n\t}\n\n\tobj, err := metadata.Call(pipelineMock, ctx)\n\tassert.ErrorContains(t, err, \"invalid\")\n\tassert.Check(t, obj == nil)\n}\n\nfunc TestGenericHttpMultipleElementsJSONResponse(t *testing.T) {\n\textHttpMetadataServer := httptest.NewHttpServerMock(testHttpMetadataServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/metadata\": httptest.NewHttpServerMockResponseFuncJSON(`{\"foo\":\"bar\"}{\"blah\":\"bleh\"}`),\n\t})\n\tdefer extHttpMetadataServer.Close()\n\n\tctx := context.TODO()\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tendpoint := \"http://\" + testHttpMetadataServerHost + \"/metadata\"\n\n\tpipelineMock := mock_auth.NewMockAuthPipeline(ctrl)\n\tpipelineMock.EXPECT().GetAuthorizationJSON().Return(genericHttpAuthDataMock())\n\n\tsharedCredsMock := mock_auth.NewMockAuthCredentials(ctrl)\n\thttpRequestMock, _ := http.NewRequest(\"GET\", endpoint, nil)\n\tsharedCredsMock.EXPECT().BuildRequestWithCredentials(ctx, endpoint, \"GET\", \"secret\", nil).Return(httpRequestMock, nil)\n\n\tmetadata := &GenericHttp{\n\t\tEndpoint:        endpoint,\n\t\tMethod:          \"GET\",\n\t\tSharedSecret:    \"secret\",\n\t\tAuthCredentials: sharedCredsMock,\n\t}\n\n\tobj, err := metadata.Call(pipelineMock, ctx)\n\n\tassert.NilError(t, err)\n\n\tobjJSON := obj.([]map[string]interface{})\n\tassert.Equal(t, len(objJSON), 2)\n\tassert.Equal(t, objJSON[0][\"foo\"], \"bar\")\n\tassert.Equal(t, objJSON[1][\"blah\"], \"bleh\")\n}\n\nfunc TestGenericHttpWithTextPlainResponse(t *testing.T) {\n\textHttpMetadataServer := httptest.NewHttpServerMock(testHttpMetadataServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/metadata\": httptest.NewHttpServerMockResponseFuncPlain(\"OK\"),\n\t})\n\tdefer extHttpMetadataServer.Close()\n\n\tctx := context.TODO()\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tendpoint := \"http://\" + testHttpMetadataServerHost + \"/metadata\"\n\n\tpipelineMock := mock_auth.NewMockAuthPipeline(ctrl)\n\tpipelineMock.EXPECT().GetAuthorizationJSON().Return(genericHttpAuthDataMock())\n\n\tmetadata := &GenericHttp{\n\t\tEndpoint: endpoint,\n\t\tMethod:   \"GET\",\n\t}\n\n\tobj, err := metadata.Call(pipelineMock, ctx)\n\tassert.NilError(t, err)\n\tassert.Equal(t, fmt.Sprintf(\"%s\", obj), \"OK\")\n}\n\nfunc TestWithOAuth2Authentication(t *testing.T) {\n\textHttpMetadataServer := httptest.NewHttpServerMock(testHttpMetadataServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/metadata\": httptest.NewHttpServerMockResponseFuncJSON(`{\"foo\":\"bar\"}`),\n\t})\n\tdefer extHttpMetadataServer.Close()\n\n\tnonce := 0\n\toauth2Server := httptest.NewHttpServerMock(testOAuth2ServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/token\": func() httptest.HttpServerMockResponse {\n\t\t\tnonce = nonce + 1\n\t\t\treturn httptest.HttpServerMockResponse{\n\t\t\t\tStatus:  http.StatusOK,\n\t\t\t\tHeaders: map[string]string{\"Content-Type\": \"application/json\"},\n\t\t\t\tBody:    fmt.Sprintf(`{\"access_token\":\"xyz-%d\",\"token_type\":\"Bearer\",\"expires_in\":300}`, nonce), // token expires in 5 min\n\t\t\t}\n\t\t},\n\t})\n\tdefer oauth2Server.Close()\n\n\tctx := context.TODO()\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tendpoint := \"http://\" + testHttpMetadataServerHost + \"/metadata\"\n\ttokenUrl := \"http://\" + testOAuth2ServerHost + \"/token\"\n\n\tpipelineMock := mock_auth.NewMockAuthPipeline(ctrl)\n\tpipelineMock.EXPECT().GetAuthorizationJSON().Return(genericHttpAuthDataMock()).Times(2)\n\n\tsharedCredsMock := mock_auth.NewMockAuthCredentials(ctrl)\n\thttpRequestMock, _ := http.NewRequest(\"GET\", endpoint, nil)\n\tsharedCredsMock.EXPECT().BuildRequestWithCredentials(ctx, endpoint, \"GET\", \"xyz-1\", nil).Return(httpRequestMock, nil).Times(2)\n\n\tmetadata := &GenericHttp{\n\t\tEndpoint:        endpoint,\n\t\tMethod:          \"GET\",\n\t\tOAuth2:          oauth2.NewClientCredentialsConfig(tokenUrl, \"foo\", \"secret\", []string{}, map[string]string{}),\n\t\tAuthCredentials: sharedCredsMock,\n\t}\n\n\tobj, err := metadata.Call(pipelineMock, ctx)\n\tassert.NilError(t, err)\n\tobjJSON := obj.(map[string]interface{})\n\tassert.Equal(t, objJSON[\"foo\"], \"bar\")\n\n\tobj, err = metadata.Call(pipelineMock, ctx)\n\tassert.NilError(t, err)\n\tobjJSON = obj.(map[string]interface{})\n\tassert.Equal(t, objJSON[\"foo\"], \"bar\")\n}\n\nfunc TestWithOAuth2AuthenticationWithoutTokenCache(t *testing.T) {\n\textHttpMetadataServer := httptest.NewHttpServerMock(testHttpMetadataServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/metadata\": httptest.NewHttpServerMockResponseFuncJSON(`{\"foo\":\"bar\"}`),\n\t})\n\tdefer extHttpMetadataServer.Close()\n\n\tnonce := 0\n\toauth2Server := httptest.NewHttpServerMock(testOAuth2ServerHost, map[string]httptest.HttpServerMockResponseFunc{\n\t\t\"/token\": func() httptest.HttpServerMockResponse {\n\t\t\tnonce = nonce + 1\n\t\t\treturn httptest.HttpServerMockResponse{\n\t\t\t\tStatus:  http.StatusOK,\n\t\t\t\tHeaders: map[string]string{\"Content-Type\": \"application/json\"},\n\t\t\t\tBody:    fmt.Sprintf(`{\"access_token\":\"xyz-%d\",\"token_type\":\"Bearer\",\"expires_in\":300}`, nonce), // token expires in 5 min\n\t\t\t}\n\t\t},\n\t})\n\tdefer oauth2Server.Close()\n\n\tctx := context.TODO()\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tendpoint := \"http://\" + testHttpMetadataServerHost + \"/metadata\"\n\ttokenUrl := \"http://\" + testOAuth2ServerHost + \"/token\"\n\n\tpipelineMock := mock_auth.NewMockAuthPipeline(ctrl)\n\tpipelineMock.EXPECT().GetAuthorizationJSON().Return(genericHttpAuthDataMock()).Times(2)\n\n\tsharedCredsMock := mock_auth.NewMockAuthCredentials(ctrl)\n\thttpRequestMock, _ := http.NewRequest(\"GET\", endpoint, nil)\n\tsharedCredsMock.EXPECT().BuildRequestWithCredentials(ctx, endpoint, \"GET\", \"xyz-1\", nil).Return(httpRequestMock, nil)\n\tsharedCredsMock.EXPECT().BuildRequestWithCredentials(ctx, endpoint, \"GET\", \"xyz-2\", nil).Return(httpRequestMock, nil)\n\n\tmetadata := &GenericHttp{\n\t\tEndpoint:              endpoint,\n\t\tMethod:                \"GET\",\n\t\tOAuth2:                oauth2.NewClientCredentialsConfig(tokenUrl, \"foo\", \"secret\", []string{}, map[string]string{}),\n\t\tOAuth2TokenForceFetch: true,\n\t\tAuthCredentials:       sharedCredsMock,\n\t}\n\n\tobj, err := metadata.Call(pipelineMock, ctx)\n\tassert.NilError(t, err)\n\tobjJSON := obj.(map[string]interface{})\n\tassert.Equal(t, objJSON[\"foo\"], \"bar\")\n\n\tobj, err = metadata.Call(pipelineMock, ctx)\n\tassert.NilError(t, err)\n\tobjJSON = obj.(map[string]interface{})\n\tassert.Equal(t, objJSON[\"foo\"], \"bar\")\n}\n\nfunc genericHttpAuthDataMock() string {\n\ttype mockIdentityObject struct {\n\t\tUser string `json:\"user\"`\n\t}\n\n\ttype authorizationJSON struct {\n\t\tContext  *envoy_auth.AttributeContext `json:\"context\"`\n\t\tAuthData map[string]interface{}       `json:\"auth\"`\n\t}\n\n\tauthJSON, _ := gojson.Marshal(&authorizationJSON{\n\t\tContext: &envoy_auth.AttributeContext{\n\t\t\tRequest: &envoy_auth.AttributeContext_Request{\n\t\t\t\tHttp: &envoy_auth.AttributeContext_HttpRequest{\n\t\t\t\t\tHeaders: map[string]string{\n\t\t\t\t\t\t\"x-secret-header\": \"no-one-knows\",\n\t\t\t\t\t\t\"x-origin\":        \"some-origin\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tAuthData: map[string]interface{}{\n\t\t\t\"identity\": &mockIdentityObject{User: \"mock\"},\n\t\t},\n\t})\n\n\treturn string(authJSON)\n}"
