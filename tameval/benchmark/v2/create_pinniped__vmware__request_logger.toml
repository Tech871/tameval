[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.24.4"

[repo_info]
repository = "vmware/pinniped"
sha = "e20c5beb47391281e19d13b1e22c5fd42f577686"

[run_info]
docker_image = "golang:1.24.4"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/federationdomain/requestlogger/request_logger.go internal/federationdomain/requestlogger/request_logger_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/federationdomain/requestlogger/request_logger.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 62.0
original_coverage = 62.0
mutation_kill_rate = 73.0
original_mutation_kill_rate = 73.0
covered_lines = [ 69, 70, 71, 72, 73, 75, 76, 77, 78, 79, 80, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 109, 110, 111, 112, 114, 115, 116, 117, 120, 121, 122, 123, 124, 125, 126, 127, 128, 130, 131, 132, 134, 135, 138, 139, 140, 141, 142, 143, 145, 146, 147, 148, 149, 150, 151, 152, 153, 162, 163, 164,]
missed_lines = [ 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 157, 158, 159, 167, 168, 169, 170, 171, 175, 176, 177, 178, 181, 182, 183, 184, 185, 186, 187, 189, 190, 191, 192,]

[input_info]
test_file_path = "internal/federationdomain/requestlogger/request_logger_test.go"
focal_file_path = "internal/federationdomain/requestlogger/request_logger.go"
test_file_url = "https://github.com/vmware/pinniped/blob/e20c5beb47391281e19d13b1e22c5fd42f577686/internal/federationdomain/requestlogger/request_logger_test.go"
focal_file_url = "https://github.com/vmware/pinniped/blob/e20c5beb47391281e19d13b1e22c5fd42f577686/internal/federationdomain/requestlogger/request_logger.go"
first_commit_date = "2024-11-27"
last_commit_date = "2025-01-07"
test_file_content = "// Copyright 2024-2025 the Pinniped contributors. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\npackage requestlogger\n\nimport (\n\t\"crypto/tls\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"testing\"\n\t\"time\"\n\n\t\"go.uber.org/mock/gomock\"\n\tclocktesting \"k8s.io/utils/clock/testing\"\n\n\t\"go.pinniped.dev/internal/mocks/mockresponsewriter\"\n\t\"go.pinniped.dev/internal/plog\"\n\t\"go.pinniped.dev/internal/testutil\"\n)\n\nfunc TestLogRequestReceived(t *testing.T) {\n\tvar noAuditEventsWanted []testutil.WantedAuditLog\n\n\thappyAuditEventWanted := func(path string, sourceIPs []any) []testutil.WantedAuditLog {\n\t\treturn []testutil.WantedAuditLog{\n\t\t\ttestutil.WantAuditLog(\"HTTP Request Received\",\n\t\t\t\tmap[string]any{\n\t\t\t\t\t\"proto\":      \"some-proto\",\n\t\t\t\t\t\"method\":     \"some-method\",\n\t\t\t\t\t\"host\":       \"some-host\",\n\t\t\t\t\t\"serverName\": \"some-sni-server-name\",\n\t\t\t\t\t\"path\":       path,\n\t\t\t\t\t\"userAgent\":  \"some-user-agent\",\n\t\t\t\t\t\"sourceIPs\":  sourceIPs,\n\t\t\t\t},\n\t\t\t),\n\t\t}\n\t}\n\n\ttests := []struct {\n\t\tname               string\n\t\treqPath            string\n\t\treqRemoteAddr      string\n\t\treqHeaders         map[string][]string\n\t\tauditInternalPaths bool\n\t\twantAuditLogs      []testutil.WantedAuditLog\n\t}{\n\t\t{\n\t\t\tname:               \"when internal paths are not enabled, ignores internal paths\",\n\t\t\treqPath:            \"/healthz\",\n\t\t\tauditInternalPaths: false,\n\t\t\twantAuditLogs:      noAuditEventsWanted,\n\t\t},\n\t\t{\n\t\t\tname:               \"when internal paths are not enabled, audits external path\",\n\t\t\treqPath:            \"/pretend-to-login\",\n\t\t\treqRemoteAddr:      \"1.2.3.4\",\n\t\t\tauditInternalPaths: false,\n\t\t\twantAuditLogs:      happyAuditEventWanted(\"/pretend-to-login\", []any{\"1.2.3.4\"}),\n\t\t},\n\t\t{\n\t\t\tname:               \"when internal paths are enabled, audits internal paths\",\n\t\t\treqPath:            \"/healthz\",\n\t\t\treqRemoteAddr:      \"1.2.3.4\",\n\t\t\tauditInternalPaths: true,\n\t\t\twantAuditLogs:      happyAuditEventWanted(\"/healthz\", []any{\"1.2.3.4\"}),\n\t\t},\n\t\t{\n\t\t\tname:               \"when internal paths are enabled, audits external paths\",\n\t\t\treqPath:            \"/pretend-to-login\",\n\t\t\treqRemoteAddr:      \"1.2.3.4\",\n\t\t\tauditInternalPaths: true,\n\t\t\twantAuditLogs:      happyAuditEventWanted(\"/pretend-to-login\", []any{\"1.2.3.4\"}),\n\t\t},\n\t\t{\n\t\t\tname:               \"when X-Forwarded-For header is present, includes its values in sourceIPs before the remoteAddr\",\n\t\t\treqPath:            \"/pretend-to-login\",\n\t\t\treqRemoteAddr:      \"1.2.3.4\",\n\t\t\treqHeaders:         map[string][]string{\"X-Forwarded-For\": {\"5.6.7.8, 9.10.11.12\"}},\n\t\t\tauditInternalPaths: true,\n\t\t\twantAuditLogs:      happyAuditEventWanted(\"/pretend-to-login\", []any{\"5.6.7.8\", \"9.10.11.12\", \"1.2.3.4\"}),\n\t\t},\n\t\t{\n\t\t\tname:               \"when X-Real-Ip header is present, includes its value in sourceIPs before the remoteAddr\",\n\t\t\treqPath:            \"/pretend-to-login\",\n\t\t\treqRemoteAddr:      \"1.2.3.4\",\n\t\t\treqHeaders:         map[string][]string{\"X-Real-Ip\": {\"5.6.7.8\"}},\n\t\t\tauditInternalPaths: true,\n\t\t\twantAuditLogs:      happyAuditEventWanted(\"/pretend-to-login\", []any{\"5.6.7.8\", \"1.2.3.4\"}),\n\t\t},\n\t\t{\n\t\t\tname:          \"when both X-Forwarded-For and X-Real-Ip headers are present, includes both headers' values in sourceIPs before the remoteAddr\",\n\t\t\treqPath:       \"/pretend-to-login\",\n\t\t\treqRemoteAddr: \"1.2.3.4\",\n\t\t\treqHeaders: map[string][]string{\n\t\t\t\t\"X-Forwarded-For\": {\"5.6.7.8, 9.10.11.12\"},\n\t\t\t\t\"X-Real-Ip\":       {\"13.14.15.16\"},\n\t\t\t},\n\t\t\tauditInternalPaths: true,\n\t\t\twantAuditLogs:      happyAuditEventWanted(\"/pretend-to-login\", []any{\"5.6.7.8\", \"9.10.11.12\", \"13.14.15.16\", \"1.2.3.4\"}),\n\t\t},\n\t\t{\n\t\t\tname:          \"when the X-Real-Ip is the same as remoteAddr, does not duplicate remoteAddr\",\n\t\t\treqPath:       \"/pretend-to-login\",\n\t\t\treqRemoteAddr: \"1.2.3.4\",\n\t\t\treqHeaders: map[string][]string{\n\t\t\t\t\"X-Forwarded-For\": {\"5.6.7.8, 9.10.11.12\"},\n\t\t\t\t\"X-Real-Ip\":       {\"1.2.3.4\"},\n\t\t\t},\n\t\t\tauditInternalPaths: true,\n\t\t\twantAuditLogs:      happyAuditEventWanted(\"/pretend-to-login\", []any{\"5.6.7.8\", \"9.10.11.12\", \"1.2.3.4\"}),\n\t\t},\n\t\t{\n\t\t\tname:               \"when the last value of X-Forwarded-For is the same as remoteAddr and there is no X-Real-Ip, does not duplicate remoteAddr\",\n\t\t\treqPath:            \"/pretend-to-login\",\n\t\t\treqRemoteAddr:      \"1.2.3.4\",\n\t\t\treqHeaders:         map[string][]string{\"X-Forwarded-For\": {\"5.6.7.8, 1.2.3.4\"}},\n\t\t\tauditInternalPaths: true,\n\t\t\twantAuditLogs:      happyAuditEventWanted(\"/pretend-to-login\", []any{\"5.6.7.8\", \"1.2.3.4\"}),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\tauditLogger, actualAuditLog := plog.TestAuditLogger(t)\n\n\t\t\tsubject := requestLogger{\n\t\t\t\tauditLogger: auditLogger,\n\t\t\t\treq: &http.Request{\n\t\t\t\t\tMethod: \"some-method\",\n\t\t\t\t\tProto:  \"some-proto\",\n\t\t\t\t\tHost:   \"some-host\",\n\t\t\t\t\tURL: &url.URL{\n\t\t\t\t\t\tPath: test.reqPath,\n\t\t\t\t\t},\n\t\t\t\t\tRemoteAddr: test.reqRemoteAddr,\n\t\t\t\t\tHeader:     test.reqHeaders,\n\t\t\t\t\tTLS: &tls.ConnectionState{\n\t\t\t\t\t\tServerName: \"some-sni-server-name\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tuserAgent:          \"some-user-agent\",\n\t\t\t\tauditInternalPaths: test.auditInternalPaths,\n\t\t\t}\n\n\t\t\tsubject.logRequestReceived()\n\n\t\t\ttestutil.CompareAuditLogs(t, test.wantAuditLogs, actualAuditLog.String())\n\t\t})\n\t}\n}\n\nfunc TestLogRequestComplete(t *testing.T) {\n\twantLatency := time.Minute + 2*time.Second + 345*time.Millisecond\n\n\tvar noAuditEventsWanted []testutil.WantedAuditLog\n\n\thappyAuditEventWanted := func(path, location string) []testutil.WantedAuditLog {\n\t\treturn []testutil.WantedAuditLog{\n\t\t\ttestutil.WantAuditLog(\"HTTP Request Completed\",\n\t\t\t\tmap[string]any{\n\t\t\t\t\t\"path\":           path,\n\t\t\t\t\t\"latency\":        \"1m2.345s\",\n\t\t\t\t\t\"responseStatus\": 777.0, // JSON serializes this as a float\n\t\t\t\t\t\"location\":       location,\n\t\t\t\t},\n\t\t\t),\n\t\t}\n\t}\n\n\ttests := []struct {\n\t\tname               string\n\t\treqPath            string\n\t\tlocation           string\n\t\tauditInternalPaths bool\n\t\twantAuditLogs      []testutil.WantedAuditLog\n\t}{\n\t\t{\n\t\t\tname:               \"when internal paths are not enabled, ignores internal paths\",\n\t\t\treqPath:            \"/healthz\",\n\t\t\tauditInternalPaths: false,\n\t\t\twantAuditLogs:      noAuditEventsWanted,\n\t\t},\n\t\t{\n\t\t\tname:               \"when internal paths are not enabled, audits external path with location (redacting unknown query params)\",\n\t\t\treqPath:            \"/pretend-to-login\",\n\t\t\tlocation:           \"http://127.0.0.1?foo=bar&foo=quz&lorem=ipsum\",\n\t\t\tauditInternalPaths: false,\n\t\t\twantAuditLogs:      happyAuditEventWanted(\"/pretend-to-login\", \"http://127.0.0.1?foo=redacted&foo=redacted&lorem=redacted\"),\n\t\t},\n\t\t{\n\t\t\tname:               \"when internal paths are enabled, audits internal paths\",\n\t\t\treqPath:            \"/healthz\",\n\t\t\tauditInternalPaths: true,\n\t\t\twantAuditLogs:      happyAuditEventWanted(\"/healthz\", \"no location header\"),\n\t\t},\n\t\t{\n\t\t\tname:               \"when internal paths are enabled, audits external paths\",\n\t\t\treqPath:            \"/pretend-to-login\",\n\t\t\tlocation:           \"some-location\",\n\t\t\tauditInternalPaths: true,\n\t\t\twantAuditLogs:      happyAuditEventWanted(\"/pretend-to-login\", \"some-location\"),\n\t\t},\n\t\t{\n\t\t\tname:          \"audits path without location\",\n\t\t\treqPath:       \"/pretend-to-login\",\n\t\t\tlocation:      \"\", // make it obvious\n\t\t\twantAuditLogs: happyAuditEventWanted(\"/pretend-to-login\", \"no location header\"),\n\t\t},\n\t\t{\n\t\t\tname:          \"audits path with invalid location\",\n\t\t\treqPath:       \"/pretend-to-login\",\n\t\t\tlocation:      \"http://e x a m p l e.com\",\n\t\t\twantAuditLogs: happyAuditEventWanted(\"/pretend-to-login\", \"unparsable location header\"),\n\t\t},\n\t\t{\n\t\t\tname:          \"audits path with location redacting all query params except err, error, and error_description\",\n\t\t\treqPath:       \"/pretend-to-login\",\n\t\t\tlocation:      \"http://127.0.0.1:1234?code=pin_ac_FAKE&foo=bar&foo=quz&lorem=ipsum&err=some-err&error=some-error&error_description=some-error-description&zzlast=some-value\",\n\t\t\twantAuditLogs: happyAuditEventWanted(\"/pretend-to-login\", \"http://127.0.0.1:1234?code=redacted&err=some-err&error=some-error&error_description=some-error-description&foo=redacted&foo=redacted&lorem=redacted&zzlast=redacted\"),\n\t\t},\n\t}\n\n\tnowDoesntMatter := time.Date(1122, time.September, 33, 4, 55, 56, 778899, time.Local)\n\tstartTime := nowDoesntMatter.Add(-wantLatency)\n\tfrozenClock := clocktesting.NewFakeClock(nowDoesntMatter)\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tt.Parallel()\n\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockResponseWriter := mockresponsewriter.NewMockResponseWriter(ctrl)\n\t\t\tif len(test.wantAuditLogs) > 0 {\n\t\t\t\tmockResponseWriter.EXPECT().Header().Return(http.Header{\n\t\t\t\t\t\"Location\": []string{test.location},\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tauditLogger, actualAuditLog := plog.TestAuditLogger(t)\n\n\t\t\tsubject := requestLogger{\n\t\t\t\tauditLogger: auditLogger,\n\t\t\t\tstartTime:   startTime,\n\t\t\t\tclock:       frozenClock,\n\t\t\t\treq: &http.Request{\n\t\t\t\t\tURL: &url.URL{\n\t\t\t\t\t\tPath: test.reqPath,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tstatus:             777,\n\t\t\t\tw:                  mockResponseWriter,\n\t\t\t\tauditInternalPaths: test.auditInternalPaths,\n\t\t\t}\n\n\t\t\tsubject.logRequestComplete()\n\n\t\t\ttestutil.CompareAuditLogs(t, test.wantAuditLogs, actualAuditLog.String())\n\t\t})\n\t}\n}\n"
