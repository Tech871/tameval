[meta]
task = "repair"
scenario = "repair_duplicate_entity"

[lang_info]
lang = "Go"
go_version = "1.21"

[repo_info]
repository = "ozontech/file.d"
sha = "0b8e06edc7baa07bda8b1d7637edf1ae5108ea4b"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pipeline/antispam/antispammer.go pipeline/antispam/antispammer_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pipeline/antispam/antispammer.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 80.0
mutation_kill_rate = 0.0
original_mutation_kill_rate = 46.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "pipeline/antispam/antispammer_test.go"
focal_file_path = "pipeline/antispam/antispammer.go"
test_file_url = "https://github.com/ozontech/file.d/blob/0b8e06edc7baa07bda8b1d7637edf1ae5108ea4b/pipeline/antispam/antispammer_test.go"
focal_file_url = "https://github.com/ozontech/file.d/blob/0b8e06edc7baa07bda8b1d7637edf1ae5108ea4b/pipeline/antispam/antispammer.go"
first_commit_date = "2023-03-30"
last_commit_date = "2025-01-29"
test_file_content = "package antispam\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/ozontech/file.d/cfg/matchrule\"\n\t\"github.com/ozontech/file.d/logger\"\n\t\"github.com/ozontech/file.d/metric\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/testutil\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc newAntispammer(threshold, unbanIterations int, maintenanceInterval time.Duration) *Antispammer {\n\tholder := metric.NewHolder(time.Minute)\n\treturn NewAntispammer(&Options{\n\t\tMaintenanceInterval: maintenanceInterval,\n\t\tThreshold:           threshold,\n\t\tUnbanIterations:     unbanIterations,\n\t\tLogger:              logger.Instance.Named(\"antispam\").Desugar(),\n\t\tMetricsController:   metric.NewCtl(\"test\", prometheus.NewRegistry()),\n\t\tMetricHolder:        holder,\n\t})\n}\n\nfunc newAntispammer(threshold, unbanIterations int, maintenanceInterval time.Duration) *Antispammer {\n\tholder := metric.NewHolder(time.Minute)\n\treturn NewAntispammer(&Options{\n\t\tMaintenanceInterval: maintenanceInterval,\n\t\tThreshold:           threshold,\n\t\tUnbanIterations:     unbanIterations,\n\t\tLogger:              logger.Instance.Named(\"antispam\").Desugar(),\n\t\tMetricsController:   metric.NewCtl(\"test\", prometheus.NewRegistry()),\n\t\tMetricHolder:        holder,\n\t})\n}\n\nfunc TestAntispam(t *testing.T) {\n\tr := require.New(t)\n\n\tthreshold := 5\n\tunbanIterations := 2\n\tmaintenanceInterval := time.Second * 1\n\n\tantispamer := newAntispammer(threshold, unbanIterations, maintenanceInterval)\n\n\tstartTime := time.Now()\n\tcheckSpam := func(i int) bool {\n\t\teventTime := startTime.Add(time.Duration(i) * maintenanceInterval / 2)\n\t\treturn antispamer.IsSpam(\"1\", \"test\", false, []byte(`{}`), eventTime)\n\t}\n\n\tfor i := 1; i < threshold; i++ {\n\t\tresult := checkSpam(i)\n\t\tr.False(result)\n\t}\n\n\tfor i := 0; i <= unbanIterations-1; i++ {\n\t\tresult := checkSpam(threshold + i)\n\t\tr.True(result)\n\t\tantispamer.Maintenance()\n\t}\n\n\tresult := checkSpam(threshold + 1)\n\tr.False(result)\n}\n\nfunc TestAntispamAfterRestart(t *testing.T) {\n\tr := require.New(t)\n\n\tthreshold := 5\n\tunbanIterations := 2\n\tmaintenanceInterval := time.Second * 1\n\n\tantispamer := newAntispammer(threshold, unbanIterations, maintenanceInterval)\n\n\tstartTime := time.Now()\n\tcheckSpam := func(i int) bool {\n\t\teventTime := startTime.Add(time.Duration(i) * maintenanceInterval)\n\t\treturn antispamer.IsSpam(\"1\", \"test\", false, []byte(`{}`), eventTime)\n\t}\n\n\tfor i := 1; i < threshold; i++ {\n\t\tresult := checkSpam(i)\n\t\tr.False(result)\n\t}\n\n\tresult := checkSpam(threshold)\n\tr.False(result)\n}\n\nfunc TestAntispamExceptions(t *testing.T) {\n\tr := require.New(t)\n\tnow := time.Now()\n\n\tthreshold := 1\n\tunbanIterations := 2\n\tmaintenanceInterval := time.Second * 1\n\n\tantispamer := newAntispammer(threshold, unbanIterations, maintenanceInterval)\n\n\teventRulesetName := \"test_event\"\n\tsourceRulesetName := \"test_sourcename\"\n\n\tantispamer.exceptions = Exceptions{\n\t\t{\n\t\t\tRuleSet: matchrule.RuleSet{\n\t\t\t\tName: eventRulesetName,\n\t\t\t\tCond: matchrule.CondOr,\n\t\t\t\tRules: []matchrule.Rule{\n\t\t\t\t\t{\n\t\t\t\t\t\tMode: matchrule.ModePrefix,\n\t\t\t\t\t\tValues: []string{\n\t\t\t\t\t\t\t`{\"level\":\"debug\"`,\n\t\t\t\t\t\t\t`{\"level\":\"info\"`,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tMode:   matchrule.ModeContains,\n\t\t\t\t\t\tValues: []string{\"test_event\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tCheckSourceName: true,\n\t\t\tRuleSet: matchrule.RuleSet{\n\t\t\t\tName: sourceRulesetName,\n\t\t\t\tCond: matchrule.CondAnd,\n\t\t\t\tRules: []matchrule.Rule{\n\t\t\t\t\t{\n\t\t\t\t\t\tMode:   matchrule.ModeContains,\n\t\t\t\t\t\tValues: []string{\"my_source1\", \"my_source2\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tantispamer.exceptions.Prepare()\n\n\tcheckSpam := func(source, event string, wantMetric map[string]float64) {\n\t\tantispamer.IsSpam(\"1\", source, true, []byte(event), now)\n\t\tfor k, v := range wantMetric {\n\t\t\tr.Equal(v, testutil.ToFloat64(antispamer.exceptionMetric.WithLabelValues(k)))\n\t\t}\n\t}\n\n\tcheckSpam(\"test\", `{\"level\":\"info\",\"message\":test\"}`, map[string]float64{\n\t\teventRulesetName:  1,\n\t\tsourceRulesetName: 0,\n\t})\n\n\tcheckSpam(\"test\", `{\"level\":\"error\",\"message\":test_event123\"}`, map[string]float64{\n\t\teventRulesetName:  2,\n\t\tsourceRulesetName: 0,\n\t})\n\n\tcheckSpam(\"my_source2\", `{\"level\":\"error\",\"message\":test\"}`, map[string]float64{\n\t\teventRulesetName:  2,\n\t\tsourceRulesetName: 1,\n\t})\n\n\tcheckSpam(\"my_source1\", `{\"level\":\"debug\",\"message\":test\"}`, map[string]float64{\n\t\teventRulesetName:  3,\n\t\tsourceRulesetName: 1,\n\t})\n\n\tcheckSpam(\"test\", `{\"level\":\"error\",\"message\":test\"}`, map[string]float64{\n\t\teventRulesetName:  3,\n\t\tsourceRulesetName: 1,\n\t})\n}\n\nfunc TestAntispamExceptions(t *testing.T) {\n\tr := require.New(t)\n\tnow := time.Now()\n\n\tthreshold := 1\n\tunbanIterations := 2\n\tmaintenanceInterval := time.Second * 1\n\n\tantispamer := newAntispammer(threshold, unbanIterations, maintenanceInterval)\n\n\teventRulesetName := \"test_event\"\n\tsourceRulesetName := \"test_sourcename\"\n\n\tantispamer.exceptions = Exceptions{\n\t\t{\n\t\t\tRuleSet: matchrule.RuleSet{\n\t\t\t\tName: eventRulesetName,\n\t\t\t\tCond: matchrule.CondOr,\n\t\t\t\tRules: []matchrule.Rule{\n\t\t\t\t\t{\n\t\t\t\t\t\tMode: matchrule.ModePrefix,\n\t\t\t\t\t\tValues: []string{\n\t\t\t\t\t\t\t`{\"level\":\"debug\"`,\n\t\t\t\t\t\t\t`{\"level\":\"info\"`,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tMode:   matchrule.ModeContains,\n\t\t\t\t\t\tValues: []string{\"test_event\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tCheckSourceName: true,\n\t\t\tRuleSet: matchrule.RuleSet{\n\t\t\t\tName: sourceRulesetName,\n\t\t\t\tCond: matchrule.CondAnd,\n\t\t\t\tRules: []matchrule.Rule{\n\t\t\t\t\t{\n\t\t\t\t\t\tMode:   matchrule.ModeContains,\n\t\t\t\t\t\tValues: []string{\"my_source1\", \"my_source2\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tantispamer.exceptions.Prepare()\n\n\tcheckSpam := func(source, event string, wantMetric map[string]float64) {\n\t\tantispamer.IsSpam(\"1\", source, true, []byte(event), now)\n\t\tfor k, v := range wantMetric {\n\t\t\tr.Equal(v, testutil.ToFloat64(antispamer.exceptionMetric.WithLabelValues(k)))\n\t\t}\n\t}\n\n\tcheckSpam(\"test\", `{\"level\":\"info\",\"message\":test\"}`, map[string]float64{\n\t\teventRulesetName:  1,\n\t\tsourceRulesetName: 0,\n\t})\n\n\tcheckSpam(\"test\", `{\"level\":\"error\",\"message\":test_event123\"}`, map[string]float64{\n\t\teventRulesetName:  2,\n\t\tsourceRulesetName: 0,\n\t})\n\n\tcheckSpam(\"my_source2\", `{\"level\":\"error\",\"message\":test\"}`, map[string]float64{\n\t\teventRulesetName:  2,\n\t\tsourceRulesetName: 1,\n\t})\n\n\tcheckSpam(\"my_source1\", `{\"level\":\"debug\",\"message\":test\"}`, map[string]float64{\n\t\teventRulesetName:  3,\n\t\tsourceRulesetName: 1,\n\t})\n\n\tcheckSpam(\"test\", `{\"level\":\"error\",\"message\":test\"}`, map[string]float64{\n\t\teventRulesetName:  3,\n\t\tsourceRulesetName: 1,\n\t})\n}"
