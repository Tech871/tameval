[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "ArduPilot/MethodicConfigurator"
sha = "8f14cac0abb19c133ba74e6693d4efb6385cb8f0"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "(pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=ardupilot_methodic_configurator/backend_filesystem_vehicle_components.py -m pytest -q --junit-xml=test_output.xml tests/test_backend_filesystem_vehicle_components.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target ardupilot_methodic_configurator.backend_filesystem_vehicle_components --unit-test tests.test_backend_filesystem_vehicle_components --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target ardupilot_methodic_configurator/backend_filesystem_vehicle_components.py --unit-test tests/test_backend_filesystem_vehicle_components.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 88.0
original_coverage = 88.0
mutation_kill_rate = 100.0
original_mutation_kill_rate = 100.0
covered_lines = [ 10, 11, 12, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 32, 35, 36, 39, 41, 47, 49, 58, 61, 64, 65, 66, 67, 70, 71, 72, 74, 77, 78, 79, 80, 81, 82, 84, 85, 87, 89, 95, 96, 97, 99, 100, 101, 102, 107, 109, 115, 116, 117, 119, 120, 121, 122, 123, 124, 127, 129, 140, 143, 145, 147, 150, 151, 152, 155, 157, 158, 159, 163, 164, 165, 167, 168, 170, 171, 174, 175, 177, 179, 180, 181, 185, 187, 188, 189, 190, 191, 194, 195, 198, 200, 201, 204, 207, 210, 212, 213, 218, 219, 222, 223, 224, 225, 226, 227, 230, 232, 233, 234, 235, 236, 239, 240, 241, 242, 245, 246, 247, 248, 250, 257, 259, 260, 262, 270, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 295, 296, 297, 299, 300, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 323, 325, 326, 327, 328, 330, 338, 339, 340, 341, 370, 371, 372, 373, 377, 379, 385, 386, 388, 389, 391, 392, 394, 395, 396, 397, 398, 399, 400, 401, 402, 404, 407, 447,]
missed_lines = [ 103, 104, 105, 106, 125, 126, 160, 166, 182, 208, 215, 237, 238, 243, 244, 374, 375, 409, 410, 412, 437, 438, 440, 441, 442, 443, 444, 448,]

[input_info]
test_file_path = "tests/test_backend_filesystem_vehicle_components.py"
focal_file_path = "ardupilot_methodic_configurator/backend_filesystem_vehicle_components.py"
test_file_url = "https://github.com/ArduPilot/MethodicConfigurator/blob/8f14cac0abb19c133ba74e6693d4efb6385cb8f0/tests/test_backend_filesystem_vehicle_components.py"
focal_file_url = "https://github.com/ArduPilot/MethodicConfigurator/blob/8f14cac0abb19c133ba74e6693d4efb6385cb8f0/ardupilot_methodic_configurator/backend_filesystem_vehicle_components.py"
first_commit_date = "2024-12-02"
last_commit_date = "2025-08-16"
test_file_content = "#!/usr/bin/env python3\n\n\"\"\"\nTests for the backend_filesystem_vehicle_components.py file.\n\nThis file is part of Ardupilot methodic configurator. https://github.com/ArduPilot/MethodicConfigurator\n\nSPDX-FileCopyrightText: 2024-2025 Amilcar do Carmo Lucas <amilcar.lucas@iav.de>\n\nSPDX-License-Identifier: GPL-3.0-or-later\n\"\"\"\n\nimport os.path\nimport unittest\nfrom json.decoder import JSONDecodeError as RealJSONDecodeError\nfrom unittest.mock import mock_open, patch\n\nfrom ardupilot_methodic_configurator.backend_filesystem_vehicle_components import VehicleComponents\nfrom ardupilot_methodic_configurator.data_model_template_overview import TemplateOverview\n\n# pylint: disable=protected-access\n\n\nclass TestVehicleComponents(unittest.TestCase):  # pylint: disable=too-many-public-methods\n    \"\"\"VehicleComponents test class.\"\"\"\n\n    def setUp(self) -> None:\n        self.vehicle_components = VehicleComponents()\n        # Sample valid schema\n        self.valid_schema = {\n            \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n            \"type\": \"object\",\n            \"properties\": {\"Components\": {\"type\": \"object\"}},\n            \"required\": [\"Components\"],\n        }\n        # Sample valid component data\n        self.valid_component_data = {\n            \"Components\": {\"Flight Controller\": {\"Firmware\": {\"Type\": \"ArduCopter\", \"Version\": \"4.3.0\"}}}\n        }\n        # Sample invalid component data\n        self.invalid_component_data: dict[str, dict] = {\"WrongKey\": {\"Flight Controller\": {}}}\n\n        # Detailed schema with MCU Series for testing modify_schema_for_mcu_series\n        self.schema_with_mcu_series = {\n            \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n            \"definitions\": {\n                \"flightController\": {\n                    \"allOf\": [\n                        {\n                            \"properties\": {\n                                \"Specifications\": {\n                                    \"type\": \"object\",\n                                    \"properties\": {\n                                        \"MCU Series\": {\n                                            \"type\": \"string\",\n                                            \"description\": \"Microcontroller series used in the flight controller\",\n                                        }\n                                    },\n                                }\n                            }\n                        }\n                    ]\n                }\n            },\n            \"properties\": {\n                \"Components\": {\n                    \"type\": \"object\",\n                    \"properties\": {\"Flight Controller\": {\"$ref\": \"#/definitions/flightController\"}},\n                }\n            },\n        }\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_load_schema(self, mock_fs_class) -> None:  # type: ignore[misc]\n        mock_fs = mock_fs_class.return_value\n        mock_fs.load_schema.return_value = self.valid_schema\n\n        # Create a new instance so it uses the mocked FilesystemJSONWithSchema\n        vehicle_components = VehicleComponents()\n        result = vehicle_components.load_schema()\n\n        assert result == self.valid_schema\n        mock_fs.load_schema.assert_called_once()\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_validate_vehicle_components_valid(self, mock_fs_class) -> None:  # type: ignore[misc]\n        mock_fs = mock_fs_class.return_value\n        mock_fs.validate_json_against_schema.return_value = (True, \"\")\n\n        vehicle_components = VehicleComponents()\n        is_valid, error_message = vehicle_components.validate_vehicle_components(self.valid_component_data)\n        assert is_valid\n        assert error_message == \"\"\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_validate_vehicle_components_invalid(self, mock_fs_class) -> None:  # type: ignore[misc]\n        mock_fs = mock_fs_class.return_value\n        mock_fs.validate_json_against_schema.return_value = (False, \"Validation error\")\n\n        vehicle_components = VehicleComponents()\n        is_valid, error_message = vehicle_components.validate_vehicle_components(self.invalid_component_data)\n        assert not is_valid\n        assert \"Validation error\" in error_message\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_load_vehicle_components_json_data(self, mock_fs_class) -> None:  # type: ignore[misc]\n        mock_fs = mock_fs_class.return_value\n        mock_fs.load_json_data.return_value = self.valid_component_data\n\n        vehicle_components = VehicleComponents()\n        result = vehicle_components.load_vehicle_components_json_data(\"/test/dir\")\n\n        assert result == self.valid_component_data\n        mock_fs.load_json_data.assert_called_once_with(\"/test/dir\")\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_save_vehicle_components_json_data_valid(self, mock_fs_class) -> None:  # type: ignore[misc]\n        mock_fs = mock_fs_class.return_value\n        mock_fs.save_json_data.return_value = (False, \"\")\n\n        vehicle_components = VehicleComponents()\n        result, _msg = vehicle_components.save_vehicle_components_json_data(self.valid_component_data, \"/test/dir\")\n\n        assert not result  # False means success\n        mock_fs.save_json_data.assert_called_once_with(self.valid_component_data, \"/test/dir\")\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_save_vehicle_components_json_data_invalid(self, mock_fs_class) -> None:  # type: ignore[misc]\n        mock_fs = mock_fs_class.return_value\n        mock_fs.save_json_data.return_value = (True, \"Validation error\")\n\n        vehicle_components = VehicleComponents()\n        result, _msg = vehicle_components.save_vehicle_components_json_data(self.invalid_component_data, \"/test/dir\")\n\n        assert result  # True means failure\n\n    def test_get_fc_fw_type_from_vehicle_components_json(self) -> None:\n        self.vehicle_components.vehicle_components_fs.data = self.valid_component_data\n        fw_type = self.vehicle_components.get_fc_fw_type_from_vehicle_components_json()\n        assert fw_type == \"ArduCopter\"\n\n        # Test with unsupported firmware type\n        invalid_data = {\"Components\": {\"Flight Controller\": {\"Firmware\": {\"Type\": \"UnsupportedType\", \"Version\": \"4.3.0\"}}}}\n        self.vehicle_components.vehicle_components_fs.data = invalid_data\n        fw_type = self.vehicle_components.get_fc_fw_type_from_vehicle_components_json()\n        assert fw_type == \"\"\n\n    def test_get_fc_fw_version_from_vehicle_components_json(self) -> None:\n        self.vehicle_components.vehicle_components_fs.data = self.valid_component_data\n        version = self.vehicle_components.get_fc_fw_version_from_vehicle_components_json()\n        assert version == \"4.3.0\"\n\n        # Test with invalid version format\n        invalid_data = {\n            \"Components\": {\"Flight Controller\": {\"Firmware\": {\"Type\": \"ArduCopter\", \"Version\": \"invalid-version\"}}}\n        }\n        self.vehicle_components.vehicle_components_fs.data = invalid_data\n        version = self.vehicle_components.get_fc_fw_version_from_vehicle_components_json()\n        assert version == \"\"\n\n    def test_supported_vehicles(self) -> None:\n        supported = VehicleComponents.supported_vehicles()\n        assert isinstance(supported, tuple)\n        assert \"ArduCopter\" in supported\n        assert \"ArduPlane\" in supported\n        assert len(supported) >= 9  # Ensure all expected vehicles are present\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_walk\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_path.relpath\")\n    @patch.object(VehicleComponents, \"load_vehicle_components_json_data\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    def test_get_vehicle_components_overviews(  # type: ignore[misc]\n        self,\n        mock_get_base_dir,\n        mock_load_data,\n        mock_relpath,\n        mock_walk,\n    ) -> None:\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_walk.return_value = [\n            (\"/templates/copter\", [], [\"vehicle_components.json\"]),\n            (\"/templates/plane\", [], [\"vehicle_components.json\"]),\n        ]\n        mock_relpath.side_effect = [\"copter\", \"plane\"]\n        mock_load_data.side_effect = [\n            {\"Components\": {\"Flight Controller\": {\"Firmware\": {\"Type\": \"ArduCopter\"}}}},\n            {\"Components\": {\"Flight Controller\": {\"Firmware\": {\"Type\": \"ArduPlane\"}}}},\n        ]\n\n        result = VehicleComponents.get_vehicle_components_overviews()\n\n        assert len(result) == 2\n        assert \"copter\" in result\n        assert \"plane\" in result\n        assert isinstance(result[\"copter\"], TemplateOverview)\n        assert isinstance(result[\"plane\"], TemplateOverview)\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    @patch(\"os.path.join\")\n    def test_get_vehicle_image_filepath(self, mock_join, mock_get_base_dir) -> None:  # type: ignore[misc]\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_join.return_value = \"/templates/copter/vehicle.jpg\"\n\n        result = VehicleComponents.get_vehicle_image_filepath(\"copter\")\n\n        mock_get_base_dir.assert_called_once()\n        mock_join.assert_called_once_with(\"/templates\", \"copter\", \"vehicle.jpg\")\n        assert result == \"/templates/copter/vehicle.jpg\"\n\n    def test_wipe_component_info(self) -> None:\n        # Test with nested dictionary containing various data types\n        test_data = {\n            \"Components\": {\n                \"Flight Controller\": {\n                    \"Firmware\": {\"Type\": \"ArduCopter\", \"Version\": \"4.3.0\"},\n                    \"Hardware\": {\"Model\": \"Pixhawk\", \"Ports\": 5, \"Sensors\": [\"GPS\", \"Barometer\", \"IMU\"]},\n                    \"Options\": {\"Enabled\": True, \"Value\": 42.5},\n                }\n            }\n        }\n        self.vehicle_components.vehicle_components_fs.data = test_data\n\n        # Call the method to wipe\n        self.vehicle_components.wipe_component_info()\n\n        # Verify structure is preserved but values are cleared\n        result = self.vehicle_components.vehicle_components_fs.data\n        assert \"Components\" in result\n        assert \"Flight Controller\" in result[\"Components\"]\n        assert \"Firmware\" in result[\"Components\"][\"Flight Controller\"]\n        assert result[\"Components\"][\"Flight Controller\"][\"Firmware\"][\"Type\"] == \"\"\n        assert result[\"Components\"][\"Flight Controller\"][\"Firmware\"][\"Version\"] == \"\"\n        assert result[\"Components\"][\"Flight Controller\"][\"Hardware\"][\"Model\"] == \"\"\n        assert result[\"Components\"][\"Flight Controller\"][\"Hardware\"][\"Ports\"] == 0\n        assert result[\"Components\"][\"Flight Controller\"][\"Hardware\"][\"Sensors\"] == []\n        assert result[\"Components\"][\"Flight Controller\"][\"Options\"][\"Enabled\"] == 0\n        assert result[\"Components\"][\"Flight Controller\"][\"Options\"][\"Value\"] == 0.0\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_save_vehicle_components_json_data_file_not_found(self, mock_fs_class) -> None:  # type: ignore[misc]\n        mock_fs = mock_fs_class.return_value\n        mock_fs.save_json_data.return_value = (True, \"File not found\")\n\n        vehicle_components = VehicleComponents()\n        result, msg = vehicle_components.save_vehicle_components_json_data(self.valid_component_data, \"/nonexistent/dir\")\n\n        assert result  # True means error\n        assert \"not found\" in msg\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_save_vehicle_components_json_data_permission_error(self, mock_fs_class) -> None:  # type: ignore[misc]\n        mock_fs = mock_fs_class.return_value\n        mock_fs.save_json_data.return_value = (True, \"Permission denied\")\n\n        vehicle_components = VehicleComponents()\n        result, msg = vehicle_components.save_vehicle_components_json_data(self.valid_component_data, \"/test/dir\")\n\n        assert result  # True means error\n        assert \"Permission denied\" in msg\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_save_vehicle_components_json_data_is_a_directory_error(self, mock_fs_class) -> None:  # type: ignore[misc]\n        mock_fs = mock_fs_class.return_value\n        mock_fs.save_json_data.return_value = (True, \"path is a directory\")\n\n        vehicle_components = VehicleComponents()\n        result, msg = vehicle_components.save_vehicle_components_json_data(self.valid_component_data, \"/test/dir\")\n\n        assert result  # True means error\n        assert \"is a directory\" in msg.lower()\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_save_vehicle_components_json_data_os_error(self, mock_fs_class) -> None:  # type: ignore[misc]\n        mock_fs = mock_fs_class.return_value\n        mock_fs.save_json_data.return_value = (True, \"OS error: Disk full\")\n\n        vehicle_components = VehicleComponents()\n        result, msg = vehicle_components.save_vehicle_components_json_data(self.valid_component_data, \"/test/dir\")\n\n        assert result  # True means error\n        assert \"OS error\" in msg\n        assert \"Disk full\" in msg\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_save_vehicle_components_json_data_type_error(self, mock_fs_class) -> None:  # type: ignore[misc]\n        mock_fs = mock_fs_class.return_value\n        mock_fs.save_json_data.return_value = (True, \"Type error: Invalid type\")\n\n        vehicle_components = VehicleComponents()\n        result, msg = vehicle_components.save_vehicle_components_json_data(self.valid_component_data, \"/test/dir\")\n\n        assert result  # True means error\n        assert \"Type error\" in msg\n        assert \"Invalid type\" in msg\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_save_vehicle_components_json_data_value_error(self, mock_fs_class) -> None:  # type: ignore[misc]\n        mock_fs = mock_fs_class.return_value\n        mock_fs.save_json_data.return_value = (True, \"Value error: Circular reference\")\n\n        vehicle_components = VehicleComponents()\n        result, msg = vehicle_components.save_vehicle_components_json_data(self.valid_component_data, \"/test/dir\")\n\n        assert result  # True means error\n        assert \"Value error\" in msg\n        assert \"Circular reference\" in msg\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    @patch(\"builtins.open\", new_callable=mock_open)\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_load\")\n    def test_load_system_templates(self, mock_json_load, mock_file, mock_get_base_dir) -> None:  # type: ignore[misc]\n        \"\"\"Test loading system templates.\"\"\"\n        system_templates = {\n            \"TestComponent\": [\n                {\"name\": \"System Template 1\", \"data\": {\"param1\": \"value1\"}},\n                {\"name\": \"System Template 2\", \"data\": {\"param2\": \"value2\"}},\n            ]\n        }\n        mock_json_load.return_value = system_templates\n        mock_get_base_dir.return_value = \"/app/path\"\n\n        # Call the method to load system templates\n        result = self.vehicle_components._load_system_templates()  # pylint: disable=protected-access\n\n        # Verify the result\n        assert result == system_templates\n\n        # Verify the correct path was used\n        expected_path = os.path.join(\"/app/path\", \"system_vehicle_components_template.json\")\n        mock_file.assert_called_once_with(expected_path, encoding=\"utf-8\")\n        mock_json_load.assert_called_once()\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    @patch(\"builtins.open\", new_callable=mock_open)\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_load\")\n    def test_load_user_templates(self, mock_json_load, mock_file, mock_get_base_dir) -> None:  # type: ignore[misc]\n        \"\"\"Test loading user templates.\"\"\"\n        user_templates = {\"TestComponent\": [{\"name\": \"User Template\", \"data\": {\"param1\": \"custom\"}}]}\n        mock_json_load.return_value = user_templates\n        mock_get_base_dir.return_value = \"/user/templates\"\n\n        # Call the method to load user templates\n        result = self.vehicle_components._load_user_templates()  # pylint: disable=protected-access\n\n        # Verify the result\n        assert result == user_templates\n\n        # Verify the file was opened from the correct location\n        expected_path = os.path.join(\"/user/templates\", \"user_vehicle_components_template.json\")\n        mock_file.assert_called_once_with(expected_path, encoding=\"utf-8\")\n        mock_json_load.assert_called_once()\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"_load_user_templates\")\n    def test_load_component_templates_merge(self, mock_load_user, mock_load_system) -> None:  # type: ignore[misc]\n        \"\"\"Test that system and user templates are properly merged with user templates taking precedence.\"\"\"\n        # Setup system templates\n        system_templates = {\n            \"Component1\": [\n                {\"name\": \"Template A\", \"data\": {\"original\": \"value\"}},\n                {\"name\": \"Template B\", \"data\": {\"system\": \"value\"}},\n            ],\n            \"Component2\": [{\"name\": \"System Only\", \"data\": {\"system\": \"unchanged\"}}],\n        }\n\n        # Setup user templates with one overriding system template and one new template\n        user_templates = {\n            \"Component1\": [\n                {\"name\": \"Template A\", \"data\": {\"modified\": \"value\"}},  # Overrides system template\n                {\"name\": \"User Only\", \"data\": {\"user\": \"value\"}},  # New template\n            ]\n        }\n\n        mock_load_system.return_value = system_templates\n        mock_load_user.return_value = user_templates\n\n        # Call the method to load and merge templates\n        result = self.vehicle_components.load_component_templates()\n\n        # Verify system templates were loaded\n        assert \"Component1\" in result\n        assert \"Component2\" in result\n\n        # Verify Component1 has all templates (2 from system, 1 new from user)\n        component1_templates = result[\"Component1\"]\n        assert len(component1_templates) == 3\n\n        # Find templates by name\n        template_a = next((t for t in component1_templates if t[\"name\"] == \"Template A\"), None)\n        template_b = next((t for t in component1_templates if t[\"name\"] == \"Template B\"), None)\n        user_only = next((t for t in component1_templates if t[\"name\"] == \"User Only\"), None)\n\n        # Verify Template A was overridden by user template\n        assert template_a is not None\n        assert template_a[\"data\"][\"modified\"] == \"value\"\n        assert \"original\" not in template_a[\"data\"]\n        assert template_a.get(\"is_user_modified\") is True\n\n        # Verify Template B remains unchanged\n        assert template_b is not None\n        assert template_b[\"data\"][\"system\"] == \"value\"\n\n        # Verify new user template was added\n        assert user_only is not None\n        assert user_only[\"data\"][\"user\"] == \"value\"\n        assert user_only.get(\"is_user_modified\") is True\n\n        # Verify Component2 templates remain unchanged\n        assert len(result[\"Component2\"]) == 1\n        assert result[\"Component2\"][0][\"name\"] == \"System Only\"\n        assert result[\"Component2\"][0][\"data\"][\"system\"] == \"unchanged\"\n\n    @patch(\"builtins.open\", new_callable=mock_open)\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_load\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.logging_debug\")\n    def test_load_user_templates_file_not_found(self, mock_logging_debug, mock_json_load, mock_file) -> None:  # type: ignore[misc] # pylint: disable=unused-argument\n        \"\"\"Test loading user templates when the file doesn't exist.\"\"\"\n        # Setup the mock to raise FileNotFoundError\n        mock_file.side_effect = FileNotFoundError()\n\n        # Call the method - this should handle the exception internally\n        result = self.vehicle_components._load_user_templates()  # pylint: disable=protected-access\n\n        # Verify an empty dict is returned\n        assert result == {}\n        # Verify the logging message was called\n        mock_logging_debug.assert_called_once()\n        assert \"not found\" in str(mock_logging_debug.call_args)\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"_load_user_templates\")\n    def test_load_component_templates_no_user_templates(self, mock_load_user, mock_load_system) -> None:  # type: ignore[misc]\n        \"\"\"Test loading component templates when no user templates exist.\"\"\"\n        system_templates = {\"Component1\": [{\"name\": \"System Template\", \"data\": {\"param\": \"value\"}}]}\n\n        mock_load_system.return_value = system_templates\n        mock_load_user.return_value = {}\n\n        # Call the method\n        result = self.vehicle_components.load_component_templates()\n\n        # Verify only system templates are returned, unmodified\n        assert result == system_templates\n        assert not result[\"Component1\"][0].get(\"is_user_modified\", False)\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"_load_user_templates\")\n    def test_load_component_templates_no_system_templates(  # type: ignore[misc]\n        self,\n        mock_load_user,\n        mock_load_system,\n    ) -> None:\n        \"\"\"Test loading component templates when no system templates exist.\"\"\"\n        user_templates = {\"Component1\": [{\"name\": \"User Template\", \"data\": {\"param\": \"value\"}}]}\n\n        mock_load_system.return_value = {}\n        mock_load_user.return_value = user_templates\n\n        # Call the method\n        result = self.vehicle_components.load_component_templates()\n\n        # Verify user templates are returned with is_user_modified flag\n        assert \"Component1\" in result\n        assert len(result[\"Component1\"]) == 1\n        assert result[\"Component1\"][0][\"name\"] == \"User Template\"\n        assert result[\"Component1\"][0][\"is_user_modified\"] is True\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"_load_user_templates\")\n    @patch(\"builtins.open\", new_callable=mock_open)\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_dump\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_makedirs\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    def test_save_component_templates_basic(  # type: ignore[misc] # pylint: disable=too-many-arguments, too-many-positional-arguments\n        self, mock_get_base_dir, mock_makedirs, mock_json_dump, mock_file, mock_load_user, mock_load_system\n    ) -> None:\n        \"\"\"Test basic successful saving of component templates.\"\"\"\n        # Setup\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_load_system.return_value = {}\n        mock_load_user.return_value = {}\n\n        templates = {\"Component1\": [{\"name\": \"Test Template\", \"data\": {\"param\": \"value\"}, \"is_user_modified\": True}]}\n\n        # Call method\n        result, msg = self.vehicle_components.save_component_templates(templates)\n\n        # Verify results\n        assert not result  # False means success\n        assert msg == \"\"\n\n        # Verify directory was created\n        mock_makedirs.assert_called_once_with(\"/templates\", exist_ok=True)\n\n        # Verify file was opened correctly\n        expected_path = os.path.join(\"/templates\", \"user_vehicle_components_template.json\")\n        mock_file.assert_called_once_with(expected_path, \"w\", encoding=\"utf-8\")\n\n        # Verify JSON was dumped with is_user_modified flag removed\n        expected_save = {\"Component1\": [{\"name\": \"Test Template\", \"data\": {\"param\": \"value\"}}]}\n        mock_json_dump.assert_called_once()\n        args, kwargs = mock_json_dump.call_args\n        assert args[0] == expected_save  # First argument should be the data\n        assert kwargs[\"indent\"] == 4\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"_load_user_templates\")\n    @patch(\"builtins.open\", new_callable=mock_open)\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_dump\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_makedirs\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    def test_save_component_templates_only_modified(  # type: ignore[misc] # pylint: disable=too-many-arguments, too-many-positional-arguments\n        self,\n        mock_get_base_dir,\n        mock_makedirs,  # pylint: disable=unused-argument\n        mock_json_dump,\n        mock_file,  # pylint: disable=unused-argument\n        mock_load_user,\n        mock_load_system,\n    ) -> None:\n        \"\"\"Test that only user-modified templates are saved.\"\"\"\n        # Setup system templates\n        system_templates = {\n            \"Component1\": [\n                {\"name\": \"Template A\", \"data\": {\"original\": \"value\"}},\n                {\"name\": \"Template B\", \"data\": {\"system\": \"value\"}},\n            ]\n        }\n\n        # Setup templates with one modified and one unmodified\n        templates = {\n            \"Component1\": [\n                {\"name\": \"Template A\", \"data\": {\"original\": \"value\"}, \"is_user_modified\": True},  # Modified flag\n                {\"name\": \"Template B\", \"data\": {\"system\": \"value\"}},  # No modification\n            ]\n        }\n\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_load_system.return_value = system_templates\n        mock_load_user.return_value = {}\n\n        # Call method\n        result, msg = self.vehicle_components.save_component_templates(templates)\n\n        # Verify results\n        assert not result  # False means success\n        assert msg == \"\"\n\n        # Verify only Template A was saved (with is_user_modified flag removed)\n        expected_save = {\"Component1\": [{\"name\": \"Template A\", \"data\": {\"original\": \"value\"}}]}\n        mock_json_dump.assert_called_once()\n        args, _kwargs = mock_json_dump.call_args\n        assert args[0] == expected_save\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"_load_user_templates\")\n    @patch(\"builtins.open\", new_callable=mock_open)\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_dump\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_makedirs\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    def test_save_component_templates_different_data(  # type: ignore[misc] # pylint: disable=too-many-arguments, too-many-positional-arguments\n        self,\n        mock_get_base_dir,\n        mock_makedirs,  # pylint: disable=unused-argument\n        mock_json_dump,\n        mock_file,  # pylint: disable=unused-argument\n        mock_load_user,\n        mock_load_system,\n    ) -> None:\n        \"\"\"Test that templates with data different from system templates are saved.\"\"\"\n        # Setup system templates\n        system_templates = {\"Component1\": [{\"name\": \"Template A\", \"data\": {\"original\": \"value\"}}]}\n\n        # Setup templates with modified data but no is_user_modified flag\n        templates = {\n            \"Component1\": [\n                {\"name\": \"Template A\", \"data\": {\"modified\": \"new_value\"}}  # Different data\n            ]\n        }\n\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_load_system.return_value = system_templates\n        mock_load_user.return_value = {}\n\n        # Call method\n        result, msg = self.vehicle_components.save_component_templates(templates)\n\n        # Verify results\n        assert not result  # False means success\n        assert msg == \"\"\n\n        # Verify Template A was saved with new data\n        expected_save = {\"Component1\": [{\"name\": \"Template A\", \"data\": {\"modified\": \"new_value\"}}]}\n        mock_json_dump.assert_called_once()\n        args, _kwargs = mock_json_dump.call_args\n        assert args[0] == expected_save\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"_load_user_templates\")\n    @patch(\"builtins.open\", new_callable=mock_open)\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_dump\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_makedirs\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    def test_save_component_templates_not_in_system(  # type: ignore[misc] # pylint: disable=too-many-arguments, too-many-positional-arguments\n        self,\n        mock_get_base_dir,\n        mock_makedirs,  # pylint: disable=unused-argument\n        mock_json_dump,\n        mock_file,  # pylint: disable=unused-argument\n        mock_load_user,\n        mock_load_system,\n    ) -> None:\n        \"\"\"Test that templates not in system templates are saved.\"\"\"\n        # Setup system templates\n        system_templates = {\"Component1\": [{\"name\": \"System Template\", \"data\": {\"system\": \"value\"}}]}\n\n        # Setup templates with one new template not in system\n        templates = {\n            \"Component1\": [\n                {\"name\": \"System Template\", \"data\": {\"system\": \"value\"}},\n                {\"name\": \"New Template\", \"data\": {\"new\": \"value\"}},  # Not in system\n            ]\n        }\n\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_load_system.return_value = system_templates\n        mock_load_user.return_value = {}\n\n        # Call method\n        result, msg = self.vehicle_components.save_component_templates(templates)\n\n        # Verify results\n        assert not result  # False means success\n        assert msg == \"\"\n\n        # Verify only the new template was saved\n        expected_save = {\"Component1\": [{\"name\": \"New Template\", \"data\": {\"new\": \"value\"}}]}\n        mock_json_dump.assert_called_once()\n        args, _kwargs = mock_json_dump.call_args\n        assert args[0] == expected_save\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"_load_user_templates\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_makedirs\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    def test_save_component_templates_directory_error(  # type: ignore[misc]\n        self, mock_get_base_dir, mock_makedirs, mock_load_user, mock_load_system\n    ) -> None:\n        \"\"\"Test error handling when template directory cannot be created.\"\"\"\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_load_system.return_value = {}\n        mock_load_user.return_value = {}\n        mock_makedirs.side_effect = OSError(\"Permission denied\")\n\n        templates = {\"Component1\": [{\"name\": \"Test Template\", \"data\": {\"param\": \"value\"}, \"is_user_modified\": True}]}\n\n        # Call method\n        result, msg = self.vehicle_components.save_component_templates(templates)\n\n        # Verify results\n        assert result  # True means error\n        assert \"Failed to create templates directory\" in msg\n        assert \"Permission denied\" in msg\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"_load_user_templates\")\n    @patch(\"builtins.open\", new_callable=mock_open)\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_dump\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_makedirs\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    def test_save_component_templates_directory_creation_error(  # type: ignore[misc] # pylint: disable=too-many-arguments, too-many-positional-arguments\n        self, mock_get_base_dir, mock_makedirs, mock_json_dump, mock_file, mock_load_user, mock_load_system\n    ) -> None:\n        \"\"\"Test handling of directory creation errors.\"\"\"\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_makedirs.side_effect = PermissionError(\"Access denied\")\n        mock_load_system.return_value = {}\n        mock_load_user.return_value = {}\n\n        templates = {\"Component1\": [{\"name\": \"Test Template\", \"data\": {\"param\": \"value\"}}]}\n\n        # Call method\n        result, msg = self.vehicle_components.save_component_templates(templates)\n\n        # Verify error handling\n        assert result  # True means error\n        assert \"Failed to create templates directory\" in msg\n        assert \"Access denied\" in msg\n        mock_file.assert_not_called()\n        mock_json_dump.assert_not_called()\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"_load_user_templates\")\n    @patch(\"builtins.open\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_dump\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_makedirs\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    def test_save_component_templates_file_errors(  # type: ignore[misc] # pylint: disable=too-many-arguments, too-many-positional-arguments\n        self,\n        mock_get_base_dir,\n        mock_makedirs,  # pylint: disable=unused-argument\n        mock_json_dump,  # pylint: disable=unused-argument\n        mock_file,\n        mock_load_user,\n        mock_load_system,\n    ) -> None:\n        \"\"\"Test handling of file-related errors.\"\"\"\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_load_system.return_value = {}\n        mock_load_user.return_value = {}\n\n        # Test permission error\n        mock_file.side_effect = PermissionError()\n\n        templates = {\"Component1\": [{\"name\": \"Test Template\", \"data\": {\"param\": \"value\"}}]}\n\n        # Call method\n        result, msg = self.vehicle_components.save_component_templates(templates)\n\n        # Verify error handling\n        assert result  # True means error\n        assert \"Permission denied\" in msg\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"_load_user_templates\")\n    @patch(\"builtins.open\", new_callable=mock_open)\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_dump\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_makedirs\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    def test_save_component_templates_empty_input(  # type: ignore[misc] # pylint: disable=too-many-arguments, too-many-positional-arguments\n        self,\n        mock_get_base_dir,\n        mock_makedirs,  # pylint: disable=unused-argument\n        mock_json_dump,\n        mock_file,\n        mock_load_user,\n        mock_load_system,\n    ) -> None:\n        \"\"\"Test saving empty templates dictionary.\"\"\"\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_load_system.return_value = {}\n        mock_load_user.return_value = {}\n\n        # Call method with empty dictionary\n        result, msg = self.vehicle_components.save_component_templates({})\n\n        # Verify results\n        assert not result  # False means success\n        assert msg == \"\"\n        # Should save empty dict\n        mock_json_dump.assert_called_once_with({}, mock_file(), indent=4)\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"_load_user_templates\")\n    @patch(\"builtins.open\", new_callable=mock_open)\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_dump\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_makedirs\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    def test_save_component_templates_json_error(  # type: ignore[misc] # pylint: disable=too-many-arguments, too-many-positional-arguments\n        self,\n        mock_get_base_dir,\n        mock_makedirs,  # pylint: disable=unused-argument\n        mock_json_dump,\n        mock_file,  # pylint: disable=unused-argument\n        mock_load_user,\n        mock_load_system,\n    ) -> None:\n        \"\"\"Test handling JSON serialization error.\"\"\"\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_load_system.return_value = {}\n        mock_load_user.return_value = {}\n        mock_json_dump.side_effect = TypeError(\"Cannot serialize circular reference\")\n\n        templates = {\"Component1\": [{\"name\": \"Test Template\", \"data\": {\"param\": \"value\"}}]}\n\n        # Call method\n        result, msg = self.vehicle_components.save_component_templates(templates)\n\n        # Verify error handling\n        assert result  # True means error\n        assert \"Unexpected error\" in msg\n        assert \"Cannot serialize circular reference\" in msg\n\n    @patch.object(VehicleComponents, \"_load_system_templates\")\n    @patch.object(VehicleComponents, \"save_component_templates_to_file\")\n    def test_save_component_templates_to_system(  # type: ignore[misc]\n        self, mock_save_to_file, mock_load_system\n    ) -> None:\n        \"\"\"Test saving templates to system templates when save_component_to_system_templates is True.\"\"\"\n        # Setup system templates\n        system_templates = {\"ExistingComponent\": [{\"name\": \"Existing Template\", \"data\": {\"param\": \"value\"}}]}\n\n        # Setup new templates to save\n        new_templates = {\"NewComponent\": [{\"name\": \"New Template\", \"data\": {\"param\": \"new_value\"}}]}\n\n        # Set up the instance to save to system templates\n        self.vehicle_components.save_component_to_system_templates = True\n\n        # Mock loading system templates\n        mock_load_system.return_value = system_templates\n        mock_save_to_file.return_value = (False, \"\")  # No error\n\n        # Call the method\n        result, msg = self.vehicle_components.save_component_templates(new_templates)\n\n        # Verify success\n        assert not result  # False means success\n        assert msg == \"\"\n\n        # Capture what was passed to save_component_templates_to_file\n        saved_templates = mock_save_to_file.call_args[0][0]\n\n        # Verify that system templates and new templates were merged\n        assert \"ExistingComponent\" in saved_templates\n        assert \"NewComponent\" in saved_templates\n\n        # Verify existing component was preserved\n        assert len(saved_templates[\"ExistingComponent\"]) == 1\n        assert saved_templates[\"ExistingComponent\"][0][\"name\"] == \"Existing Template\"\n\n        # Verify new component was added\n        assert len(saved_templates[\"NewComponent\"]) == 1\n        assert saved_templates[\"NewComponent\"][0][\"name\"] == \"New Template\"\n        assert saved_templates[\"NewComponent\"][0][\"data\"][\"param\"] == \"new_value\"\n\n    def test_recursively_clear_dict_edge_cases(self) -> None:\n        \"\"\"Test edge cases for the recursive dictionary clearing method.\"\"\"\n        # Test with empty dictionary\n        empty_dict = {}\n        self.vehicle_components._recursively_clear_dict(empty_dict)\n        assert not empty_dict\n\n        # Test with nested empty dictionaries\n        nested_empty = {\"level1\": {\"level2\": {}}}\n        self.vehicle_components._recursively_clear_dict(nested_empty)\n        assert nested_empty == {\"level1\": {\"level2\": {}}}\n\n        # Test with None values\n        none_dict = {\"key1\": None, \"key2\": {\"nested\": None}}\n        self.vehicle_components._recursively_clear_dict(none_dict)\n        assert none_dict == {\"key1\": None, \"key2\": {\"nested\": None}}\n\n        # Test with mixed types including complex ones\n        complex_dict = {\n            \"string\": \"value\",\n            \"int\": 42,\n            \"float\": 3.14,\n            \"bool\": True,\n            \"list\": [\"a\", \"b\", \"c\"],\n            \"dict\": {\"nested\": \"value\"},\n            \"none\": None,\n            \"complex_nested\": {\n                \"strings\": [\"a\", \"b\"],\n                \"numbers\": [1, 2, 3],\n                \"mixed\": [1, \"a\", True],\n                \"deep\": {\"deeper\": {\"deepest\": \"value\"}},\n            },\n        }\n\n        self.vehicle_components._recursively_clear_dict(complex_dict)\n\n        # Verify all values are cleared properly\n        assert complex_dict[\"string\"] == \"\"\n        assert complex_dict[\"int\"] == 0\n        assert complex_dict[\"float\"] == 0.0\n        assert complex_dict[\"bool\"] is False\n        assert not complex_dict[\"list\"]\n        assert complex_dict[\"dict\"] == {\"nested\": \"\"}\n        assert complex_dict[\"none\"] is None\n        assert not complex_dict[\"complex_nested\"][\"strings\"]\n        assert not complex_dict[\"complex_nested\"][\"numbers\"]\n        assert not complex_dict[\"complex_nested\"][\"mixed\"]\n        assert complex_dict[\"complex_nested\"][\"deep\"][\"deeper\"][\"deepest\"] == \"\"\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.FilesystemJSONWithSchema\")\n    def test_load_schema_invalid_json(self, mock_fs_class) -> None:\n        \"\"\"Test handling of invalid JSON in schema file.\"\"\"\n        mock_fs = mock_fs_class.return_value\n        mock_fs.load_schema.return_value = {}  # FilesystemJSONWithSchema returns empty dict on error\n\n        vehicle_components = VehicleComponents()\n        result = vehicle_components.load_schema()\n\n        # Verify an empty dict is returned\n        assert result == {}\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_path.relpath\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_walk\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    def test_get_vehicle_components_overviews_empty(self, mock_get_base_dir, mock_walk, mock_relpath) -> None:\n        \"\"\"Test getting vehicle component overviews when no templates exist.\"\"\"\n        # Setup\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_walk.return_value = []  # No directories found\n\n        # Call the method\n        result = VehicleComponents.get_vehicle_components_overviews()\n\n        # Verify an empty dict is returned\n        assert not result\n        mock_walk.assert_called_once_with(\"/templates\")\n        mock_relpath.assert_not_called()\n\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.os_walk\")\n    @patch(\"ardupilot_methodic_configurator.backend_filesystem_program_settings.ProgramSettings.get_templates_base_dir\")\n    def test_get_vehicle_components_overviews_no_components_files(self, mock_get_base_dir, mock_walk) -> None:\n        \"\"\"Test getting vehicle component overviews when directories exist but no component files.\"\"\"\n        # Setup\n        mock_get_base_dir.return_value = \"/templates\"\n        mock_walk.return_value = [(\"/templates/dir1\", [], [\"other_file.txt\"]), (\"/templates/dir2\", [], [\"another_file.json\"])]\n\n        # Call the method\n        result = VehicleComponents.get_vehicle_components_overviews()\n\n        # Verify an empty dict is returned since no vehicle_components.json files were found\n        assert not result\n\n    def test_recursively_clear_dict_non_dict_input(self) -> None:\n        \"\"\"Test handling of non-dictionary inputs to _recursively_clear_dict.\"\"\"\n        # Test with various non-dictionary inputs\n        list_input = [1, 2, 3]\n        self.vehicle_components._recursively_clear_dict(list_input)\n        assert list_input == [1, 2, 3]  # Should remain unchanged\n\n        string_input = \"test\"\n        self.vehicle_components._recursively_clear_dict(string_input)\n        assert string_input == \"test\"  # Should remain unchanged\n\n        int_input = 42\n        self.vehicle_components._recursively_clear_dict(int_input)\n        assert int_input == 42  # Should remain unchanged\n\n        none_input = None\n        self.vehicle_components._recursively_clear_dict(none_input)\n        assert none_input is None  # Should remain unchanged\n\n    def test_json_load_error_handling(self) -> None:\n        \"\"\"Test handling of various errors in JSON loading.\"\"\"\n        # Test with broken JSON that generates a JSONDecodeError\n        broken_json = '{\"broken\": \"json\",}'\n\n        with (\n            patch(\"builtins.open\", mock_open(read_data=broken_json)),\n            patch(\n                \"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_load\",\n                side_effect=RealJSONDecodeError(\"Expecting ',' delimiter\", broken_json, 15),\n            ),\n        ):\n            result = self.vehicle_components.load_vehicle_components_json_data(\"/test/dir\")\n            assert result == {}  # Should return empty dict on error\n\n        # Test with valid JSON but invalid schema\n        with (\n            patch(\"builtins.open\", mock_open(read_data='{\"valid\": \"json\"}')),\n            patch(\n                \"ardupilot_methodic_configurator.backend_filesystem_vehicle_components.json_load\",\n                return_value={\"valid\": \"json\"},\n            ),\n            patch.object(VehicleComponents, \"validate_vehicle_components\", return_value=(False, \"Schema validation error\")),\n        ):\n            # Should still return the data even if validation fails\n            result = self.vehicle_components.load_vehicle_components_json_data(\"/test/dir\")\n            assert result == {\"valid\": \"json\"}\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n"
