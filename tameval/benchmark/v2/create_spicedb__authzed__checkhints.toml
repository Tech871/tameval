[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "authzed/spicedb"
sha = "449c43d3c8dbb72defa98dfd097392c2fa137870"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/graph/hints/checkhints.go internal/graph/hints/checkhints_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/graph/hints/checkhints.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 79.0
original_coverage = 79.0
mutation_kill_rate = 79.0
original_mutation_kill_rate = 79.0
covered_lines = [ 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 38, 39, 40, 41, 43, 44, 45, 47, 51, 52, 53, 54, 56, 57, 58, 60, 64, 65, 69, 70, 71, 76, 81, 83, 84, 85, 90,]
missed_lines = [ 66, 67, 72, 73, 74, 77, 78, 79, 86, 87, 88, 92, 93,]

[input_info]
test_file_path = "internal/graph/hints/checkhints_test.go"
focal_file_path = "internal/graph/hints/checkhints.go"
test_file_url = "https://github.com/authzed/spicedb/blob/449c43d3c8dbb72defa98dfd097392c2fa137870/internal/graph/hints/checkhints_test.go"
focal_file_url = "https://github.com/authzed/spicedb/blob/449c43d3c8dbb72defa98dfd097392c2fa137870/internal/graph/hints/checkhints.go"
first_commit_date = "2024-07-18"
last_commit_date = "2025-03-13"
test_file_content = "package hints\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/authzed/spicedb/internal/datastore/dsfortesting\"\n\t\"github.com/authzed/spicedb/internal/datastore/memdb\"\n\tdatastoremw \"github.com/authzed/spicedb/internal/middleware/datastore\"\n\t\"github.com/authzed/spicedb/pkg/datastore\"\n\tcore \"github.com/authzed/spicedb/pkg/proto/core/v1\"\n\tv1 \"github.com/authzed/spicedb/pkg/proto/dispatch/v1\"\n\t\"github.com/authzed/spicedb/pkg/schema\"\n\t\"github.com/authzed/spicedb/pkg/schemadsl/compiler\"\n\t\"github.com/authzed/spicedb/pkg/schemadsl/input\"\n\t\"github.com/authzed/spicedb/pkg/tuple\"\n)\n\nfunc TestHintForEntrypoint(t *testing.T) {\n\ttcs := []struct {\n\t\tname            string\n\t\tschema          string\n\t\tsubjectType     string\n\t\tsubjectRelation string\n\t\texpectedHints   []*v1.CheckHint\n\t}{\n\t\t{\n\t\t\t\"computed userset entrypoint\",\n\t\t\t`\n\t\t\tdefinition org {\n\t\t\t\trelation member: user\n\t\t\t\tpermission is_member = member\n\t\t\t}\n\n\t\t\tdefinition resource {\n\t\t\t\trelation org: org\n\t\t\t\tpermission view = org->is_member\n\t\t\t}`,\n\t\t\t\"org\",\n\t\t\t\"member\",\n\t\t\t[]*v1.CheckHint{\n\t\t\t\tCheckHintForComputedUserset(\"org\", \"someid\", \"member\", tuple.MustParseSubjectONR(\"user:tom\"), &v1.ResourceCheckResult{}),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"arrow entrypoint\",\n\t\t\t`\n\t\t\tdefinition org {\n\t\t\t\trelation member: user\n\t\t\t\tpermission is_member = member\n\t\t\t}\n\n\t\t\tdefinition resource {\n\t\t\t\trelation org: org\n\t\t\t\tpermission view = org->is_member\n\t\t\t}`,\n\t\t\t\"org\",\n\t\t\t\"is_member\",\n\t\t\t[]*v1.CheckHint{\n\t\t\t\tCheckHintForArrow(\"resource\", \"someid\", \"org\", \"is_member\", tuple.MustParseSubjectONR(\"user:tom\"), &v1.ResourceCheckResult{}),\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range tcs {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\trg := buildReachabilityGraph(t, tc.schema)\n\t\t\tsubject := tuple.MustParseSubjectONR(\"user:tom\")\n\n\t\t\tentrypoints, err := rg.FirstEntrypointsForSubjectToResource(t.Context(), &core.RelationReference{\n\t\t\t\tNamespace: tc.subjectType,\n\t\t\t\tRelation:  tc.subjectRelation,\n\t\t\t}, &core.RelationReference{\n\t\t\t\tNamespace: \"resource\",\n\t\t\t\tRelation:  \"view\",\n\t\t\t})\n\t\t\trequire.NoError(t, err)\n\n\t\t\thints := make([]*v1.CheckHint, 0, len(entrypoints))\n\t\t\tfor _, ep := range entrypoints {\n\t\t\t\tif ep.EntrypointKind() == core.ReachabilityEntrypoint_RELATION_ENTRYPOINT {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\thint, err := HintForEntrypoint(ep, \"someid\", subject, &v1.ResourceCheckResult{})\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\thints = append(hints, hint)\n\t\t\t}\n\n\t\t\trequire.Equal(t, tc.expectedHints, hints)\n\t\t})\n\t}\n}\n\nfunc buildReachabilityGraph(t *testing.T, schemaStr string) *schema.DefinitionReachability {\n\trequire := require.New(t)\n\n\tds, err := dsfortesting.NewMemDBDatastoreForTesting(0, 0, memdb.DisableGC)\n\trequire.NoError(err)\n\n\tctx := datastoremw.ContextWithDatastore(t.Context(), ds)\n\n\tcompiled, err := compiler.Compile(compiler.InputSchema{\n\t\tSource:       input.Source(\"schema\"),\n\t\tSchemaString: schemaStr,\n\t}, compiler.AllowUnprefixedObjectType())\n\trequire.NoError(err)\n\n\t// Write the schema.\n\t_, err = ds.ReadWriteTx(t.Context(), func(ctx context.Context, tx datastore.ReadWriteTransaction) error {\n\t\tfor _, nsDef := range compiled.ObjectDefinitions {\n\t\t\tif err := tx.WriteNamespaces(ctx, nsDef); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\trequire.NoError(err)\n\n\tlastRevision, err := ds.HeadRevision(t.Context())\n\trequire.NoError(err)\n\n\treader := ds.SnapshotReader(lastRevision)\n\tts := schema.NewTypeSystem(schema.ResolverForDatastoreReader(reader))\n\n\tvdef, err := ts.GetValidatedDefinition(ctx, \"resource\")\n\trequire.NoError(err)\n\n\treturn vdef.Reachability()\n}\n\nfunc TestCheckHintForComputedUserset(t *testing.T) {\n\tresourceType := \"resourceType\"\n\tresourceID := \"resourceID\"\n\trelation := \"relation\"\n\tsubject := tuple.ONR(\"subjectNamespace\", \"subjectObjectId\", \"subjectRelation\")\n\tresult := &v1.ResourceCheckResult{\n\t\tMembership: v1.ResourceCheckResult_MEMBER,\n\t}\n\n\tcheckHint := CheckHintForComputedUserset(resourceType, resourceID, relation, subject, result)\n\n\trequire.Equal(t, resourceType, checkHint.Resource.Namespace)\n\trequire.Equal(t, resourceID, checkHint.Resource.ObjectId)\n\trequire.Equal(t, relation, checkHint.Resource.Relation)\n\trequire.Equal(t, subject.ToCoreONR(), checkHint.Subject)\n\trequire.Equal(t, result, checkHint.Result)\n\trequire.Empty(t, checkHint.TtuComputedUsersetRelation)\n\n\tresourceID, ok := AsCheckHintForComputedUserset(checkHint, resourceType, relation, subject)\n\trequire.True(t, ok)\n\trequire.Equal(t, \"resourceID\", resourceID)\n}\n\nfunc TestCheckHintForArrow(t *testing.T) {\n\tresourceType := \"resourceType\"\n\tresourceID := \"resourceID\"\n\ttuplesetRelation := \"tuplesetRelation\"\n\tcomputedUsersetRelation := \"computedUsersetRelation\"\n\tsubject := tuple.ONR(\"subjectNamespace\", \"subjectObjectId\", \"subjectRelation\")\n\tresult := &v1.ResourceCheckResult{\n\t\tMembership: v1.ResourceCheckResult_MEMBER,\n\t}\n\n\tcheckHint := CheckHintForArrow(resourceType, resourceID, tuplesetRelation, computedUsersetRelation, subject, result)\n\n\trequire.Equal(t, resourceType, checkHint.Resource.Namespace)\n\trequire.Equal(t, resourceID, checkHint.Resource.ObjectId)\n\trequire.Equal(t, tuplesetRelation, checkHint.Resource.Relation)\n\trequire.Equal(t, subject.ToCoreONR(), checkHint.Subject)\n\trequire.Equal(t, result, checkHint.Result)\n\trequire.Equal(t, computedUsersetRelation, checkHint.TtuComputedUsersetRelation)\n\n\tresourceID, ok := AsCheckHintForArrow(checkHint, resourceType, tuplesetRelation, computedUsersetRelation, subject)\n\trequire.True(t, ok)\n\trequire.Equal(t, \"resourceID\", resourceID)\n}\n\nfunc TestAsCheckHintForComputedUserset(t *testing.T) {\n\ttcs := []struct {\n\t\tname           string\n\t\tcheckHint      *v1.CheckHint\n\t\thandler        func(*v1.CheckHint) (string, bool)\n\t\texpectedResult string\n\t}{\n\t\t{\n\t\t\t\"matching resource and subject\",\n\t\t\tCheckHintForComputedUserset(\"resourceType\", \"resourceID\", \"relation\", tuple.MustParseSubjectONR(\"user:tom\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForComputedUserset(ch, \"resourceType\", \"relation\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"resourceID\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch subject ID\",\n\t\t\tCheckHintForComputedUserset(\"resourceType\", \"resourceID\", \"relation\", tuple.MustParseSubjectONR(\"user:anothersubject\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForComputedUserset(ch, \"resourceType\", \"relation\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch subject type\",\n\t\t\tCheckHintForComputedUserset(\"resourceType\", \"resourceID\", \"relation\", tuple.MustParseSubjectONR(\"githubuser:tom\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForComputedUserset(ch, \"resourceType\", \"relation\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch subject relation\",\n\t\t\tCheckHintForComputedUserset(\"resourceType\", \"resourceID\", \"relation\", tuple.MustParseSubjectONR(\"user:tom#foo\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForComputedUserset(ch, \"resourceType\", \"relation\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch resource type\",\n\t\t\tCheckHintForComputedUserset(\"anotherType\", \"resourceID\", \"relation\", tuple.MustParseSubjectONR(\"user:tom\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForComputedUserset(ch, \"resourceType\", \"relation\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch resource relation\",\n\t\t\tCheckHintForComputedUserset(\"resourceType\", \"resourceID\", \"anotherRelation\", tuple.MustParseSubjectONR(\"user:tom\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForComputedUserset(ch, \"resourceType\", \"relation\", tuple.MustParseSubjectONR(\"user:tom#...\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch kind\",\n\t\t\tCheckHintForArrow(\"resourceType\", \"resourceID\", \"ttu\", \"clu\", tuple.MustParseSubjectONR(\"user:tom\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForComputedUserset(ch, \"resourceType\", \"relation\", tuple.MustParseSubjectONR(\"user:tom#...\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t}\n\n\tfor _, tc := range tcs {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresourceID, ok := tc.handler(tc.checkHint)\n\t\t\tif tc.expectedResult == \"\" {\n\t\t\t\trequire.False(t, ok)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.Equal(t, tc.expectedResult, resourceID)\n\t\t\trequire.True(t, ok)\n\t\t})\n\t}\n}\n\nfunc TestAsCheckHintForArrow(t *testing.T) {\n\ttcs := []struct {\n\t\tname           string\n\t\tcheckHint      *v1.CheckHint\n\t\thandler        func(*v1.CheckHint) (string, bool)\n\t\texpectedResult string\n\t}{\n\t\t{\n\t\t\t\"matching resource and subject\",\n\t\t\tCheckHintForArrow(\"resourceType\", \"resourceID\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForArrow(ch, \"resourceType\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"resourceID\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch TTU\",\n\t\t\tCheckHintForArrow(\"resourceType\", \"resourceID\", \"anotherttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForArrow(ch, \"resourceType\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch computeduserset\",\n\t\t\tCheckHintForArrow(\"resourceType\", \"resourceID\", \"ttu\", \"anothercur\", tuple.MustParseSubjectONR(\"user:tom\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForArrow(ch, \"resourceType\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch subject ID\",\n\t\t\tCheckHintForArrow(\"resourceType\", \"resourceID\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:anothersubject\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForArrow(ch, \"resourceType\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch subject type\",\n\t\t\tCheckHintForArrow(\"resourceType\", \"resourceID\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"githubuser:tom\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForArrow(ch, \"resourceType\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch subject relation\",\n\t\t\tCheckHintForArrow(\"resourceType\", \"resourceID\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom#something\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForArrow(ch, \"resourceType\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch resource type\",\n\t\t\tCheckHintForArrow(\"anotherType\", \"resourceID\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForArrow(ch, \"resourceType\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch resource relation\",\n\t\t\tCheckHintForArrow(\"resourceType\", \"resourceID\", \"anotherttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForArrow(ch, \"resourceType\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"mismatch kind\",\n\t\t\tCheckHintForComputedUserset(\"resourceType\", \"resourceID\", \"relation\", tuple.MustParseSubjectONR(\"user:tom\"), &v1.ResourceCheckResult{}),\n\t\t\tfunc(ch *v1.CheckHint) (string, bool) {\n\t\t\t\treturn AsCheckHintForArrow(ch, \"resourceType\", \"ttu\", \"cur\", tuple.MustParseSubjectONR(\"user:tom\"))\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t}\n\n\tfor _, tc := range tcs {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresourceID, ok := tc.handler(tc.checkHint)\n\t\t\tif tc.expectedResult == \"\" {\n\t\t\t\trequire.False(t, ok)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.Equal(t, tc.expectedResult, resourceID)\n\t\t\trequire.True(t, ok)\n\t\t})\n\t}\n}\n"
