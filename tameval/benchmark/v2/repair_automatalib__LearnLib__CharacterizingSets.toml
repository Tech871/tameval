[meta]
task = "repair"
scenario = "repair_invalid_constructor"

[lang_info]
lang = "Java"
java_builder = "Maven"
is_multi_module = true

[repo_info]
repository = "LearnLib/automatalib"
sha = "125bd7267571158b87da3e5dbe92f505ce1729a5"

[run_info]
docker_image = "maven:3.8.3-openjdk-17"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "mvn -Dmaven.repo.local=/.m2 -T 4 clean install"
test_run_command = "mvn clean -Dmaven.repo.local=/.m2 test -q -pl util -Dtest=CharacterizingSetsTest && mvn jacoco:report -Djacoco.append=false"
mutation_run_command = "mvn -Dmaven.repo.local=/.m2 org.pitest:pitest-maven:mutationCoverage -pl util -DtargetClasses=**.CharacterizingSets  -DtargetTests=**.CharacterizingSetsTest  -DoutputFormats=XML"
coverage_report_path = "util/target/site/jacoco/jacoco.xml"
coverage_report_type = "jacoco"
mutation_report_path = "util/target/pit-reports/mutations.xml"
mutation_report_type = "pitest"

[coverage]
coverage = 0.0
original_coverage = 83.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "util/src/test/java/net/automatalib/util/automaton/equivalence/CharacterizingSetsTest.java"
focal_file_path = "util/src/main/java/net/automatalib/util/automaton/equivalence/CharacterizingSets.java"
test_file_url = "https://github.com/LearnLib/automatalib/blob/125bd7267571158b87da3e5dbe92f505ce1729a5/util/src/test/java/net/automatalib/util/automaton/equivalence/CharacterizingSetsTest.java"
focal_file_url = "https://github.com/LearnLib/automatalib/blob/125bd7267571158b87da3e5dbe92f505ce1729a5/util/src/main/java/net/automatalib/util/automaton/equivalence/CharacterizingSets.java"
first_commit_date = "2023-10-10"
last_commit_date = "2025-01-07"
test_file_content = "package net.automatalib.util.automaton.equivalence;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Random;\n\nimport net.automatalib.alphabet.Alphabet;\nimport net.automatalib.alphabet.impl.Alphabets;\nimport net.automatalib.automaton.concept.DetSuffixOutputAutomaton;\nimport net.automatalib.automaton.fsa.impl.CompactDFA;\nimport net.automatalib.automaton.transducer.impl.CompactMealy;\nimport net.automatalib.automaton.transducer.impl.CompactMoore;\nimport net.automatalib.util.automaton.Automata;\nimport net.automatalib.util.automaton.builder.AutomatonBuilders;\nimport net.automatalib.util.automaton.fsa.MutableDFAs;\nimport net.automatalib.util.automaton.random.RandomAutomata;\nimport net.automatalib.word.Word;\nimport org.testng.Assert;\nimport org.testng.annotations.Test;\n\npublic class CharacterizingSetsTest {\n\n    private static final Random RANDOM = new Random(0);\n    private static final int AUTOMATON_SIZE = 20;\n    private static final Alphabet<Integer> INPUT_ALPHABET = Alphabets.integers(0, 5);\n    private static final Alphabet<Character> OUTPUT_ALPHABET = Alphabets.characters('a', 'f');\n\n    private static final CompactDFA<Integer> DFA = RandomAutomata.randomDFA(RANDOM, AUTOMATON_SIZE, INPUT_ALPHABET, 3);\n    private static final CompactMealy<Integer, Character> MEALY =\n            RandomAutomata.randomMealy(RANDOM, AUTOMATON_SIZE, INPUT_ALPHABET, OUTPUT_ALPHABET, 1, 2);\n    private static final CompactMoore<Integer, Character> MOORE =\n            RandomAutomata.randomMoore(RANDOM, AUTOMATON_SIZE, INPUT_ALPHABET, OUTPUT_ALPHABET, 'g');\n\n    @Test\n    public void characterizingDFATest() {\n        final List<Word<Integer>> characterizingSet = Automata.characterizingSet(DFA, INPUT_ALPHABET);\n\n        checkCharacterizingSet(DFA, characterizingSet);\n    }\n\n    @Test\n    public void characterizingDFASingleTest() {\n        final Integer state = DFA.getState(AUTOMATON_SIZE / 2);\n        final List<Word<Integer>> characterizingSet = new ArrayList<>();\n        CharacterizingSets.findCharacterizingSet(DFA, INPUT_ALPHABET, state, characterizingSet);\n\n        checkCharacterizingSet(DFA, state, characterizingSet);\n    }\n\n    @Test\n    public void characterizingMealyTest() {\n        final List<Word<Integer>> characterizingSet = Automata.characterizingSet(MEALY, INPUT_ALPHABET);\n\n        checkCharacterizingSet(MEALY, characterizingSet);\n    }\n\n    @Test\n    public void characterizingMealySingleTest() {\n        final Integer state = MEALY.getState(AUTOMATON_SIZE / 2);\n        final List<Word<Integer>> characterizingSet = new ArrayList<>();\n        CharacterizingSets.findCharacterizingSet(MEALY, INPUT_ALPHABET, state, characterizingSet);\n\n        checkCharacterizingSet(MEALY, state, characterizingSet);\n    }\n\n    @Test\n    public void characterizingMooreTest() {\n        final List<Word<Integer>> characterizingSet = Automata.characterizingSet(MOORE, INPUT_ALPHABET);\n\n        checkCharacterizingSet(MOORE, characterizingSet);\n    }\n\n    @Test\n    public void characterizingMooreSingleTest() {\n        final Integer state = MOORE.getState(AUTOMATON_SIZE / 2);\n        final List<Word<Integer>> characterizingSet = new ArrayList<>();\n        CharacterizingSets.findCharacterizingSet(MOORE, INPUT_ALPHABET, state, characterizingSet);\n\n        checkCharacterizingSet(MOORE, state, characterizingSet);\n    }\n\n    @Test\n    public void issue36Test() {\n        final Alphabet<String> inputs = Alphabets.fromArray(\"a\", \"b\");\n\n        final CompactMealy<String, Object> machine = AutomatonBuilders.newMealy(inputs, 1)\n                .withInitial(\"0\")\n                .from(\"0\")\n                    .on(\"a\").withOutput(\"a\").to(\"1\")\n                    .on(\"b\").withOutput(\"b\").to(\"0\")\n                .from(\"1\")\n                    .on(\"a\").withOutput(\"b\").to(\"2\")\n                    .on(\"b\").withOutput(\"b\").to(\"3\")\n                .from(\"2\")\n                    .on(\"a\").withOutput(\"b\").to(\"1\")\n                    .on(\"b\").withOutput(\"b\").to(\"0\")\n                .from(\"3\")\n                    .on(\"a\").withOutput(\"a\").to(\"0\")\n                    .on(\"b\").withOutput(\"b\").to(\"0\")\n                .create();\n\n        final List<Word<String>> characterizingSet = Automata.characterizingSet(machine, inputs);\n        checkCharacterizingSet(machine, characterizingSet);\n    }\n\n    @Test\n    public void pedigreeTest() {\n        final Alphabet<Character> inputs = Alphabets.fromArray('P', 'M', 'F', 'n', 'd');\n\n        final CompactDFA<Character> dfa = AutomatonBuilders.forDFA(new CompactDFA<>(inputs, 2))\n                                                           .withInitial(\"s0\")\n                                                           .from(\"s0\").on('n').to(\"s1\")\n                                                           .from(\"s0\").on('d').to(\"s3\")\n                                                           .from(\"s1\").on('d').to(\"s4\")\n                                                           .from(\"s1\").on('M').to(\"s6\")\n                                                           .from(\"s1\").on('F').to(\"s5\")\n                                                           .from(\"s3\").on('n').to(\"s4\")\n                                                           .from(\"s4\").on('M').to(\"s6\")\n                                                           .from(\"s4\").on('F').to(\"s5\")\n                                                           .from(\"s5\").on('M').to(\"s7\")\n                                                           .from(\"s6\").on('F').to(\"s7\")\n                                                           .withAccepting(\"s1\", \"s4\", \"s5\", \"s6\", \"s7\")\n                                                           .create();\n\n        MutableDFAs.complete(dfa, inputs);\n\n        final List<Word<Character>> characterizingSet = Automata.characterizingSet(dfa, inputs);\n        checkCharacterizingSet(dfa, characterizingSet);\n    }\n\n    private <S, I> void checkCharacterizingSet(DetSuffixOutputAutomaton<S, I, ?, ?> automaton,\n                                               Collection<Word<I>> characterizingSet) {\n        for (S s : automaton) {\n            checkCharacterizingSet(automaton, s, characterizingSet);\n        }\n    }\n\n    private <S, I, D> void checkCharacterizingSet(DetSuffixOutputAutomaton<S, I, ?, D> automaton,\n                                                  S state,\n                                                  Collection<Word<I>> characterizingSet) {\n\n        outer:\n        for (S s : automaton) {\n            if (!Objects.equals(s, state)) {\n                for (Word<I> trace : characterizingSet) {\n\n                    final D baseOutput = automaton.computeStateOutput(state, trace);\n                    final D checkOutput = automaton.computeStateOutput(s, trace);\n\n                    if (!Objects.equals(baseOutput, checkOutput)) {\n                        continue outer;\n                    }\n                }\n\n                Assert.fail(\"State '\" + state + \"' cannot be distinguished from state '\" + s + '\\'');\n            }\n        }\n    }\n}"
