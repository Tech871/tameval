[meta]
task = "repair"
scenario = "repair_missed_dependencies"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "antrea-io/antrea"
sha = "0cd2eed3cc54448553096bf4e6ee74836c9c1d11"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/avito-tech/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/util/podstore/podstore.go pkg/util/podstore/podstore_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/util/podstore/podstore.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 70.0
mutation_kill_rate = nan
original_mutation_kill_rate = 47.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "pkg/util/podstore/podstore_test.go"
focal_file_path = "pkg/util/podstore/podstore.go"
test_file_url = "https://github.com/antrea-io/antrea/blob/0cd2eed3cc54448553096bf4e6ee74836c9c1d11/pkg/util/podstore/podstore_test.go"
focal_file_url = "https://github.com/antrea-io/antrea/blob/0cd2eed3cc54448553096bf4e6ee74836c9c1d11/pkg/util/podstore/podstore.go"
first_commit_date = "2023-07-26"
last_commit_date = "2025-02-27"
test_file_content = "\n\npackage podstore\n\n\nvar (\n\trefTime  = time.Now()\n\trefTime2 = refTime.Add(-5 * time.Minute)\n\tpod1     = &v1.Pod{\n\t\tStatus: v1.PodStatus{\n\t\t\tPodIPs: []v1.PodIP{\n\t\t\t\t{\n\t\t\t\t\tIP: \"1.2.3.4\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tPhase: v1.PodPending,\n\t\t},\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:              \"pod1\",\n\t\t\tNamespace:         \"pod1_ns\",\n\t\t\tUID:               \"pod1\",\n\t\t\tCreationTimestamp: metav1.Time{Time: refTime2},\n\t\t},\n\t}\n\tpod2 = &v1.Pod{\n\t\tStatus: v1.PodStatus{\n\t\t\tPodIPs: []v1.PodIP{\n\t\t\t\t{\n\t\t\t\t\tIP: \"5.6.7.8\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:              \"pod2\",\n\t\t\tNamespace:         \"pod2_ns\",\n\t\t\tUID:               \"pod2\",\n\t\t\tCreationTimestamp: metav1.Time{Time: refTime2},\n\t\t\tDeletionTimestamp: &metav1.Time{Time: refTime},\n\t\t},\n\t}\n\tpod3 = &v1.Pod{\n\t\tStatus: v1.PodStatus{\n\t\t\tPodIPs: []v1.PodIP{\n\t\t\t\t{\n\t\t\t\t\tIP: \"4.3.2.1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tPhase: v1.PodRunning,\n\t\t},\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:              \"pod3\",\n\t\t\tNamespace:         \"pod3_ns\",\n\t\t\tUID:               \"pod3\",\n\t\t\tCreationTimestamp: metav1.Time{Time: refTime2},\n\t\t},\n\t}\n\tpod4 = &v1.Pod{\n\t\tStatus: v1.PodStatus{\n\t\t\tPodIPs: []v1.PodIP{\n\t\t\t\t{\n\t\t\t\t\tIP: \"1.2.3.4\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tPhase: v1.PodSucceeded,\n\t\t},\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:              \"pod1\",\n\t\t\tNamespace:         \"pod1_ns\",\n\t\t\tUID:               \"pod4\",\n\t\t\tCreationTimestamp: metav1.Time{Time: refTime2},\n\t\t\tDeletionTimestamp: &metav1.Time{Time: refTime},\n\t\t},\n\t}\n\thostNetworkPod = &v1.Pod{\n\t\tSpec: v1.PodSpec{\n\t\t\tHostNetwork: true,\n\t\t},\n\t\tStatus: v1.PodStatus{\n\t\t\tPodIPs: []v1.PodIP{\n\t\t\t\t{\n\t\t\t\t\tIP: \"172.18.0.1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tPhase: v1.PodSucceeded,\n\t\t},\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:              \"hnpod\",\n\t\t\tUID:               \"hnpod\",\n\t\t\tCreationTimestamp: metav1.Time{Time: refTime2},\n\t\t},\n\t}\n\ttimestampMap = map[types.UID]*podTimestamps{\n\t\t\"pod1\": {CreationTimestamp: refTime},\n\t\t\"pod2\": {CreationTimestamp: refTime2, DeletionTimestamp: &refTime},\n\t\t\"pod4\": {CreationTimestamp: refTime2, DeletionTimestamp: &refTime},\n\t}\n\tnode = &v1.Node{}\n)\n\nfunc Test_onPodUpdate(t *testing.T) {\n\tfakeClock := clock.NewFakeClock(time.Now())\n\toldPod := &v1.Pod{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"pod1\",\n\t\t\tNamespace: \"pod1_ns\",\n\t\t\tUID:       \"pod1\",\n\t\t},\n\t}\n\tnewPod1 := oldPod.DeepCopy()\n\tnewPod1.Status.PodIPs = []v1.PodIP{\n\t\t{\n\t\t\tIP: \"4.5.6.7\",\n\t\t},\n\t}\n\tnewPod2 := oldPod.DeepCopy()\n\tnewPod2.UID = \"pod1_new\"\n\ttests := []struct {\n\t\tname          string\n\t\tnewObj        interface{}\n\t\texpectedPods  []*v1.Pod\n\t\toldPodDeleted bool\n\t}{\n\t\t{\n\t\t\tname:         \"newObj is not Pod\",\n\t\t\tnewObj:       node,\n\t\t\texpectedPods: []*v1.Pod{oldPod},\n\t\t},\n\t\t{\n\t\t\tname:         \"Pod IP update\",\n\t\t\tnewObj:       newPod1,\n\t\t\texpectedPods: []*v1.Pod{newPod1},\n\t\t},\n\t\t{\n\t\t\tname:          \"same name, new UID\",\n\t\t\tnewObj:        newPod2,\n\t\t\texpectedPods:  []*v1.Pod{oldPod, newPod2},\n\t\t\toldPodDeleted: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tpodStore := &PodStore{\n\t\t\t\ttimestampMap: map[types.UID]*podTimestamps{},\n\t\t\t\tclock:        fakeClock,\n\t\t\t\tpods:         cache.NewIndexer(podKeyFunc, cache.Indexers{podIPIndex: podIPIndexFunc}),\n\t\t\t\tpodsToDelete: workqueue.NewTypedDelayingQueueWithConfig(workqueue.TypedDelayingQueueConfig[types.UID]{\n\t\t\t\t\tName:  deleteQueueName,\n\t\t\t\t\tClock: fakeClock,\n\t\t\t\t}),\n\t\t\t}\n\t\t\trequire.NoError(t, podStore.addPod(oldPod))\n\t\t\tpodStore.onPodUpdate(oldPod, tt.newObj)\n\t\t\tpods := make([]*v1.Pod, 0)\n\t\t\tfor _, obj := range podStore.pods.List() {\n\t\t\t\tpods = append(pods, obj.(*v1.Pod))\n\t\t\t}\n\t\t\tassert.ElementsMatch(t, tt.expectedPods, pods)\n\t\t\tif tt.oldPodDeleted {\n\t\t\t\trequire.Equal(t, 1, podStore.podsToDelete.Len())\n\t\t\t\tuid, _ := podStore.podsToDelete.Get()\n\t\t\t\tassert.Equal(t, oldPod.UID, uid)\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, 0, podStore.podsToDelete.Len())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_onPodCreate(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tobj         interface{}\n\t\texpectedMap map[types.UID]*podTimestamps\n\t}{\n\t\t{\n\t\t\tname:        \"object is not Pod\",\n\t\t\tobj:         node,\n\t\t\texpectedMap: map[types.UID]*podTimestamps{},\n\t\t},\n\t\t{\n\t\t\tname:        \"valid case for Pending Pod\",\n\t\t\tobj:         pod1,\n\t\t\texpectedMap: map[types.UID]*podTimestamps{\"pod1\": {CreationTimestamp: refTime}},\n\t\t},\n\t\t{\n\t\t\tname:        \"valid case for Running Pod\",\n\t\t\tobj:         pod3,\n\t\t\texpectedMap: map[types.UID]*podTimestamps{\"pod3\": {CreationTimestamp: refTime2}},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tpodStore := &PodStore{\n\t\t\t\ttimestampMap: map[types.UID]*podTimestamps{},\n\t\t\t\tclock:        clock.NewFakeClock(refTime),\n\t\t\t\tpods:         cache.NewIndexer(podKeyFunc, cache.Indexers{podIPIndex: podIPIndexFunc}),\n\t\t\t}\n\t\t\tpodStore.onPodCreate(tt.obj)\n\t\t\tassert.Equal(t, tt.expectedMap, podStore.timestampMap)\n\t\t})\n\t}\n}\n\nfunc getPodInformer(k8sClient kubernetes.Interface) cache.SharedIndexInformer {\n\tpodInformer := coreinformers.NewPodInformer(\n\t\tk8sClient,\n\t\tmetav1.NamespaceAll,\n\t\t0,\n\t\tcache.Indexers{},\n\t)\n\tpodInformer.SetTransform(k8s.NewTrimmer(k8s.TrimPod))\n\treturn podInformer\n}\n\nfunc Test_onPodDelete(t *testing.T) {\n\tt.Run(\"object is neither Pod nor DeletedFinalStateUnknown\", func(t *testing.T) {\n\t\tk8sClient := fake.NewSimpleClientset()\n\t\tpodInformer := getPodInformer(k8sClient)\n\t\tpodStore := NewPodStore(podInformer)\n\t\trequire.NoError(t, podStore.pods.Add(pod1))\n\t\tpodStore.timestampMap = map[types.UID]*podTimestamps{\"pod1\": {CreationTimestamp: refTime}}\n\t\tpodStore.onPodDelete(node)\n\t\tassert.Equal(t, &podTimestamps{CreationTimestamp: refTime}, podStore.timestampMap[\"pod1\"])\n\t})\n\tt.Run(\"Pod is in prevPod and podsToDelete\", func(t *testing.T) {\n\t\tk8sClient := fake.NewSimpleClientset()\n\t\tpodInformer := getPodInformer(k8sClient)\n\t\tfakeClock := clock.NewFakeClock(refTime)\n\t\tpodStore := NewPodStoreWithClock(podInformer, fakeClock)\n\t\trequire.NoError(t, podStore.pods.Add(pod1))\n\t\tpodStore.timestampMap = map[types.UID]*podTimestamps{\"pod1\": {CreationTimestamp: refTime}}\n\t\texpectedDeleteTime := refTime.Add(delayTime)\n\t\tpodStore.onPodDelete(pod1)\n\t\tassert.Equal(t, &podTimestamps{CreationTimestamp: refTime, DeletionTimestamp: &refTime}, podStore.timestampMap[\"pod1\"])\n\t\tfakeClock.SetTime(expectedDeleteTime.Add(-10 * time.Millisecond))\n\t\tassert.Equal(t, podStore.podsToDelete.Len(), 0)\n\t\tfakeClock.SetTime(expectedDeleteTime.Add(10 * time.Millisecond))\n\t\tassert.Eventuallyf(t, func() bool {\n\t\t\treturn podStore.podsToDelete.Len() == 1\n\t\t}, 1*time.Second, 10*time.Millisecond, \"Pod is not added to PodsToDelete\")\n\t})\n}\n\nfunc Test_checkDeletedPod(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tobj            interface{}\n\t\texpectedResult *v1.Pod\n\t\texpectedErr    string\n\t}{\n\t\t{\n\t\t\tname:        \"object is not DeletedFinalStateUnknown\",\n\t\t\tobj:         node,\n\t\t\texpectedErr: \"received unexpected object: \",\n\t\t},\n\t\t{\n\t\t\tname:        \"object in DeletedFinalStateUnknown is not Pod\",\n\t\t\tobj:         cache.DeletedFinalStateUnknown{Obj: node},\n\t\t\texpectedErr: \"DeletedFinalStateUnknown object is not of type Pod\",\n\t\t},\n\t\t{\n\t\t\tname:           \"valid case\",\n\t\t\tobj:            cache.DeletedFinalStateUnknown{Obj: pod1},\n\t\t\texpectedResult: pod1,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tpod, err := (&PodStore{}).checkDeletedPod(tt.obj)\n\t\t\tif tt.expectedErr != \"\" {\n\t\t\t\tassert.ErrorContains(t, err, tt.expectedErr)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, tt.expectedResult, pod)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_GetPodByIPAndTime(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tip             string\n\t\tstartTime      time.Time\n\t\texpectedResult *v1.Pod\n\t}{\n\t\t{\n\t\t\tname:           \"no Pod in the Pod store\",\n\t\t\tip:             \"1.3.5.7\",\n\t\t\tstartTime:      refTime,\n\t\t\texpectedResult: nil,\n\t\t},\n\t\t{\n\t\t\tname:           \"find only one Pod in the Pod store - correct startTime\",\n\t\t\tip:             \"5.6.7.8\",\n\t\t\tstartTime:      refTime.Add(-time.Minute),\n\t\t\texpectedResult: pod2,\n\t\t},\n\t\t{\n\t\t\tname:           \"find only one Pod in the Pod store - incorrect startTime\",\n\t\t\tip:             \"5.6.7.8\",\n\t\t\tstartTime:      refTime.Add(time.Minute),\n\t\t\texpectedResult: pod2,\n\t\t},\n\t\t{\n\t\t\tname:           \"find current Pod in the Pod store\",\n\t\t\tip:             \"1.2.3.4\",\n\t\t\tstartTime:      refTime.Add(time.Minute),\n\t\t\texpectedResult: pod1,\n\t\t},\n\t\t{\n\t\t\tname:           \"find previous Pod in the Pod store\",\n\t\t\tip:             \"1.2.3.4\",\n\t\t\tstartTime:      refTime.Add(-time.Minute),\n\t\t\texpectedResult: pod4,\n\t\t},\n\t\t{\n\t\t\tname:           \"cannot find the Pod in the Pod store - SearchTime < CreationTime\",\n\t\t\tip:             \"1.2.3.4\",\n\t\t\tstartTime:      refTime.Add(-time.Minute * 10),\n\t\t\texpectedResult: nil,\n\t\t},\n\t\t{\n\t\t\tname:           \"cannot find the Pod in the Pod store - SearchTime > DeletionTime\",\n\t\t\tip:             \"1.2.3.4\",\n\t\t\tstartTime:      refTime,\n\t\t\texpectedResult: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tk8sClient := fake.NewSimpleClientset()\n\t\t\tpodInformer := getPodInformer(k8sClient)\n\t\t\tpodStore := NewPodStore(podInformer)\n\t\t\trequire.NoError(t, podStore.pods.Add(pod1))\n\t\t\trequire.NoError(t, podStore.pods.Add(pod2))\n\t\t\trequire.NoError(t, podStore.pods.Add(pod4))\n\t\t\tpodStore.timestampMap = timestampMap\n\t\t\tpod, ok := podStore.GetPodByIPAndTime(tt.ip, tt.startTime)\n\t\t\tif tt.expectedResult == nil {\n\t\t\t\tassert.False(t, ok)\n\t\t\t} else {\n\t\t\t\tassert.True(t, ok)\n\t\t\t\tassert.Equal(t, tt.expectedResult, pod)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_processDeleteQueueItem(t *testing.T) {\n\tfakeClock := clock.NewFakeClock(time.Now())\n\tpodStore := &PodStore{\n\t\tpods: cache.NewIndexer(podKeyFunc, cache.Indexers{podIPIndex: podIPIndexFunc}),\n\t\tpodsToDelete: workqueue.NewTypedDelayingQueueWithConfig(workqueue.TypedDelayingQueueConfig[types.UID]{\n\t\t\tName:  deleteQueueName,\n\t\t\tClock: fakeClock,\n\t\t}),\n\t\tclock:        fakeClock,\n\t\ttimestampMap: map[types.UID]*podTimestamps{\"pod1\": {}},\n\t}\n\trequire.NoError(t, podStore.pods.Add(pod1))\n\tpodStore.podsToDelete.Add(pod1.UID)\n\tresult := podStore.processDeleteQueueItem(&v1.Pod{})\n\trequire.Equal(t, true, result)\n\tassert.Equal(t, 0, podStore.podsToDelete.Len())\n\tassert.Len(t, podStore.pods.List(), 0)\n\tassert.Len(t, podStore.timestampMap, 0)\n}\n\nfunc Test_podKeyFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tobj            interface{}\n\t\texpectedResult string\n\t\texpectedErr    string\n\t}{\n\t\t{\n\t\t\tname:        \"object is not Pod\",\n\t\t\tobj:         node,\n\t\t\texpectedErr: \"obj is not Pod: \",\n\t\t},\n\t\t{\n\t\t\tname:           \"valid case\",\n\t\t\tobj:            pod1,\n\t\t\texpectedResult: \"pod1\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := podKeyFunc(tt.obj)\n\t\t\tif tt.expectedErr != \"\" {\n\t\t\t\tassert.ErrorContains(t, err, tt.expectedErr)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, tt.expectedResult, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_podIPIndexFunc(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tobj            interface{}\n\t\texpectedResult []string\n\t\texpectedErr    string\n\t}{\n\t\t{\n\t\t\tname:        \"object is not Pod\",\n\t\t\tobj:         node,\n\t\t\texpectedErr: \"obj is not Pod:\",\n\t\t},\n\t\t{\n\t\t\tname:           \"valid case\",\n\t\t\tobj:            pod1,\n\t\t\texpectedResult: []string{\"1.2.3.4\"},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := podIPIndexFunc(tt.obj)\n\t\t\tif tt.expectedErr != \"\" {\n\t\t\t\tassert.ErrorContains(t, err, tt.expectedErr)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.ElementsMatch(t, tt.expectedResult, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_noHostNetworkPod(t *testing.T) {\n\tk8sClient := fake.NewSimpleClientset(hostNetworkPod, pod1)\n\tpodInformer := getPodInformer(k8sClient)\n\tpodStore := NewPodStore(podInformer)\n\tstopCh := make(chan struct{})\n\tgo podInformer.Run(stopCh)\n\tcache.WaitForCacheSync(stopCh, podInformer.HasSynced)\n\tassert.EventuallyWithT(t, func(t *assert.CollectT) {\n\t\tpodStore.mutex.RLock()\n\t\tdefer podStore.mutex.RUnlock()\n\t\tassert.Contains(t, podStore.timestampMap, pod1.UID)\n\t}, 1*time.Second, 10*time.Millisecond)\n\tassert.Never(t, func() bool {\n\t\tpodStore.mutex.RLock()\n\t\tdefer podStore.mutex.RUnlock()\n\t\treturn len(podStore.timestampMap) != 1\n\t}, 100*time.Millisecond, 10*time.Millisecond, \"host-network Pods should be filtered out by informer\")\n}\n\n/*\nSample output:\ngoos: darwin\ngoarch: amd64\npkg: antrea.io/antrea/pkg/util/podstore\ncpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz\nBenchmarkGetPodByIPAndTime\nBenchmarkGetPodByIPAndTime/input_size_100\nBenchmarkGetPodByIPAndTime/input_size_100-12         \t 2232166\t       538.6 ns/op\n    podstore_test.go:465:\n        Summary:\n        Number of initial Pods: 100\n        Total times of calling GetPodByIPAndTime: 3242267\n        Total times of successfully finding Pod in podStore: 3242267\nBenchmarkGetPodByIPAndTime/input_size_1000\nBenchmarkGetPodByIPAndTime/input_size_1000-12        \t 2238074\t       551.0 ns/op\n    podstore_test.go:465:\n        Summary:\n        Number of initial Pods: 1000\n        Total times of calling GetPodByIPAndTime: 3248175\n        Total times of successfully finding Pod in podStore: 3248175\nBenchmarkGetPodByIPAndTime/input_size_10000\nBenchmarkGetPodByIPAndTime/input_size_10000-12       \t 1000000\t      1043 ns/op\n    podstore_test.go:465:\n        Summary:\n        Number of initial Pods: 10000\n        Total times of calling GetPodByIPAndTime: 1010101\n        Total times of successfully finding Pod in podStore: 1010101\nPASS\n*/\n\nfunc BenchmarkGetPodByIPAndTime(b *testing.B) {\n\tvar PodNumber = []struct {\n\t\tinput int\n\t}{\n\t\t{input: 100},\n\t\t{input: 1000},\n\t\t{input: 10000},\n\t}\n\tfor _, v := range PodNumber {\n\t\tsuccess := 0\n\t\ttotal := 0\n\t\tk8sClient := fake.NewSimpleClientset()\n\t\tpodInformer := getPodInformer(k8sClient)\n\t\tpodStore := NewPodStore(podInformer)\n\t\tstopCh := make(chan struct{})\n\t\tgo podInformer.Run(stopCh)\n\t\tcache.WaitForCacheSync(stopCh, podInformer.HasSynced)\n\t\tpodArray, err := addPods(v.input, k8sClient)\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"error when adding Pods: %v\", err)\n\t\t}\n\t\tassert.Eventuallyf(b, func() bool {\n\t\t\treturn len(podInformer.GetIndexer().List()) == v.input\n\t\t}, 1*time.Second, 10*time.Millisecond, \"Pods should be added to podInformer\")\n\t\terrChan := make(chan error)\n\t\tgo func() {\n\t\t\terr = deletePodsK8s(podArray, k8sClient)\n\t\t\tif err != nil {\n\t\t\t\terrChan <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tclose(errChan)\n\t\t}()\n\t\tb.Run(fmt.Sprintf(\"input_size_%d\", v.input), func(b *testing.B) {\n\t\t\tb.ResetTimer()\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\trandomPod := podArray[rand.Intn(v.input)]\n\t\t\t\tcreationTime := podStore.timestampMap[randomPod.UID].CreationTimestamp\n\t\t\t\t_, ok := podStore.GetPodByIPAndTime(randomPod.Status.PodIPs[0].IP, creationTime.Add(time.Millisecond))\n\t\t\t\ttotal++\n\t\t\t\tif ok {\n\t\t\t\t\tsuccess++\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tclose(stopCh)\n\t\terr = <-errChan\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"error when deleting Pods: %v\", err)\n\t\t}\n\t\tb.Logf(\"\\nSummary:\\nNumber of initial Pods: %d\\nTotal times of calling GetPodByIPAndTime: %d\\nTotal times of successfully finding Pod in podStore: %d\\n\", v.input, total, success)\n\t}\n}\n\nfunc deletePodsK8s(pods []*v1.Pod, k8sClient kubernetes.Interface) error {\n\tfor _, pod := range pods {\n\t\terr := k8sClient.CoreV1().Pods(pod.Namespace).Delete(context.TODO(), pod.Name, metav1.DeleteOptions{})\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error when deleting Pods through k8s api: %v\", err)\n\t\t}\n\t\ttime.Sleep(time.Millisecond)\n\t}\n\treturn nil\n}\n\nfunc addPods(number int, k8sClient kubernetes.Interface) ([]*v1.Pod, error) {\n\tvar podArray []*v1.Pod\n\tfor i := 0; i < number; i++ {\n\t\tpod := generatePod()\n\t\t_, err := k8sClient.CoreV1().Pods(pod.Namespace).Create(context.TODO(), pod, metav1.CreateOptions{})\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"error when adding Pods through k8s api: %v\", err)\n\t\t}\n\t\ttime.Sleep(time.Millisecond)\n\t\tpodArray = append(podArray, pod)\n\t}\n\treturn podArray, nil\n}\n\nfunc generatePod() *v1.Pod {\n\tip := getRandomIP()\n\tuid := uuid.New().String()\n\tstartTime := rand.Intn(360000000)\n\tcreationTime := refTime.Add(time.Duration(startTime))\n\tdeletionTime := creationTime.Add(time.Hour)\n\tpod := &v1.Pod{\n\t\tStatus: v1.PodStatus{\n\t\t\tPodIPs: []v1.PodIP{\n\t\t\t\t{\n\t\t\t\t\tIP: ip,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tCreationTimestamp: metav1.Time{Time: creationTime},\n\t\t\tDeletionTimestamp: &metav1.Time{Time: deletionTime},\n\t\t\tName:              \"pod-\" + uid,\n\t\t\tNamespace:         \"pod_ns\",\n\t\t\tUID:               types.UID(uid),\n\t\t},\n\t}\n\treturn pod\n}\n\nfunc getRandomIP() string {\n\treturn fmt.Sprintf(\"%d.%d.%d.%d\", rand.Intn(256), rand.Intn(256), rand.Intn(256), rand.Intn(256))\n}"
