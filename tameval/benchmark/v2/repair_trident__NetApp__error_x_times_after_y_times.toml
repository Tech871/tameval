[meta]
task = "repair"
scenario = "repair_no_new_covered_logic"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "NetApp/trident"
sha = "4d3b2b199cf35d9bee2ff4ea6bb4eb39d65304b3"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/fiji/models/handlers/error_x_times_after_y_times.go internal/fiji/models/handlers/error_x_times_after_y_times_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/fiji/models/handlers/error_x_times_after_y_times.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 100.0
original_coverage = 100.0
mutation_kill_rate = 57.0
original_mutation_kill_rate = 57.0
covered_lines = [ 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 29, 30, 31, 32, 33, 34, 37, 38, 41, 42, 43, 44, 45, 48, 49, 50, 52, 53, 54, 56,]
missed_lines = []

[input_info]
test_file_path = "internal/fiji/models/handlers/error_x_times_after_y_times_test.go"
focal_file_path = "internal/fiji/models/handlers/error_x_times_after_y_times.go"
test_file_url = "https://github.com/NetApp/trident/blob/4d3b2b199cf35d9bee2ff4ea6bb4eb39d65304b3/internal/fiji/models/handlers/error_x_times_after_y_times_test.go"
focal_file_url = "https://github.com/NetApp/trident/blob/4d3b2b199cf35d9bee2ff4ea6bb4eb39d65304b3/internal/fiji/models/handlers/error_x_times_after_y_times.go"
first_commit_date = "2025-04-29"
last_commit_date = "2025-04-29"
test_file_content = "package handlers\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestErrorXTimesAfterYTimesHandler_Variant1(t *testing.T) {\n\ttt := map[string]struct {\n\t\tformatStr   string\n\t\tpassCount   int\n\t\tfailCount   int\n\t\tassertValue assert.ValueAssertionFunc\n\t\tassertError assert.ErrorAssertionFunc\n\t}{\n\t\t\"with no KVP for counts\": {\n\t\t\tformatStr:   `{\"name\":\"error-x-times-after-y-times\"}`,\n\t\t\tassertValue: assert.Nil,\n\t\t\tassertError: assert.Error,\n\t\t},\n\t\t\"with negative passCount\": {\n\t\t\tformatStr:   `{\"name\":\"error-x-times-after-y-times\", \"passCount\": %v, \"failCount\": %v}`,\n\t\t\tpassCount:   -1,\n\t\t\tfailCount:   3,\n\t\t\tassertValue: assert.Nil,\n\t\t\tassertError: assert.Error,\n\t\t},\n\t\t\"with negative failCount\": {\n\t\t\tformatStr:   `{\"name\":\"error-x-times-after-y-times\", \"passCount\": %v, \"failCount\": %v}`,\n\t\t\tpassCount:   2,\n\t\t\tfailCount:   -1,\n\t\t\tassertValue: assert.Nil,\n\t\t\tassertError: assert.Error,\n\t\t},\n\t\t\"with zero passCount\": {\n\t\t\tformatStr:   `{\"name\":\"error-x-times-after-y-times\", \"passCount\": %v, \"failCount\": %v}`,\n\t\t\tpassCount:   0,\n\t\t\tfailCount:   3,\n\t\t\tassertValue: assert.Nil,\n\t\t\tassertError: assert.Error,\n\t\t},\n\t\t\"with zero failCount\": {\n\t\t\tformatStr:   `{\"name\":\"error-x-times-after-y-times\", \"passCount\": %v, \"failCount\": %v}`,\n\t\t\tpassCount:   2,\n\t\t\tfailCount:   0,\n\t\t\tassertValue: assert.Nil,\n\t\t\tassertError: assert.Error,\n\t\t},\n\t\t\"with valid values\": {\n\t\t\tformatStr:   `{\"name\":\"error-x-times-after-y-times\", \"passCount\": %v, \"failCount\": %v}`,\n\t\t\tpassCount:   2,\n\t\t\tfailCount:   3,\n\t\t\tassertValue: assert.NotNil,\n\t\t\tassertError: assert.NoError,\n\t\t},\n\t}\n\n\tfor name, test := range tt {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tmodelStr := fmt.Sprintf(test.formatStr, test.passCount, test.failCount)\n\t\t\thandler, err := NewErrorXTimesAfterYTimesHandler([]byte(modelStr))\n\t\t\tif test.assertError != nil {\n\t\t\t\ttest.assertError(t, err)\n\t\t\t}\n\t\t\tif test.assertValue != nil {\n\t\t\t\ttest.assertValue(t, handler)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestErrorXTimesAfterYTimesHandler_Variant2(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tinput       string\n\t\twantErr     bool\n\t\twantHandler *ErrorXTimesAfterYTimesHandler\n\t}{\n\t\t{\n\t\t\tname:    \"with no KVP for counts\",\n\t\t\tinput:   `{\"name\":\"error-x-times-after-y-times\"}`,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:      \"with negative passCount\",\n\t\t\tinput:     `{\"name\":\"error-x-times-after-y-times\", \"passCount\": -1, \"failCount\": 3}`,\n\t\t\twantErr:   true,\n\t\t\twantHandler: nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"with negative failCount\",\n\t\t\tinput:     `{\"name\":\"error-x-times-after-y-times\", \"passCount\": 2, \"failCount\": -1}`,\n\t\t\twantErr:   true,\n\t\t\twantHandler: nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"with zero passCount\",\n\t\t\tinput:     `{\"name\":\"error-x-times-after-y-times\", \"passCount\": 0, \"failCount\": 3}`,\n\t\t\twantErr:   true,\n\t\t\twantHandler: nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"with zero failCount\",\n\t\t\tinput:     `{\"name\":\"error-x-times-after-y-times\", \"passCount\": 2, \"failCount\": 0}`,\n\t\t\twantErr:   true,\n\t\t\twantHandler: nil,\n\t\t},\n\t\t{\n\t\t\tname:      \"with valid values\",\n\t\t\tinput:     `{\"name\":\"error-x-times-after-y-times\", \"passCount\": 2, \"failCount\": 3}`,\n\t\t\twantErr:   false,\n\t\t\twantHandler: &ErrorXTimesAfterYTimesHandler{\n\t\t\t\tName:        \"error-x-times-after-y-times\",\n\t\t\t\tHitCount:    0,\n\t\t\t\tPassCount:   2,\n\t\t\t\tFailCount:   3,\n\t\t\t\tErrorHitCount: 0,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\thandler, err := NewErrorXTimesAfterYTimesHandler([]byte(test.input))\n\t\t\tif test.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tassert.Nil(t, handler)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.NotNil(t, handler)\n\t\t\t\tassert.Equal(t, test.wantHandler.Name, handler.Name)\n\t\t\t\tassert.Equal(t, test.wantHandler.HitCount, handler.HitCount)\n\t\t\t\tassert.Equal(t, test.wantHandler.PassCount, handler.PassCount)\n\t\t\t\tassert.Equal(t, test.wantHandler.FailCount, handler.FailCount)\n\t\t\t\tassert.Equal(t, test.wantHandler.ErrorHitCount, handler.ErrorHitCount)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestErrorXTimesAfterYTimesHandler_Handle(t *testing.T) {\n\tpassCount := 2\n\tfailCount := 3\n\tmodelJSON := fmt.Sprintf(`{\"name\":\"error-x-times-after-y-times\", \"passCount\": %v, \"failCount\": %v}`, passCount, failCount)\n\thandler, err := NewErrorXTimesAfterYTimesHandler([]byte(modelJSON))\n\tassert.NoError(t, err)\n\tassert.NotNil(t, handler)\n\tassert.Equal(t, passCount, handler.PassCount)\n\tassert.Equal(t, failCount, handler.FailCount)\n\tfor i := 0; i < passCount; i++ {\n\t\tassert.NoError(t, handler.Handle())\n\t}\n\tfor i := 0; i < failCount; i++ {\n\t\tassert.Error(t, handler.Handle())\n\t}\n\tfor i := 0; i < 5; i++ {\n\t\tassert.NoError(t, handler.Handle())\n\t}\n}\n\nfunc TestErrorXTimesAfterYTimesHandler_Handle_Variant1(t *testing.T) {\n\tpassCount := 2\n\tfailCount := 3\n\tmodelJSON := fmt.Sprintf(`{\"name\":\"error-x-times-after-y-times\", \"passCount\": %v, \"failCount\": %v}`, passCount, failCount)\n\thandler, err := NewErrorXTimesAfterYTimesHandler([]byte(modelJSON))\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create handler: %v\", err)\n\t}\n\tif handler == nil {\n\t\tt.Fatalf(\"Handler is nil\")\n\t}\n\tif handler.PassCount != passCount {\n\t\tt.Fatalf(\"Unexpected PassCount: got %v, want %v\", handler.PassCount, passCount)\n\t}\n\tif handler.FailCount != failCount {\n\t\tt.Fatalf(\"Unexpected FailCount: got %v, want %v\", handler.FailCount, failCount)\n\t}\n\tfor i := 0; i < passCount; i++ {\n\t\tif err := handler.Handle(); err != nil {\n\t\t\tt.Errorf(\"Handle() returned an error on pass %v; want nil: %v\", i+1, err)\n\t\t}\n\t}\n\tfor i := 0; i < failCount; i++ {\n\t\tif err := handler.Handle(); err == nil {\n\t\t\tt.Errorf(\"Handle() returned nil on failure %v; want error\", i+1)\n\t\t}\n\t}\n\tfor i := 0; i < 5; i++ {\n\t\tif err := handler.Handle(); err != nil {\n\t\t\tt.Errorf(\"Handle() returned an error after failures; want nil: %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestErrorXTimesAfterYTimesHandler_Handle_Variant2(t *testing.T) {\n\tpassCount := 2\n\tfailCount := 3\n\tmodelJSON := fmt.Sprintf(`{\"name\":\"error-x-times-after-y-times\", \"passCount\": %v, \"failCount\": %v}`, passCount, failCount)\n\thandler, err := NewErrorXTimesAfterYTimesHandler([]byte(modelJSON))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif handler == nil {\n\t\tt.Fatal(\"Handler is nil\")\n\t}\n\tfor i := 0; i < passCount; i++ {\n\t\terr := handler.Handle()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Handle() returned an error on pass %v; want nil: %v\", i+1, err)\n\t\t}\n\t}\n\tfor i := 0; i < failCount; i++ {\n\t\terr := handler.Handle()\n\t\tif err == nil {\n\t\t\tt.Errorf(\"Handle() returned nil on failure %v; want error\", i+1)\n\t\t}\n\t}\n\tfor i := 0; i < 5; i++ {\n\t\terr := handler.Handle()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Handle() returned an error after failures; want nil: %v\", err)\n\t\t}\n\t}\n}"
