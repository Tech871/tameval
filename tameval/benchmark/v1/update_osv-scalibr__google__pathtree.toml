[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.23.4"

[repo_info]
repository = "google/osv-scalibr"
sha = "68757353cde699f714e3edbe2ef641c84e737ac6"

[run_info]
docker_image = "golang:1.23.4"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out artifact/image/pathtree/pathtree.go artifact/image/pathtree/pathtree_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting artifact/image/pathtree/pathtree.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 61.0
original_coverage = 90.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = [ 38, 39, 40, 41, 42, 49, 50, 57, 58, 59, 60, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 76, 77, 78, 80, 81, 82, 86, 87, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99, 100, 102, 107, 108, 109, 110, 111, 112, 116, 117, 118, 119, 120, 122, 123, 124, 125, 126, 127, 128, 131, 136, 137, 142, 146, 147, 148, 151, 152, 153, 158, 159, 165,]
missed_lines = [ 51, 52, 53, 138, 139, 140, 154, 155, 156, 160, 161, 162, 169, 170, 171, 172, 173, 174, 175, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 210,]

[input_info]
test_file_path = "artifact/image/pathtree/pathtree_test.go"
focal_file_path = "artifact/image/pathtree/pathtree.go"
test_file_url = "https://github.com/google/osv-scalibr/blob/68757353cde699f714e3edbe2ef641c84e737ac6/artifact/image/pathtree/pathtree_test.go"
focal_file_url = "https://github.com/google/osv-scalibr/blob/68757353cde699f714e3edbe2ef641c84e737ac6/artifact/image/pathtree/pathtree.go"
first_commit_date = "2024-11-07"
last_commit_date = "2025-03-14"
test_file_content = "// Copyright 2025 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage pathtree\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n)\n\ntype testVal struct {\n\tstring\n}\n\nfunc assertNoError(t *testing.T, err error) {\n\tt.Helper()\n\n\tif err != nil {\n\t\tt.Errorf(\"%v\", err)\n\t}\n}\n\nfunc testTree(t *testing.T) *Node[testVal] {\n\tt.Helper()\n\n\ttree := NewNode[testVal]()\n\tassertNoError(t, tree.Insert(\"/\", &testVal{\"value0\"}))\n\tassertNoError(t, tree.Insert(\"/a\", &testVal{\"value1\"}))\n\tassertNoError(t, tree.Insert(\"/a/b\", &testVal{\"value2\"}))\n\tassertNoError(t, tree.Insert(\"/a/b/c\", &testVal{\"value3\"}))\n\tassertNoError(t, tree.Insert(\"/a/b/d\", &testVal{\"value4\"}))\n\tassertNoError(t, tree.Insert(\"/a/e\", &testVal{\"value5\"}))\n\tassertNoError(t, tree.Insert(\"/a/e/f\", &testVal{\"value6\"}))\n\tassertNoError(t, tree.Insert(\"/a/b/d/f\", &testVal{\"value7\"}))\n\tassertNoError(t, tree.Insert(\"/a/g\", &testVal{\"value8\"}))\n\tassertNoError(t, tree.Insert(\"/x/y/z\", &testVal{\"value9\"}))\n\n\treturn tree\n}\n\nfunc TestNode_Insert_Error(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ttree *Node[testVal]\n\t\tkey  string\n\t\tval  *testVal\n\t}{\n\t\t{\n\t\t\tname: \"duplicate node\",\n\t\t\ttree: func() *Node[testVal] {\n\t\t\t\ttree := NewNode[testVal]()\n\t\t\t\t_ = tree.Insert(\"/a\", &testVal{\"value1\"})\n\n\t\t\t\treturn tree\n\t\t\t}(),\n\t\t\tkey: \"/a\",\n\t\t\tval: &testVal{\"value2\"},\n\t\t},\n\t\t{\n\t\t\tname: \"duplicate node in subtree\",\n\t\t\ttree: func() *Node[testVal] {\n\t\t\t\ttree := NewNode[testVal]()\n\t\t\t\t_ = tree.Insert(\"/a\", &testVal{\"value1\"})\n\t\t\t\t_ = tree.Insert(\"/a/b\", &testVal{\"value2\"})\n\n\t\t\t\treturn tree\n\t\t\t}(),\n\t\t\tkey: \"/a/b\",\n\t\t\tval: &testVal{\"value3\"},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\terr := tt.tree.Insert(tt.key, tt.val)\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"Node.Insert() expected error, got nil\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_Get(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ttree *Node[testVal]\n\t\tkey  string\n\t\twant *testVal\n\t}{\n\t\t{\n\t\t\tname: \"empty tree\",\n\t\t\ttree: NewNode[testVal](),\n\t\t\tkey:  \"/a\",\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"single node\",\n\t\t\ttree: func() *Node[testVal] {\n\t\t\t\ttree := NewNode[testVal]()\n\t\t\t\t_ = tree.Insert(\"/a\", &testVal{\"value\"})\n\n\t\t\t\treturn tree\n\t\t\t}(),\n\t\t\tkey:  \"/a\",\n\t\t\twant: &testVal{\"value\"},\n\t\t},\n\t\t{\n\t\t\tname: \"nonexistent node in single node tree\",\n\t\t\ttree: func() *Node[testVal] {\n\t\t\t\ttree := NewNode[testVal]()\n\t\t\t\t_ = tree.Insert(\"/a\", &testVal{\"value\"})\n\n\t\t\t\treturn tree\n\t\t\t}(),\n\t\t\tkey:  \"/b\",\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"root node\",\n\t\t\ttree: testTree(t),\n\t\t\tkey:  \"/\",\n\t\t\twant: &testVal{\"value0\"},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple nodes\",\n\t\t\ttree: testTree(t),\n\t\t\tkey:  \"/a/b/c\",\n\t\t\twant: &testVal{\"value3\"},\n\t\t},\n\t\t{\n\t\t\tname: \"nonexistent node\",\n\t\t\ttree: testTree(t),\n\t\t\tkey:  \"/a/b/g\",\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.tree.Get(tt.key)\n\t\t\tif diff := cmp.Diff(tt.want, got, cmp.AllowUnexported(testVal{})); diff != \"\" {\n\t\t\t\tt.Errorf(\"Node.Get() (-want +got): %v\", diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestNode_GetChildren(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ttree *Node[testVal]\n\t\tkey  string\n\t\twant []*testVal\n\t}{\n\t\t{\n\t\t\tname: \"empty tree\",\n\t\t\ttree: NewNode[testVal](),\n\t\t\tkey:  \"/a\",\n\t\t\twant: nil,\n\t\t},\n\t\t{\n\t\t\tname: \"single node no children\",\n\t\t\ttree: func() *Node[testVal] {\n\t\t\t\ttree := NewNode[testVal]()\n\t\t\t\t_ = tree.Insert(\"/a\", &testVal{\"value\"})\n\n\t\t\t\treturn tree\n\t\t\t}(),\n\t\t\tkey:  \"/a\",\n\t\t\twant: []*testVal{},\n\t\t},\n\t\t{\n\t\t\tname: \"root node\",\n\t\t\ttree: testTree(t),\n\t\t\tkey:  \"/\",\n\t\t\t// /x is not included since the subdir is nil.\n\t\t\twant: []*testVal{\n\t\t\t\t{\"value1\"}, // \"value1\" is a value of /a\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple nodes with children\",\n\t\t\ttree: testTree(t),\n\t\t\tkey:  \"/a/b\",\n\t\t\twant: []*testVal{\n\t\t\t\t{\"value3\"},\n\t\t\t\t{\"value4\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"nonexistent node\",\n\t\t\ttree: testTree(t),\n\t\t\tkey:  \"/a/b/g\",\n\t\t\twant: nil,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.tree.GetChildren(tt.key)\n\t\t\tif diff := cmp.Diff(tt.want, got, cmp.AllowUnexported(testVal{}), cmpopts.SortSlices(func(a, b *testVal) bool {\n\t\t\t\treturn strings.Compare(a.string, b.string) < 0\n\t\t\t})); diff != \"\" {\n\t\t\t\tt.Errorf(\"Node.GetChildren() (-want +got): %v\", diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype keyValue struct {\n\tkey string\n\tval string\n}\n\nfunc TestNode_Walk(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\ttree *Node[testVal]\n\t\twant []keyValue\n\t}{\n\t\t{\n\t\t\tname: \"empty tree\",\n\t\t\ttree: NewNode[testVal](),\n\t\t\twant: []keyValue{},\n\t\t},\n\t\t{\n\t\t\tname: \"single node\",\n\t\t\ttree: func() *Node[testVal] {\n\t\t\t\ttree := NewNode[testVal]()\n\t\t\t\t_ = tree.Insert(\"/a\", &testVal{\"value\"})\n\n\t\t\t\treturn tree\n\t\t\t}(),\n\t\t\twant: []keyValue{\n\t\t\t\t{\"/a\", \"value\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"multiple nodes\",\n\t\t\ttree: testTree(t),\n\t\t\twant: []keyValue{\n\t\t\t\t{key: \"\", val: \"value0\"},\n\t\t\t\t{key: \"/a\", val: \"value1\"},\n\t\t\t\t{key: \"/a/b\", val: \"value2\"},\n\t\t\t\t{key: \"/a/b/c\", val: \"value3\"},\n\t\t\t\t{key: \"/a/b/d\", val: \"value4\"},\n\t\t\t\t{key: \"/a/e\", val: \"value5\"},\n\t\t\t\t{key: \"/a/e/f\", val: \"value6\"},\n\t\t\t\t{key: \"/a/b/d/f\", val: \"value7\"},\n\t\t\t\t{key: \"/a/g\", val: \"value8\"},\n\t\t\t\t{key: \"/x/y/z\", val: \"value9\"},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := []keyValue{}\n\t\t\terr := tt.tree.Walk(func(path string, node *testVal) error {\n\t\t\t\tgot = append(got, keyValue{key: path, val: node.string})\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Node.Walk() error = %v\", err)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(tt.want, got, cmp.AllowUnexported(keyValue{}), cmpopts.SortSlices(func(a, b keyValue) bool {\n\t\t\t\tif a.key == b.key {\n\t\t\t\t\treturn a.val < b.val\n\t\t\t\t}\n\t\t\t\treturn a.key < b.key\n\t\t\t})); diff != \"\" {\n\t\t\t\tt.Errorf(\"Node.Walk() (-want +got): %v\", diff)\n\t\t\t}\n\t\t})\n\t}\n}"
