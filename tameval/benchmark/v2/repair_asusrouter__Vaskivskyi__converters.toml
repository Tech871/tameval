[meta]
task = "repair"
scenario = "repair_missed_asserts"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "Vaskivskyi/asusrouter"
sha = "1f98018ace04703492b654cd02f4f3a4890cedcb"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "(pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=asusrouter/tools/converters.py -m pytest -q --junit-xml=test_output.xml tests/tools/test_converters.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target asusrouter.tools.converters --unit-test tests.tools.test_converters --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target asusrouter/tools/converters.py --unit-test tests/tools/test_converters.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 0.0
original_coverage = 100.0
mutation_kill_rate = 0
original_mutation_kill_rate = 7.0
covered_lines = []
missed_lines = [ 10, 12, 13, 14, 15, 17, 19, 20, 23, 24, 27, 30, 33, 34, 35, 37, 40, 48, 49, 50, 51, 52, 54, 57, 61, 62, 64, 66, 67, 69, 72, 80, 81, 83, 84, 86, 87, 88, 89, 93, 95, 96, 97, 99, 100, 101, 102, 104, 105, 108, 114, 115, 117, 119, 121, 123, 124, 126, 127, 129, 130, 132, 135, 140, 141, 142, 143, 145, 146, 148, 151, 154, 155, 156, 159, 162, 163, 166, 167, 170, 171, 173, 176, 182, 183, 186, 188, 192, 194, 195, 198, 202, 205, 208, 211, 214, 215, 217, 218, 220, 223, 228, 229, 231, 232, 234, 235, 237, 240, 245, 246, 248, 249, 251, 252, 253, 254, 255, 256, 258, 260, 263, 264, 267, 268, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 281, 284, 287, 288, 291, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 315, 316, 319, 320, 322, 323, 324, 325, 326, 327, 328, 331, 341, 342, 344, 345, 347, 349, 351, 353, 354, 356, 357, 359, 362, 363, 366, 369, 370, 375, 378, 381, 384, 385, 388, 389, 399, 402, 403, 409, 414, 417, 418, 420, 421, 423, 426, 429, 432, 433, 438, 439, 441, 444, 445, 448, 451, 461, 462, 464, 466, 469, 472, 477, 478, 485, 486, 488, 489, 490, 493, 494, 497, 520, 521, 522, 523, 530, 531, 534, 536, 537, 540, 543, 552, 554, 555, 558, 559, 563, 564, 567, 573, 574, 576, 579, 580, 582, 585, 596, 597, 600, 601, 603, 606, 609, 610, 612, 613, 614, 615, 616, 617, 618, 621, 624, 625, 627, 630, 633, 635, 636, 638, 641, 648, 649, 651,]

[input_info]
test_file_path = "tests/tools/test_converters.py"
focal_file_path = "asusrouter/tools/converters.py"
test_file_url = "https://github.com/Vaskivskyi/asusrouter/blob/1f98018ace04703492b654cd02f4f3a4890cedcb/tests/tools/test_converters.py"
focal_file_url = "https://github.com/Vaskivskyi/asusrouter/blob/1f98018ace04703492b654cd02f4f3a4890cedcb/asusrouter/tools/converters.py"
first_commit_date = "2023-10-28"
last_commit_date = "2025-08-13"
test_file_content = "\nfrom datetime import UTC, datetime, timedelta\nfrom enum import Enum\nfrom typing import Any\nfrom unittest.mock import MagicMock, patch\n\nimport pytest\n\nfrom asusrouter.tools import converters\n\n\n@pytest.mark.parametrize(\n    (\"input_value\", \"jitter\", \"expected_output\"),\n    [\n        (0, 1, 1),\n        (1, 1, 1),\n        (2, 1, 1),\n        (3, 1, 4),\n        (4, 1, 4),\n        (5, 1, 4),\n        (6, 1, 7),\n        (7, 1, 7),\n        (8, 1, 7),\n        (0, 2, 2),\n        (11, 2, 12),\n        (0, 3, 3),\n        (1, 4, 4),\n        (5, 11, 11),\n        (\"2\", 1, 1),\n        (0.9, 2, 2),\n        (\"4.4\", 1, 4),\n        (15, -1, 15),\n        (77, 0, 77),\n        (\"any\", -1, \"any\"),\n        (None, None, None),\n        (\"None\", None, \"None\"),\n        (\"string\", None, \"string\"),\n        (\" \", None, \" \"),\n    ],\n)\ndef test_clean_jitter(\n    input_value: Any, jitter: Any | None, expected_output: Any\n) -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"content\", \"result\"),\n    [\n        (None, None),\n        (12, None),\n        (\"\", None),\n        (\"  \", None),\n        (\"test\", \"test\"),\n        (\"  test  \", \"test\"),\n    ],\n)\ndef test_clean_string(content: str | None, result: str | None) -> None:\n\n\n\ndef test_flatten_dict() -> None:\n\n    nested_dict = {\"a\": {\"b\": {\"c\": 1}}, \"d\": {\"e\": 2}}\n    expected_output = {\"a_b_c\": 1, \"d_e\": 2}\n\n\n    nested_dict = {\"a\": {\"b\": {\"c\": 1}}, \"d\": 2}\n    expected_output = {\"a_b\": {\"c\": 1}, \"d\": 2}\n\n\nclass EnumForTest(Enum):\n\n    A = 1\n    B = 2\n\n\n@pytest.mark.parametrize(\n    (\"args\", \"kwargs\", \"expected_result\"),\n    [\n        (\"vpnc_unit\", {\"vpnc_unit\": 1}, 1),\n        (\"vpnc_unit\", {\"arguments\": {\"vpnc_unit\": 1}}, 1),\n        ((\"vpnc_unit\",), {\"vpnc_unit\": 1}, 1),\n        ((\"vpnc_unit\",), {\"arguments\": {\"vpnc_unit\": 1}}, 1),\n        (\n            (\"vpnc_unit\", \"vpnc_clientlist\"),\n            {\"vpnc_unit\": 1, \"vpnc_clientlist\": \"list\"},\n            (1, \"list\"),\n        ),\n        ((\"vpnc_unit\", \"vpnc_clientlist\"), {\"vpnc_unit\": 1}, (1, None)),\n        (None, {\"vpnc_unit\": 1}, None),\n        (1, {\"vpnc_unit\": 1}, None),\n    ],\n)\ndef test_get_arguments(\n    args: str | tuple[str, ...],\n    kwargs: Any,\n    expected_result: Any | tuple[Any | None, ...],\n) -> None:\n    result = converters.get_arguments(args, **kwargs)\n\n\ndef test_get_enum_key_by_value() -> None:\n\n    with pytest.raises(ValueError):\n        converters.get_enum_key_by_value(EnumForTest, 3)\n\n\n@pytest.mark.parametrize(\n    (\"content\", \"result\"),\n    [\n        (0, [False]),\n        (1, [True]),\n        (2, [False, True]),\n        (3, [True, True]),\n        (10, [False, True, False, True]),\n        (-1, []),\n        (\"string\", []),\n        (None, []),\n    ],\n)\ndef test_int_as_bits(content: int, result: list[bool]) -> None:\nclass Capabilities(Enum):\n\n    CAPABILITY1 = 0\n    CAPABILITY2 = 1\n    CAPABILITY3 = 2\n    CAPABILITY4 = 3\n    CAPABILITY5 = \"not an int\"\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"capabilities\", \"result\"),\n    [\n        (\n            0,\n            Capabilities,\n            {\n                Capabilities.CAPABILITY1: False,\n                Capabilities.CAPABILITY2: False,\n                Capabilities.CAPABILITY3: False,\n                Capabilities.CAPABILITY4: False,\n            },\n        ),\n        (\n            1,\n            Capabilities,\n            {\n                Capabilities.CAPABILITY1: True,\n                Capabilities.CAPABILITY2: False,\n                Capabilities.CAPABILITY3: False,\n                Capabilities.CAPABILITY4: False,\n            },\n        ),\n        (\n            10,\n            Capabilities,\n            {\n                Capabilities.CAPABILITY1: False,\n                Capabilities.CAPABILITY2: True,\n                Capabilities.CAPABILITY3: False,\n                Capabilities.CAPABILITY4: True,\n            },\n        ),\n        (None, Capabilities, {}),\n        (\"string\", Capabilities, {}),\n        (15, \"not an enum\", {}),\n        (15, None, {}),\n    ],\n)\ndef test_int_as_capabilities(\n    value: int, capabilities: type[Enum], result: dict[Enum, bool]\n) -> None:\n\n\n\ndef test_is_enum() -> None:\n\n    class TestEnum(Enum):\n\n        A = 1\n        B = 2\n\n    class NotEnum:\n\n\ndef test_list_from_dict() -> None:\n\n\n\n\n\ndef test_nvram_get() -> None:\n\n\n\n\n\ndef test_run_method() -> None:\n\n\n\n    class TestEnum(Enum):\n\n        A = 1\n        B = 2\n    class TestEnumWithUnknown(Enum):\n\n        UNKNOWN = -999\n        A = 1\n        B = 2\n\n\n\n@pytest.mark.parametrize(\n    (\"content\", \"result\"),\n    [\n        (None, None),\n        (\"\", None),\n        (\"  \", None),\n        (\"unknown\", None),\n        (\"test\", None),\n        (\"  test  \", None),\n        (False, False),\n        (0, False),\n        (\"0\", False),\n        (\"false\", False),\n        (\"off\", False),\n        (\"disabled\", False),\n        (True, True),\n        (1, True),\n        (\"1\", True),\n        (\"true\", True),\n        (\"on\", True),\n        (\"enabled\", True),\n    ],\n)\ndef test_safe_bool(\n    content: str | float | bool | None, result: bool | None\n) -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"content\", \"result\"),\n    [\n        (\"2021-01-01   \", datetime(2021, 1, 1)),\n        (\"2021-01-01 00:00:00\", datetime(2021, 1, 1)),\n        (None, None),\n        (\"\", None),\n        (\"  \", None),\n        (\"unknown\", None),\n        (\"test\", None),\n        (\"  test  \", None),\n    ],\n)\ndef test_safe_datetime(content: str | None, result: datetime | None) -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"enum\", \"value\", \"default_value\", \"default\", \"expected\"),\n    [\n        (EnumForTest, 1, None, None, EnumForTest.A),\n        (EnumForTest, 2, None, None, EnumForTest.B),\n        (EnumForTest, None, 1, None, EnumForTest.A),\n        (EnumForTest, None, 2, None, EnumForTest.B),\n        (EnumForTest, None, None, EnumForTest.A, EnumForTest.A),\n        (EnumForTest, None, None, EnumForTest.B, EnumForTest.B),\n        (EnumForTest, 3, None, None, None),\n        (EnumForTest, None, None, None, None),\n        (EnumForTest, None, 2, EnumForTest.B, EnumForTest.B),\n    ],\n)\ndef test_safe_enum(\n    enum: type[Enum],\n    value: int | None,\n    default_value: int | None,\n    default: Enum | None,\n    expected: Enum | None,\n) -> None:\n\n\n\ndef test_safe_exists() -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"content\", \"result\"),\n    [\n        (1, 1.0),\n        (1.0, 1.0),\n        (\"1\", 1.0),\n        (\"1.0\", 1.0),\n        (None, None),\n        (\"\", None),\n        (\"  \", None),\n        (\"unknown\", None),\n        (\"test\", None),\n        (\"  test  \", None),\n    ],\n)\ndef test_safe_float(content: str | float | None, result: float | None) -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"content\", \"base\", \"result\"),\n    [\n        (1, 10, 1),\n        (\"1\", 10, 1),\n        (1.0, 10, 1),\n        (\"1.0\", 10, 1),\n        (\"1.1\", 10, 1),\n        (\"1.9\", 10, 1),\n        (None, 10, None),\n        (\"\", 10, None),\n        (\"  \", 10, None),\n        (\"unknown\", 10, None),\n        (\"test\", 10, None),\n        (\"  test  \", 10, None),\n        (\"0x1\", 16, 1),\n        (\"0xA\", 16, 10),\n        (\"0xFF\", 16, 255),\n        (\"0x100\", 16, 256),\n        (\"0xabc\", 16, 2748),\n        (\"0xABC\", 16, 2748),\n        (\"0x2692247c7\", 16, 10353788871),\n        (\"0x123456789ABCDEF\", 16, 81985529216486895),\n    ],\n)\ndef test_safe_int(\n    content: str | float | None, base: int, result: int | None\n) -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"content\", \"result\"),\n    [\n        (None, []),\n        (\"test\", [\"test\"]),\n        (1, [1]),\n        (1.0, [1.0]),\n        (True, [True]),\n        (False, [False]),\n        ([], []),\n        ([1, 2, 3], [1, 2, 3]),\n    ],\n)\ndef test_safe_list(content: Any, result: list[Any]) -> None:\n\n\n\ndef test_safe_list_csv() -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"content\", \"delimiter\", \"result\"),\n    [\n        (None, None, []),\n        (1, None, []),\n        ({1: 2}, None, []),\n        (\"test\", None, [\"test\"]),\n        (\"test1 test2\", None, [\"test1\", \"test2\"]),\n        (\"test1 test2\", \";\", [\"test1 test2\"]),\n    ],\n)\ndef test_safe_list_from_string(\n    content: str | None, delimiter: str, result: list[str]\n) -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"content\", \"result\"),\n    [\n        (None, None),\n        (1, 1),\n        (5.0, 5.0),\n        ([1, 2, 3], [1, 2, 3]),\n        ({\"a\": 1}, {\"a\": 1}),\n        (\"test\", \"test\"),\n        (\"   test   \", \"test\"),\n        (\"   \", None),\n        (\"\", None),\n    ],\n)\ndef test_safe_return(content: Any, result: Any) -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"current\", \"previous\", \"time_delta\", \"result\"),\n    [\n        (None, None, None, 0.0),\n        (1, None, None, 0.0),\n        (1, 1, None, 0.0),\n        (1, 1, 0, 0.0),\n        (1, 1, 1, 0.0),\n        (1, 1, 2, 0.0),\n        (1, 2, 1, 0.0),\n        (2, 1, 1, 1.0),\n        (4, 2, 2, 1.0),\n    ],\n)\ndef test_safe_speed(\n    current: float, previous: float, time_delta: float | None, result: float\n) -> None:\n\n\n\n@patch(\"asusrouter.tools.converters.datetime\")\ndef test_safe_time_from_delta(mock_datetime: MagicMock) -> None:\n    mock_datetime.now.return_value = datetime(2023, 8, 15, tzinfo=UTC)\n\n    result = converters.safe_time_from_delta(\n        \"48:00:15\"\n    )\n    expected = datetime(2023, 8, 12, 23, 59, 45, tzinfo=UTC)\n\n\ndef test_safe_timedelta_long() -> None:\n\n\n\n\ndef test_safe_unpack_key() -> None:\n\n    def test_method(content: Any) -> dict[str, Any]:\n\n        return {\"content\": content}\n    result = converters.safe_unpack_key(\"key\")\n    result = converters.safe_unpack_key((\"key\", test_method))\n    if result[1] is not None and not isinstance(result[1], list):\n    elif result[1] is not None:\n    else:\n    result = converters.safe_unpack_key((\"key\", [test_method, test_method]))\n    if isinstance(result[1], list):\n    result = converters.safe_unpack_key((\"key\", 123))\n    result = converters.safe_unpack_key((\"key\",))\n\n\ndef test_safe_unpack_keys() -> None:\n\n    def test_method(content: Any) -> dict[str, Any]:\n\n        return {\"content\": content}\n    result = converters.safe_unpack_keys((\"key\", \"key_to_use\", test_method))\n    result = converters.safe_unpack_keys(\n        (\"key\", \"key_to_use\", [test_method, test_method])\n    )\n    result = converters.safe_unpack_keys((\"key\", \"key_to_use\"))\n    result = converters.safe_unpack_keys(\"key\")\n\n\n@pytest.mark.parametrize(\n    (\"used\", \"total\", \"result\"),\n    [\n        (5, 10, 50.0),\n        (10, 10, 100.0),\n        (3, 9, 33.33),\n        (-1, 2, 0.0),\n        (1, -2, 0.0),\n        (-1, -1, 100.0),\n        (1, 0, 0.0),\n        (0, 0, 0.0),\n    ],\n)\ndef test_safe_usage(used: float, total: float, result: float) -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"used\", \"total\", \"prev_used\", \"prev_total\", \"result\"),\n    [\n        (10, 20, 5, 10, 50.0),\n        (10, 20, 10, 20, 0.0),\n        (6, 18, 3, 9, 33.33),\n        (\n            5,\n            20,\n            10,\n            10,\n            0.0,\n        ),\n        (\n            10,\n            20,\n            5,\n            25,\n            0.0,\n        ),\n        (\n            5,\n            10,\n            10,\n            20,\n            0.0,\n        ),\n    ],\n)\ndef test_safe_usage_historic(\n    used: float,\n    total: float,\n    prev_used: float,\n    prev_total: float,\n    result: float,\n) -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"result\"),\n    [\n        (\n            1700515143689,\n            datetime(2023, 11, 20, 21, 19, 3, 689000, tzinfo=UTC),\n        ),\n        (None, None),\n        (0, datetime(1970, 1, 1, 0, 0, 0, tzinfo=UTC)),\n        (\"test\", None),\n    ],\n)\ndef test_safe_timestamp_to_utc(\n    value: int | None, result: datetime | None\n) -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"result\"),\n    [\n        (\n            datetime(2023, 11, 20, 21, 19, 3, 689000, tzinfo=UTC),\n            1700515143.689,\n        ),\n        (None, None),\n        (datetime(1970, 1, 1, 0, 0, 0, tzinfo=UTC), 0),\n        (\"test\", None),\n    ],\n)\ndef test_safe_utc_to_timestamp(\n    value: datetime | None, result: float | None\n) -> None:\n\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"result\"),\n    [\n        (\n            datetime(2023, 11, 20, 21, 19, 3, 689000, tzinfo=UTC),\n            1700515143689,\n        ),\n        (None, None),\n        (datetime(1970, 1, 1, 0, 0, 0, tzinfo=UTC), 0),\n        (\"test\", None),\n    ],\n)\ndef test_safe_utc_to_timestamp_milli(\n    value: datetime | None, result: int | None\n) -> None:"
