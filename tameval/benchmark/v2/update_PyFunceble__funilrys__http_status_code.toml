[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Python"
python_cfg_file = "requirements.txt"

[repo_info]
repository = "funilrys/PyFunceble"
sha = "3e6e0cf72a6e6a82298fe503bf7fad6907446136"
bench_version = 2

[run_info]
docker_image = "python:3"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r requirements.txt && pip install -r requirements.win.txt && pip install -r requirements.docs.txt && pip install -r requirements.test.txt && pip install -r requirements.dev.txt && (pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=PyFunceble/query/http_status_code.py -m pytest -q --junit-xml=test_output.xml tests/query/test_http_status_code.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target PyFunceble.query.http_status_code --unit-test tests.query.test_http_status_code --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target PyFunceble/query/http_status_code.py --unit-test tests/query/test_http_status_code.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 95.0
original_coverage = 100.0
mutation_kill_rate = nan
original_mutation_kill_rate = 95.0
covered_lines = [ 52, 53, 54, 56, 57, 58, 59, 62, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 108, 116, 117, 118, 119, 123, 125, 127, 128, 133, 135, 136, 149, 150, 152, 153, 155, 157, 165, 167, 169, 170, 175, 177, 178, 192, 193, 195, 196, 198, 200, 208, 210, 212, 217, 218, 220, 222, 224, 225, 230, 232, 233, 244, 245, 247, 249, 257, 259, 261, 266, 267, 271, 273, 275, 276, 281, 283, 284, 295, 296, 298, 300, 308, 310, 312, 313, 337, 338, 345, 349, 354, 358, 365,]
missed_lines = [ 350, 363, 366, 374, 376,]

[input_info]
test_file_path = "tests/query/test_http_status_code.py"
focal_file_path = "PyFunceble/query/http_status_code.py"
test_file_url = "https://github.com/funilrys/PyFunceble/blob/3e6e0cf72a6e6a82298fe503bf7fad6907446136/tests/query/test_http_status_code.py"
focal_file_url = "https://github.com/funilrys/PyFunceble/blob/3e6e0cf72a6e6a82298fe503bf7fad6907446136/PyFunceble/query/http_status_code.py"
first_commit_date = "2020-12-19"
last_commit_date = "2025-02-23"
test_file_content = "\"\"\"\nThe tool to check the availability or syntax of domain, IP or URL.\n\n::\n\n\n    ██████╗ ██╗   ██╗███████╗██╗   ██╗███╗   ██╗ ██████╗███████╗██████╗ ██╗     ███████╗\n    ██╔══██╗╚██╗ ██╔╝██╔════╝██║   ██║████╗  ██║██╔════╝██╔════╝██╔══██╗██║     ██╔════╝\n    ██████╔╝ ╚████╔╝ █████╗  ██║   ██║██╔██╗ ██║██║     █████╗  ██████╔╝██║     █████╗\n    ██╔═══╝   ╚██╔╝  ██╔══╝  ██║   ██║██║╚██╗██║██║     ██╔══╝  ██╔══██╗██║     ██╔══╝\n    ██║        ██║   ██║     ╚██████╔╝██║ ╚████║╚██████╗███████╗██████╔╝███████╗███████╗\n    ╚═╝        ╚═╝   ╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝╚══════╝╚═════╝ ╚══════╝╚══════╝\n\nTests of the HTTP status code query tool.\n\nAuthor:\n    Nissar Chababy, @funilrys, contactTATAfunilrysTODTODcom\n\nSpecial thanks:\n    https://pyfunceble.github.io/special-thanks.html\n\nContributors:\n    https://pyfunceble.github.io/contributors.html\n\nProject link:\n    https://github.com/funilrys/PyFunceble\n\nProject documentation:\n    https://docs.pyfunceble.com\n\nProject homepage:\n    https://pyfunceble.github.io/\n\nLicense:\n::\n\n\n    Copyright 2017, 2018, 2019, 2020, 2022, 2023, 2024 Nissar Chababy\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        https://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\"\"\"\n\nimport unittest\nimport unittest.mock\n\nimport requests\nimport requests.models\n\nimport PyFunceble.factory\nfrom PyFunceble.config.loader import ConfigLoader\nfrom PyFunceble.query.http_status_code import HTTPStatusCode\n\n\nclass TestHTTPStatusCode(unittest.TestCase):\n    \"\"\"\n    Tests the HTTP status code query tool.\n    \"\"\"\n\n    def setUp(self) -> None:\n        \"\"\"\n        Sets everything needed by the tests.\n        \"\"\"\n\n        self.query_tool = HTTPStatusCode()\n\n        return super().setUp()\n\n    def tearDown(self) -> None:\n        \"\"\"\n        Destroys everything needed by the tests.\n        \"\"\"\n\n        del self.query_tool\n\n    def test_set_subject_return(self) -> None:\n        \"\"\"\n        Tests the response from the method which let us set the subject\n        to work with.\n        \"\"\"\n\n        given = \"example.org\"\n\n        actual = self.query_tool.set_subject(given)\n\n        self.assertIsInstance(actual, HTTPStatusCode)\n\n    def test_set_subject_method(self) -> None:\n        \"\"\"\n        Tests the method which let us set the subject to work with.\n        \"\"\"\n\n        given = \"example.org\"\n        expected = \"example.org\"\n\n        self.query_tool.set_subject(given)\n\n        actual = self.query_tool.subject\n\n        self.assertEqual(expected, actual)\n\n    def test_set_subject_attribute(self) -> None:\n        \"\"\"\n        Tests overwritting of the :code:`subject` attribute.\n        \"\"\"\n\n        given = \"example.org\"\n        expected = \"example.org\"\n\n        self.query_tool.subject = given\n        actual = self.query_tool.subject\n\n        self.assertEqual(expected, actual)\n\n    def test_set_subject_through_init(self) -> None:\n        \"\"\"\n        Tests the overwritting of the subject to work through the class\n        constructor.\n        \"\"\"\n\n        given = \"example.org\"\n        expected = \"example.org\"\n\n        query_tool = HTTPStatusCode(subject=given)\n        actual = query_tool.subject\n\n        self.assertEqual(expected, actual)\n\n    def test_set_subject_not_str(self) -> None:\n        \"\"\"\n        Tests the method which let us set the subject to work with for the case\n        that the given subject is not a :py:class:`str`.\n        \"\"\"\n\n        given = [\"Hello\", \"World!\"]\n\n        self.assertRaises(TypeError, lambda: self.query_tool.set_subject(given))\n\n    def test_set_subject_empty_str(self) -> None:\n        \"\"\"\n        Tests the method which let us set the subject to work with for the case\n        that the given subject is an empty :py:class:`str`.\n        \"\"\"\n\n        given = \"\"\n\n        self.assertRaises(ValueError, lambda: self.query_tool.set_subject(given))\n\n    def test_set_timeout_return(self) -> None:\n        \"\"\"\n        Tests the response from the method which let us set the timeout\n        to work with.\n        \"\"\"\n\n        given = 15.0\n\n        actual = self.query_tool.set_timeout(given)\n\n        self.assertIsInstance(actual, HTTPStatusCode)\n\n    def test_set_timeout_method(self) -> None:\n        \"\"\"\n        Tests the method which let us set the timeout to work with.\n        \"\"\"\n\n        given = 15.0\n        expected = 15.0\n\n        self.query_tool.set_timeout(given)\n\n        actual = self.query_tool.timeout\n\n        self.assertEqual(expected, actual)\n\n    def test_set_timeout_attribute(self) -> None:\n        \"\"\"\n        Tests overwritting of the :code:`timeout` attribute.\n        \"\"\"\n\n        given = 15.0\n        expected = 15.0\n\n        self.query_tool.timeout = given\n        actual = self.query_tool.timeout\n\n        self.assertEqual(expected, actual)\n\n    def test_set_timeout_through_init(self) -> None:\n        \"\"\"\n        Tests the overwritting of the timeout to work through the class\n        constructor.\n        \"\"\"\n\n        given = 15.0\n        expected = 15.0\n\n        query_tool = HTTPStatusCode(timeout=given)\n        actual = query_tool.timeout\n\n        self.assertEqual(expected, actual)\n\n    def test_set_timeout_not_int_nor_float(self) -> None:\n        \"\"\"\n        Tests the method which let us set the timeout to work with for the case\n        that the given timeout is not a :py:class:`int`.\n        \"\"\"\n\n        given = [\"Hello\", \"World!\"]\n\n        self.assertRaises(TypeError, lambda: self.query_tool.set_timeout(given))\n\n    def test_set_timeout_lower_than_1(self) -> None:\n        \"\"\"\n        Tests the method which let us set the timeout to work with for the case\n        that the given timeout is less than 1.\n        \"\"\"\n\n        given = 0.5\n        expected = 0.5\n\n        query_tool = HTTPStatusCode(timeout=given)\n        actual = query_tool.timeout\n\n        self.assertEqual(expected, actual)\n\n    def test_set_timeout_equal_0(self) -> None:\n        \"\"\"\n        Tests the method which let us set the timeout to work with for the case\n        that the given timeout is equal to 0.\n        \"\"\"\n\n        given = 0\n        expected = 0.0\n\n        query_tool = HTTPStatusCode(timeout=given)\n        actual = query_tool.timeout\n\n        self.assertEqual(expected, actual)\n\n    def test_set_timeout_lower_0(self) -> None:\n        \"\"\"\n        Tests the method which let us set the timeout to work with for the case\n        that the given timeout is lower then 0.\n        \"\"\"\n\n        given = -3\n\n        self.assertRaises(ValueError, lambda: self.query_tool.set_timeout(given))\n\n    def test_guess_and_set_timeout(self) -> None:\n        \"\"\"\n        Tests the method which let us guess and set the timeout from the\n        configuration file.\n        \"\"\"\n\n        config_loader = ConfigLoader()\n        config_loader.set_custom_config({\"lookup\": {\"timeout\": 15.0}}).start()\n\n        self.query_tool.guess_and_set_timeout()\n\n        expected = 15.0\n        actual = self.query_tool.timeout\n\n        self.assertEqual(expected, actual)\n\n        del config_loader\n\n    def test_guess_and_set_timeout_config_not_loaded(self) -> None:\n        \"\"\"\n        Tests the method which let us guess and set the timeout from the\n        configuration file.\n        \"\"\"\n\n        self.query_tool.guess_and_set_timeout()\n\n        expected = self.query_tool.STD_TIMEOUT\n        actual = self.query_tool.timeout\n\n        self.assertEqual(expected, actual)\n\n    def test_set_verify_certificate_return(self) -> None:\n        \"\"\"\n        Tests the response from the method which let us activate or disable\n        the certificate verification.\n        \"\"\"\n\n        given = True\n\n        actual = self.query_tool.set_verify_certificate(given)\n\n        self.assertIsInstance(actual, HTTPStatusCode)\n\n    def test_set_verify_certificate_method(self) -> None:\n        \"\"\"\n        Tests the method which let us activate or disable the certificate\n        verification.\n        \"\"\"\n\n        given = True\n        expected = True\n\n        self.query_tool.set_verify_certificate(given)\n\n        actual = self.query_tool.verify_certificate\n\n        self.assertEqual(expected, actual)\n\n    def test_set_verify_certificate_attribute(self) -> None:\n        \"\"\"\n        Tests overwritting of the :code:`verify_certificate` attribute.\n        \"\"\"\n\n        given = True\n        expected = True\n\n        self.query_tool.verify_certificate = given\n        actual = self.query_tool.verify_certificate\n\n        self.assertEqual(expected, actual)\n\n    def test_set_verify_certificate_through_init(self) -> None:\n        \"\"\"\n        Tests the overwritting of the value of the certificate validation\n        through the class constructor.\n        \"\"\"\n\n        given = True\n        expected = True\n\n        query_tool = HTTPStatusCode(verify_certificate=given)\n        actual = query_tool.verify_certificate\n\n        self.assertEqual(expected, actual)\n\n    def test_set_verify_certificate_not_bool(self) -> None:\n        \"\"\"\n        Tests the method which let us activate or disable the certificate\n        validation for the case that the given value is not a :py:class`bool`.\n        \"\"\"\n\n        given = [\"Hello\", \"World!\"]\n\n        self.assertRaises(\n            TypeError, lambda: self.query_tool.set_verify_certificate(given)\n        )\n\n    def test_guess_and_set_verify_certificate(self) -> None:\n        \"\"\"\n        Tests the method which let us guess and set the certificate verification\n        attribute from the configuration file.\n        \"\"\"\n\n        config_loader = ConfigLoader()\n        config_loader.set_custom_config({\"verify_ssl_certificate\": True}).start()\n\n        self.query_tool.guess_and_set_verify_certificate()\n\n        expected = True\n        actual = self.query_tool.verify_certificate\n\n        self.assertEqual(expected, actual)\n\n        del config_loader\n\n    def test_guess_and_set_certificate_verification_config_not_loaded(self) -> None:\n        \"\"\"\n        Tests the method which let us guess and set the certificate\n        verification from the configuration file.\n        \"\"\"\n\n        self.query_tool.guess_and_set_verify_certificate()\n\n        expected = self.query_tool.STD_VERIFY_CERTIFICATE\n        actual = self.query_tool.verify_certificate\n\n        self.assertEqual(expected, actual)\n\n    def test_set_allow_redirects_return(self) -> None:\n        \"\"\"\n        Tests the response from the method which let us allow the redirection.\n        \"\"\"\n\n        given = True\n\n        actual = self.query_tool.set_allow_redirects(given)\n\n        self.assertIsInstance(actual, HTTPStatusCode)\n\n    def test_set_allow_redirects_method(self) -> None:\n        \"\"\"\n        Tests the method which let us allow the redirection.\n        \"\"\"\n\n        given = True\n        expected = True\n\n        self.query_tool.set_allow_redirects(given)\n\n        actual = self.query_tool.allow_redirects\n\n        self.assertEqual(expected, actual)\n\n    def test_set_allow_redirects_not_bool(self) -> None:\n        \"\"\"\n        Tests the method which let us allow the redirection for the case that\n        the given value is not a boolean.\n        \"\"\"\n\n        given = [\"Hello\", \"World!\"]\n\n        self.assertRaises(TypeError, lambda: self.query_tool.set_allow_redirects(given))\n\n    def test_set_allow_redirects_attribute(self) -> None:\n        \"\"\"\n        Tests overwritting of the :code:`allow_redirects` attribute.\n        \"\"\"\n\n        given = True\n        expected = True\n\n        self.query_tool.allow_redirects = given\n        actual = self.query_tool.allow_redirects\n\n        self.assertEqual(expected, actual)\n\n    def test_set_allow_redirects_through_init(self) -> None:\n        \"\"\"\n        Tests the overwritting of the attribute which let us allow the\n        redirection.\n        \"\"\"\n\n        given = True\n        expected = True\n\n        query_tool = HTTPStatusCode(allow_redirects=given)\n        actual = query_tool.allow_redirects\n\n        self.assertEqual(expected, actual)\n\n    def test_get_status_code_no_subject(self) -> None:\n        \"\"\"\n        Tests the method which let us get the status code of the given subject\n        for the case that no subject is actually given.\n        \"\"\"\n\n        # pylint: disable=unnecessary-lambda\n        self.assertRaises(TypeError, lambda: self.query_tool.get_status_code())\n\n    @unittest.mock.patch.object(PyFunceble.factory.Requester, \"get\")\n    def test_get_status_code(self, request_mock) -> None:\n        \"\"\"\n        Tests the method which let us get the status code of the given subject.\n        \"\"\"\n\n        def mocking(*args, **kwargs):  # pylint: disable=unused-argument\n            response_content = \"I'm a teapot.\"\n\n            response = requests.models.Response()\n            response.url = \"https://example.org\"\n            response.status_code = 418\n\n            # pylint: disable=protected-access\n            response._content = str.encode(response_content)\n\n            response.history = [response]\n\n            return response\n\n        self.query_tool.subject = \"https://example.org\"\n\n        request_mock.side_effect = mocking\n\n        expected = 418\n        actual = self.query_tool.get_status_code()\n\n        self.assertEqual(expected, actual)\n\n    @unittest.mock.patch.object(PyFunceble.factory.Requester, \"get\")\n    def test_get_status_code_error(self, request_mock) -> None:\n        \"\"\"\n        Tests the method which let us get the status code of the given subject\n        for the case that an error happened during the request.\n        \"\"\"\n\n        def mocking(*args, **kwargs):  # pylint: disable=unused-argument\n            raise PyFunceble.factory.Requester.exceptions.ConnectionError(\n                \"I'm a teapot.\"\n            )\n\n        self.query_tool.subject = \"https://example.org\"\n\n        request_mock.side_effect = mocking\n\n        expected = self.query_tool.STD_UNKNOWN_STATUS_CODE\n        actual = self.query_tool.get_status_code()\n\n        self.assertEqual(expected, actual)\n\n    @unittest.mock.patch.object(PyFunceble.factory.Requester, \"get\")\n    def test_get_status_code_too_many_redirects(self, request_mock) -> None:\n        \"\"\"\n        Tests the method which let us get the status code of the given subject\n        for the case that too many redirects happened during the request.\n        \"\"\"\n\n        def mocking(*args, **kwargs):  # pylint: disable=unused-argument\n            raise PyFunceble.factory.Requester.exceptions.TooManyRedirects(\n                \"Exceeded 30 redirects.\"\n            )\n\n        self.query_tool.subject = \"https://example.org\"\n\n        request_mock.side_effect = mocking\n\n        expected = self.query_tool.STD_UNKNOWN_STATUS_CODE\n        actual = self.query_tool.get_status_code()\n\n        self.assertEqual(expected, actual)\n\n    @unittest.mock.patch.object(PyFunceble.factory.Requester, \"get\")\n    def test_get_status_code_http_to_https(self, request_mock) -> None:\n        \"\"\"\n        Tests the method which let us get the status code of the given subject\n        for the case that a redirection from HTTP to HTTPS is done.\n        \"\"\"\n\n        def mocking(*args, **kwargs):  # pylint: disable=unused-argument\n            first_response = requests.models.Response()\n            first_response.headers = {\"Location\": \"https://example.org\"}\n            first_response.url = \"http://example.org\"\n            first_response.status_code = 302\n\n            final_response = requests.models.Response()\n            final_response.url = \"https://example.org\"\n            final_response.status_code = 200\n\n            # pylint: disable=protected-access\n            final_response._content = \"Hello, World!\".encode(\"utf-8\")\n\n            final_response.history = [first_response]\n\n            return final_response\n\n        self.query_tool.subject = \"http://example.org\"\n\n        request_mock.side_effect = mocking\n\n        expected = 200\n        actual = self.query_tool.get_status_code()\n\n        self.assertEqual(expected, actual)\n\n    @unittest.mock.patch.object(PyFunceble.factory.Requester, \"get\")\n    def test_get_status_code_http_to_https_different_subject(\n        self, request_mock\n    ) -> None:\n        \"\"\"\n        Tests the method which let us get the status code of the given subject\n        for the case that a redirection from HTTP to HTTPS is done but the\n        subject of the HTTPS query is different from the original one.\n        \"\"\"\n\n        def mocking(*args, **kwargs):  # pylint: disable=unused-argument\n            first_response = requests.models.Response()\n            first_response.headers = {\"Location\": \"https://test.example.org\"}\n            first_response.url = \"http://example.org\"\n            first_response.status_code = 302\n\n            final_response = requests.models.Response()\n            final_response.url = \"https://test.example.org\"\n            final_response.status_code = 200\n\n            # pylint: disable=protected-access\n            final_response._content = \"Hello, World!\".encode(\"utf-8\")\n\n            final_response.history = [first_response]\n\n            return final_response\n\n        self.query_tool.subject = \"http://example.org\"\n\n        request_mock.side_effect = mocking\n\n        expected = 302\n        actual = self.query_tool.get_status_code()\n\n        self.assertEqual(expected, actual)\n\n    @unittest.mock.patch.object(PyFunceble.factory.Requester, \"get\")\n    def test_get_status_code_http_to_https_different_subject_allow_redirects(\n        self, request_mock\n    ) -> None:\n        \"\"\"\n        Tests the method which let us get the status code of the given subject\n        for the case that a redirection from HTTP to HTTPS is done but the\n        subject of the HTTPS query is different from the original one.\n\n        In this case, we forces the interface to follow the redirect. Meaning\n        that the status code of the final one should be always returned.\n        \"\"\"\n\n        def mocking(*args, **kwargs):  # pylint: disable=unused-argument\n            first_response = requests.models.Response()\n            first_response.headers = {\"Location\": \"https://test.example.org\"}\n            first_response.url = \"http://example.org\"\n            first_response.status_code = 302\n\n            final_response = requests.models.Response()\n            final_response.url = \"https://test.example.org\"\n            final_response.status_code = 200\n\n            # pylint: disable=protected-access\n            final_response._content = \"Hello, World!\".encode(\"utf-8\")\n\n            final_response.history = [first_response]\n\n            return final_response\n\n        self.query_tool.allow_redirects = True\n        self.query_tool.subject = \"http://example.org\"\n\n        request_mock.side_effect = mocking\n\n        expected = 200\n        actual = self.query_tool.get_status_code()\n\n        self.assertEqual(expected, actual)\n\n    @unittest.mock.patch.object(PyFunceble.factory.Requester, \"get\")\n    def test_get_status_code_http_to_https_multiple_jump(self, request_mock) -> None:\n        \"\"\"\n        Tests the method which let us get the status code of the given subject\n        for the case that a redirection from HTTP to HTTPS is done but other\n        redirect came along the route.\n\n        In this case, only the first one (in the row) should be provided.\n        \"\"\"\n\n        def mocking(*args, **kwargs):  # pylint: disable=unused-argument\n            first_response = requests.models.Response()\n            first_response.headers = {\"Location\": \"https://test.example.org\"}\n            first_response.url = \"http://example.org\"\n            first_response.status_code = 301\n\n            second_response = requests.models.Response()\n            second_response.headers = {\"Location\": \"https://test2.example.org\"}\n            second_response.url = \"https://test.example.org\"\n            second_response.status_code = 302\n\n            third_response = requests.models.Response()\n            third_response.headers = {\"Location\": \"https://example.org\"}\n            third_response.url = \"https://test2.example.org\"\n            third_response.status_code = 302\n\n            final_response = requests.models.Response()\n            final_response.url = \"https://test.example.org\"\n            final_response.status_code = 200\n\n            # pylint: disable=protected-access\n            final_response._content = \"Hello, World!\".encode(\"utf-8\")\n\n            final_response.history = [first_response, second_response, third_response]\n\n            return final_response\n\n        self.query_tool.subject = \"http://example.org\"\n\n        request_mock.side_effect = mocking\n\n        expected = 301\n        actual = self.query_tool.get_status_code()\n\n        self.assertEqual(expected, actual)\n\n    @unittest.mock.patch.object(PyFunceble.factory.Requester, \"get\")\n    def test_get_status_code_http_to_https_multiple_jump_allow_redirects(\n        self, request_mock\n    ) -> None:\n        \"\"\"\n        Tests the method which let us get the status code of the given subject\n        for the case that a redirection from HTTP to HTTPS is done but other\n        redirect came along the route.\n\n        In this case we force the interface to follow the redirect. Meaning that\n        the final status code should be provided.\n        \"\"\"\n\n        def mocking(*args, **kwargs):  # pylint: disable=unused-argument\n            first_response = requests.models.Response()\n            first_response.headers = {\"Location\": \"https://test.example.org\"}\n            first_response.url = \"http://example.org\"\n            first_response.status_code = 301\n\n            second_response = requests.models.Response()\n            second_response.headers = {\"Location\": \"https://test2.example.org\"}\n            second_response.url = \"https://test.example.org\"\n            second_response.status_code = 302\n\n            third_response = requests.models.Response()\n            third_response.headers = {\"Location\": \"https://example.org\"}\n            third_response.url = \"https://test2.example.org\"\n            third_response.status_code = 302\n\n            final_response = requests.models.Response()\n            final_response.url = \"https://test.example.org\"\n            final_response.status_code = 200\n\n            # pylint: disable=protected-access\n            final_response._content = \"Hello, World!\".encode(\"utf-8\")\n\n            final_response.history = [first_response, second_response, third_response]\n\n            return final_response\n\n        self.query_tool.allow_redirects = True\n        self.query_tool.subject = \"http://example.org\"\n\n        request_mock.side_effect = mocking\n\n        expected = 200\n        actual = self.query_tool.get_status_code()\n\n        self.assertEqual(expected, actual)\n\n\nif __name__ == \"__main__\":\n    unittest.main()"
