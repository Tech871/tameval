[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.22"

[repo_info]
repository = "cadence-workflow/cadence"
sha = "6d4ff3b9586899afadea49387fa6cfe75b0d00aa"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out common/rpc/middleware.go common/rpc/middleware_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting common/rpc/middleware.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 84.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "common/rpc/middleware_test.go"
focal_file_path = "common/rpc/middleware.go"
test_file_url = "https://github.com/cadence-workflow/cadence/blob/6d4ff3b9586899afadea49387fa6cfe75b0d00aa/common/rpc/middleware_test.go"
focal_file_url = "https://github.com/cadence-workflow/cadence/blob/6d4ff3b9586899afadea49387fa6cfe75b0d00aa/common/rpc/middleware.go"
first_commit_date = "2021-09-29"
last_commit_date = "2025-01-30"
test_file_content = "// Copyright (c) 2021 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage rpc\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"regexp\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/yarpc/api/transport\"\n\t\"go.uber.org/yarpc/yarpctest\"\n\n\t\"github.com/uber/cadence/common\"\n\t\"github.com/uber/cadence/common/config\"\n\t\"github.com/uber/cadence/common/metrics\"\n\t\"github.com/uber/cadence/common/partition\"\n)\n\nfunc TestAuthOubboundMiddleware(t *testing.T) {\n\tm := authOutboundMiddleware{}\n\t_, err := m.Call(context.Background(), &transport.Request{}, &fakeOutbound{verify: func(request *transport.Request) {\n\t\tassert.Empty(t, request.Headers)\n\t}})\n\tassert.NoError(t, err)\n\n\tm = authOutboundMiddleware{fakeAuthProvider{err: assert.AnError}}\n\t_, err = m.Call(context.Background(), &transport.Request{}, &fakeOutbound{})\n\tassert.Error(t, err)\n\n\tm = authOutboundMiddleware{fakeAuthProvider{token: []byte(\"token\")}}\n\t_, err = m.Call(context.Background(), &transport.Request{}, &fakeOutbound{verify: func(request *transport.Request) {\n\t\tassert.Equal(t, \"token\", request.Headers.Items()[common.AuthorizationTokenHeaderName])\n\t}})\n\tassert.NoError(t, err)\n}\n\nfunc TestResponseInfoMiddleware(t *testing.T) {\n\tm := ResponseInfoMiddleware{}\n\tctx, responseInfo := ContextWithResponseInfo(context.Background())\n\tbody := ioutil.NopCloser(bytes.NewReader([]byte{1, 2, 3, 4, 5}))\n\tresponse, err := m.Call(ctx, &transport.Request{}, &fakeOutbound{response: &transport.Response{Body: body}})\n\tassert.NoError(t, err)\n\tioutil.ReadAll(response.Body)\n\tassert.Equal(t, 5, responseInfo.Size)\n}\n\nfunc TestResponseInfoMiddleware_Error(t *testing.T) {\n\tm := ResponseInfoMiddleware{}\n\tctx, responseInfo := ContextWithResponseInfo(context.Background())\n\t_, err := m.Call(ctx, &transport.Request{}, &fakeOutbound{err: fmt.Errorf(\"test\")})\n\tassert.Error(t, err)\n\tassert.Equal(t, 0, responseInfo.Size)\n}\n\nfunc TestInboundMetricsMiddleware(t *testing.T) {\n\tm := InboundMetricsMiddleware{}\n\th := &fakeHandler{}\n\terr := m.Handle(context.Background(), &transport.Request{Transport: \"grpc\", Caller: \"x-caller\"}, nil, h)\n\tassert.NoError(t, err)\n\tassert.ElementsMatch(t, metrics.GetContextTags(h.ctx), []metrics.Tag{\n\t\tmetrics.TransportTag(\"grpc\"),\n\t\tmetrics.CallerTag(\"x-caller\"),\n\t})\n}\n\nfunc TestOverrideCallerMiddleware(t *testing.T) {\n\tm := overrideCallerMiddleware{\"x-caller\"}\n\t_, err := m.Call(context.Background(), &transport.Request{Caller: \"service\"}, &fakeOutbound{verify: func(r *transport.Request) {\n\t\tassert.Equal(t, \"x-caller\", r.Caller)\n\t}})\n\tassert.NoError(t, err)\n}\n\nfunc TestHeaderForwardingMiddleware(t *testing.T) {\n\tinboundHeaders := map[string]string{\n\t\t\"key-a\": \"inbound-value-a\",\n\t\t\"key-b\": \"inbound-value-b\",\n\t\t\"key-x\": \"inbound-value-x\",\n\t}\n\toutboundHeaders := map[string]string{\n\t\t\"key-b\": \"outbound-value-b\",\n\t\t\"key-c\": \"outbound-value-c\",\n\t}\n\tcombinedHeaders := map[string]string{\n\t\t\"key-a\": \"inbound-value-a\",\n\t\t\"key-b\": \"outbound-value-b\",\n\t\t\"key-c\": \"outbound-value-c\",\n\t\t\"key-x\": \"inbound-value-x\",\n\t}\n\tcombinedHeadersWithoutX := map[string]string{\n\t\t\"key-a\": \"inbound-value-a\",\n\t\t\"key-b\": \"outbound-value-b\",\n\t\t\"key-c\": \"outbound-value-c\",\n\t}\n\n\tctxWithInbound := yarpctest.ContextWithCall(context.Background(), &yarpctest.Call{Headers: inboundHeaders})\n\tmakeRequest := func() *transport.Request {\n\t\t// request and headers are mutated by Call, so we must not share data\n\t\treturn &transport.Request{Headers: transport.HeadersFromMap(outboundHeaders)}\n\t}\n\n\tt.Run(\"default rules\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tm := HeaderForwardingMiddleware{\n\t\t\tRules: []config.HeaderRule{\n\t\t\t\t// default\n\t\t\t\t{\n\t\t\t\t\tAdd:   true,\n\t\t\t\t\tMatch: regexp.MustCompile(\"\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tt.Run(\"no inbound makes no changes\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t// No ongoing inbound call -> keep existing outbound headers\n\t\t\t_, err := m.Call(context.Background(), makeRequest(), &fakeOutbound{verify: func(r *transport.Request) {\n\t\t\t\tassert.Equal(t, outboundHeaders, r.Headers.Items())\n\t\t\t}})\n\t\t\tassert.NoError(t, err)\n\t\t})\n\n\t\tt.Run(\"inbound headers merge missing\", func(t *testing.T) {\n\t\t\tt.Parallel()\n\t\t\t// With ongoing inbound call -> forward inbound headers not present in the request\n\t\t\t_, err := m.Call(ctxWithInbound, makeRequest(), &fakeOutbound{verify: func(r *transport.Request) {\n\t\t\t\tassert.Equal(t, combinedHeaders, r.Headers.Items())\n\t\t\t}})\n\t\t\tassert.NoError(t, err)\n\t\t})\n\t})\n\tt.Run(\"can exclude inbound headers\", func(t *testing.T) {\n\t\tt.Parallel()\n\t\tm := HeaderForwardingMiddleware{\n\t\t\tRules: []config.HeaderRule{\n\t\t\t\t// add by default, earlier tests ensure this works\n\t\t\t\t{\n\t\t\t\t\tAdd:   true,\n\t\t\t\t\tMatch: regexp.MustCompile(\"\"),\n\t\t\t\t},\n\t\t\t\t// remove X\n\t\t\t\t{\n\t\t\t\t\tAdd:   false,\n\t\t\t\t\tMatch: regexp.MustCompile(\"(?i)Key-x\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\t_, err := m.Call(ctxWithInbound, makeRequest(), &fakeOutbound{verify: func(r *transport.Request) {\n\t\t\tassert.Equal(t, combinedHeadersWithoutX, r.Headers.Items())\n\t\t}})\n\t\tassert.NoError(t, err)\n\t})\n}\n\nfunc TestForwardPartitionConfigMiddleware(t *testing.T) {\n\tt.Run(\"inbound middleware\", func(t *testing.T) {\n\t\tpartitionConfig := map[string]string{\"isolation-group\": \"xyz\"}\n\t\tblob, err := json.Marshal(partitionConfig)\n\t\trequire.NoError(t, err)\n\t\ttestCases := []struct {\n\t\t\tmessage                 string\n\t\t\theaders                 transport.Headers\n\t\t\tctx                     context.Context\n\t\t\texpectedPartitionConfig map[string]string\n\t\t\texpectedIsolationGroup  string\n\t\t}{\n\t\t\t{\n\t\t\t\tmessage: \"it injects partition config into context\",\n\t\t\t\theaders: transport.NewHeaders().\n\t\t\t\t\tWith(common.PartitionConfigHeaderName, string(blob)).\n\t\t\t\t\tWith(common.IsolationGroupHeaderName, \"abc\").\n\t\t\t\t\tWith(common.AutoforwardingClusterHeaderName, \"cluster0\"),\n\t\t\t\tctx:                     context.Background(),\n\t\t\t\texpectedPartitionConfig: partitionConfig,\n\t\t\t\texpectedIsolationGroup:  \"abc\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tmessage: \"it overwrites the existing partition config in the context\",\n\t\t\t\theaders: transport.NewHeaders().\n\t\t\t\t\tWith(common.PartitionConfigHeaderName, string(blob)).\n\t\t\t\t\tWith(common.IsolationGroupHeaderName, \"abc\").\n\t\t\t\t\tWith(common.AutoforwardingClusterHeaderName, \"cluster0\"),\n\t\t\t\tctx:                     partition.ContextWithIsolationGroup(partition.ContextWithConfig(context.Background(), map[string]string{\"z\": \"x\"}), \"fff\"),\n\t\t\t\texpectedPartitionConfig: partitionConfig,\n\t\t\t\texpectedIsolationGroup:  \"abc\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tmessage: \"it overwrites the existing partition config in the context with nil config\",\n\t\t\t\theaders: transport.NewHeaders().\n\t\t\t\t\tWith(common.AutoforwardingClusterHeaderName, \"cluster0\"),\n\t\t\t\tctx:                     partition.ContextWithIsolationGroup(partition.ContextWithConfig(context.Background(), map[string]string{\"z\": \"x\"}), \"fff\"),\n\t\t\t\texpectedPartitionConfig: nil,\n\t\t\t\texpectedIsolationGroup:  \"\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tmessage: \"it injects partition config into context only if the request is an auto-fowarding request\",\n\t\t\t\theaders: transport.NewHeaders().\n\t\t\t\t\tWith(common.PartitionConfigHeaderName, string(blob)).\n\t\t\t\t\tWith(common.IsolationGroupHeaderName, \"abc\"),\n\t\t\t\tctx:                     context.Background(),\n\t\t\t\texpectedPartitionConfig: nil,\n\t\t\t\texpectedIsolationGroup:  \"\",\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range testCases {\n\t\t\tt.Run(tt.message, func(t *testing.T) {\n\t\t\t\tm := &ForwardPartitionConfigMiddleware{}\n\t\t\t\th := &fakeHandler{}\n\t\t\t\terr := m.Handle(tt.ctx, &transport.Request{Headers: tt.headers}, nil, h)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, tt.expectedPartitionConfig, partition.ConfigFromContext(h.ctx))\n\t\t\t\tassert.Equal(t, tt.expectedIsolationGroup, partition.IsolationGroupFromContext(h.ctx))\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"outbound middleware\", func(t *testing.T) {\n\t\tpartitionConfig := map[string]string{\"isolation-group\": \"xyz\"}\n\t\tblob, err := json.Marshal(partitionConfig)\n\t\trequire.NoError(t, err)\n\t\ttestCases := []struct {\n\t\t\tmessage                           string\n\t\t\theaders                           transport.Headers\n\t\t\tctx                               context.Context\n\t\t\texpectedSerializedPartitionConfig string\n\t\t\texpectedIsolationGroup            string\n\t\t}{\n\t\t\t{\n\t\t\t\tmessage: \"it retrieves partition config from the context and sets it in the request header\",\n\t\t\t\theaders: transport.NewHeaders().\n\t\t\t\t\tWith(common.AutoforwardingClusterHeaderName, \"cluster0\"),\n\t\t\t\tctx:                               partition.ContextWithIsolationGroup(partition.ContextWithConfig(context.Background(), partitionConfig), \"abc\"),\n\t\t\t\texpectedSerializedPartitionConfig: string(blob),\n\t\t\t\texpectedIsolationGroup:            \"abc\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tmessage: \"it retrieves partition config from the context and overwrites the existing request header\",\n\t\t\t\theaders: transport.NewHeaders().\n\t\t\t\t\tWith(common.IsolationGroupHeaderName, \"lll\").\n\t\t\t\t\tWith(common.PartitionConfigHeaderName, \"asdfasf\").\n\t\t\t\t\tWith(common.AutoforwardingClusterHeaderName, \"cluster0\"),\n\t\t\t\tctx:                               partition.ContextWithIsolationGroup(partition.ContextWithConfig(context.Background(), partitionConfig), \"abc\"),\n\t\t\t\texpectedSerializedPartitionConfig: string(blob),\n\t\t\t\texpectedIsolationGroup:            \"abc\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tmessage: \"it deletes the existing request header if we cannot retrieve partition config from the context\",\n\t\t\t\theaders: transport.NewHeaders().\n\t\t\t\t\tWith(common.IsolationGroupHeaderName, \"lll\").\n\t\t\t\t\tWith(common.PartitionConfigHeaderName, \"asdfasf\").\n\t\t\t\t\tWith(common.AutoforwardingClusterHeaderName, \"cluster0\"),\n\t\t\t\tctx:                               context.Background(),\n\t\t\t\texpectedSerializedPartitionConfig: \"\",\n\t\t\t\texpectedIsolationGroup:            \"\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tmessage: \"it retrieves partition config from the context and sets it in the request header only if the request is an auto-forwarding request\",\n\t\t\t\theaders: transport.NewHeaders().\n\t\t\t\t\tWith(common.IsolationGroupHeaderName, \"lll\").\n\t\t\t\t\tWith(common.PartitionConfigHeaderName, \"asdfasf\"),\n\t\t\t\tctx:                               partition.ContextWithIsolationGroup(partition.ContextWithConfig(context.Background(), partitionConfig), \"abc\"),\n\t\t\t\texpectedSerializedPartitionConfig: \"asdfasf\",\n\t\t\t\texpectedIsolationGroup:            \"lll\",\n\t\t\t},\n\t\t}\n\n\t\tfor _, tt := range testCases {\n\t\t\tt.Run(tt.message, func(t *testing.T) {\n\t\t\t\tm := &ForwardPartitionConfigMiddleware{}\n\t\t\t\to := &fakeOutbound{\n\t\t\t\t\tverify: func(r *transport.Request) {\n\t\t\t\t\t\tassert.Equal(t, tt.expectedIsolationGroup, r.Headers.Items()[common.IsolationGroupHeaderName])\n\t\t\t\t\t\tassert.Equal(t, tt.expectedSerializedPartitionConfig, r.Headers.Items()[common.PartitionConfigHeaderName])\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t\t_, err := m.Call(tt.ctx, &transport.Request{Headers: tt.headers}, o)\n\t\t\t\tassert.NoError(t, err)\n\t\t\t})\n\t\t}\n\t})\n}\n\nfunc TestZonalPartitionConfigMiddleware(t *testing.T) {\n\tt.Run(\"it sets the partition config\", func(t *testing.T) {\n\t\tm := &ZonalPartitionConfigMiddleware{}\n\t\th := &fakeHandler{}\n\t\theaders := transport.NewHeaders().\n\t\t\tWith(common.ClientZoneHeaderName, \"dca1\")\n\t\terr := m.Handle(context.Background(), &transport.Request{Headers: headers}, nil, h)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, map[string]string{partition.IsolationGroupKey: \"dca1\"}, partition.ConfigFromContext(h.ctx))\n\t\tassert.Equal(t, \"dca1\", partition.IsolationGroupFromContext(h.ctx))\n\t})\n\n\tt.Run(\"noop when header is empty\", func(t *testing.T) {\n\t\tm := &ZonalPartitionConfigMiddleware{}\n\t\th := &fakeHandler{}\n\t\theaders := transport.NewHeaders()\n\t\tctx := context.Background()\n\t\terr := m.Handle(ctx, &transport.Request{Headers: headers}, nil, h)\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, partition.ConfigFromContext(h.ctx))\n\t\tassert.Equal(t, \"\", partition.IsolationGroupFromContext(h.ctx))\n\t\tassert.Equal(t, ctx, h.ctx)\n\t})\n}\n\ntype fakeHandler struct {\n\tctx context.Context\n}\n\nfunc (h *fakeHandler) Handle(ctx context.Context, req *transport.Request, resw transport.ResponseWriter) error {\n\th.ctx = ctx\n\treturn nil\n}\n\ntype fakeOutbound struct {\n\tverify   func(*transport.Request)\n\tresponse *transport.Response\n\terr      error\n}\n\nfunc (o fakeOutbound) Call(ctx context.Context, request *transport.Request) (*transport.Response, error) {\n\tif o.verify != nil {\n\t\to.verify(request)\n\t}\n\treturn o.response, o.err\n}\nfunc (o fakeOutbound) Start() error                      { return nil }\nfunc (o fakeOutbound) Stop() error                       { return nil }\nfunc (o fakeOutbound) IsRunning() bool                   { return true }\nfunc (o fakeOutbound) Transports() []transport.Transport { return nil }\n\ntype fakeAuthProvider struct {\n\ttoken []byte\n\terr   error\n}\n\nfunc (p fakeAuthProvider) GetAuthToken() ([]byte, error) {\n\treturn p.token, p.err\n}"
