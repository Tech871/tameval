[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Go"
go_version = "1.23.6"

[repo_info]
repository = "cloudprober/cloudprober"
sha = "01736e0103a53b703064edec034c30ef5e25681d"

[run_info]
docker_image = "golang:1.23.6"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/avito-tech/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out surfacers/internal/otel/otel.go surfacers/internal/otel/otel_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting surfacers/internal/otel/otel.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 59.0
original_coverage = 59.0
mutation_kill_rate = 54.0
original_mutation_kill_rate = 54.0
covered_lines = [ 62, 63, 64, 65, 66, 67, 98, 102, 105, 106, 107, 108, 109, 110, 111, 112, 135, 139, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 207, 208, 211, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 245, 246, 247, 248, 251, 252, 253, 255, 258, 259, 260, 261, 262, 263, 266, 270, 271, 272, 273, 274, 277, 278, 279, 280, 281, 282, 283, 284, 286, 287, 288, 289, 290, 291, 292, 293, 295, 296, 297, 298, 299, 300, 301, 302, 304, 305, 306, 307, 308, 309, 310, 316, 317, 323, 324, 325, 326, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 350, 355, 360,]
missed_lines = [ 68, 69, 70, 71, 72, 74, 75, 76, 77, 78, 81, 82, 83, 85, 86, 87, 89, 90, 91, 92, 93, 94, 95, 99, 100, 101, 114, 115, 116, 118, 119, 120, 122, 123, 124, 126, 127, 128, 129, 130, 131, 132, 136, 137, 138, 142, 143, 149, 150, 151, 152, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 184, 185, 186, 187, 249, 250, 267, 268, 269, 311, 312, 313, 314, 315, 320, 327, 328, 329, 330, 351, 352, 356, 357, 358,]

[input_info]
test_file_path = "surfacers/internal/otel/otel_test.go"
focal_file_path = "surfacers/internal/otel/otel.go"
test_file_url = "https://github.com/cloudprober/cloudprober/blob/01736e0103a53b703064edec034c30ef5e25681d/surfacers/internal/otel/otel_test.go"
focal_file_url = "https://github.com/cloudprober/cloudprober/blob/01736e0103a53b703064edec034c30ef5e25681d/surfacers/internal/otel/otel.go"
first_commit_date = "2023-12-14"
last_commit_date = "2025-03-12"
test_file_content = "// Copyright 2023 The Cloudprober Authors.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage otel\n\nimport (\n\t\"context\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cloudprober/cloudprober/metrics\"\n\tconfigpb \"github.com/cloudprober/cloudprober/surfacers/internal/otel/proto\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"go.opentelemetry.io/otel/attribute\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc\"\n\t\"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetrichttp\"\n\t\"go.opentelemetry.io/otel/sdk/instrumentation\"\n\t\"go.opentelemetry.io/otel/sdk/metric\"\n\t\"go.opentelemetry.io/otel/sdk/metric/metricdata\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc testEMs(ts time.Time) []*metrics.EventMetrics {\n\td := metrics.NewDistribution([]float64{1, 10, 100})\n\td.AddSample(2)\n\td.AddSample(20)\n\n\trespCode := metrics.NewMap(\"code\")\n\trespCode.IncKeyBy(\"200\", 2)\n\trespCode.IncKey(\"500\")\n\n\tems := []*metrics.EventMetrics{\n\t\tmetrics.NewEventMetrics(ts).\n\t\t\tAddMetric(\"failures\", metrics.NewInt(20)).\n\t\t\tAddMetric(\"latency\", metrics.NewFloat(9.2)).\n\t\t\tAddLabel(\"probe\", \"p1\"),\n\t\tmetrics.NewEventMetrics(ts.Add(time.Second)).\n\t\t\tAddMetric(\"resp_code\", respCode).\n\t\t\tAddMetric(\"latency\", d).\n\t\t\tAddLabel(\"probe\", \"p2\"),\n\t\tmetrics.NewEventMetrics(ts.Add(2*time.Second)).\n\t\t\tAddMetric(\"failures\", metrics.NewInt(25)).\n\t\t\tAddMetric(\"latency\", metrics.NewFloat(8.7)).\n\t\t\tAddMetric(\"dns_latency\", metrics.NewFloat(1.2)).\n\t\t\tAddLabel(\"probe\", \"p1\"),\n\t}\n\n\tems[1].LatencyUnit = time.Millisecond\n\treturn ems\n}\n\nfunc testMetric(name, unit string, data metricdata.Aggregation) metricdata.Metrics {\n\treturn metricdata.Metrics{\n\t\tName:        name,\n\t\tDescription: name + \" metric for Cloudprober\",\n\t\tUnit:        unit,\n\t\tData:        data,\n\t}\n}\n\nfunc dataPoint[T int64 | float64](val T, kvs [][2]string, startTime, ts time.Time) metricdata.DataPoint[T] {\n\tvar attrs []attribute.KeyValue\n\tfor _, kv := range kvs {\n\t\tattrs = append(attrs, attribute.String(kv[0], kv[1]))\n\t}\n\treturn metricdata.DataPoint[T]{\n\t\tAttributes: attribute.NewSet(attrs...),\n\t\tStartTime:  startTime,\n\t\tTime:       ts,\n\t\tValue:      val,\n\t}\n}\n\nfunc sumData[T int64 | float64](dataPoints ...metricdata.DataPoint[T]) metricdata.Sum[T] {\n\treturn metricdata.Sum[T]{\n\t\tDataPoints:  dataPoints,\n\t\tTemporality: metricdata.CumulativeTemporality,\n\t\tIsMonotonic: true,\n\t}\n}\n\nfunc TestOtelSurfacerWrite(t *testing.T) {\n\tstartTime := time.Now()\n\tems := testEMs(startTime.Add(time.Second))\n\n\ttests := []struct {\n\t\tname             string\n\t\tem               *metrics.EventMetrics\n\t\twantScopeMetrics map[string]*metricdata.ScopeMetrics\n\t}{\n\t\t{\n\t\t\tname: \"em0\",\n\t\t\tem:   ems[0],\n\t\t\twantScopeMetrics: map[string]*metricdata.ScopeMetrics{\n\t\t\t\t\"probe.p1\": {\n\t\t\t\t\tScope: instrumentation.Scope{Name: \"probe.p1\"},\n\t\t\t\t\tMetrics: []metricdata.Metrics{\n\t\t\t\t\t\ttestMetric(\"cloudprober_failures\", \"1\", sumData(dataPoint[int64](20, [][2]string{{\"probe\", \"p1\"}}, startTime, ems[0].Timestamp))),\n\t\t\t\t\t\ttestMetric(\"cloudprober_latency\", \"us\", sumData(dataPoint[float64](9.2, [][2]string{{\"probe\", \"p1\"}}, startTime, ems[0].Timestamp))),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"em1\",\n\t\t\tem:   ems[1],\n\t\t\twantScopeMetrics: map[string]*metricdata.ScopeMetrics{\n\t\t\t\t\"probe.p2\": {\n\t\t\t\t\tScope: instrumentation.Scope{Name: \"probe.p2\"},\n\t\t\t\t\tMetrics: []metricdata.Metrics{\n\t\t\t\t\t\ttestMetric(\"cloudprober_resp_code\", \"1\", sumData(\n\t\t\t\t\t\t\tdataPoint[int64](2, [][2]string{{\"probe\", \"p2\"}, {\"code\", \"200\"}}, startTime, ems[1].Timestamp),\n\t\t\t\t\t\t\tdataPoint[int64](1, [][2]string{{\"probe\", \"p2\"}, {\"code\", \"500\"}}, startTime, ems[1].Timestamp))),\n\t\t\t\t\t\ttestMetric(\"cloudprober_latency\", \"ms\", metricdata.Histogram[float64]{\n\t\t\t\t\t\t\tDataPoints: []metricdata.HistogramDataPoint[float64]{\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tAttributes:   attribute.NewSet(attribute.String(\"probe\", \"p2\")),\n\t\t\t\t\t\t\t\t\tStartTime:    startTime,\n\t\t\t\t\t\t\t\t\tTime:         ems[1].Timestamp,\n\t\t\t\t\t\t\t\t\tCount:        2,\n\t\t\t\t\t\t\t\t\tSum:          22,\n\t\t\t\t\t\t\t\t\tBounds:       []float64{1, 10, 100},\n\t\t\t\t\t\t\t\t\tBucketCounts: []uint64{0, 1, 1, 0},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tTemporality: metricdata.CumulativeTemporality,\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"em2\",\n\t\t\tem:   ems[2],\n\t\t\twantScopeMetrics: map[string]*metricdata.ScopeMetrics{\n\t\t\t\t\"probe.p1\": {\n\t\t\t\t\tScope: instrumentation.Scope{Name: \"probe.p1\"},\n\t\t\t\t\tMetrics: []metricdata.Metrics{\n\t\t\t\t\t\ttestMetric(\"cloudprober_failures\", \"1\", sumData(dataPoint[int64](20, [][2]string{{\"probe\", \"p1\"}}, startTime, ems[0].Timestamp))),\n\t\t\t\t\t\ttestMetric(\"cloudprober_latency\", \"us\", sumData(dataPoint[float64](9.2, [][2]string{{\"probe\", \"p1\"}}, startTime, ems[0].Timestamp))),\n\t\t\t\t\t\ttestMetric(\"cloudprober_failures\", \"1\", sumData(dataPoint[int64](25, [][2]string{{\"probe\", \"p1\"}}, startTime, ems[0].Timestamp.Add(2*time.Second)))),\n\t\t\t\t\t\ttestMetric(\"cloudprober_latency\", \"us\", sumData(dataPoint[float64](8.7, [][2]string{{\"probe\", \"p1\"}}, startTime, ems[0].Timestamp.Add(2*time.Second)))),\n\t\t\t\t\t\ttestMetric(\"cloudprober_dns_latency\", \"us\", sumData(dataPoint[float64](1.2, [][2]string{{\"probe\", \"p1\"}}, startTime, ems[0].Timestamp.Add(2*time.Second)))),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\twantScopeMetrics := make(map[string]*metricdata.ScopeMetrics)\n\tos := &OtelSurfacer{\n\t\tstartTime:    startTime,\n\t\tscopeMetrics: make(map[string]*metricdata.ScopeMetrics),\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tos.Write(context.Background(), tt.em)\n\t\t\tfor k, v := range tt.wantScopeMetrics {\n\t\t\t\twantScopeMetrics[k] = v\n\t\t\t}\n\t\t\tassert.Equal(t, wantScopeMetrics, os.scopeMetrics)\n\t\t})\n\t}\n\n\t// First produce now will return all scope metrics\n\tvar wantProducedMetrics []metricdata.ScopeMetrics\n\tfor _, scope := range []string{\"probe.p1\", \"probe.p2\"} {\n\t\twantProducedMetrics = append(wantProducedMetrics, *wantScopeMetrics[scope])\n\t}\n\tproducedMetrics, _ := os.Produce(context.Background())\n\tassert.Equal(t, wantProducedMetrics, producedMetrics)\n\n\t// Next produce will be empty\n\tproducedMetrics, _ = os.Produce(context.Background())\n\tassert.Empty(t, producedMetrics)\n}\n\nfunc TestGetExporterType(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tconfig   *configpb.SurfacerConf\n\t\twantType metric.Exporter\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname: \"otlp_http\",\n\t\t\tconfig: &configpb.SurfacerConf{\n\t\t\t\tExporter: &configpb.SurfacerConf_OtlpHttpExporter{\n\t\t\t\t\tOtlpHttpExporter: &configpb.HTTPExporter{},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantType: &otlpmetrichttp.Exporter{},\n\t\t},\n\t\t{\n\t\t\tname: \"otlp_grpc\",\n\t\t\tconfig: &configpb.SurfacerConf{\n\t\t\t\tExporter: &configpb.SurfacerConf_OtlpGrpcExporter{\n\t\t\t\t\tOtlpGrpcExporter: &configpb.GRPCExporter{\n\t\t\t\t\t\tEndpoint: proto.String(\"localhost:1234\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantType: &otlpmetricgrpc.Exporter{},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := getExporter(context.Background(), tt.config, nil)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"getExporter() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.IsType(t, tt.wantType, got, \"unexpected exporter type\")\n\t\t})\n\t}\n}\n"
