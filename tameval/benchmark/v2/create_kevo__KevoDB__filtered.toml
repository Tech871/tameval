[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.24.2"

[repo_info]
repository = "KevoDB/kevo"
sha = "a0bcddabc1700e19208bd8adb99211654de65bc8"

[run_info]
docker_image = "golang:1.24.2"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/common/iterator/filtered/filtered.go pkg/common/iterator/filtered/filtered_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/common/iterator/filtered/filtered.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 59.0
original_coverage = 59.0
mutation_kill_rate = 24.0
original_mutation_kill_rate = 24.0
covered_lines = [ 19, 20, 21, 22, 23, 24, 27, 28, 29, 30, 31, 33, 37, 38, 39, 42, 43, 44, 47, 48, 49, 52, 53, 54, 57, 58, 59, 60, 100, 106, 107, 108, 110, 114, 115, 116, 117, 121, 122, 123, 124, 128, 129, 130, 133, 134, 135,]
missed_lines = [ 61, 62, 63, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 89, 90, 91, 92, 93, 94, 95, 101, 102, 103,]

[input_info]
test_file_path = "pkg/common/iterator/filtered/filtered_test.go"
focal_file_path = "pkg/common/iterator/filtered/filtered.go"
test_file_url = "https://github.com/KevoDB/kevo/blob/a0bcddabc1700e19208bd8adb99211654de65bc8/pkg/common/iterator/filtered/filtered_test.go"
focal_file_url = "https://github.com/KevoDB/kevo/blob/a0bcddabc1700e19208bd8adb99211654de65bc8/pkg/common/iterator/filtered/filtered.go"
first_commit_date = "2025-05-03"
last_commit_date = "2025-05-17"
test_file_content = "package filtered\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/KevoDB/kevo/pkg/common/iterator\"\n)\n\n// MockEntry represents a single entry in the mock iterator\ntype MockEntry struct {\n\tKey       []byte\n\tValue     []byte\n\tTombstone bool\n}\n\n// MockIterator is a simple in-memory iterator for testing\ntype MockIterator struct {\n\tentries    []MockEntry\n\tcurrentIdx int\n}\n\n// NewMockIterator creates a new mock iterator with the given entries\nfunc NewMockIterator(entries []MockEntry) *MockIterator {\n\treturn &MockIterator{\n\t\tentries:    entries,\n\t\tcurrentIdx: -1, // Start before the first entry\n\t}\n}\n\n// SeekToFirst positions at the first entry\nfunc (mi *MockIterator) SeekToFirst() {\n\tif len(mi.entries) > 0 {\n\t\tmi.currentIdx = 0\n\t} else {\n\t\tmi.currentIdx = -1\n\t}\n}\n\n// SeekToLast positions at the last entry\nfunc (mi *MockIterator) SeekToLast() {\n\tif len(mi.entries) > 0 {\n\t\tmi.currentIdx = len(mi.entries) - 1\n\t} else {\n\t\tmi.currentIdx = -1\n\t}\n}\n\n// Seek positions at the first entry with key >= target\nfunc (mi *MockIterator) Seek(target []byte) bool {\n\tfor i, entry := range mi.entries {\n\t\tif bytes.Compare(entry.Key, target) >= 0 {\n\t\t\tmi.currentIdx = i\n\t\t\treturn true\n\t\t}\n\t}\n\tmi.currentIdx = len(mi.entries)\n\treturn false\n}\n\n// Next advances to the next entry\nfunc (mi *MockIterator) Next() bool {\n\tif mi.currentIdx < len(mi.entries)-1 {\n\t\tmi.currentIdx++\n\t\treturn true\n\t}\n\tmi.currentIdx = len(mi.entries)\n\treturn false\n}\n\n// Key returns the current key\nfunc (mi *MockIterator) Key() []byte {\n\tif mi.Valid() {\n\t\treturn mi.entries[mi.currentIdx].Key\n\t}\n\treturn nil\n}\n\n// Value returns the current value\nfunc (mi *MockIterator) Value() []byte {\n\tif mi.Valid() {\n\t\treturn mi.entries[mi.currentIdx].Value\n\t}\n\treturn nil\n}\n\n// Valid returns true if positioned at a valid entry\nfunc (mi *MockIterator) Valid() bool {\n\treturn mi.currentIdx >= 0 && mi.currentIdx < len(mi.entries)\n}\n\n// IsTombstone returns whether the current entry is a tombstone\nfunc (mi *MockIterator) IsTombstone() bool {\n\tif mi.Valid() {\n\t\treturn mi.entries[mi.currentIdx].Tombstone\n\t}\n\treturn false\n}\n\n// Verify the MockIterator implements Iterator\nvar _ iterator.Iterator = (*MockIterator)(nil)\n\n// Test the FilteredIterator with a simple filter\nfunc TestFilteredIterator(t *testing.T) {\n\tentries := []MockEntry{\n\t\t{Key: []byte(\"a1\"), Value: []byte(\"val1\"), Tombstone: false},\n\t\t{Key: []byte(\"b2\"), Value: []byte(\"val2\"), Tombstone: false},\n\t\t{Key: []byte(\"a3\"), Value: []byte(\"val3\"), Tombstone: true},\n\t\t{Key: []byte(\"c4\"), Value: []byte(\"val4\"), Tombstone: false},\n\t\t{Key: []byte(\"a5\"), Value: []byte(\"val5\"), Tombstone: false},\n\t}\n\n\tbaseIter := NewMockIterator(entries)\n\n\t// Filter for keys starting with 'a'\n\tfilter := func(key []byte) bool {\n\t\treturn bytes.HasPrefix(key, []byte(\"a\"))\n\t}\n\n\tfiltered := NewFilteredIterator(baseIter, filter)\n\n\t// Test SeekToFirst and Next\n\tfiltered.SeekToFirst()\n\n\tif !filtered.Valid() {\n\t\tt.Fatal(\"Expected valid position after SeekToFirst\")\n\t}\n\n\tif string(filtered.Key()) != \"a1\" {\n\t\tt.Errorf(\"Expected key 'a1', got '%s'\", string(filtered.Key()))\n\t}\n\n\tif string(filtered.Value()) != \"val1\" {\n\t\tt.Errorf(\"Expected value 'val1', got '%s'\", string(filtered.Value()))\n\t}\n\n\tif filtered.IsTombstone() {\n\t\tt.Error(\"Expected non-tombstone for first entry\")\n\t}\n\n\t// Advance to next matching entry\n\tif !filtered.Next() {\n\t\tt.Fatal(\"Expected successful Next() call\")\n\t}\n\n\tif string(filtered.Key()) != \"a3\" {\n\t\tt.Errorf(\"Expected key 'a3', got '%s'\", string(filtered.Key()))\n\t}\n\n\tif !filtered.IsTombstone() {\n\t\tt.Error(\"Expected tombstone for second entry\")\n\t}\n\n\t// Advance again\n\tif !filtered.Next() {\n\t\tt.Fatal(\"Expected successful Next() call\")\n\t}\n\n\tif string(filtered.Key()) != \"a5\" {\n\t\tt.Errorf(\"Expected key 'a5', got '%s'\", string(filtered.Key()))\n\t}\n\n\t// No more entries\n\tif filtered.Next() {\n\t\tt.Fatal(\"Expected end of iteration\")\n\t}\n\n\tif filtered.Valid() {\n\t\tt.Fatal(\"Expected invalid position at end of iteration\")\n\t}\n}\n\n// Test the PrefixIterator\nfunc TestPrefixIterator(t *testing.T) {\n\tentries := []MockEntry{\n\t\t{Key: []byte(\"apple1\"), Value: []byte(\"val1\"), Tombstone: false},\n\t\t{Key: []byte(\"banana2\"), Value: []byte(\"val2\"), Tombstone: false},\n\t\t{Key: []byte(\"apple3\"), Value: []byte(\"val3\"), Tombstone: true},\n\t\t{Key: []byte(\"cherry4\"), Value: []byte(\"val4\"), Tombstone: false},\n\t\t{Key: []byte(\"apple5\"), Value: []byte(\"val5\"), Tombstone: false},\n\t}\n\n\tbaseIter := NewMockIterator(entries)\n\tprefixIter := NewPrefixIterator(baseIter, []byte(\"apple\"))\n\n\t// Count matching entries\n\tprefixIter.SeekToFirst()\n\n\tcount := 0\n\tfor prefixIter.Valid() {\n\t\tcount++\n\t\tprefixIter.Next()\n\t}\n\n\tif count != 3 {\n\t\tt.Errorf(\"Expected 3 entries with prefix 'apple', got %d\", count)\n\t}\n\n\t// Test Seek\n\tprefixIter.Seek([]byte(\"apple3\"))\n\n\tif !prefixIter.Valid() {\n\t\tt.Fatal(\"Expected valid position after Seek\")\n\t}\n\n\tif string(prefixIter.Key()) != \"apple3\" {\n\t\tt.Errorf(\"Expected key 'apple3', got '%s'\", string(prefixIter.Key()))\n\t}\n}\n\n// Test the SuffixIterator\nfunc TestSuffixIterator(t *testing.T) {\n\tentries := []MockEntry{\n\t\t{Key: []byte(\"key1_suffix\"), Value: []byte(\"val1\"), Tombstone: false},\n\t\t{Key: []byte(\"key2_other\"), Value: []byte(\"val2\"), Tombstone: false},\n\t\t{Key: []byte(\"key3_suffix\"), Value: []byte(\"val3\"), Tombstone: true},\n\t\t{Key: []byte(\"key4_test\"), Value: []byte(\"val4\"), Tombstone: false},\n\t\t{Key: []byte(\"key5_suffix\"), Value: []byte(\"val5\"), Tombstone: false},\n\t}\n\n\tbaseIter := NewMockIterator(entries)\n\tsuffixIter := NewSuffixIterator(baseIter, []byte(\"_suffix\"))\n\n\t// Count matching entries\n\tsuffixIter.SeekToFirst()\n\n\tcount := 0\n\tfor suffixIter.Valid() {\n\t\tcount++\n\t\tsuffixIter.Next()\n\t}\n\n\tif count != 3 {\n\t\tt.Errorf(\"Expected 3 entries with suffix '_suffix', got %d\", count)\n\t}\n\n\t// Test seeking to find entries with suffix\n\tsuffixIter.Seek([]byte(\"key3\"))\n\n\tif !suffixIter.Valid() {\n\t\tt.Fatal(\"Expected valid position after Seek\")\n\t}\n\n\tif string(suffixIter.Key()) != \"key3_suffix\" {\n\t\tt.Errorf(\"Expected key 'key3_suffix', got '%s'\", string(suffixIter.Key()))\n\t}\n}\n"
