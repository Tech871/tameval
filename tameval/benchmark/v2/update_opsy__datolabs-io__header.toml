[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "datolabs-io/opsy"
sha = "34d0c4dd506970419e9238a3343710100422dd33"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/tui/components/header/header.go internal/tui/components/header/header_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/tui/components/header/header.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 93.0
mutation_kill_rate = nan
original_mutation_kill_rate = 59.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "internal/tui/components/header/header_test.go"
focal_file_path = "internal/tui/components/header/header.go"
test_file_url = "https://github.com/datolabs-io/opsy/blob/34d0c4dd506970419e9238a3343710100422dd33/internal/tui/components/header/header_test.go"
focal_file_url = "https://github.com/datolabs-io/opsy/blob/34d0c4dd506970419e9238a3343710100422dd33/internal/tui/components/header/header.go"
first_commit_date = "2025-02-19"
last_commit_date = "2025-03-01"
test_file_content = "package header\n\nimport (\n\t\"regexp\"\n\t\"sync\"\n\t\"testing\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/datolabs-io/sredo/internal/thememanager\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// stripANSI removes ANSI color codes from a string.\nfunc stripANSI(str string) string {\n\tre := regexp.MustCompile(`\\x1b\\[[0-9;]*[a-zA-Z]`)\n\treturn re.ReplaceAllString(str, \"\")\n}\n\n// TestHeaderCreation tests the creation of a new header component.\nfunc TestHeaderCreation(t *testing.T) {\n\tt.Run(\"creates with default values\", func(t *testing.T) {\n\t\theader := New()\n\t\tassert.NotNil(t, header)\n\t\tassert.Empty(t, header.task)\n\t\tassert.Equal(t, thememanager.Theme{}, header.theme)\n\t})\n\n\tt.Run(\"creates with task\", func(t *testing.T) {\n\t\ttask := \"Test Task\"\n\t\theader := New(WithTask(task))\n\t\tassert.Equal(t, task, header.task)\n\t})\n\n\tt.Run(\"creates with theme\", func(t *testing.T) {\n\t\ttheme := thememanager.Theme{\n\t\t\tBaseColors: thememanager.BaseColors{\n\t\t\t\tBase01: \"#000000\",\n\t\t\t\tBase04: \"#FFFFFF\",\n\t\t\t},\n\t\t}\n\t\theader := New(WithTheme(theme))\n\t\tassert.Equal(t, theme, header.theme)\n\t})\n}\n\n// TestHeaderUpdate tests the update function of the header component.\nfunc TestHeaderUpdate(t *testing.T) {\n\tt.Run(\"handles window size update\", func(t *testing.T) {\n\t\theader := New()\n\t\tnewWidth := 100\n\t\tupdatedHeader, cmd := header.Update(tea.WindowSizeMsg{Width: newWidth})\n\t\tassert.NotNil(t, updatedHeader)\n\t\tassert.Nil(t, cmd)\n\t\tassert.Equal(t, newWidth, updatedHeader.maxWidth)\n\t})\n}\n\n// TestHeaderView tests the view function of the header component.\nfunc TestHeaderView(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t\tBase04: \"#FFFFFF\",\n\t\t},\n\t}\n\n\ttestCases := []struct {\n\t\tname     string\n\t\ttask     string\n\t\twidth    int\n\t\tcontains []string\n\t}{\n\t\t{\n\t\t\tname:     \"empty task\",\n\t\t\ttask:     \"\",\n\t\t\twidth:    100,\n\t\t\tcontains: []string{\"Task:\", \"\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"with task\",\n\t\t\ttask:     \"Test Task\",\n\t\t\twidth:    100,\n\t\t\tcontains: []string{\"Task:\", \"Test Task\"},\n\t\t},\n\t\t{\n\t\t\tname:     \"long task with wrapping\",\n\t\t\ttask:     \"This is a very long task that should be wrapped to multiple lines when the width is limited\",\n\t\t\twidth:    40,\n\t\t\tcontains: []string{\"Task:\", \"This is a very\", \"long task that\"},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\theader := New(\n\t\t\t\tWithTask(tc.task),\n\t\t\t\tWithTheme(theme),\n\t\t\t)\n\t\t\theader.maxWidth = tc.width\n\n\t\t\tview := stripANSI(header.View())\n\n\t\t\tfor _, expected := range tc.contains {\n\t\t\t\tassert.Contains(t, view, expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestHeaderOptions tests the option functions of the header component.\nfunc TestHeaderOptions(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t\tBase04: \"#FFFFFF\",\n\t\t},\n\t}\n\n\ttestCases := []struct {\n\t\tname          string\n\t\toptions       []Option\n\t\texpectedTask  string\n\t\texpectedTheme thememanager.Theme\n\t}{\n\t\t{\n\t\t\tname:          \"with task option\",\n\t\t\toptions:       []Option{WithTask(\"Test Task\")},\n\t\t\texpectedTask:  \"Test Task\",\n\t\t\texpectedTheme: thememanager.Theme{},\n\t\t},\n\t\t{\n\t\t\tname:          \"with theme option\",\n\t\t\toptions:       []Option{WithTheme(theme)},\n\t\t\texpectedTask:  \"\",\n\t\t\texpectedTheme: theme,\n\t\t},\n\t\t{\n\t\t\tname: \"with both options\",\n\t\t\toptions: []Option{\n\t\t\t\tWithTask(\"Test Task\"),\n\t\t\t\tWithTheme(theme),\n\t\t\t},\n\t\t\texpectedTask:  \"Test Task\",\n\t\t\texpectedTheme: theme,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\theader := New(tc.options...)\n\t\t\tassert.Equal(t, tc.expectedTask, header.task)\n\t\t\tassert.Equal(t, tc.expectedTheme, header.theme)\n\t\t})\n\t}\n}\n\n// TestThemeChange tests the component's response to theme changes.\nfunc TestThemeChange(t *testing.T) {\n\tinitialTheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t\tBase04: \"#FFFFFF\",\n\t\t},\n\t}\n\n\tnewTheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#111111\",\n\t\t\tBase04: \"#EEEEEE\",\n\t\t},\n\t}\n\n\ttask := \"Test Task\"\n\n\t// Create and setup first model\n\tm1 := New(WithTheme(initialTheme), WithTask(task))\n\tm1, _ = m1.Update(tea.WindowSizeMsg{Width: 100})\n\n\t// Create and setup second model\n\tm2 := New(WithTheme(newTheme), WithTask(task))\n\tm2, _ = m2.Update(tea.WindowSizeMsg{Width: 100})\n\n\t// Verify container styles are different\n\tassert.NotEqual(t,\n\t\tm1.containerStyle.GetBackground(),\n\t\tm2.containerStyle.GetBackground(),\n\t\t\"container styles should have different backgrounds\",\n\t)\n\n\t// Verify text styles are different\n\tassert.NotEqual(t,\n\t\tm1.textStyle.GetForeground(),\n\t\tm2.textStyle.GetForeground(),\n\t\t\"text styles should have different colors\",\n\t)\n\n\t// Verify styles match their themes\n\tassert.Equal(t,\n\t\tlipgloss.Color(initialTheme.BaseColors.Base01),\n\t\tm1.containerStyle.GetBackground(),\n\t\t\"container style should use Base01 color\",\n\t)\n\n\tassert.Equal(t,\n\t\tlipgloss.Color(initialTheme.BaseColors.Base04),\n\t\tm1.textStyle.GetForeground(),\n\t\t\"text style should use Base04 color\",\n\t)\n\n\t// Verify content is identical\n\tstripped1 := stripANSI(m1.View())\n\tstripped2 := stripANSI(m2.View())\n\tassert.Equal(t, stripped1, stripped2, \"content should be same after stripping ANSI codes\")\n}\n\n// TestConcurrentAccess tests thread safety of the header component.\nfunc TestConcurrentAccess(t *testing.T) {\n\tm := New(WithTask(\"Test Task\"))\n\tvar wg sync.WaitGroup\n\tnumGoroutines := 10\n\n\t// Test concurrent updates\n\twg.Add(numGoroutines)\n\tfor i := 0; i < numGoroutines; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\t_, _ = m.Update(tea.WindowSizeMsg{Width: 100})\n\t\t\t_ = m.View()\n\t\t}()\n\t}\n\twg.Wait()\n\n\t// Verify component is still in a valid state\n\tview := stripANSI(m.View())\n\tassert.NotEmpty(t, view)\n\tassert.Contains(t, view, \"Test Task\")\n}"
