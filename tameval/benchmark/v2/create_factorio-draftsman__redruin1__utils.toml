[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "redruin1/factorio-draftsman"
sha = "4a795c6530c6d5ea2571c8a234164da22928a4a1"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r requirements.txt && (pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=draftsman/utils.py -m pytest -q --junit-xml=test_output.xml test/test_utils.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target draftsman.utils --unit-test test.test_utils --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target draftsman/utils.py --unit-test test/test_utils.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 83.0
original_coverage = 83.0
mutation_kill_rate = 7.0
original_mutation_kill_rate = 7.0
covered_lines = [ 8, 9, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 34, 40, 41, 56, 64, 96, 97, 99, 103, 105, 107, 108, 116, 118, 119, 120, 121, 123, 124, 130, 135, 136, 142, 147, 148, 149, 150, 151, 153, 155, 163, 168, 178, 181, 182, 183, 184, 185, 187, 202, 203, 210, 211, 216, 223, 228, 230, 231, 238, 239, 240, 253, 256, 263, 279, 280, 281, 282, 284, 285, 286, 289, 290, 291, 292, 293, 294, 295, 297, 298, 300, 308, 311, 316, 324, 325, 326, 327, 328, 330, 331, 332, 333, 334, 335, 336, 337, 338, 340, 342, 361, 381, 395, 396, 401, 420, 425, 441, 444, 456, 457, 458, 459, 460, 463, 478, 479, 482, 495, 503, 516, 525, 531, 540, 543, 551, 554, 562, 563, 566, 575, 583, 592, 597, 607, 616, 627, 628, 629, 632, 644, 645, 646, 650, 652, 653, 654, 655, 657, 658, 659, 660, 662, 666, 669, 676, 677, 679, 680, 682, 683, 684, 685, 687, 688, 691, 702, 703, 705, 706, 709, 710, 712, 715, 728, 729, 731, 732, 733, 735, 736, 737, 739, 742, 754, 755, 756, 757, 759, 767, 778, 784, 785, 787, 795, 811, 823, 824, 825, 826, 829, 853, 872, 890, 913, 925, 926, 927, 929, 930, 931, 932, 933, 934, 935, 937, 939, 942, 986, 996, 997, 998, 999, 1001, 1002, 1004, 1006, 1009, 1098,]
missed_lines = [ 117, 354, 362, 397, 398, 513, 779, 800, 801, 802, 803, 805, 807, 808, 839, 841, 842, 843, 844, 846, 847, 848, 850, 864, 866, 867, 869, 882, 884, 885, 887, 948, 949, 951, 952, 954, 955, 956, 957, 958, 960, 1026, 1031, 1032, 1033, 1034, 1103,]

[input_info]
test_file_path = "test/test_utils.py"
focal_file_path = "draftsman/utils.py"
test_file_url = "https://github.com/redruin1/factorio-draftsman/blob/4a795c6530c6d5ea2571c8a234164da22928a4a1/test/test_utils.py"
focal_file_url = "https://github.com/redruin1/factorio-draftsman/blob/4a795c6530c6d5ea2571c8a234164da22928a4a1/draftsman/utils.py"
first_commit_date = "2022-02-22"
last_commit_date = "2025-07-19"
test_file_content = "# test_utils.py\n\nfrom collections import OrderedDict\nfrom draftsman import utils\nfrom draftsman.classes.vector import Vector\nfrom draftsman.constants import Direction, Orientation, Ticks, ValidationMode\nfrom draftsman.error import InvalidSignalError\nfrom draftsman.data import recipes, signals\n\nimport pytest\nimport warnings\n\n\nclass TestAABB:\n    def test_constructor(self):\n        aabb = utils.AABB(0, 0, 1, 1)\n        # self.assertEqual(aabb.top_left, Vector(0, 0))\n        assert aabb.top_left == Vector(0, 0)\n        # self.assertEqual(aabb.bot_right, Vector(1, 1))\n        assert aabb.bot_right == Vector(1, 1)\n        # self.assertEqual(aabb.position, Vector(0, 0))\n        assert aabb.position == Vector(0, 0)\n\n        aabb = utils.AABB(0, 0, 2, 2, (1, 1))\n        # self.assertEqual(aabb.top_left, Vector(0, 0))\n        assert aabb.top_left == Vector(0, 0)\n        # self.assertEqual(aabb.bot_right, Vector(2, 2))\n        assert aabb.bot_right == Vector(2, 2)\n        # self.assertEqual(aabb.position, Vector(1, 1))\n        assert aabb.position == Vector(1, 1)\n\n    def test_from_other(self):\n        aabb = utils.AABB.from_other([0, 1, 2, 3])\n        # self.assertEqual(aabb.top_left, Vector(0, 1))\n        assert aabb.top_left == Vector(0, 1)\n        # self.assertEqual(aabb.bot_right, Vector(2, 3))\n        assert aabb.bot_right == Vector(2, 3)\n        # self.assertEqual(aabb.position, Vector(0, 0))\n        assert aabb.position == Vector(0, 0)\n\n        aabb = utils.AABB.from_other((0, 1, 2, 3))\n        # self.assertEqual(aabb.top_left, Vector(0, 1))\n        assert aabb.top_left == Vector(0, 1)\n        # self.assertEqual(aabb.bot_right, Vector(2, 3))\n        assert aabb.bot_right == Vector(2, 3)\n        # self.assertEqual(aabb.position, Vector(0, 0))\n        assert aabb.position == Vector(0, 0)\n\n        with pytest.raises(TypeError):\n            utils.AABB.from_other(123.4)\n\n        with pytest.raises(TypeError):\n            utils.AABB.from_other([1, 1])\n\n    def test_overlaps(self):\n        aabb1 = utils.AABB(0, 0, 1, 1)\n        aabb2 = utils.AABB(0.5, 0.5, 1.5, 1.5)\n        aabb3 = utils.AABB(1, 0, 2, 1)\n        aabb4 = utils.AABB(0, 0, 1, 1, (5, 5))\n\n        # Normal case\n        assert aabb1.overlaps(aabb2)\n        # Test reciprocal\n        assert aabb2.overlaps(aabb1)\n        # Edge overlap does not count\n        assert not aabb1.overlaps(aabb3)\n        # Account for position\n        assert not aabb1.overlaps(aabb4)\n\n        # Rectangle cases\n        rect1 = utils.Rectangle((1, 1), 1, 1, 0)\n        rect2 = utils.Rectangle((1, 1), 1, 1, 45)\n        rect3 = utils.Rectangle((1.4, 1.4), 1, 1, 45)\n\n        assert aabb1.overlaps(rect1)\n        assert aabb1.overlaps(rect2)\n\n        assert not aabb1.overlaps(rect3)\n        assert not rect3.overlaps(aabb1)  # reciprocal\n\n        # Error case\n        with pytest.raises(TypeError):\n            aabb1.overlaps(Vector(0.5, 0.5))\n\n    def test_get_bounding_box(self):\n        aabb = utils.AABB(0, 1, 2, 3)\n        bounding_box = aabb.get_bounding_box()\n        assert bounding_box == utils.AABB(0, 1, 2, 3)\n        assert aabb is not bounding_box\n\n    def test_rotate(self):\n        aabb = utils.AABB(0, 0, 1, 1)\n        rotated_aabb = aabb.rotate(4)\n        assert round(abs(rotated_aabb.top_left[0] - -1), 7) == 0\n        assert round(abs(rotated_aabb.top_left[1] - 0), 7) == 0\n        assert round(abs(rotated_aabb.bot_right[0] - 0), 7) == 0\n        assert round(abs(rotated_aabb.bot_right[1] - 1), 7) == 0\n\n        with pytest.raises(ValueError):\n            aabb.rotate(1)\n\n    def test_add(self):\n        aabb = utils.AABB(0, 0, 1, 1)\n        new_aabb = aabb + (10, 10)\n        assert new_aabb.position == Vector(10, 10)\n        assert new_aabb.get_bounding_box() == utils.AABB(\n            10,\n            10,\n            11,\n            11,\n        )\n\n    def test_eq(self):\n        assert utils.AABB(0, 0, 1, 1) == utils.AABB(0, 0, 1, 1)\n        assert utils.AABB(0, 0, 1, 1) != utils.AABB(1, 1, 2, 2)\n\n\nclass TestRectangle:\n    def test_constructor(self):\n        # TODO\n        pass\n\n    def test_overlaps(self):\n        # TODO\n        pass\n\n    def test_get_bounding_box(self):\n        rect = utils.Rectangle((4, 4), 1, 1, 45)\n        bounding_box = rect.get_bounding_box()\n        assert round(abs(bounding_box.top_left[0] - 3.292), 2) == 0\n        assert round(abs(bounding_box.top_left[1] - 3.292), 2) == 0\n        assert round(abs(bounding_box.bot_right[0] - 4.707), 2) == 0\n        assert round(abs(bounding_box.bot_right[1] - 4.707), 2) == 0\n        assert bounding_box.position == Vector(0, 0)\n\n    def test_rotate(self):\n        pass\n\n    def test_eq(self):\n        pass\n\n\nclass TestConstants:\n    def test_orientation_to_direction(self):\n        assert Orientation.NORTH.to_direction() == Direction.NORTH\n        assert Orientation.NORTHEAST.to_direction() == Direction.NORTH\n        assert (\n            Orientation.NORTHEAST.to_direction(sixteen_way=True) == Direction.NORTHEAST\n        )\n\n    def test_orientation_add(self):\n        assert Orientation(0.75) + Orientation(0.5) == Orientation(0.25)\n        assert Orientation(0.75) + 0.5 == Orientation(0.25)\n        assert 0.75 + Orientation(0.5) == Orientation(0.25)\n        with pytest.raises(TypeError):\n            Orientation.NORTH + \"string\"\n        with pytest.raises(TypeError):\n            \"string\" + Orientation.NORTH\n\n    def test_orientation_sub(self):\n        assert Orientation(0.25) - Orientation(0.5) == Orientation(0.75)\n        assert Orientation(0.25) - 0.5 == Orientation(0.75)\n        assert 0.25 - Orientation(0.5) == Orientation(0.75)\n        with pytest.raises(TypeError):\n            Orientation.NORTH - \"string\"\n        with pytest.raises(TypeError):\n            \"string\" - Orientation.NORTH\n\n    def test_eq(self):\n        assert not Orientation.NORTH == \"wrong\"\n\n    def test_lt(self):\n        assert Orientation.NORTH < Orientation.SOUTH\n        with pytest.raises(TypeError):\n            Orientation.NORTH < \"wrong\"\n\n    def test_ticks_from_timedelta(self):\n        from datetime import timedelta\n\n        td = timedelta(1, 123, 2 * 8)\n        assert Ticks.from_timedelta(td) == 5191380\n\n    def test_validation_mode_eq(self):\n        assert ValidationMode.MINIMUM != TypeError\n\n    def test_validation_mode_gt(self):\n        with pytest.raises(TypeError):\n            ValidationMode.DISABLED > TypeError\n\n\nclass TestUtils:\n    def test_string_to_JSON(self):\n        # Blueprints\n        resulting_dict = utils.string_to_JSON(\n            \"0eNqN0N0KwjAMBeB3yXU33E/d7KuISKdRCltW2mxsjL67ncIEvdDLHnK+lCzQtANaZ4hBLWAuPXlQxwW8uZNu14xni6BgNI6HmAgg3a3BayLZQRBg6IoTqCycBCCxYYMv5vmYzzR0Dbo4sLVv2nPCTpO3veOkwZYjbXsfuz2te6Mnd1UqBcygkqyuUxmC+CLzjfyt7X9qxabhZB16/8cf6w813sAwdtF431bAiM4/W3mdldUhr8qDLCtZhPAAeZl+cQ==\"\n        )\n        assert resulting_dict == {\n            \"blueprint\": {\n                \"item\": \"blueprint\",\n                \"version\": 281479274954753,\n                \"icons\": [\n                    {\"signal\": {\"type\": \"virtual\", \"name\": \"signal-0\"}, \"index\": 1}\n                ],\n                \"entities\": [\n                    {\n                        \"entity_number\": 1,\n                        \"name\": \"fast-transport-belt\",\n                        \"position\": {\"x\": 507.5, \"y\": -188.5},\n                    },\n                    {\n                        \"entity_number\": 2,\n                        \"name\": \"transport-belt\",\n                        \"position\": {\"x\": 506.5, \"y\": -188.5},\n                    },\n                    {\n                        \"entity_number\": 3,\n                        \"name\": \"express-transport-belt\",\n                        \"position\": {\"x\": 508.5, \"y\": -188.5},\n                    },\n                ],\n            }\n        }\n\n    def test_JSON_to_string(self):\n        # Blueprints\n        test_dict = OrderedDict(\n            [\n                (\"arbitrary_data_1\", 1),\n                (\"arbitrary_data_2\", 2.0),\n                (\"arbitrary_data_3\", [\"stringy\", \"strigger\", \"others\"]),\n                (\"finally\", {\"key\": \"value\"}),\n            ]\n        )\n        assert (\n            utils.JSON_to_string(test_dict)\n            == \"0eNplyEEKgCAURdG9vLFE2sytRMiPzCQx+Fog0t6ThjW6h1tBPPvMxMUslMlIaCm+U0Grrv/tAXpEyuyjKxCvnLPceOTNcsIksPpIIRToit224KJwWtz3AzZ8Kjs=\"\n        )\n\n    def test_encode_version(self):\n        assert utils.encode_version(1, 1, 50, 1) == 281479274954753\n\n    def test_decode_version(self):\n        assert utils.decode_version(281479274954753) == (1, 1, 50, 1)\n\n    def test_version_string_to_tuple(self):\n        assert utils.version_string_to_tuple(\"1.15.2.3\") == (1, 15, 2, 3)\n\n    def test_version_tuple_to_string(self):\n        assert utils.version_tuple_to_string((1, 15, 2, 3)) == \"1.15.2.3\"\n\n    def test_get_signal_types(self):\n        assert signals.get_signal_types(\"signal-anything\") == [\"virtual\"]\n        assert signals.get_signal_types(\"water\") == [\"fluid\"]\n        assert signals.get_signal_types(\"wooden-chest\") == [\"item\", \"recipe\", \"entity\"]\n        with pytest.raises(InvalidSignalError):\n            signals.get_signal_types(\"incorrect\")\n\n    # def test_signal_dict(self):\n    #     assert signals.signal_dict(\"signal-anything\") == {\n    #         \"name\": \"signal-anything\",\n    #         \"type\": \"virtual\",\n    #     }\n    #     assert signals.signal_dict(\"water\") == {\"name\": \"water\", \"type\": \"fluid\"}\n    #     assert signals.signal_dict(\"wooden-chest\") == {\n    #         \"name\": \"wooden-chest\",\n    #         \"type\": \"item\",\n    #     }\n    #     with pytest.raises(InvalidSignalError):\n    #         signals.signal_dict(\"incorrect\")\n\n    # def test_dist(self):\n    #     self.assertAlmostEqual(\n    #         utils.dist([0, 0], [100, 0]),\n    #         100\n    #     )\n    #     self.assertAlmostEqual(\n    #         utils.dist([0, 0], [4, 3]),\n    #         5\n    #     )\n\n    def test_point_in_aabb(self):\n        aabb = utils.AABB(0, 0, 1, 1)\n        # Inside\n        assert utils.point_in_aabb([0.5, 0.5], aabb) == True\n        # On edge\n        assert utils.point_in_aabb([1.0, 0.5], aabb) == True\n        # Outside\n        assert utils.point_in_aabb([2.0, 0.5], aabb) == False\n\n    def test_aabb_overlaps_aabb(self):\n        aabb1 = utils.AABB(0, 0, 10, 10)\n        aabb2 = utils.AABB(1, 1, 2, 2)\n        aabb3 = utils.AABB(2, 1, 18, 8)\n        aabb4 = utils.AABB(3, 3, 4, 4)\n        # 1 vs 2\n        assert utils.aabb_overlaps_aabb(aabb1, aabb2) == True\n        # Converse\n        assert utils.aabb_overlaps_aabb(aabb2, aabb1) == True\n        # 1 vs 3\n        assert utils.aabb_overlaps_aabb(aabb1, aabb3) == True\n        # Converse\n        assert utils.aabb_overlaps_aabb(aabb3, aabb1) == True\n        # 2 vs 3 (Edge)\n        assert utils.aabb_overlaps_aabb(aabb2, aabb3) == False\n        # Converse\n        assert utils.aabb_overlaps_aabb(aabb3, aabb2) == False\n        # 2 vs 4\n        assert utils.aabb_overlaps_aabb(aabb2, aabb4) == False\n        # Converse\n        assert utils.aabb_overlaps_aabb(aabb4, aabb2) == False\n\n    def test_point_in_circle(self):\n        # Inside\n        assert utils.point_in_circle([0, 0], 1) == True\n        # Edge\n        assert utils.point_in_circle([1, 0], 1) == True\n        # Outside\n        assert utils.point_in_circle([2, 0], 1) == False\n        # Inside (Offset)\n        assert utils.point_in_circle([1, 1], 1, (1, 1)) == True\n        # Edge (Offset)\n        assert utils.point_in_circle([1, 2], 1, (1, 1)) == True\n        # Outside (Offset)\n        assert utils.point_in_circle([0, 0], 1, (1, 1)) == False\n\n    def test_aabb_overlaps_circle(self):\n        # AABB inside circle\n        assert utils.aabb_overlaps_circle(utils.AABB(-1, -1, 1, 1), 2, (0, 0)) == True\n        # Circle inside AABB\n        assert utils.aabb_overlaps_circle(utils.AABB(-4, -4, 4, 4), 1, (0, 0)) == True\n        assert utils.aabb_overlaps_circle(utils.AABB(-5, -1, -4, 1), 1, (0, 0)) == False\n        assert utils.aabb_overlaps_circle(utils.AABB(-1, 10, 1, 11), 1, (0, 0)) == False\n        assert (\n            utils.aabb_overlaps_circle(utils.AABB(-1.0, -0.5, -0.5, 0.5), 1, (0, 0))\n            == True\n        )\n        # Edge\n        assert (\n            utils.aabb_overlaps_circle(utils.AABB(-1.5, -1.5, -0.5, -0.5), 1, (0, 0))\n            == True\n        )\n\n    def test_rect_overlaps_rect(self):\n        pass\n\n    def test_extend_aabb(self):\n        base_aabb = utils.AABB(0, 0, 0, 0)\n        base_aabb = utils.extend_aabb(base_aabb, utils.AABB(0, 0, 1, 1))\n        assert base_aabb == utils.AABB(0, 0, 1, 1)\n\n        # Swap orders\n        base_aabb = utils.extend_aabb(utils.AABB(9, 9, 10, 10), base_aabb)\n        assert base_aabb == utils.AABB(0, 0, 10, 10)\n\n        # First None case\n        result_aabb = utils.extend_aabb(None, utils.AABB(0, 0, 1, 1))\n        assert result_aabb == utils.AABB(0, 0, 1, 1)\n\n        # Second None case\n        result_aabb = utils.extend_aabb(utils.AABB(0, 0, 1, 1), None)\n        assert result_aabb == utils.AABB(0, 0, 1, 1)\n\n        # Both None case\n        result_aabb = utils.extend_aabb(None, None)\n        assert result_aabb == None\n\n    def test_aabb_to_dimensions(self):\n        assert utils.aabb_to_dimensions(utils.AABB(-5, -5, 10, 0)) == (15, 5)\n\n    def test_get_first(self):\n        test_list = [\"a\", \"b\", \"c\"]\n        assert utils.get_first(test_list) == \"a\"\n        test_list = []\n        assert utils.get_first(test_list) == None\n\n    def test_parse_energy(self):\n        # Normal\n        assert utils.parse_energy(\"100J\") == 100\n        assert utils.parse_energy(\"1000KJ\") == 1_000_000\n        assert utils.parse_energy(\"60MW\") == 1_000_000\n\n        # Unknown unit type specifier\n        with pytest.raises(ValueError):\n            utils.parse_energy(\"100MY\")\n\n        # Unknown unit scale specifier\n        with pytest.raises(ValueError):\n            utils.parse_energy(\"100QW\")\n\n    def test_reissue_warnings(self):\n        @utils.reissue_warnings\n        def test_function():\n            warnings.warn(\"testing\")\n            return \"examples\"\n\n        with pytest.warns(UserWarning):\n            result = test_function()\n\n        assert result == \"examples\"\n"
