[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "datolabs-io/opsy"
sha = "34d0c4dd506970419e9238a3343710100422dd33"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/tui/components/commandspane/commandspane.go internal/tui/components/commandspane/commandspane_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/tui/components/commandspane/commandspane.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 98.0
mutation_kill_rate = nan
original_mutation_kill_rate = 56.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "internal/tui/components/commandspane/commandspane_test.go"
focal_file_path = "internal/tui/components/commandspane/commandspane.go"
test_file_url = "https://github.com/datolabs-io/opsy/blob/34d0c4dd506970419e9238a3343710100422dd33/internal/tui/components/commandspane/commandspane_test.go"
focal_file_url = "https://github.com/datolabs-io/opsy/blob/34d0c4dd506970419e9238a3343710100422dd33/internal/tui/components/commandspane/commandspane.go"
first_commit_date = "2025-02-19"
last_commit_date = "2025-03-01"
test_file_content = "package commandspane\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/datolabs-io/sredo/internal/thememanager\"\n\t\"github.com/datolabs-io/sredo/internal/tool\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// stripANSI removes ANSI color codes from a string.\nfunc stripANSI(str string) string {\n\tre := regexp.MustCompile(`\\x1b\\[[0-9;]*[a-zA-Z]`)\n\treturn re.ReplaceAllString(str, \"\")\n}\n\n// TestNew tests the creation of a new commands pane component.\nfunc TestNew(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t\tBase02: \"#111111\",\n\t\t\tBase03: \"#222222\",\n\t\t\tBase04: \"#333333\",\n\t\t},\n\t\tAccentColors: thememanager.AccentColors{\n\t\t\tAccent0: \"#FF0000\",\n\t\t},\n\t}\n\n\tm := New(\n\t\tWithTheme(theme),\n\t)\n\n\tassert.NotNil(t, m)\n\tassert.Equal(t, theme, m.theme)\n\tassert.NotNil(t, m.viewport)\n\tassert.Empty(t, m.commands)\n}\n\n// TestUpdate tests the update function of the commands pane component.\nfunc TestUpdate(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t\tBase02: \"#111111\",\n\t\t\tBase03: \"#222222\",\n\t\t\tBase04: \"#333333\",\n\t\t},\n\t}\n\tm := New(WithTheme(theme))\n\n\t// Test window size message\n\tnewModel, cmd := m.Update(tea.WindowSizeMsg{Width: 100, Height: 50})\n\tassert.NotNil(t, newModel)\n\tassert.Nil(t, cmd)\n\tassert.Equal(t, 94, newModel.maxWidth) // Width - 6 for padding\n\tassert.Equal(t, 50, newModel.maxHeight)\n\tassert.Equal(t, 94, newModel.viewport.Width)\n\tassert.Equal(t, 50, newModel.viewport.Height)\n\n\t// Test command message\n\tnow := time.Now()\n\ttestCmd := tool.Command{\n\t\tCommand:          \"ls -la\",\n\t\tWorkingDirectory: \"~/sredo\",\n\t\tStartedAt:        now,\n\t}\n\tm, cmd = m.Update(testCmd)\n\tassert.Nil(t, cmd)\n\tassert.Len(t, m.commands, 1)\n\tassert.Equal(t, testCmd, m.commands[0])\n}\n\n// TestView tests the view function of the commands pane component.\nfunc TestView(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t\tBase02: \"#111111\",\n\t\t\tBase03: \"#222222\",\n\t\t\tBase04: \"#333333\",\n\t\t},\n\t\tAccentColors: thememanager.AccentColors{\n\t\t\tAccent0: \"#FF0000\",\n\t\t},\n\t}\n\n\tm := New(\n\t\tWithTheme(theme),\n\t)\n\n\t// Set dimensions to test rendering\n\tm, _ = m.Update(tea.WindowSizeMsg{Width: 100, Height: 50})\n\n\t// Test initial view (empty commands)\n\tview := stripANSI(m.View())\n\tassert.NotEmpty(t, view)\n\tassert.Contains(t, view, \"Commands\")\n\n\t// Add test command\n\tnow := time.Now()\n\tm.Update(tool.Command{\n\t\tCommand:          \"ls -la\",\n\t\tWorkingDirectory: \"~/sredo\",\n\t\tStartedAt:        now,\n\t})\n\n\t// Test view with command\n\tview = stripANSI(m.View())\n\tassert.Contains(t, view, \"Commands\")\n\tassert.Contains(t, view, \"~/sredo\")\n\tassert.Contains(t, view, \"ls -la\")\n\tassert.Contains(t, view, now.Format(\"15:04:05\"))\n}\n\n// TestInit tests the initialization of the commands pane component.\nfunc TestInit(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t},\n\t}\n\tm := New(WithTheme(theme))\n\tcmd := m.Init()\n\tassert.Nil(t, cmd)\n}\n\n// TestCommandWrapping tests the wrapping behavior of long commands.\nfunc TestCommandWrapping(t *testing.T) {\n\tm := New()\n\tm, _ = m.Update(tea.WindowSizeMsg{Width: 40, Height: 40})\n\n\t// Create a command that will definitely wrap\n\tlongCommand := \"ls -la /very/long/path/that/will/definitely/wrap/across/multiple/lines/in/the/terminal/output/when/rendered\"\n\tcmd := tool.Command{\n\t\tCommand:          longCommand,\n\t\tWorkingDirectory: \"~/sredo\",\n\t\tStartedAt:        time.Now(),\n\t}\n\tm, _ = m.Update(cmd)\n\n\t// Get the view\n\tview := m.View()\n\n\t// Count the number of lines in the view\n\tlines := strings.Split(view, \"\\n\")\n\tnonEmptyLines := 0\n\tfor _, line := range lines {\n\t\tif strings.TrimSpace(line) != \"\" {\n\t\t\tnonEmptyLines++\n\t\t}\n\t}\n\n\t// With a width of 40, the command should wrap to at least 3 lines:\n\t// 1. Line with timestamp and start of command\n\t// 2. At least one wrapped line\n\t// 3. Line with working directory\n\tassert.GreaterOrEqual(t, nonEmptyLines, 3, \"command should wrap to at least 3 lines\")\n\n\t// Verify parts of the command are present, accounting for word wrapping\n\tassert.Contains(t, view, \"ls -la /very/\")\n\tassert.Contains(t, view, \"long/path/tha\")\n\tassert.Contains(t, view, \"t/will/defini\")\n\tassert.Contains(t, view, \"tely/wrap/acr\")\n\tassert.Contains(t, view, \"oss/multiple/\")\n\tassert.Contains(t, view, \"lines/in/the/\")\n\tassert.Contains(t, view, \"terminal/outp\")\n\tassert.Contains(t, view, \"ut/when/rende\")\n\tassert.Contains(t, view, \"red\")\n\n\t// Verify working directory is present\n\tassert.Contains(t, view, cmd.WorkingDirectory)\n}\n\n// TestMultipleCommands tests rendering of multiple commands.\nfunc TestMultipleCommands(t *testing.T) {\n\ttheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase01: \"#000000\",\n\t\t\tBase02: \"#111111\",\n\t\t\tBase03: \"#222222\",\n\t\t\tBase04: \"#333333\",\n\t\t},\n\t\tAccentColors: thememanager.AccentColors{\n\t\t\tAccent0: \"#FF0000\",\n\t\t},\n\t}\n\n\tm := New(WithTheme(theme))\n\tm, _ = m.Update(tea.WindowSizeMsg{Width: 100, Height: 50})\n\n\t// Add multiple commands\n\tcommands := []tool.Command{\n\t\t{\n\t\t\tCommand:          \"git status\",\n\t\t\tWorkingDirectory: \"~/project1\",\n\t\t\tStartedAt:        time.Now(),\n\t\t},\n\t\t{\n\t\t\tCommand:          \"make build\",\n\t\t\tWorkingDirectory: \"~/project2\",\n\t\t\tStartedAt:        time.Now().Add(time.Second),\n\t\t},\n\t\t{\n\t\t\tCommand:          \"docker ps\",\n\t\t\tWorkingDirectory: \"~/project3\",\n\t\t\tStartedAt:        time.Now().Add(2 * time.Second),\n\t\t},\n\t}\n\n\tfor _, cmd := range commands {\n\t\tm, _ = m.Update(cmd)\n\t}\n\n\tview := stripANSI(m.View())\n\n\t// Verify all commands are rendered\n\tfor _, cmd := range commands {\n\t\tassert.Contains(t, view, cmd.Command)\n\t\tassert.Contains(t, view, cmd.WorkingDirectory)\n\t\tassert.Contains(t, view, cmd.StartedAt.Format(\"15:04:05\"))\n\t}\n\n\t// Verify order (last command should be at the bottom)\n\tlastCmdIndex := strings.LastIndex(view, commands[len(commands)-1].Command)\n\tfor i := 0; i < len(commands)-1; i++ {\n\t\tcmdIndex := strings.LastIndex(view, commands[i].Command)\n\t\tassert.Less(t, cmdIndex, lastCmdIndex, \"commands should be in chronological order\")\n\t}\n}\n\n// TestThemeChange tests the component's response to theme changes.\nfunc TestThemeChange(t *testing.T) {\n\tinitialTheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase00: \"#000000\",\n\t\t\tBase01: \"#111111\",\n\t\t\tBase02: \"#222222\",\n\t\t\tBase03: \"#333333\",\n\t\t\tBase04: \"#444444\",\n\t\t},\n\t\tAccentColors: thememanager.AccentColors{\n\t\t\tAccent0: \"#FF0000\",\n\t\t\tAccent1: \"#00FF00\",\n\t\t\tAccent2: \"#0000FF\",\n\t\t},\n\t}\n\n\tnewTheme := thememanager.Theme{\n\t\tBaseColors: thememanager.BaseColors{\n\t\t\tBase00: \"#FFFFFF\",\n\t\t\tBase01: \"#EEEEEE\",\n\t\t\tBase02: \"#DDDDDD\",\n\t\t\tBase03: \"#CCCCCC\",\n\t\t\tBase04: \"#BBBBBB\",\n\t\t},\n\t\tAccentColors: thememanager.AccentColors{\n\t\t\tAccent0: \"#00FF00\",\n\t\t\tAccent1: \"#FF0000\",\n\t\t\tAccent2: \"#0000FF\",\n\t\t},\n\t}\n\n\t// Create models with different themes\n\tm1 := New(WithTheme(initialTheme))\n\tm2 := New(WithTheme(newTheme))\n\n\t// Verify that styles are different\n\tassert.NotEqual(t,\n\t\tm1.commandStyle().GetForeground(),\n\t\tm2.commandStyle().GetForeground(),\n\t\t\"command styles should have different colors\",\n\t)\n\n\tassert.NotEqual(t,\n\t\tm1.containerStyle().GetBackground(),\n\t\tm2.containerStyle().GetBackground(),\n\t\t\"container styles should have different backgrounds\",\n\t)\n\n\tassert.NotEqual(t,\n\t\tm1.workdirStyle().GetBackground(),\n\t\tm2.workdirStyle().GetBackground(),\n\t\t\"workdir styles should have different backgrounds\",\n\t)\n\n\t// Verify that the styles use the correct theme colors\n\tassert.Equal(t,\n\t\tlipgloss.Color(initialTheme.AccentColors.Accent0),\n\t\tm1.commandStyle().GetForeground(),\n\t\t\"command style should use Accent0 color\",\n\t)\n\n\tassert.Equal(t,\n\t\tlipgloss.Color(initialTheme.BaseColors.Base01),\n\t\tm1.containerStyle().GetBackground(),\n\t\t\"container style should use Base01 color\",\n\t)\n\n\tassert.Equal(t,\n\t\tlipgloss.Color(newTheme.AccentColors.Accent0),\n\t\tm2.commandStyle().GetForeground(),\n\t\t\"command style should use Accent0 color\",\n\t)\n\n\tassert.Equal(t,\n\t\tlipgloss.Color(newTheme.BaseColors.Base01),\n\t\tm2.containerStyle().GetBackground(),\n\t\t\"container style should use Base01 color\",\n\t)\n}"
