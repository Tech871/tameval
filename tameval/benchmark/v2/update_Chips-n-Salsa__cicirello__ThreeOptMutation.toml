[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Java"
java_builder = "Maven"
is_multi_module = false

[repo_info]
repository = "cicirello/Chips-n-Salsa"
sha = "0dc132865b107fc955f50f8659bca138cbfc43c5"

[run_info]
docker_image = "maven:3.8.3-openjdk-17"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "mvn -Dmaven.repo.local=/.m2 -T 4 clean install"
test_run_command = "mvn clean -Dmaven.repo.local=/.m2 test -q -Dtest=ThreeOptMutationTests && mvn jacoco:report -Djacoco.append=false"
mutation_run_command = "mvn -Dmaven.repo.local=/.m2 org.pitest:pitest-maven:mutationCoverage -DtargetClasses=**.ThreeOptMutation  -DtargetTests=**.ThreeOptMutationTests  -DoutputFormats=XML"
coverage_report_path = "target/site/jacoco/jacoco.xml"
coverage_report_type = "jacoco"
mutation_report_path = "target/pit-reports/mutations.xml"
mutation_report_type = "pitest"

[coverage]
coverage = 0
original_coverage = 100.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "src/test/java/org/cicirello/search/operators/permutations/ThreeOptMutationTests.java"
focal_file_path = "src/main/java/org/cicirello/search/operators/permutations/ThreeOptMutation.java"
test_file_url = "https://github.com/cicirello/Chips-n-Salsa/blob/0dc132865b107fc955f50f8659bca138cbfc43c5/src/test/java/org/cicirello/search/operators/permutations/ThreeOptMutationTests.java"
focal_file_url = "https://github.com/cicirello/Chips-n-Salsa/blob/0dc132865b107fc955f50f8659bca138cbfc43c5/src/main/java/org/cicirello/search/operators/permutations/ThreeOptMutation.java"
first_commit_date = "2021-09-27"
last_commit_date = "2024-05-15"
test_file_content = "/*\n * Chips-n-Salsa: A library of parallel self-adaptive local search algorithms.\n * Copyright (C) 2002-2021  Vincent A. Cicirello\n *\n * This file is part of Chips-n-Salsa (https://chips-n-salsa.cicirello.org/).\n * \n * Chips-n-Salsa is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * Chips-n-Salsa is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n \npackage org.cicirello.search.operators.permutations;\n\nimport org.junit.*;\nimport static org.junit.Assert.*;\nimport org.cicirello.permutations.Permutation;\nimport org.cicirello.permutations.distance.CyclicEdgeDistance;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.HashMap;\nimport java.util.Set;\n\n\n/**\n * JUnit 4 test cases for ThreeOptMutation.\n */\npublic class ThreeOptMutationTests {\n\t\n\t@Test\n\tpublic void testThreeOptMutation() {\n\t\tThreeOptMutation mutation = new ThreeOptMutation();\n\t\tCyclicEdgeDistance distance = new CyclicEdgeDistance();\n\t\tfor (int n = 5; n <= 10; n++) {\n\t\t\tPermutation p = new Permutation(n);\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tPermutation mutant = new Permutation(p);\n\t\t\t\tmutation.mutate(mutant);\n\t\t\t\tint d = distance.distance(p, mutant);\n\t\t\t\tassertTrue(d >= 2);\n\t\t\t\tassertTrue(d <= 3);\n\t\t\t\tassertNotEquals(p, mutant);\n\t\t\t\tmutation.undo(mutant);\n\t\t\t\tassertEquals(p, mutant);\n\t\t\t}\n\t\t}\n\t\t// only 2-changes in this case\n\t\tint n = 4;\n\t\tPermutation p = new Permutation(n);\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tPermutation mutant = new Permutation(p);\n\t\t\tmutation.mutate(mutant);\n\t\t\tassertEquals(2, distance.distance(p, mutant));\n\t\t\tassertNotEquals(p, mutant);\n\t\t\tmutation.undo(mutant);\n\t\t\tassertEquals(p, mutant);\n\t\t}\n\t\t// n < 4 should have no change\n\t\tfor (n = 0; n < 4; n++) {\n\t\t\tp = new Permutation(n);\n\t\t\tPermutation mutant = new Permutation(p);\n\t\t\tmutation.mutate(mutant);\n\t\t\tassertEquals(p, mutant);\n\t\t\tmutation.undo(mutant);\n\t\t\tassertEquals(p, mutant);\n\t\t}\n\t}\n\t\n\t@Test\n\tpublic void testSplit() {\n\t\tThreeOptMutation mutation = (new ThreeOptMutation()).split();\n\t\tCyclicEdgeDistance distance = new CyclicEdgeDistance();\n\t\tfor (int n = 5; n <= 7; n++) {\n\t\t\tPermutation p = new Permutation(n);\n\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\tPermutation mutant = new Permutation(p);\n\t\t\t\tmutation.mutate(mutant);\n\t\t\t\tint d = distance.distance(p, mutant);\n\t\t\t\tassertTrue(d >= 2);\n\t\t\t\tassertTrue(d <= 3);\n\t\t\t\tassertNotEquals(p, mutant);\n\t\t\t\tmutation.undo(mutant);\n\t\t\t\tassertEquals(p, mutant);\n\t\t\t}\n\t\t}\n\t\t// only 2-changes in this case\n\t\tint n = 4;\n\t\tPermutation p = new Permutation(n);\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tPermutation mutant = new Permutation(p);\n\t\t\tmutation.mutate(mutant);\n\t\t\tassertEquals(2, distance.distance(p, mutant));\n\t\t\tassertNotEquals(p, mutant);\n\t\t\tmutation.undo(mutant);\n\t\t\tassertEquals(p, mutant);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testInternalHelpers() {\n\t\tThreeOptMutation mutation = new ThreeOptMutation();\n\t\tCyclicEdgeDistance distance = new CyclicEdgeDistance();\n\t\tint[] indexes = new int[3];\n\t\tfor (int n = 5; n <= 8; n++) {\n\t\t\tPermutation p = new Permutation(n);\n\t\t\tHashSet<Edge> edges = getEdgeSet(p);\n\t\t\tHashMap<EdgeCombo, HashSet<EdgeCombo>> mapping2 = new HashMap<EdgeCombo, HashSet<EdgeCombo>>();\n\t\t\tHashMap<EdgeCombo, HashSet<EdgeCombo>> mapping3 = new HashMap<EdgeCombo, HashSet<EdgeCombo>>();\n\t\t\tint count2 = 0;\n\t\t\tint count3 = 0;\n\t\t\tint expectedCount3 = 4*(n*(n-1)*(n-2)/6 - n*(n-4) - n) + n*(n-4);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = i+1; j < n; j++) {\n\t\t\t\t\tfor (int k = j+1; k < n; k++) {\n\t\t\t\t\t\tfor (int which = 0; which < 4; which++) {\n\t\t\t\t\t\t\tindexes[0]=i;\n\t\t\t\t\t\t\tindexes[1]=j;\n\t\t\t\t\t\t\tindexes[2]=k;\n\t\t\t\t\t\t\tPermutation mutant = new Permutation(p);\n\t\t\t\t\t\t\tmutation.threeOrTwoChange(indexes, which, mutant);\n\t\t\t\t\t\t\tint d = distance.distance(p, mutant);\n\t\t\t\t\t\t\tassertTrue(d >= 2 && d <= 3);\n\t\t\t\t\t\t\tHashSet<Edge> mutantEdges = getEdgeSet(mutant);\n\t\t\t\t\t\t\tEdgeCombo changedFrom = new EdgeCombo(mutantEdges, edges);\n\t\t\t\t\t\t\tEdgeCombo changedTo = new EdgeCombo(edges, mutantEdges);\n\t\t\t\t\t\t\tif (d == 2) {\n\t\t\t\t\t\t\t\tcount2++;\n\t\t\t\t\t\t\t\tif (!mapping2.containsKey(changedFrom)) {\n\t\t\t\t\t\t\t\t\tHashSet<EdgeCombo> toSet = new HashSet<EdgeCombo>();\n\t\t\t\t\t\t\t\t\ttoSet.add(changedTo);\n\t\t\t\t\t\t\t\t\tmapping2.put(changedFrom, toSet);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmapping2.get(changedFrom).add(changedTo);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (d == 3) {\n\t\t\t\t\t\t\t\tcount3++;\n\t\t\t\t\t\t\t\tif (!mapping3.containsKey(changedFrom)) {\n\t\t\t\t\t\t\t\t\tHashSet<EdgeCombo> toSet = new HashSet<EdgeCombo>();\n\t\t\t\t\t\t\t\t\ttoSet.add(changedTo);\n\t\t\t\t\t\t\t\t\tmapping3.put(changedFrom, toSet);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmapping3.get(changedFrom).add(changedTo);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tmutation.undoThreeOrTwoChange(indexes, which, mutant);\n\t\t\t\t\t\t\tassertEquals(0, distance.distance(p, mutant));\n\t\t\t\t\t\t\tassertEquals(p, mutant);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tassertEquals(expectedCount3, count3);\n\t\t\tint expectedNumRemovedCombos3 = (n*(n-1)*(n-2)/6 - n*(n-4) - n) + n*(n-4);\n\t\t\tassertEquals(expectedNumRemovedCombos3, mapping3.size());\n\t\t\tSet<EdgeCombo> keys = mapping3.keySet();\n\t\t\tint totalNumReplacements = 0;\n\t\t\tfor (EdgeCombo key : keys) {\n\t\t\t\tint s = mapping3.get(key).size();\n\t\t\t\tassertTrue(s==4 || s==1);\n\t\t\t\ttotalNumReplacements += s;\n\t\t\t}\n\t\t\tassertEquals(expectedCount3, totalNumReplacements);\n\t\t\t\n\t\t\tassertEquals(n*(n-3)/2, mapping2.size());\n\t\t\tkeys = mapping2.keySet();\n\t\t\ttotalNumReplacements = 0;\n\t\t\tfor (EdgeCombo key : keys) {\n\t\t\t\tint s = mapping2.get(key).size();\n\t\t\t\tassertTrue(s==1);\n\t\t\t\ttotalNumReplacements += s;\n\t\t\t}\n\t\t\tassertEquals(n*(n-3)/2, totalNumReplacements);\n\t\t}\n\t}\n\t\n\tprivate HashSet<Edge> getEdgeSet(Permutation p) {\n\t\tHashSet<Edge> s = new HashSet<Edge>();\n\t\tfor (int i = 1; i < p.length(); i++) {\n\t\t\ts.add(new Edge(p.get(i-1), p.get(i)));\n\t\t}\n\t\tif (p.length()>2) s.add(new Edge(p.get(0), p.get(p.length()-1)));\n\t\treturn s;\n\t}\n\t\n\tprivate static class EdgeCombo {\n\t\tArrayList<Edge> combo;\n\t\t\n\t\tEdgeCombo() {\n\t\t\tcombo = new ArrayList<Edge>(3);\n\t\t}\n\t\t\n\t\tEdgeCombo(HashSet<Edge> original, HashSet<Edge> mutant) {\n\t\t\tthis();\n\t\t\tfor (Edge e : mutant) {\n\t\t\t\tif (!original.contains(e)) {\n\t\t\t\t\taddEdge(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsort();\n\t\t}\n\t\t\n\t\tvoid addEdge(Edge e) {\n\t\t\tcombo.add(e);\n\t\t}\n\t\t\n\t\tvoid sort() {\n\t\t\tCollections.sort(combo);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (!(o instanceof EdgeCombo)) return false;\n\t\t\tEdgeCombo other = (EdgeCombo)o;\n\t\t\tif (combo.size() != other.combo.size()) return false;\n\t\t\tfor (int i = 0; i < combo.size(); i++) {\n\t\t\t\tif (!combo.get(i).equals(other.combo.get(i))) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tint h = 0;\n\t\t\tfor (Edge e : combo) {\n\t\t\t\th = 31*h + e.hashCode();\n\t\t\t}\n\t\t\treturn h;\n\t\t}\n\t}\n\t\n\tprivate static class Edge implements Comparable<Edge> {\n\t\tint a;\n\t\tint b;\n\t\tEdge(int a, int b) {\n\t\t\tif (a < b) {\n\t\t\t\tthis.a = a;\n\t\t\t\tthis.b = b;\n\t\t\t} else {\n\t\t\t\tthis.a = b;\n\t\t\t\tthis.b = a;\n\t\t\t}\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn 31*a + b;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (!(other instanceof Edge)) return false;\n\t\t\treturn a == ((Edge)other).a && b == ((Edge)other).b;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Edge other) {\n\t\t\tif (equals(other)) return 0;\n\t\t\telse if (a < other.a || a==other.a && b < other.b) return -1;\n\t\t\telse return 1;\n\t\t}\n\t}\n\n}"
