[meta]
task = "repair"
scenario = "repair_no_new_covered_logic"

[lang_info]
lang = "Go"
go_version = "1.23.6"

[repo_info]
repository = "cloudprober/cloudprober"
sha = "01736e0103a53b703064edec034c30ef5e25681d"

[run_info]
docker_image = "golang:1.23.6"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out probes/common/sched/sched.go probes/common/sched/sched_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting probes/common/sched/sched.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 70.0
original_coverage = 70.0
mutation_kill_rate = 39.0
original_mutation_kill_rate = 39.0
covered_lines = [ 33, 34, 35, 36, 37, 38, 91, 92, 93, 94, 96, 97, 101, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 117, 118, 119, 124, 127, 128, 129, 136, 137, 138, 139, 140, 141, 142, 143, 144, 146, 147, 148, 149, 150, 155, 156, 157, 158, 159, 160, 161, 162, 163, 167, 168, 169, 175, 176, 177, 183, 184, 187, 188, 189, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 203, 204, 205, 206, 207, 210, 211, 212, 214, 215, 216, 219, 220, 221, 222, 223, 224, 225, 226, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 243, 245, 248, 249, 250,]
missed_lines = [ 98, 99, 100, 130, 131, 132, 133, 151, 152, 164, 165, 185, 186, 239, 240, 241, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 270, 271, 272, 273, 274, 275, 277, 278, 281, 282, 283, 284, 285, 286, 287, 288, 289,]

[input_info]
test_file_path = "probes/common/sched/sched_test.go"
focal_file_path = "probes/common/sched/sched.go"
test_file_url = "https://github.com/cloudprober/cloudprober/blob/01736e0103a53b703064edec034c30ef5e25681d/probes/common/sched/sched_test.go"
focal_file_url = "https://github.com/cloudprober/cloudprober/blob/01736e0103a53b703064edec034c30ef5e25681d/probes/common/sched/sched.go"
first_commit_date = "2022-03-03"
last_commit_date = "2025-01-22"
test_file_content = "\n\npackage sched\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/cloudprober/cloudprober/logger\"\n\t\"github.com/cloudprober/cloudprober/metrics\"\n\t\"github.com/cloudprober/cloudprober/metrics/testutils\"\n\tdnsconfigpb \"github.com/cloudprober/cloudprober/probes/dns/proto\"\n\thttpconfigpb \"github.com/cloudprober/cloudprober/probes/http/proto\"\n\t\"github.com/cloudprober/cloudprober/probes/options\"\n\ttcpconfigpb \"github.com/cloudprober/cloudprober/probes/tcp/proto\"\n\t\"github.com/cloudprober/cloudprober/targets\"\n\t\"github.com/cloudprober/cloudprober/targets/endpoint\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\ntype testProbeResult struct {\n\ttotal int\n}\n\nfunc (tpr *testProbeResult) Metrics(ts time.Time, _ int64, opts *options.Options) []*metrics.EventMetrics {\n\treturn []*metrics.EventMetrics{metrics.NewEventMetrics(ts).AddMetric(\"total\", metrics.NewInt(int64(tpr.total)))}\n}\n\nfunc compareNumberOfMetrics(t *testing.T, ems []*metrics.EventMetrics, metricName string, targets [2]string, wantCloseRange bool) {\n\tt.Helper()\n\n\tmmap := testutils.MetricsMapByTarget(ems).Filter(metricName)\n\tnum1 := len(mmap[targets[0]])\n\tnum2 := len(mmap[targets[1]])\n\n\tdiff := num1 - num2\n\tthreshold := num1 / 2\n\tnotCloseRange := diff < -(threshold) || diff > threshold\n\n\tif notCloseRange && wantCloseRange {\n\t\tt.Errorf(\"Number of metrics for two targets are not within a close range (%d, %d)\", num1, num2)\n\t}\n\tif !notCloseRange && !wantCloseRange {\n\t\tt.Errorf(\"Number of metrics for two targets are within a close range (%d, %d)\", num1, num2)\n\t}\n\tfor _, mvs := range mmap {\n\t\tnumMetrics := len(mvs)\n\t\tlastVal := int(mvs[numMetrics-1].(metrics.NumValue).Int64())\n\t\tif lastVal < numMetrics {\n\t\t\tt.Errorf(\"Metric (%s) last value: %d, less than: %d\", metricName, lastVal, numMetrics)\n\t\t}\n\t}\n}\n\nfunc TestUpdateTargetsAndStartProbes(t *testing.T) {\n\ttestTargets := [2]string{\"test1.com\", \"test2.com\"}\n\n\topts := &options.Options{\n\t\tTargets:             targets.StaticTargets(fmt.Sprintf(\"%s,%s\", testTargets[0], testTargets[1])),\n\t\tInterval:            10 * time.Millisecond,\n\t\tStatsExportInterval: 20 * time.Millisecond,\n\t\tLogger:              &logger.Logger{},\n\t}\n\n\ts := &Scheduler{\n\t\tOpts:              opts,\n\t\tDataChan:          make(chan *metrics.EventMetrics, 100),\n\t\tNewResult:         func(_ *endpoint.Endpoint) ProbeResult { return &testProbeResult{} },\n\t\tRunProbeForTarget: func(ctx context.Context, runReq *RunProbeForTargetRequest) { runReq.Result.(*testProbeResult).total++ },\n\t}\n\ts.init()\n\n\tctx, cancelF := context.WithCancel(context.Background())\n\ts.refreshTargets(ctx)\n\tif len(s.cancelFuncs) != 2 {\n\t\tt.Errorf(\"len(s.cancelFunc)=%d, want=2\", len(s.cancelFuncs))\n\t}\n\tems, _ := testutils.MetricsFromChannel(s.DataChan, 100, time.Second)\n\twantCloseRange := true\n\tcompareNumberOfMetrics(t, ems, \"total\", testTargets, wantCloseRange)\n\n\topts.Targets = targets.StaticTargets(testTargets[0])\n\ts.refreshTargets(ctx)\n\tif len(s.cancelFuncs) != 1 {\n\t\tt.Errorf(\"len(s.cancelFunc)=%d, want=1\", len(s.cancelFuncs))\n\t}\n\tems, _ = testutils.MetricsFromChannel(s.DataChan, 100, time.Second)\n\twantCloseRange = false\n\tcompareNumberOfMetrics(t, ems, \"total\", testTargets, wantCloseRange)\n\n\tcancelF()\n\ts.Wait()\n}\n\nfunc TestVerifyTargetsAndStartProbing(t *testing.T) {\n\ttestTargets := [2]string{\"test1.com\", \"test2.com\"}\n\n\topts := &options.Options{\n\t\tTargets:             targets.StaticTargets(fmt.Sprintf(\"%s,%s\", testTargets[0], testTargets[1])),\n\t\tInterval:            15 * time.Millisecond,\n\t\tStatsExportInterval: 30 * time.Millisecond,\n\t\tLogger:              &logger.Logger{},\n\t}\n\n\ts := &Scheduler{\n\t\tProbeName:         \"test-probe\",\n\t\tOpts:              opts,\n\t\tDataChan:          make(chan *metrics.EventMetrics, 200),\n\t\tNewResult:         func(_ *endpoint.Endpoint) ProbeResult { return &testProbeResult{} },\n\t\tRunProbeForTarget: func(ctx context.Context, runReq *RunProbeForTargetRequest) { runReq.Result.(*testProbeResult).total += 2 },\n\t}\n\ts.init()\n\n\tctx, cancelF := context.WithCancel(context.Background())\n\ts.refreshTargets(ctx)\n\tif len(s.cancelFuncs) != 2 {\n\t\tt.Errorf(\"len(s.cancelFunc)=%d, want=2\", len(s.cancelFuncs))\n\t}\n\tems, _ := testutils.MetricsFromChannel(s.DataChan, 200, 2*time.Second)\n\twantCloseRange := true\n\tcompareNumberOfMetrics(t, ems, \"total\", testTargets, wantCloseRange)\n\n\topts.Targets = targets.StaticTargets(testTargets[0])\n\ts.refreshTargets(ctx)\n\tif len(s.cancelFuncs) != 1 {\n\t\tt.Errorf(\"len(s.cancelFunc)=%d, want=1\", len(s.cancelFuncs))\n\t}\n\tems, _ = testutils.MetricsFromChannel(s.DataChan, 200, 2*time.Second)\n\twantCloseRange = false\n\tcompareNumberOfMetrics(t, ems, \"total\", testTargets, wantCloseRange)\n\n\tcancelF()\n\ts.Wait()\n}\n\nfunc TestRunProbeForTargetTimeout(t *testing.T) {\n\ttestTargets := [2]string{\"test1.com\", \"test2.com\"}\n\n\topts := &options.Options{\n\t\tTargets:  targets.StaticTargets(strings.Join(testTargets[:], \",\")),\n\t\tInterval: 10 * time.Millisecond,\n\t\tTimeout:  5 * time.Millisecond,\n\t}\n\n\ts := &Scheduler{\n\t\tOpts:      opts,\n\t\tDataChan:  make(chan *metrics.EventMetrics, 100),\n\t\tNewResult: func(_ *endpoint.Endpoint) ProbeResult { return &testProbeResult{} },\n\t\tRunProbeForTarget: func(ctx context.Context, runReq *RunProbeForTargetRequest) {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tif ctx.Err() != context.DeadlineExceeded {\n\t\t\t\t\tif ctx.Err() == context.Canceled {\n\t\t\t\t\t\tt.Log(\"Probe canceled by the test\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt.Errorf(\"Probe did not timeout as expected\")\n\t\t\t\t}\n\t\t\tcase <-time.After(50 * time.Millisecond):\n\t\t\t\tt.Errorf(\"Probe did not timeout as expected\")\n\t\t\t}\n\t\t},\n\t}\n\ts.init()\n\n\tctx, cancelF := context.WithCancel(context.Background())\n\n\ts.refreshTargets(ctx)\n\ttime.Sleep(100 * time.Millisecond)\n\n\tassert.Equal(t, len(testTargets), len(s.cancelFuncs), \"len(s.cancelFunc)=%d, want=%d\", len(s.cancelFuncs), len(testTargets))\n\n\tcancelF()\n\ts.Wait()\n}\n\nfunc TestSchedulerGapBetweenTargets(t *testing.T) {\n\ttestTargets := []endpoint.Endpoint{{Name: \"test1.com\"}, {Name: \"test2.com\"}}\n\ttests := []struct {\n\t\tname string\n\t\topts *options.Options\n\t\twant time.Duration\n\t}{\n\t\t{\n\t\t\tname: \"default\",\n\t\t\topts: &options.Options{\n\t\t\t\tInterval: 10 * time.Second,\n\t\t\t},\n\t\t\twant: 500 * time.Millisecond,\n\t\t},\n\t\t{\n\t\t\tname: \"tcp probe\",\n\t\t\topts: &options.Options{\n\t\t\t\tInterval: 10 * time.Second,\n\t\t\t\tProbeConf: &tcpconfigpb.ProbeConf{\n\t\t\t\t\tIntervalBetweenTargetsMsec: proto.Int32(1000),\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: 1 * time.Second,\n\t\t},\n\t\t{\n\t\t\tname: \"http probe\",\n\t\t\topts: &options.Options{\n\t\t\t\tInterval: 10 * time.Second,\n\t\t\t\tProbeConf: &httpconfigpb.ProbeConf{\n\t\t\t\t\tIntervalBetweenTargetsMsec: proto.Int32(2000),\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: 2 * time.Second,\n\t\t},\n\t\t{\n\t\t\tname: \"dns probe doesn't have interval between targets\",\n\t\t\topts: &options.Options{\n\t\t\t\tInterval:  10 * time.Second,\n\t\t\t\tProbeConf: &dnsconfigpb.ProbeConf{},\n\t\t\t},\n\t\t\twant: 500 * time.Millisecond,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ts := &Scheduler{\n\t\t\t\tOpts:    tt.opts,\n\t\t\t\ttargets: testTargets,\n\t\t\t}\n\t\t\tif got := s.gapBetweenTargets(); got != tt.want {\n\t\t\t\tt.Errorf(\"Scheduler.gapBetweenTargets() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}"
