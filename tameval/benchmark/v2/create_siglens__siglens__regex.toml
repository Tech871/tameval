[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.21.0"

[repo_info]
repository = "siglens/siglens"
sha = "536f72508926e48d734d15d40b1c66da22d7f8df"
bench_version = 2

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/regex/regex.go pkg/regex/regex_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/regex/regex.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 80.0
original_coverage = 80.0
mutation_kill_rate = 71.0
original_mutation_kill_rate = 71.0
covered_lines = [ 50, 59, 60, 61, 62, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 84, 85, 86, 87, 88, 89, 90, 91, 94, 95, 96, 99, 100, 101, 103, 106, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 127, 137, 138, 139, 141, 142, 144, 145, 152, 153, 154,]
missed_lines = [ 51, 52, 53, 55, 56, 57, 124, 125, 126, 129, 130, 131, 132, 133, 147, 148,]

[input_info]
test_file_path = "pkg/regex/regex_test.go"
focal_file_path = "pkg/regex/regex.go"
test_file_url = "https://github.com/siglens/siglens/blob/536f72508926e48d734d15d40b1c66da22d7f8df/pkg/regex/regex_test.go"
focal_file_url = "https://github.com/siglens/siglens/blob/536f72508926e48d734d15d40b1c66da22d7f8df/pkg/regex/regex.go"
first_commit_date = "2025-04-28"
last_commit_date = "2025-06-26"
test_file_content = "// Copyright (c) 2021-2025 SigScalr, Inc.\n//\n// This file is part of SigLens Observability Solution\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npackage regex\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_Match(t *testing.T) {\n\tassertMatches(t, `.*`, `abc`)\n\tassertMatches(t, `.*foo.*`, `abc`)\n\tassertMatches(t, `.*foo.*`, `foo`)\n\tassertMatches(t, `.*foo.*`, `abcfooxyz`)\n\tassertMatches(t, `foo.*`, `foobar`)\n\tassertMatches(t, `foo.*`, `abcfooxyz`)\n\tassertMatches(t, `^foo.*`, `abcfooxyz`)\n\tassertMatches(t, `^.*foo.*`, `abcfooxyz`)\n\tassertMatches(t, `(?i).*bar$`, `abcBaR`)\n\tassertMatches(t, `.*bar$`, `abcBaR`)\n\n\tassertMatches(t, `.*google.*`, \"visit\\nwww.google.com\")\n\tassertMatches(t, `(?i).*GOOGLE.*`, \"some\\ntext\\nGoogle\\nhere\")\n\tassertMatches(t, `.*foo.*`, \"line1\\nline2fooinfo\")\n\n\tassertMatches(t, `.*google.*`, \"My favorite search engine is google\")\n\tassertMatches(t, `.*google.*`, \"Google with different case\")\n\tassertMatches(t, `(?i).*google.*`, \"GOOGLE with case insensitivity\")\n\tassertMatches(t, `.*google.*`, \"My\\nfavorite\\nsearch\\nengine\\nis\\ngoogle\")\n\tassertMatches(t, `.*search.*google.*`, \"I want to search\\nusing google\")\n\tassertMatches(t, `.*google.*search.*`, \"Using google to\\nsearch the web\")\n\n}\n\nfunc assertMatches(t *testing.T, pattern string, str string) {\n\tt.Helper()\n\n\tregex, err := New(pattern)\n\tassert.NoError(t, err)\n\n\tactualRegex, err := regexp.Compile(pattern)\n\tassert.NoError(t, err)\n\tshouldMatch := actualRegex.Match([]byte(str))\n\n\tif shouldMatch {\n\t\tassert.True(t, regex.Match([]byte(str)), \"Pattern %s should match %s\", pattern, str)\n\t} else {\n\t\tassert.False(t, regex.Match([]byte(str)), \"Pattern %s should not match %s\", pattern, str)\n\t}\n}\n\nfunc Test_UsesOptimizedRegex(t *testing.T) {\n\tassertUsesOptimizedRegex(t, `.*`, false)\n\tassertUsesOptimizedRegex(t, `.*foo.*`, true)\n\tassertUsesOptimizedRegex(t, `foo.*`, true)\n\tassertUsesOptimizedRegex(t, `^foo.*`, true)\n\tassertUsesOptimizedRegex(t, `^.*foo.*`, true)\n\tassertUsesOptimizedRegex(t, `^.*foo$`, true)\n\tassertUsesOptimizedRegex(t, `^.*foo.*$`, true)\n\tassertUsesOptimizedRegex(t, `^foo$`, true)\n\tassertUsesOptimizedRegex(t, `(?i).*foo$`, true)\n\n\tassertUsesOptimizedRegex(t, `foo.*bar.*`, false) // TODO: maybe we'll want to handle this.\n\tassertUsesOptimizedRegex(t, `(.*foo.*|.*bar.*)`, false)\n\n}\nfunc Test_simpleRegex_Match(t *testing.T) {\n\ttests := []struct {\n\t\tname          string\n\t\tpattern       string\n\t\tinput         string\n\t\tshouldMatch   bool\n\t\tcaseSensitive bool\n\t}{\n\t\t{\n\t\t\tname:        \"exact match, case sensitive\",\n\t\t\tpattern:     \"foo\",\n\t\t\tinput:       \"foo\",\n\t\t\tshouldMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"exact match, case sensitive, mismatch\",\n\t\t\tpattern:     \"foo\",\n\t\t\tinput:       \"Foo\",\n\t\t\tshouldMatch: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"exact match, case insensitive\",\n\t\t\tpattern:     \"(?i)foo\",\n\t\t\tinput:       \"Foo\",\n\t\t\tshouldMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"wildcard before and after, contains\",\n\t\t\tpattern:     \".*bar.*\",\n\t\t\tinput:       \"xxbarxx\",\n\t\t\tshouldMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"wildcard before and after, does not contain\",\n\t\t\tpattern:     \".*bar.*\",\n\t\t\tinput:       \"baz\",\n\t\t\tshouldMatch: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"wildcard before only, ends with\",\n\t\t\tpattern:     \".*end\",\n\t\t\tinput:       \"theend\",\n\t\t\tshouldMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"case insensitive ends with\",\n\t\t\tpattern:     \"(?i).*BAR\",\n\t\t\tinput:       \"abcBaR\",\n\t\t\tshouldMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"case insensitive starts with\",\n\t\t\tpattern:     \"(?i)foo.*\",\n\t\t\tinput:       \"FOObar\",\n\t\t\tshouldMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"exact match, case insensitive\",\n\t\t\tpattern:     \"(?i)foo\",\n\t\t\tinput:       \"fOo\",\n\t\t\tshouldMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"exact match, case insensitive, mismatch\",\n\t\t\tpattern:     \"(?i)foo\",\n\t\t\tinput:       \"bar\",\n\t\t\tshouldMatch: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"wildcard before and after, case insensitive, does not contain\",\n\t\t\tpattern:     \"(?i).*bar.*\",\n\t\t\tinput:       \"baz\",\n\t\t\tshouldMatch: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"pattern with allowed special chars\",\n\t\t\tpattern:     \"foo-bar_123:/\",\n\t\t\tinput:       \"foo-bar_123:/\",\n\t\t\tshouldMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"pattern with allowed special chars, mismatch\",\n\t\t\tpattern:     \"foo-bar_123:/\",\n\t\t\tinput:       \"foo-bar_123\",\n\t\t\tshouldMatch: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"multiline text with wildcard match\",\n\t\t\tpattern:     `.*google.*`,\n\t\t\tinput:       `watching\\nhttps://google.com`,\n\t\t\tshouldMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"multiline text with case insensitive wildcard match\",\n\t\t\tpattern:     `(?i).*GOOGLE.*`,\n\t\t\tinput:       `watching\\nhttps://google.com/search`,\n\t\t\tshouldMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"multiline text with no match\",\n\t\t\tpattern:     `.*bing.*`,\n\t\t\tinput:       `watching\\nhttps://google.com`,\n\t\t\tshouldMatch: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"multiline text with start anchor\",\n\t\t\tpattern:     `^watching.*`,\n\t\t\tinput:       `watching\\nhttps://google.com`,\n\t\t\tshouldMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"multiline text with end anchor\",\n\t\t\tpattern:     `.*com$`,\n\t\t\tinput:       `watching\\nhttps://google.com`,\n\t\t\tshouldMatch: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"multiline text spanning multiple lines\",\n\t\t\tpattern:     `.*watching.*com.*`,\n\t\t\tinput:       `user is watching\\nhttps://google.com\\nright now`,\n\t\t\tshouldMatch: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tmatched := regexp.MustCompile(tt.pattern).MatchString(tt.input)\n\t\t\tif matched != tt.shouldMatch {\n\t\t\t\tt.Errorf(\"expected match: %v, got: %v\", tt.shouldMatch, matched)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_containsSingleDotWildcard(t *testing.T) {\n\ttests := []struct {\n\t\tpattern string\n\t\twant    bool\n\t}{\n\t\t{`foo.bar`, true},\n\t\t{`foo.*bar`, false},\n\t\t{`foo\\.bar`, false},   // Escaped dot\n\t\t{`foo\\\\.bar`, true},   // Escaped backslash followed by dot\n\t\t{`foo\\\\\\.bar`, false}, // Escaped backslash followed by escaped dot\n\t\t{`foo.bar.*`, true},\n\t\t{`foo.*`, false},\n\t\t{`foo`, false},\n\t\t{`foo\\.*bar`, false},\n\t\t{`foo.*bar.*baz`, false},\n\t\t{`foo.bar.baz`, true},\n\t\t{`foo\\..*bar`, false},\n\t\t{`foo\\\\\\\\.bar`, true},   // Two escaped backslashes followed by dot\n\t\t{`foo\\\\\\\\\\.bar`, false}, // Two escaped backslashes followed by escaped dot\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.pattern, func(t *testing.T) {\n\t\t\tgot := containsSingleDotWildcard(tt.pattern)\n\t\t\tassert.Equal(t, tt.want, got, \"Pattern: %s\", tt.pattern)\n\t\t})\n\t}\n}\n\nfunc Test_simpleRegex_String(t *testing.T) {\n\treg, err := New(\"foo.*\")\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"foo.*\", reg.String())\n}\nfunc assertUsesOptimizedRegex(t *testing.T, pattern string, expected bool) {\n\tt.Helper()\n\n\tregex, err := New(pattern)\n\tassert.NoError(t, err)\n\n\t_, ok := regex.(*simpleRegex)\n\tif expected {\n\t\tassert.True(t, ok, \"Pattern %s should use optimized regex\", pattern)\n\t} else {\n\t\tassert.False(t, ok, \"Pattern %s should not use optimized regex\", pattern)\n\t}\n}\n"
