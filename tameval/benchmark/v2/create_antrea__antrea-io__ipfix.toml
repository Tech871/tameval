[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "antrea-io/antrea"
sha = "0cd2eed3cc54448553096bf4e6ee74836c9c1d11"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/flowaggregator/exporter/ipfix.go pkg/flowaggregator/exporter/ipfix_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/flowaggregator/exporter/ipfix.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 25.0
original_coverage = 62.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = [ 120, 121, 122, 123, 124, 125, 127, 164, 171, 172, 173, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 284, 286, 287, 291, 293, 294, 298, 300, 301, 302, 303, 304, 305, 306, 310, 311, 312, 313, 317, 319, 320, 324, 326, 327, 328, 329, 333, 334, 335, 336, 340, 341, 342, 343, 347, 350, 351, 355, 357, 361, 371, 372, 373, 374, 377, 378, 382, 386,]
missed_lines = [ 38, 39, 40, 62, 63, 64, 65, 66, 67, 73, 74, 75, 76, 77, 78, 79, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 105, 106, 107, 108, 110, 111, 112, 113, 114, 115, 116, 129, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 165, 166, 167, 168, 169, 174, 175, 178, 179, 180, 182, 183, 184, 185, 186, 187, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 245, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 281, 282, 283, 288, 289, 290, 295, 296, 297, 307, 308, 309, 314, 315, 316, 321, 322, 323, 330, 331, 332, 337, 338, 339, 344, 345, 346, 352, 353, 354, 358, 359, 360, 362, 363, 364, 365, 366, 367, 368, 379, 380, 381, 383, 384, 385, 389, 390, 391, 392, 393,]

[input_info]
test_file_path = "pkg/flowaggregator/exporter/ipfix_test.go"
focal_file_path = "pkg/flowaggregator/exporter/ipfix.go"
test_file_url = "https://github.com/antrea-io/antrea/blob/0cd2eed3cc54448553096bf4e6ee74836c9c1d11/pkg/flowaggregator/exporter/ipfix_test.go"
focal_file_url = "https://github.com/antrea-io/antrea/blob/0cd2eed3cc54448553096bf4e6ee74836c9c1d11/pkg/flowaggregator/exporter/ipfix.go"
first_commit_date = "2022-08-17"
last_commit_date = "2025-02-21"
test_file_content = "// Copyright 2022 Antrea Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage exporter\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\tipfixentities \"github.com/vmware/go-ipfix/pkg/entities\"\n\tipfixentitiestesting \"github.com/vmware/go-ipfix/pkg/entities/testing\"\n\tipfixregistry \"github.com/vmware/go-ipfix/pkg/registry\"\n\t\"go.uber.org/mock/gomock\"\n\n\tflowaggregatorconfig \"antrea.io/antrea/pkg/config/flowaggregator\"\n\t\"antrea.io/antrea/pkg/flowaggregator/infoelements\"\n\tipfixtesting \"antrea.io/antrea/pkg/ipfix/testing\"\n)\n\nconst (\n\ttestTemplateIDv4        = uint16(256)\n\ttestTemplateIDv6        = uint16(257)\n\ttestObservationDomainID = 0xabcd\n)\n\nfunc init() {\n\tipfixregistry.LoadRegistry()\n}\n\nfunc createElement(name string, enterpriseID uint32) ipfixentities.InfoElementWithValue {\n\telement, _ := ipfixregistry.GetInfoElement(name, enterpriseID)\n\tieWithValue, _ := ipfixentities.DecodeAndCreateInfoElementWithValue(element, nil)\n\treturn ieWithValue\n}\n\nfunc TestIPFIXExporter_sendTemplateSet(t *testing.T) {\n\trunTest := func(t *testing.T, isIPv6 bool) {\n\t\tctrl := gomock.NewController(t)\n\n\t\tmockIPFIXBufferedExp := ipfixtesting.NewMockIPFIXBufferedExporter(ctrl)\n\t\tmockIPFIXRegistry := ipfixtesting.NewMockIPFIXRegistry(ctrl)\n\n\t\texporter := &IPFIXExporter{\n\t\t\texternalFlowCollectorAddr:  \"\",\n\t\t\texternalFlowCollectorProto: \"\",\n\t\t\tbufferedExporter:           mockIPFIXBufferedExp,\n\t\t\ttemplateIDv4:               testTemplateIDv4,\n\t\t\ttemplateIDv6:               testTemplateIDv6,\n\t\t\tregistry:                   mockIPFIXRegistry,\n\t\t\taggregatorMode:             flowaggregatorconfig.AggregatorModeAggregate,\n\t\t\tobservationDomainID:        testObservationDomainID,\n\t\t}\n\t\telemList := createElementList(isIPv6, mockIPFIXRegistry)\n\t\ttestTemplateID := exporter.templateIDv4\n\t\tif isIPv6 {\n\t\t\ttestTemplateID = exporter.templateIDv6\n\t\t}\n\t\tmockIPFIXBufferedExp.EXPECT().AddRecord(gomock.Cond(func(record ipfixentities.Record) bool {\n\t\t\treturn record.GetTemplateID() == testTemplateID && reflect.DeepEqual(record.GetOrderedElementList(), elemList)\n\t\t})).Return(nil)\n\n\t\tassert.NoErrorf(t, exporter.sendTemplateSet(isIPv6), \"Error when sending template record\")\n\t}\n\n\tt.Run(\"IPv4\", func(t *testing.T) { runTest(t, false) })\n\tt.Run(\"IPv6\", func(t *testing.T) { runTest(t, true) })\n}\n\n\n\n\nfunc TestIPFIXExporter_sendRecord_Error(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\n\tmockIPFIXExpProc := ipfixtesting.NewMockIPFIXExportingProcess(ctrl)\n\tmockIPFIXBufferedExp := ipfixtesting.NewMockIPFIXBufferedExporter(ctrl)\n\tmockRecord := ipfixentitiestesting.NewMockRecord(ctrl)\n\n\tipfixExporter := &IPFIXExporter{\n\t\texternalFlowCollectorAddr:  \"\",\n\t\texternalFlowCollectorProto: \"\",\n\t\texportingProcess:           mockIPFIXExpProc,\n\t\tbufferedExporter:           mockIPFIXBufferedExp,\n\t\ttemplateIDv4:               testTemplateIDv4,\n\t\ttemplateIDv6:               testTemplateIDv6,\n\t\taggregatorMode:             flowaggregatorconfig.AggregatorModeAggregate,\n\t\tobservationDomainID:        testObservationDomainID,\n\t}\n\n\tmockIPFIXBufferedExp.EXPECT().AddRecord(mockRecord).Return(fmt.Errorf(\"send error\"))\n\tmockIPFIXExpProc.EXPECT().CloseConnToCollector()\n\n\tassert.Error(t, ipfixExporter.AddRecord(mockRecord, false))\n}\n\nfunc createElementList(isIPv6 bool, mockIPFIXRegistry *ipfixtesting.MockIPFIXRegistry) []ipfixentities.InfoElementWithValue {\n\tianaInfoElements := infoelements.IANAInfoElementsIPv4\n\tantreaInfoElements := infoelements.AntreaInfoElementsIPv4\n\tif isIPv6 {\n\t\tianaInfoElements = infoelements.IANAInfoElementsIPv6\n\t\tantreaInfoElements = infoelements.AntreaInfoElementsIPv6\n\t}\n\t// Following consists of all elements that are in ianaInfoElements and antreaInfoElements (globals)\n\t// Only the element name is needed, other arguments have dummy values\n\telemList := make([]ipfixentities.InfoElementWithValue, 0)\n\tfor _, ie := range ianaInfoElements {\n\t\telemList = append(elemList, createElement(ie, ipfixregistry.IANAEnterpriseID))\n\t\tmockIPFIXRegistry.EXPECT().GetInfoElement(ie, ipfixregistry.IANAEnterpriseID).Return(elemList[len(elemList)-1].GetInfoElement(), nil)\n\t}\n\tfor _, ie := range infoelements.IANAReverseInfoElements {\n\t\telemList = append(elemList, createElement(ie, ipfixregistry.IANAReversedEnterpriseID))\n\t\tmockIPFIXRegistry.EXPECT().GetInfoElement(ie, ipfixregistry.IANAReversedEnterpriseID).Return(elemList[len(elemList)-1].GetInfoElement(), nil)\n\t}\n\tfor _, ie := range antreaInfoElements {\n\t\telemList = append(elemList, createElement(ie, ipfixregistry.AntreaEnterpriseID))\n\t\tmockIPFIXRegistry.EXPECT().GetInfoElement(ie, ipfixregistry.AntreaEnterpriseID).Return(elemList[len(elemList)-1].GetInfoElement(), nil)\n\t}\n\tfor i := range infoelements.StatsElementList {\n\t\telemList = append(elemList, createElement(infoelements.AntreaSourceStatsElementList[i], ipfixregistry.AntreaEnterpriseID))\n\t\tmockIPFIXRegistry.EXPECT().GetInfoElement(infoelements.AntreaSourceStatsElementList[i], ipfixregistry.AntreaEnterpriseID).Return(elemList[len(elemList)-1].GetInfoElement(), nil)\n\t\telemList = append(elemList, createElement(infoelements.AntreaDestinationStatsElementList[i], ipfixregistry.AntreaEnterpriseID))\n\t\tmockIPFIXRegistry.EXPECT().GetInfoElement(infoelements.AntreaDestinationStatsElementList[i], ipfixregistry.AntreaEnterpriseID).Return(elemList[len(elemList)-1].GetInfoElement(), nil)\n\t}\n\tfor _, ie := range infoelements.AntreaFlowEndSecondsElementList {\n\t\telemList = append(elemList, createElement(ie, ipfixregistry.AntreaEnterpriseID))\n\t\tmockIPFIXRegistry.EXPECT().GetInfoElement(ie, ipfixregistry.AntreaEnterpriseID).Return(elemList[len(elemList)-1].GetInfoElement(), nil)\n\t}\n\tfor i := range infoelements.AntreaThroughputElementList {\n\t\telemList = append(elemList, createElement(infoelements.AntreaThroughputElementList[i], ipfixregistry.AntreaEnterpriseID))\n\t\tmockIPFIXRegistry.EXPECT().GetInfoElement(infoelements.AntreaThroughputElementList[i], ipfixregistry.AntreaEnterpriseID).Return(elemList[len(elemList)-1].GetInfoElement(), nil)\n\t\telemList = append(elemList, createElement(infoelements.AntreaSourceThroughputElementList[i], ipfixregistry.AntreaEnterpriseID))\n\t\tmockIPFIXRegistry.EXPECT().GetInfoElement(infoelements.AntreaSourceThroughputElementList[i], ipfixregistry.AntreaEnterpriseID).Return(elemList[len(elemList)-1].GetInfoElement(), nil)\n\t\telemList = append(elemList, createElement(infoelements.AntreaDestinationThroughputElementList[i], ipfixregistry.AntreaEnterpriseID))\n\t\tmockIPFIXRegistry.EXPECT().GetInfoElement(infoelements.AntreaDestinationThroughputElementList[i], ipfixregistry.AntreaEnterpriseID).Return(elemList[len(elemList)-1].GetInfoElement(), nil)\n\t}\n\tfor _, ie := range infoelements.AntreaLabelsElementList {\n\t\telemList = append(elemList, createElement(ie, ipfixregistry.AntreaEnterpriseID))\n\t\tmockIPFIXRegistry.EXPECT().GetInfoElement(ie, ipfixregistry.AntreaEnterpriseID).Return(elemList[len(elemList)-1].GetInfoElement(), nil)\n\t}\n\telemList = append(elemList, createElement(\"clusterId\", ipfixregistry.AntreaEnterpriseID))\n\tmockIPFIXRegistry.EXPECT().GetInfoElement(\"clusterId\", ipfixregistry.AntreaEnterpriseID).Return(elemList[len(elemList)-1].GetInfoElement(), nil)\n\n\treturn elemList\n}\n"
