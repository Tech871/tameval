[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Python"
python_version = "3.13"
python_cfg_file = "pyproject.toml"

[repo_info]
repository = "mdabrowski1990/uds"
sha = "81ca93afdc4ac9e386bbdebaf44ab0ac9cc22941"

[run_info]
docker_image = "python:3.13"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -e PATH=_HOME_/.local/bin:$PATH -e PYTHONUSERBASE=_HOME_/.local/ -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = [ "PATH=_HOME_/.local/bin:$PATH", "PYTHONUSERBASE=_HOME_/.local/",]
prebuild_command = "pip install -r requirements.txt && (pip install .[all,test] && pip install git+https://github.com/Klema17/mutpy.git && pip install coverage pytest pytest_cov covdefaults Cython mock ddt pytest_mock testfixtures)"
test_run_command = "coverage run --include=uds/can/packet/consecutive_frame.py -m pytest -q --junit-xml=test_output.xml tests/software_tests/can/packet/test_consecutive_frame.py && coverage xml -o coverage.xml --fail-under=0"
mutation_run_command = "mut.py --target uds.can.packet.consecutive_frame --unit-test tests.software_tests.can.packet.test_consecutive_frame --runner pytest --report mutation_report.yaml"
mutation_run_command_fallback = "mut.py --target uds/can/packet/consecutive_frame.py --unit-test tests/software_tests/can/packet/test_consecutive_frame.py --runner pytest --report mutation_report.yaml"
coverage_report_path = "coverage.xml"
coverage_report_type = "cobertura"
mutation_report_path = "mutation_report.yaml"
mutation_report_type = "mutpy"

[coverage]
coverage = 85.0
original_coverage = 100.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = [ 2, 8, 10, 18, 19, 21, 22, 24, 25, 28, 45, 55, 56, 58, 59, 60, 61, 64, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 119, 122, 151, 152, 153, 154, 157, 158, 159, 160, 162, 163, 166, 185, 186, 189, 201, 203, 204, 205, 206, 211, 225, 226, 229, 230, 231, 234, 237, 254,]
missed_lines = [ 41, 42, 57, 202, 208, 228, 232, 250, 251, 262, 263,]

[input_info]
test_file_path = "tests/software_tests/can/packet/test_consecutive_frame.py"
focal_file_path = "uds/can/packet/consecutive_frame.py"
test_file_url = "https://github.com/mdabrowski1990/uds/blob/81ca93afdc4ac9e386bbdebaf44ab0ac9cc22941/tests/software_tests/can/packet/test_consecutive_frame.py"
focal_file_url = "https://github.com/mdabrowski1990/uds/blob/81ca93afdc4ac9e386bbdebaf44ab0ac9cc22941/uds/can/packet/consecutive_frame.py"
first_commit_date = "2025-07-29"
last_commit_date = "2025-07-29"
test_file_content = "import pytest\nfrom mock import MagicMock, Mock, patch\n\nfrom uds.can.packet.consecutive_frame import (\n    CONSECUTIVE_FRAME_N_PCI,\n    DEFAULT_FILLER_BYTE,\n    SN_BYTES_USED,\n    CanAddressingFormat,\n    CanDlcHandler,\n    InconsistentArgumentsError,\n    create_consecutive_frame_data,\n    encode_sequence_number,\n    extract_consecutive_frame_payload,\n    extract_sequence_number,\n    generate_consecutive_frame_data,\n    get_consecutive_frame_max_payload_size,\n    get_consecutive_frame_min_dlc,\n    is_consecutive_frame,\n    validate_consecutive_frame_data,\n)\n\nSCRIPT_LOCATION = \"uds.can.packet.consecutive_frame\"\n\nclass TestCanConsecutiveFrame:\n    \"\"\"Unit tests for functions in CAN Consecutive Frame module.\"\"\"\n\n    def setup_method(self):\n        self._patcher_validate_nibble = patch(f\"{SCRIPT_LOCATION}.validate_nibble\")\n        self.mock_validate_nibble = self._patcher_validate_nibble.start()\n        self._patcher_validate_raw_byte = patch(f\"{SCRIPT_LOCATION}.validate_raw_byte\")\n        self.mock_validate_raw_byte = self._patcher_validate_raw_byte.start()\n        self._patcher_validate_raw_bytes = patch(f\"{SCRIPT_LOCATION}.validate_raw_bytes\")\n        self.mock_validate_raw_bytes = self._patcher_validate_raw_bytes.start()\n        self._patcher_can_dlc_handler = patch(f\"{SCRIPT_LOCATION}.CanDlcHandler\",\n                                              Mock(MAX_DATA_BYTES_NUMBER=CanDlcHandler.MAX_DATA_BYTES_NUMBER,\n                                                   MIN_BASE_UDS_DLC=CanDlcHandler.MIN_BASE_UDS_DLC))\n        self.mock_can_dlc_handler = self._patcher_can_dlc_handler.start()\n        self._patcher_can_addressing_information = patch(f\"{SCRIPT_LOCATION}.CanAddressingInformation\")\n        self.mock_can_addressing_information = self._patcher_can_addressing_information.start()\n\n    def teardown_method(self):\n        self._patcher_validate_nibble.stop()\n        self._patcher_validate_raw_byte.stop()\n        self._patcher_validate_raw_bytes.stop()\n        self._patcher_can_dlc_handler.stop()\n        self._patcher_can_addressing_information.stop()\n\n    # is_consecutive_frame\n\n    # validate_consecutive_frame_data\n\n    @pytest.mark.parametrize(\"addressing_format, raw_frame_data, decoded_dlc, min_dlc\", [\n        (Mock(), MagicMock(), 4, 5),\n        (CanAddressingFormat.NORMAL_ADDRESSING, range(8), 1, 2),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.get_consecutive_frame_min_dlc\")\n    @patch(f\"{SCRIPT_LOCATION}.is_consecutive_frame\")\n    def test_validate_consecutive_frame_data__inconsistent(self, mock_is_consecutive_frame,\n                                                           mock_get_consecutive_frame_min_dlc,\n                                                           addressing_format, raw_frame_data,\n                                                           decoded_dlc, min_dlc):\n        mock_is_consecutive_frame.return_value = True\n        mock_get_consecutive_frame_min_dlc.return_value = min_dlc\n        self.mock_can_dlc_handler.encode_dlc.return_value = decoded_dlc\n        with pytest.raises(InconsistentArgumentsError):\n            validate_consecutive_frame_data(addressing_format=addressing_format,\n                                            raw_frame_data=raw_frame_data)\n        mock_is_consecutive_frame.assert_called_once_with(addressing_format=addressing_format,\n                                                          raw_frame_data=raw_frame_data)\n        mock_get_consecutive_frame_min_dlc.assert_called_once_with(addressing_format)\n        self.mock_can_dlc_handler.encode_dlc.assert_called_once_with(len(raw_frame_data))\n\n    # create_consecutive_frame_data\n\n    @pytest.mark.parametrize(\"addressing_format, payload, sequence_number, ai_data_bytes, sn_bytes\", [\n        (Mock(), [0x0F, 0x1E, 0x2D, 0x3C, 0x4B, 0x5A, 0x69, 0x78], 0, bytearray(), bytearray([0x20])),\n        (Mock(), [0x5A], 0xF, bytearray([0xD0]), bytearray([0x2F])),\n        (CanAddressingFormat.NORMAL_ADDRESSING, tuple(range(62)), 0x5, bytearray([0xC2]), bytearray([0xBD])),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.get_consecutive_frame_min_dlc\")\n    @patch(f\"{SCRIPT_LOCATION}.encode_sequence_number\")\n    def test_create_consecutive_frame_data__valid_mandatory_args(self, mock_encode_sequence_number,\n                                                                 mock_get_consecutive_frame_min_dlc,\n                                                                 addressing_format, payload, sequence_number,\n                                                                 ai_data_bytes, sn_bytes):\n        expected_output = ai_data_bytes + sn_bytes + bytearray(payload)\n        self.mock_can_addressing_information.encode_ai_data_bytes.return_value = ai_data_bytes\n        self.mock_can_dlc_handler.decode_dlc.return_value = len(expected_output)\n        mock_encode_sequence_number.return_value = sn_bytes\n        assert create_consecutive_frame_data(addressing_format=addressing_format,\n                                             payload=payload,\n                                             sequence_number=sequence_number) == expected_output\n        mock_get_consecutive_frame_min_dlc.assert_called_once_with(addressing_format=addressing_format,\n                                                                   payload_length=len(payload))\n        self.mock_can_addressing_information.encode_ai_data_bytes.assert_called_once_with(\n            addressing_format=addressing_format,\n            target_address=None,\n            address_extension=None)\n        self.mock_can_dlc_handler.decode_dlc.assert_called_once_with(mock_get_consecutive_frame_min_dlc.return_value)\n\n    @pytest.mark.parametrize(\"addressing_format, payload, sequence_number, dlc, filler_byte, target_address, \"\n                             \"address_extension, ai_data_bytes, sn_bytes, data_bytes_number\", [\n        (Mock(), [0x0F, 0x1E, 0x2D, 0x3C], 0, 6, 0xAA, 0xBA, 0xC9, bytearray([0xC9]), bytearray([0x20]), 6),\n        (Mock(), [0xE9], 0xF, 2, 0xAA, 0x55, 0xAA, bytearray(), bytearray([0x2F]), 2),\n        (CanAddressingFormat.NORMAL_ADDRESSING, tuple(range(20)), 0x5, 0xF, 0x3C, 0x60, 0x71, bytearray([0xC2]),\n         bytearray([0xBD]), 48),\n        (CanAddressingFormat.MIXED_29BIT_ADDRESSING, bytearray(range(100, 182, 2)), 0x7, 0xF, 0x13, Mock(), Mock(),\n         bytearray([0xFE]), bytearray([0x27]), 64),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.get_consecutive_frame_min_dlc\")\n    @patch(f\"{SCRIPT_LOCATION}.encode_sequence_number\")\n    def test_create_consecutive_frame_data__valid_all_args(self, mock_encode_sequence_number,\n                                                           mock_get_consecutive_frame_min_dlc,\n                                                           addressing_format, payload, sequence_number, dlc,\n                                                           filler_byte, target_address, address_extension,\n                                                           ai_data_bytes, sn_bytes, data_bytes_number):\n        self.mock_can_addressing_information.encode_ai_data_bytes.return_value = ai_data_bytes\n        self.mock_can_dlc_handler.decode_dlc.return_value = data_bytes_number\n        mock_encode_sequence_number.return_value = sn_bytes\n        expected_output = ai_data_bytes + sn_bytes + bytearray(payload)\n        while len(expected_output) < data_bytes_number:\n            expected_output.append(filler_byte)\n        assert create_consecutive_frame_data(addressing_format=addressing_format,\n                                             payload=payload,\n                                             sequence_number=sequence_number,\n                                             dlc=dlc,\n                                             filler_byte=filler_byte,\n                                             target_address=target_address,\n                                             address_extension=address_extension) == expected_output\n        mock_get_consecutive_frame_min_dlc.assert_not_called()\n        self.mock_can_addressing_information.encode_ai_data_bytes.assert_called_once_with(\n            addressing_format=addressing_format,\n            target_address=target_address,\n            address_extension=address_extension)\n        self.mock_can_dlc_handler.decode_dlc.assert_called_once_with(dlc)\n\n    @pytest.mark.parametrize(\"addressing_format, payload, sequence_number, dlc, filler_byte, target_address, \"\n                             \"address_extension, ai_data_bytes, sn_bytes, data_bytes_number\", [\n        (Mock(), [0xE9], 0xF, CanDlcHandler.MIN_BASE_UDS_DLC - 1, 0xAA, Mock(), Mock(), bytearray(), bytearray([0x2F]), 8),\n        (CanAddressingFormat.NORMAL_ADDRESSING, tuple(range(63)), 0x0, 0xF, 0x3C, 0x60, 0x71, bytearray([0xC2]),\n         bytearray([0xBD]), 64),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.get_consecutive_frame_min_dlc\")\n    @patch(f\"{SCRIPT_LOCATION}.encode_sequence_number\")\n    def test_create_consecutive_frame_data__inconsistent(self, mock_encode_sequence_number,\n                                                           mock_get_consecutive_frame_min_dlc,\n                                                           addressing_format, payload, sequence_number, dlc,\n                                                           filler_byte, target_address, address_extension,\n                                                           ai_data_bytes, sn_bytes, data_bytes_number):\n        self.mock_can_addressing_information.encode_ai_data_bytes.return_value = ai_data_bytes\n        self.mock_can_dlc_handler.decode_dlc.return_value = data_bytes_number\n        mock_encode_sequence_number.return_value = sn_bytes\n        with pytest.raises(InconsistentArgumentsError):\n            create_consecutive_frame_data(addressing_format=addressing_format,\n                                          payload=payload,\n                                          sequence_number=sequence_number,\n                                          dlc=dlc,\n                                          filler_byte=filler_byte,\n                                          target_address=target_address,\n                                          address_extension=address_extension)\n        mock_get_consecutive_frame_min_dlc.assert_not_called()\n        self.mock_can_addressing_information.encode_ai_data_bytes.assert_called_once_with(\n            addressing_format=addressing_format,\n            target_address=target_address,\n            address_extension=address_extension)\n        self.mock_can_dlc_handler.decode_dlc.assert_called_once_with(dlc)\n\n    # generate_consecutive_frame_data\n\n    @pytest.mark.parametrize(\"addressing_format, payload, sequence_number, dlc, ai_data_bytes, sn_bytes, \"\n                             \"data_bytes_number\", [\n        (Mock(), [0x0F, 0x1E, 0x2D, 0x3C, 0x4B, 0x5A, 0x69, 0x78], 5, CanDlcHandler.MIN_BASE_UDS_DLC - 1, bytearray(),\n         bytearray([0x20]), 12),\n        (Mock(), [], 0x0, 1, bytearray(), bytearray([0x2F]), 1),\n        (CanAddressingFormat.NORMAL_ADDRESSING, (0xF5, 0x6E), 0xF, CanDlcHandler.MIN_BASE_UDS_DLC - 2,\n         bytearray([0xC2]), bytearray([0x2D]), 6),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.encode_sequence_number\")\n    def test_generate_consecutive_frame_data__valid_mandatory_args(self, mock_encode_sequence_number,\n                                                                 addressing_format, payload, sequence_number, dlc,\n                                                                 ai_data_bytes, sn_bytes, data_bytes_number):\n\n        self.mock_can_addressing_information.encode_ai_data_bytes.return_value = ai_data_bytes\n        self.mock_can_dlc_handler.decode_dlc.return_value = data_bytes_number\n        mock_encode_sequence_number.return_value = sn_bytes\n        expected_output = ai_data_bytes + sn_bytes + bytearray(payload)\n        while len(expected_output) < data_bytes_number:\n            expected_output.append(DEFAULT_FILLER_BYTE)\n        assert generate_consecutive_frame_data(addressing_format=addressing_format,\n                                               payload=payload,\n                                               sequence_number=sequence_number,\n                                               dlc=dlc) == expected_output\n        self.mock_can_addressing_information.encode_ai_data_bytes.assert_called_once_with(\n            addressing_format=addressing_format,\n            target_address=None,\n            address_extension=None)\n        self.mock_can_dlc_handler.decode_dlc.assert_called_once_with(dlc)\n\n    @pytest.mark.parametrize(\"addressing_format, payload, sequence_number, dlc, filler_byte, target_address, \"\n                             \"address_extension, ai_data_bytes, sn_bytes, data_bytes_number\", [\n        (Mock(), [0x0F, 0x1E, 0x2D, 0x3C, 0x4B, 0x5A, 0x69, 0x78], 5, CanDlcHandler.MIN_BASE_UDS_DLC - 1, 0x5A,\n         Mock(), Mock(), bytearray(), bytearray([0x20]), 12),\n        (Mock(), [], 0x0, 1, 0xFF, 0x21, 0x31, bytearray(), bytearray([0x2F]), 1),\n        (CanAddressingFormat.NORMAL_ADDRESSING, (0xF5, 0x6E), 0xF, CanDlcHandler.MIN_BASE_UDS_DLC - 2, 0xC3, 0xD2, 0x2D,\n         bytearray([0xC2]), bytearray([0x2D]), 6),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.encode_sequence_number\")\n    def test_generate_consecutive_frame_data__valid_all_args(self, mock_encode_sequence_number,\n                                                             addressing_format, payload, sequence_number, dlc,\n                                                             filler_byte, target_address, address_extension,\n                                                             ai_data_bytes, sn_bytes, data_bytes_number):\n\n        self.mock_can_addressing_information.encode_ai_data_bytes.return_value = ai_data_bytes\n        self.mock_can_dlc_handler.decode_dlc.return_value = data_bytes_number\n        mock_encode_sequence_number.return_value = sn_bytes\n        expected_output = ai_data_bytes + sn_bytes + bytearray(payload)\n        while len(expected_output) < data_bytes_number:\n            expected_output.append(filler_byte)\n        assert generate_consecutive_frame_data(addressing_format=addressing_format,\n                                               payload=payload,\n                                               sequence_number=sequence_number,\n                                               dlc=dlc,\n                                               filler_byte=filler_byte,\n                                               target_address=target_address,\n                                               address_extension=address_extension) == expected_output\n        self.mock_can_addressing_information.encode_ai_data_bytes.assert_called_once_with(\n            addressing_format=addressing_format,\n            target_address=target_address,\n            address_extension=address_extension)\n        self.mock_can_dlc_handler.decode_dlc.assert_called_once_with(dlc)\n\n    @pytest.mark.parametrize(\"addressing_format, payload, sequence_number, dlc, filler_byte, target_address, \"\n                             \"address_extension, ai_data_bytes, sn_bytes, data_bytes_number\", [\n        (Mock(), [0x0F, 0x1E, 0x2D, 0x3C, 0x4B, 0x5A, 0x69, 0x78], 5, CanDlcHandler.MIN_BASE_UDS_DLC - 1, 0x5A,\n         Mock(), Mock(), bytearray(), bytearray([0x20]), 8),\n        (Mock(), [], 0x0, 1, 0xFF, 0x21, 0x31, bytearray(), bytearray([0x2F]), 0),\n        (CanAddressingFormat.NORMAL_ADDRESSING, (0xF5, 0x6E), 0xF, CanDlcHandler.MIN_BASE_UDS_DLC - 2, 0xC3, 0xD2, 0x2D,\n         bytearray([0xC2]), bytearray([0x2D]), 2),\n    ])\n    @patch(f\"{SCRIPT_LOCATION}.encode_sequence_number\")\n    def test_generate_consecutive_frame_data__inconsistent(self, mock_encode_sequence_number,\n                                                             addressing_format, payload, sequence_number, dlc,\n                                                             filler_byte, target_address, address_extension,\n                                                             ai_data_bytes, sn_bytes, data_bytes_number):\n        self.mock_can_addressing_information.encode_ai_data_bytes.return_value = ai_data_bytes\n        self.mock_can_dlc_handler.decode_dlc.return_value = data_bytes_number\n        mock_encode_sequence_number.return_value = sn_bytes\n        with pytest.raises(InconsistentArgumentsError):\n            generate_consecutive_frame_data(addressing_format=addressing_format,\n                                            payload=payload,\n                                            sequence_number=sequence_number,\n                                            dlc=dlc,\n                                            filler_byte=filler_byte,\n                                            target_address=target_address,\n                                            address_extension=address_extension)\n        self.mock_can_addressing_information.encode_ai_data_bytes.assert_called_once_with(\n            addressing_format=addressing_format,\n            target_address=target_address,\n            address_extension=address_extension)\n        self.mock_can_dlc_handler.decode_dlc.assert_called_once_with(dlc)\n\n    # extract_consecutive_frame_payload\n\n    @pytest.mark.parametrize(\"addressing_format, raw_frame_data, ai_bytes_number\", [\n        (Mock(), [0x2F, *range(63)], 0),\n        (Mock(), bytearray([0xFF, 0x20, 0x0F, 0x1E, 0x2D, 0x3C, 0x4B, 0x5A, 0x69, 0x78, 0x87, 0x96, 0xA5, 0xB4]), 1),\n    ])\n    def test_extract_consecutive_frame_payload(self, addressing_format, raw_frame_data,\n                                              ai_bytes_number):\n        self.mock_can_addressing_information.get_ai_data_bytes_number.return_value = ai_bytes_number\n        assert (extract_consecutive_frame_payload(addressing_format=addressing_format, raw_frame_data=raw_frame_data)\n                == bytearray(raw_frame_data)[ai_bytes_number+SN_BYTES_USED:])\n        self.mock_can_addressing_information.get_ai_data_bytes_number.assert_called_once_with(addressing_format)\n\n    # get_consecutive_frame_min_dlc\n\n    @pytest.mark.parametrize(\"addressing_format, payload_length, ai_data_bytes_number\", [\n        (Mock(), 0, 1),\n        (CanAddressingFormat.MIXED_29BIT_ADDRESSING, 63, 1),\n        (CanAddressingFormat.NORMAL_ADDRESSING, 64, 0),\n    ])\n    def test_get_min_consecutive_frame_dlc__value_error(self, addressing_format, payload_length, ai_data_bytes_number):\n        self.mock_can_addressing_information.get_ai_data_bytes_number.return_value = ai_data_bytes_number\n        with pytest.raises(ValueError):\n            get_consecutive_frame_min_dlc(addressing_format=addressing_format, payload_length=payload_length)\n        self.mock_can_addressing_information.get_ai_data_bytes_number.assert_called_once_with(addressing_format)\n        self.mock_can_dlc_handler.get_min_dlc.assert_not_called()\n\n    # get_consecutive_frame_max_payload_size\n\n    @pytest.mark.parametrize(\"addressing_format, dlc, ai_data_bytes_number, data_bytes_number\", [\n        (Mock(), Mock(), 1, 3),\n        (Mock(), Mock(), 0, 2),\n        (CanAddressingFormat.NORMAL_ADDRESSING, 2, 0, 2),\n        (CanAddressingFormat.MIXED_29BIT_ADDRESSING, 0xF, 1, 64),\n    ])\n    def test_get_consecutive_frame_max_payload_size__valid_with_dlc(self, addressing_format, dlc,\n                                                                    ai_data_bytes_number, data_bytes_number):\n        self.mock_can_dlc_handler.decode_dlc.return_value = data_bytes_number\n        self.mock_can_addressing_information.get_ai_data_bytes_number.return_value = ai_data_bytes_number\n        assert get_consecutive_frame_max_payload_size(\n            addressing_format=addressing_format,\n            dlc=dlc) == data_bytes_number - ai_data_bytes_number - SN_BYTES_USED\n        self.mock_can_dlc_handler.decode_dlc.assert_called_once_with(dlc)\n        self.mock_can_addressing_information.get_ai_data_bytes_number.assert_called_once_with(addressing_format)\n\n    # extract_sequence_number\n\n    # encode_sequence_number\n\n@pytest.mark.integration\nclass TestCanConsecutiveFrameIntegration:\n    \"\"\"Integration tests for CAN Consecutive Frame module.\"\"\"\n\n    # validate_consecutive_frame_data\n\n    # create_consecutive_frame_data\n\n    # generate_consecutive_frame_data\n\n    # extract_consecutive_frame_payload\n"
