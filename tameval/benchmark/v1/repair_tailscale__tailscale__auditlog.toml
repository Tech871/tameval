[meta]
task = "repair"
scenario = "repair_missed_dependencies"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "tailscale/tailscale"
sha = "6bbf98bef457b4403f27da79eb1861e6197ab539"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out ipn/auditlog/auditlog.go ipn/auditlog/auditlog_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting ipn/auditlog/auditlog.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 89.0
mutation_kill_rate = 0.0
original_mutation_kill_rate = 50.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "ipn/auditlog/auditlog_test.go"
focal_file_path = "ipn/auditlog/auditlog.go"
test_file_url = "https://github.com/tailscale/tailscale/blob/6bbf98bef457b4403f27da79eb1861e6197ab539/ipn/auditlog/auditlog_test.go"
focal_file_url = "https://github.com/tailscale/tailscale/blob/6bbf98bef457b4403f27da79eb1861e6197ab539/ipn/auditlog/auditlog.go"
first_commit_date = "2025-03-12"
last_commit_date = "2025-03-12"
test_file_content = "// Copyright (c) Tailscale Inc & AUTHORS\n// SPDX-License-Identifier: BSD-3-Clause\n\npackage auditlog\n\n\n// loggerForTest creates an auditLogger for you and cleans it up\n// (and ensures no goroutines are leaked) when the test is done.\nfunc loggerForTest(t *testing.T, opts Opts) *Logger {\n\tt.Helper()\n\ttstest.ResourceCheck(t)\n\n\tif opts.Logf == nil {\n\t\topts.Logf = t.Logf\n\t}\n\n\tif opts.Store == nil {\n\t\tt.Fatalf(\"opts.Store must be set\")\n\t}\n\n\ta := NewLogger(opts)\n\n\tt.Cleanup(func() {\n\t\ta.FlushAndStop(context.Background())\n\t})\n\treturn a\n}\n\nfunc TestNonRetryableErrors(t *testing.T) {\n\terrorTests := []struct {\n\t\tdesc string\n\t\terr  error\n\t\twant bool\n\t}{\n\t\t{\"DeadlineExceeded\", context.DeadlineExceeded, false},\n\t\t{\"Canceled\", context.Canceled, false},\n\t\t{\"Canceled wrapped\", fmt.Errorf(\"%w: %w\", context.Canceled, errors.New(\"ctx cancelled\")), false},\n\t\t{\"Random error\", errors.New(\"random error\"), false},\n\t}\n\n\tfor _, tt := range errorTests {\n\t\tt.Run(tt.desc, func(t *testing.T) {\n\t\t\tif IsRetryableError(tt.err) != tt.want {\n\t\t\t\tt.Fatalf(\"retriable: got %v, want %v\", !tt.want, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// TestEnqueueAndFlush enqueues n logs and flushes them.\n// We expect all logs to be flushed and for no\n// logs to remain in the store once FlushAndStop returns.\nfunc TestEnqueueAndFlush(t *testing.T) {\n\tc := qt.New(t)\n\tmockTransport := newMockTransport(nil)\n\tal := loggerForTest(t, Opts{\n\t\tRetryLimit: 200,\n\t\tLogf:       t.Logf,\n\t\tStore:      NewLogStore(&mem.Store{}),\n\t})\n\n\tc.Assert(al.SetProfileID(\"test\"), qt.IsNil)\n\tc.Assert(al.Start(mockTransport), qt.IsNil)\n\n\twantSent := 10\n\n\tfor i := range wantSent {\n\t\terr := al.Enqueue(tailcfg.AuditNodeDisconnect, fmt.Sprintf(\"log %d\", i))\n\t\tc.Assert(err, qt.IsNil)\n\t}\n\n\tal.FlushAndStop(context.Background())\n\n\tal.mu.Lock()\n\tdefer al.mu.Unlock()\n\tgotStored, err := al.storedCountLocked()\n\tc.Assert(err, qt.IsNil)\n\n\tif wantStored := 0; gotStored != wantStored {\n\t\tt.Fatalf(\"stored: got %d, want %d\", gotStored, wantStored)\n\t}\n\n\tif gotSent := mockTransport.sentCount(); gotSent != wantSent {\n\t\tt.Fatalf(\"sent: got %d, want %d\", gotSent, wantSent)\n\t}\n}\n\n// TestEnqueueAndFlushWithFlushCancel calls FlushAndCancel with a cancelled\n// context.  We expect nothing to be sent and all logs to be stored.\nfunc TestEnqueueAndFlushWithFlushCancel(t *testing.T) {\n\tc := qt.New(t)\n\tmockTransport := newMockTransport(&retriableError)\n\tal := loggerForTest(t, Opts{\n\t\tRetryLimit: 200,\n\t\tLogf:       t.Logf,\n\t\tStore:      NewLogStore(&mem.Store{}),\n\t})\n\n\tc.Assert(al.SetProfileID(\"test\"), qt.IsNil)\n\tc.Assert(al.Start(mockTransport), qt.IsNil)\n\n\tfor i := range 10 {\n\t\terr := al.Enqueue(tailcfg.AuditNodeDisconnect, fmt.Sprintf(\"log %d\", i))\n\t\tc.Assert(err, qt.IsNil)\n\t}\n\n\t// Cancel the context before calling FlushAndStop - nothing should get sent.\n\t// This mimics a timeout before flush() has a chance to execute.\n\tctx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\n\tal.FlushAndStop(ctx)\n\n\tal.mu.Lock()\n\tdefer al.mu.Unlock()\n\tgotStored, err := al.storedCountLocked()\n\tc.Assert(err, qt.IsNil)\n\n\tif wantStored := 10; gotStored != wantStored {\n\t\tt.Fatalf(\"stored: got %d, want %d\", gotStored, wantStored)\n\t}\n\n\tif gotSent, wantSent := mockTransport.sentCount(), 0; gotSent != wantSent {\n\t\tt.Fatalf(\"sent: got %d, want %d\", gotSent, wantSent)\n\t}\n}\n\n// TestDeduplicateAndSort tests that the most recent log is kept when deduplicating logs\nfunc TestDeduplicateAndSort(t *testing.T) {\n\tc := qt.New(t)\n\tal := loggerForTest(t, Opts{\n\t\tRetryLimit: 100,\n\t\tLogf:       t.Logf,\n\t\tStore:      NewLogStore(&mem.Store{}),\n\t})\n\n\tc.Assert(al.SetProfileID(\"test\"), qt.IsNil)\n\n\tlogs := []*transaction{\n\t\t{EventID: \"1\", Details: \"log 1\", TimeStamp: time.Now().Add(-time.Minute * 1), Retries: 1},\n\t}\n\n\tal.mu.Lock()\n\tdefer al.mu.Unlock()\n\tal.appendToStoreLocked(logs)\n\n\t// Update the transaction and re-append it\n\tlogs[0].Retries = 2\n\tal.appendToStoreLocked(logs)\n\n\tfromStore, err := al.store.load(\"test\")\n\tc.Assert(err, qt.IsNil)\n\n\t// We should see only one transaction\n\tif wantStored, gotStored := len(logs), len(fromStore); gotStored != wantStored {\n\t\tt.Fatalf(\"stored: got %d, want %d\", gotStored, wantStored)\n\t}\n\n\t// We should see the latest transaction\n\tif wantRetryCount, gotRetryCount := 2, fromStore[0].Retries; gotRetryCount != wantRetryCount {\n\t\tt.Fatalf(\"reties: got %d, want %d\", gotRetryCount, wantRetryCount)\n\t}\n}\n\nfunc TestChangeProfileId(t *testing.T) {\n\tc := qt.New(t)\n\tal := loggerForTest(t, Opts{\n\t\tRetryLimit: 100,\n\t\tLogf:       t.Logf,\n\t\tStore:      NewLogStore(&mem.Store{}),\n\t})\n\tc.Assert(al.SetProfileID(\"test\"), qt.IsNil)\n\n\t// Changing a profile ID must fail\n\tc.Assert(al.SetProfileID(\"test\"), qt.IsNotNil)\n}\n\n// TestSendOnRestore pushes a n logs to the persistent store, and ensures they\n// are sent as soon as Start is called then checks to ensure the sent logs no\n// longer exist in the store.\nfunc TestSendOnRestore(t *testing.T) {\n\tc := qt.New(t)\n\tmockTransport := newMockTransport(nil)\n\tal := loggerForTest(t, Opts{\n\t\tRetryLimit: 100,\n\t\tLogf:       t.Logf,\n\t\tStore:      NewLogStore(&mem.Store{}),\n\t})\n\tal.SetProfileID(\"test\")\n\n\twantTotal := 10\n\n\tfor range 10 {\n\t\tal.Enqueue(tailcfg.AuditNodeDisconnect, \"log\")\n\t}\n\n\tc.Assert(al.Start(mockTransport), qt.IsNil)\n\n\tal.FlushAndStop(context.Background())\n\n\tal.mu.Lock()\n\tdefer al.mu.Unlock()\n\tgotStored, err := al.storedCountLocked()\n\tc.Assert(err, qt.IsNil)\n\n\tif wantStored := 0; gotStored != wantStored {\n\t\tt.Fatalf(\"stored: got %d, want %d\", gotStored, wantStored)\n\t}\n\n\tif gotSent, wantSent := mockTransport.sentCount(), wantTotal; gotSent != wantSent {\n\t\tt.Fatalf(\"sent: got %d, want %d\", gotSent, wantSent)\n\t}\n}\n\n// TestFailureExhaustion enqueues n logs,  with the transport in a failable state.\n// We then set it to a non-failing state, call FlushAndStop and expect all logs to be sent.\nfunc TestFailureExhaustion(t *testing.T) {\n\tc := qt.New(t)\n\tmockTransport := newMockTransport(&retriableError)\n\n\tal := loggerForTest(t, Opts{\n\t\tRetryLimit: 1,\n\t\tLogf:       t.Logf,\n\t\tStore:      NewLogStore(&mem.Store{}),\n\t})\n\n\tc.Assert(al.SetProfileID(\"test\"), qt.IsNil)\n\tc.Assert(al.Start(mockTransport), qt.IsNil)\n\n\tfor range 10 {\n\t\terr := al.Enqueue(tailcfg.AuditNodeDisconnect, \"log\")\n\t\tc.Assert(err, qt.IsNil)\n\t}\n\n\tal.FlushAndStop(context.Background())\n\tal.mu.Lock()\n\tdefer al.mu.Unlock()\n\tgotStored, err := al.storedCountLocked()\n\tc.Assert(err, qt.IsNil)\n\n\tif wantStored := 0; gotStored != wantStored {\n\t\tt.Fatalf(\"stored: got %d, want %d\", gotStored, wantStored)\n\t}\n\n\tif gotSent, wantSent := mockTransport.sentCount(), 0; gotSent != wantSent {\n\t\tt.Fatalf(\"sent: got %d, want %d\", gotSent, wantSent)\n\t}\n}\n\n// TestEnqueueAndFailNoRetry enqueues a set of logs, all of which will fail and are not\n// retriable. We then call FlushAndStop and expect all to be unsent.\nfunc TestEnqueueAndFailNoRetry(t *testing.T) {\n\tc := qt.New(t)\n\tmockTransport := newMockTransport(&nonRetriableError)\n\n\tal := loggerForTest(t, Opts{\n\t\tRetryLimit: 100,\n\t\tLogf:       t.Logf,\n\t\tStore:      NewLogStore(&mem.Store{}),\n\t})\n\n\tc.Assert(al.SetProfileID(\"test\"), qt.IsNil)\n\tc.Assert(al.Start(mockTransport), qt.IsNil)\n\n\tfor i := range 10 {\n\t\terr := al.Enqueue(tailcfg.AuditNodeDisconnect, fmt.Sprintf(\"log %d\", i))\n\t\tc.Assert(err, qt.IsNil)\n\t}\n\n\tal.FlushAndStop(context.Background())\n\tal.mu.Lock()\n\tdefer al.mu.Unlock()\n\tgotStored, err := al.storedCountLocked()\n\tc.Assert(err, qt.IsNil)\n\n\tif wantStored := 0; gotStored != wantStored {\n\t\tt.Fatalf(\"stored: got %d, want %d\", gotStored, wantStored)\n\t}\n\n\tif gotSent, wantSent := mockTransport.sentCount(), 0; gotSent != wantSent {\n\t\tt.Fatalf(\"sent: got %d, want %d\", gotSent, wantSent)\n\t}\n}\n\n// TestEnqueueAndRetry enqueues a set of logs, all of which will fail and are retriable.\n// Mid-test, we set the transport to not-fail and expect the queue to flush properly\n// We set the backoff parameters to 0 seconds so retries are immediate.\nfunc TestEnqueueAndRetry(t *testing.T) {\n\tc := qt.New(t)\n\tmockTransport := newMockTransport(&retriableError)\n\n\tal := loggerForTest(t, Opts{\n\t\tRetryLimit: 100,\n\t\tLogf:       t.Logf,\n\t\tStore:      NewLogStore(&mem.Store{}),\n\t})\n\n\tal.backoffOpts = backoffOpts{\n\t\tmin:        1 * time.Millisecond,\n\t\tmax:        4 * time.Millisecond,\n\t\tmultiplier: 2.0,\n\t}\n\n\tc.Assert(al.SetProfileID(\"test\"), qt.IsNil)\n\tc.Assert(al.Start(mockTransport), qt.IsNil)\n\n\terr := al.Enqueue(tailcfg.AuditNodeDisconnect, fmt.Sprintf(\"log 1\"))\n\tc.Assert(err, qt.IsNil)\n\n\t// This will wait for at least 2 retries\n\tgotRetried, wantRetried := mockTransport.waitForSendAttemptsToReach(3), true\n\tif gotRetried != wantRetried {\n\t\tt.Fatalf(\"retried: got %v, want %v\", gotRetried, wantRetried)\n\t}\n\n\tmockTransport.setErrorCondition(nil)\n\n\tal.FlushAndStop(context.Background())\n\tal.mu.Lock()\n\tdefer al.mu.Unlock()\n\n\tgotStored, err := al.storedCountLocked()\n\tc.Assert(err, qt.IsNil)\n\n\tif wantStored := 0; gotStored != wantStored {\n\t\tt.Fatalf(\"stored: got %d, want %d\", gotStored, wantStored)\n\t}\n\n\tif gotSent, wantSent := mockTransport.sentCount(), 1; gotSent != wantSent {\n\t\tt.Fatalf(\"sent: got %d, want %d\", gotSent, wantSent)\n\t}\n}\n\n// TestEnqueueBeforeSetProfileID tests that logs enqueued before SetProfileId are not sent\nfunc TestEnqueueBeforeSetProfileID(t *testing.T) {\n\tc := qt.New(t)\n\tal := loggerForTest(t, Opts{\n\t\tRetryLimit: 100,\n\t\tLogf:       t.Logf,\n\t\tStore:      NewLogStore(&mem.Store{}),\n\t})\n\n\terr := al.Enqueue(tailcfg.AuditNodeDisconnect, \"log\")\n\tc.Assert(err, qt.IsNotNil)\n\tal.FlushAndStop(context.Background())\n\n\tal.mu.Lock()\n\tdefer al.mu.Unlock()\n\tgotStored, err := al.storedCountLocked()\n\tc.Assert(err, qt.IsNotNil)\n\n\tif wantStored := 0; gotStored != wantStored {\n\t\tt.Fatalf(\"stored: got %d, want %d\", gotStored, wantStored)\n\t}\n}\n\n// TestLogStoring tests that audit logs are persisted sorted by timestamp, oldest to newest\nfunc TestLogSorting(t *testing.T) {\n\tc := qt.New(t)\n\tmockStore := NewLogStore(&mem.Store{})\n\n\tlogs := []*transaction{\n\t\t{EventID: \"1\", Details: \"log 3\", TimeStamp: time.Now().Add(-time.Minute * 1)},\n\t\t{EventID: \"1\", Details: \"log 3\", TimeStamp: time.Now().Add(-time.Minute * 2)},\n\t\t{EventID: \"2\", Details: \"log 2\", TimeStamp: time.Now().Add(-time.Minute * 3)},\n\t\t{EventID: \"3\", Details: \"log 1\", TimeStamp: time.Now().Add(-time.Minute * 4)},\n\t}\n\n\twantLogs := []transaction{\n\t\t{Details: \"log 1\"},\n\t\t{Details: \"log 2\"},\n\t\t{Details: \"log 3\"},\n\t}\n\n\tmockStore.save(\"test\", logs)\n\n\tgotLogs, err := mockStore.load(\"test\")\n\tc.Assert(err, qt.IsNil)\n\tgotLogs = deduplicateAndSort(gotLogs)\n\n\tfor i := range gotLogs {\n\t\tif want, got := wantLogs[i].Details, gotLogs[i].Details; want != got {\n\t\t\tt.Fatalf(\"Details: got %v, want %v\", got, want)\n\t\t}\n\t}\n}\n\n// mock implementations for testing\n\n// newMockTransport returns a mock transport for testing\n// If err is no nil, SendAuditLog will return this error if the send is attempted\n// before the context is cancelled.\nfunc newMockTransport(err error) *mockAuditLogTransport {\n\treturn &mockAuditLogTransport{\n\t\terr:      err,\n\t\tattempts: make(chan int, 1),\n\t}\n}\n\ntype mockAuditLogTransport struct {\n\tattempts chan int // channel to notify of send attempts\n\n\tmu          sync.Mutex\n\tsendAttmpts int   // number of attempts to send logs\n\tsendCount   int   // number of logs sent by the transport\n\terr         error // error to return when sending logs\n}\n\n// waitForSendAttemptsToReach blocks until the number of send attempts reaches n\n// This should be use only in tests where the transport is expected to retry sending logs\nfunc (t *mockAuditLogTransport) waitForSendAttemptsToReach(n int) bool {\n\tfor attempts := range t.attempts {\n\t\tif attempts >= n {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (t *mockAuditLogTransport) setErrorCondition(err error) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.err = err\n}\n\nfunc (t *mockAuditLogTransport) sentCount() int {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\treturn t.sendCount\n}\n\nfunc (t *mockAuditLogTransport) SendAuditLog(ctx context.Context, _ tailcfg.AuditLogRequest) (err error) {\n\tt.mu.Lock()\n\tt.sendAttmpts += 1\n\tdefer func() {\n\t\ta := t.sendAttmpts\n\t\tt.mu.Unlock()\n\t\tselect {\n\t\tcase t.attempts <- a:\n\t\tdefault:\n\t\t}\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tdefault:\n\t}\n\n\tif t.err != nil {\n\t\treturn t.err\n\t}\n\tt.sendCount += 1\n\treturn nil\n}\n\nvar (\n\tretriableError    = mockError{errors.New(\"retriable error\")}\n\tnonRetriableError = mockError{errors.New(\"permanent failure error\")}\n)\n\ntype mockError struct {\n\terror\n}\n\nfunc (e mockError) Retryable() bool {\n\treturn e == retriableError\n}\n"
