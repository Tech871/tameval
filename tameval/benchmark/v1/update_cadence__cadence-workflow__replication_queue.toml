[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.22"

[repo_info]
repository = "cadence-workflow/cadence"
sha = "6d4ff3b9586899afadea49387fa6cfe75b0d00aa"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out common/domain/replication_queue.go common/domain/replication_queue_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting common/domain/replication_queue.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 83.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "common/domain/replication_queue_test.go"
focal_file_path = "common/domain/replication_queue.go"
test_file_url = "https://github.com/cadence-workflow/cadence/blob/6d4ff3b9586899afadea49387fa6cfe75b0d00aa/common/domain/replication_queue_test.go"
focal_file_url = "https://github.com/cadence-workflow/cadence/blob/6d4ff3b9586899afadea49387fa6cfe75b0d00aa/common/domain/replication_queue.go"
first_commit_date = "2020-11-06"
last_commit_date = "2025-03-24"
test_file_content = "// Copyright (c) 2023 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage domain\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"go.uber.org/mock/gomock\"\n\n\t\"github.com/uber/cadence/common\"\n\t\"github.com/uber/cadence/common/persistence\"\n\t\"github.com/uber/cadence/common/types\"\n)\n\nconst (\n\tpreambleVersion0 byte = 0x59\n)\n\nfunc TestReplicationQueueImpl_Start(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tinitialStatus  int32\n\t\texpectedStatus int32\n\t\tshouldStart    bool\n\t}{\n\t\t{\n\t\t\tname:           \"Should start when initialized\",\n\t\t\tinitialStatus:  common.DaemonStatusInitialized,\n\t\t\texpectedStatus: common.DaemonStatusStarted,\n\t\t\tshouldStart:    true,\n\t\t},\n\t\t{\n\t\t\tname:           \"Should not start when already started\",\n\t\t\tinitialStatus:  common.DaemonStatusStarted,\n\t\t\texpectedStatus: common.DaemonStatusStarted,\n\t\t\tshouldStart:    false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueue := persistence.NewMockQueueManager(ctrl)\n\t\t\trq := NewReplicationQueue(mockQueue, \"testCluster\", nil, nil).(*replicationQueueImpl)\n\t\t\tatomic.StoreInt32(&rq.status, tt.initialStatus)\n\n\t\t\trq.Start()\n\t\t\tdefer rq.Stop()\n\t\t\tassert.Equal(t, tt.expectedStatus, atomic.LoadInt32(&rq.status))\n\n\t\t\tif tt.shouldStart {\n\t\t\t\tselect {\n\t\t\t\tcase <-rq.done:\n\t\t\t\t\tt.Error(\"purgeProcessor should not have stopped\")\n\t\t\t\tcase <-time.After(time.Millisecond):\n\t\t\t\t\t// expected, as the purgeProcessor should still be running\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReplicationQueueImpl_Stop(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tinitialStatus  int32\n\t\texpectedStatus int32\n\t\tshouldStop     bool\n\t}{\n\t\t{\n\t\t\tname:           \"Should stop when started\",\n\t\t\tinitialStatus:  common.DaemonStatusStarted,\n\t\t\texpectedStatus: common.DaemonStatusStopped,\n\t\t\tshouldStop:     true,\n\t\t},\n\t\t{\n\t\t\tname:           \"Should not stop when not started\",\n\t\t\tinitialStatus:  common.DaemonStatusInitialized,\n\t\t\texpectedStatus: common.DaemonStatusInitialized,\n\t\t\tshouldStop:     false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueue := persistence.NewMockQueueManager(ctrl)\n\t\t\trq := NewReplicationQueue(mockQueue, \"testCluster\", nil, nil).(*replicationQueueImpl)\n\t\t\tatomic.StoreInt32(&rq.status, tt.initialStatus)\n\n\t\t\trq.Stop()\n\t\t\tassert.Equal(t, tt.expectedStatus, atomic.LoadInt32(&rq.status))\n\n\t\t\tif tt.shouldStop {\n\t\t\t\tselect {\n\t\t\t\tcase <-rq.done:\n\t\t\t\t\t// expected channel closed\n\t\t\t\tdefault:\n\t\t\t\t\tt.Error(\"done channel should be closed\")\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReplicationQueueImpl_Publish(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\ttask      *types.ReplicationTask\n\t\twantErr   bool\n\t\tsetupMock func(q *persistence.MockQueueManager)\n\t}{\n\t\t{\n\t\t\tname:    \"successful publish\",\n\t\t\ttask:    &types.ReplicationTask{},\n\t\t\twantErr: false,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().EnqueueMessage(gomock.Any(), gomock.Any()).Return(nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"publish fails\",\n\t\t\ttask:    &types.ReplicationTask{},\n\t\t\twantErr: true,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().EnqueueMessage(gomock.Any(), gomock.Any()).Return(errors.New(\"enqueue error\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueue := persistence.NewMockQueueManager(ctrl)\n\t\t\trq := NewReplicationQueue(mockQueue, \"testCluster\", nil, nil)\n\t\t\ttt.setupMock(mockQueue)\n\t\t\terr := rq.Publish(context.Background(), tt.task)\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReplicationQueueImpl_PublishToDLQ(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\ttask      *types.ReplicationTask\n\t\twantErr   bool\n\t\tsetupMock func(q *persistence.MockQueueManager)\n\t}{\n\t\t{\n\t\t\tname:    \"successful publish to DLQ\",\n\t\t\ttask:    &types.ReplicationTask{},\n\t\t\twantErr: false,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().EnqueueMessageToDLQ(gomock.Any(), gomock.Any()).Return(nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"publish to DLQ fails\",\n\t\t\ttask:    &types.ReplicationTask{},\n\t\t\twantErr: true,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().EnqueueMessageToDLQ(gomock.Any(), gomock.Any()).Return(errors.New(\"enqueue to DLQ error\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueue := persistence.NewMockQueueManager(ctrl)\n\t\t\trq := NewReplicationQueue(mockQueue, \"testCluster\", nil, nil)\n\t\t\ttt.setupMock(mockQueue)\n\t\t\terr := rq.PublishToDLQ(context.Background(), tt.task)\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetReplicationMessages(t *testing.T) {\n\ttests := []struct {\n\t\tname           string\n\t\tsetupMocks     func(mockQueueManager *persistence.MockQueueManager)\n\t\texpectedTasks  int\n\t\texpectedLastID int64\n\t\texpectError    bool\n\t}{\n\t\t{\n\t\t\tname: \"handles empty message list\",\n\t\t\tsetupMocks: func(mockQueueManager *persistence.MockQueueManager) {\n\t\t\t\tmockQueueManager.EXPECT().\n\t\t\t\t\tReadMessages(gomock.Any(), gomock.Any(), gomock.Any()).\n\t\t\t\t\tReturn(nil, nil)\n\t\t\t},\n\t\t\texpectedTasks:  0,\n\t\t\texpectedLastID: 0,\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname: \"decodes single message correctly\",\n\t\t\tsetupMocks: func(mockQueueManager *persistence.MockQueueManager) {\n\t\t\t\t// Setup mock to return one encoded message\n\t\t\t\tencodedMessage, _ := mockEncodeReplicationTask(123)\n\t\t\t\tmockQueueManager.EXPECT().\n\t\t\t\t\tReadMessages(gomock.Any(), gomock.Any(), gomock.Any()).\n\t\t\t\t\tReturn([]*persistence.QueueMessage{{ID: 1, Payload: encodedMessage}}, nil)\n\t\t\t},\n\t\t\texpectedTasks:  1,\n\t\t\texpectedLastID: 1,\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname: \"decodes multiple messages correctly\",\n\t\t\tsetupMocks: func(mockQueueManager *persistence.MockQueueManager) {\n\t\t\t\t// Setup mock to return multiple encoded messages\n\t\t\t\tencodedMessage1, _ := mockEncodeReplicationTask(123)\n\t\t\t\tencodedMessage2, _ := mockEncodeReplicationTask(456)\n\t\t\t\tmockQueueManager.EXPECT().\n\t\t\t\t\tReadMessages(gomock.Any(), gomock.Any(), gomock.Any()).\n\t\t\t\t\tReturn([]*persistence.QueueMessage{\n\t\t\t\t\t\t{ID: 1, Payload: encodedMessage1},\n\t\t\t\t\t\t{ID: 2, Payload: encodedMessage2},\n\t\t\t\t\t}, nil)\n\t\t\t},\n\t\t\texpectedTasks:  2,\n\t\t\texpectedLastID: 2,\n\t\t\texpectError:    false,\n\t\t},\n\t\t{\n\t\t\tname:           \"read messages fails\",\n\t\t\texpectedLastID: 100,\n\t\t\texpectError:    true,\n\t\t\tsetupMocks: func(mockQueueManager *persistence.MockQueueManager) {\n\t\t\t\tmockQueueManager.EXPECT().ReadMessages(gomock.Any(), gomock.Any(), gomock.Any()).Return(nil, errors.New(\"read error\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueueManager := persistence.NewMockQueueManager(ctrl)\n\t\t\ttc.setupMocks(mockQueueManager)\n\t\t\treplicationQueue := NewReplicationQueue(mockQueueManager, \"testCluster\", nil, nil)\n\t\t\ttasks, lastID, err := replicationQueue.GetReplicationMessages(context.Background(), 0, 10)\n\n\t\t\tif tc.expectError {\n\t\t\t\trequire.Error(t, err)\n\t\t\t} else {\n\t\t\t\trequire.NoError(t, err)\n\t\t\t\tassert.Equal(t, tc.expectedTasks, len(tasks))\n\t\t\t\tassert.Equal(t, tc.expectedLastID, lastID)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUpdateAckLevel(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tlastID    int64\n\t\tcluster   string\n\t\twantErr   bool\n\t\tsetupMock func(q *persistence.MockQueueManager)\n\t}{\n\t\t{\n\t\t\tname:    \"successful ack level update\",\n\t\t\tlastID:  100,\n\t\t\tcluster: \"testCluster\",\n\t\t\twantErr: false,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().UpdateAckLevel(gomock.Any(), gomock.Eq(int64(100)), gomock.Eq(\"testCluster\")).Return(nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"ack level update fails\",\n\t\t\tlastID:  100,\n\t\t\tcluster: \"testCluster\",\n\t\t\twantErr: true,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().UpdateAckLevel(gomock.Any(), gomock.Eq(int64(100)), gomock.Eq(\"testCluster\")).Return(errors.New(\"update error\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueue := persistence.NewMockQueueManager(ctrl)\n\n\t\t\trq := NewReplicationQueue(mockQueue, \"testCluster\", nil, nil)\n\t\t\ttt.setupMock(mockQueue)\n\t\t\terr := rq.UpdateAckLevel(context.Background(), tt.lastID, tt.cluster)\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReplicationQueueImpl_GetAckLevels(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\twant      map[string]int64\n\t\twantErr   bool\n\t\tsetupMock func(q *persistence.MockQueueManager)\n\t}{\n\t\t{\n\t\t\tname:    \"successful ack levels retrieval\",\n\t\t\twant:    map[string]int64{\"testCluster\": 100},\n\t\t\twantErr: false,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().GetAckLevels(gomock.Any()).Return(map[string]int64{\"testCluster\": 100}, nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"ack levels retrieval fails\",\n\t\t\twantErr: true,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().GetAckLevels(gomock.Any()).Return(nil, errors.New(\"retrieval error\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueue := persistence.NewMockQueueManager(ctrl)\n\t\t\trq := NewReplicationQueue(mockQueue, \"testCluster\", nil, nil)\n\t\t\ttt.setupMock(mockQueue)\n\t\t\tgot, err := rq.GetAckLevels(context.Background())\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc mockEncodeReplicationTask(sourceTaskID int64) ([]byte, error) {\n\tvar buf bytes.Buffer\n\tbuf.WriteByte(preambleVersion0)\n\tbinary.Write(&buf, binary.BigEndian, sourceTaskID)\n\treturn buf.Bytes(), nil\n}\n\nfunc TestGetMessagesFromDLQ(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tfirstID   int64\n\t\tlastID    int64\n\t\tpageSize  int\n\t\tpageToken []byte\n\t\ttaskID    int64\n\t\twantErr   bool\n\t}{\n\t\t{\n\t\t\tname:      \"successful message retrieval\",\n\t\t\tfirstID:   100,\n\t\t\tlastID:    200,\n\t\t\tpageSize:  10,\n\t\t\tpageToken: []byte(\"token\"),\n\t\t\ttaskID:    12345,\n\t\t\twantErr:   false,\n\t\t},\n\t\t{\n\t\t\tname:      \"read messages fails\",\n\t\t\tfirstID:   100,\n\t\t\tlastID:    200,\n\t\t\tpageSize:  10,\n\t\t\tpageToken: []byte(\"token\"),\n\t\t\twantErr:   true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueue := persistence.NewMockQueueManager(ctrl)\n\t\t\trq := NewReplicationQueue(mockQueue, \"testCluster\", nil, nil)\n\n\t\t\tif !tt.wantErr {\n\t\t\t\tencodedData, _ := mockEncodeReplicationTask(tt.taskID)\n\t\t\t\tmessages := []*persistence.QueueMessage{\n\t\t\t\t\t{ID: 1, Payload: encodedData},\n\t\t\t\t}\n\t\t\t\tmockQueue.EXPECT().ReadMessagesFromDLQ(gomock.Any(), tt.firstID, tt.lastID, tt.pageSize, tt.pageToken).Return(messages, []byte(\"nextToken\"), nil)\n\t\t\t} else {\n\t\t\t\tmockQueue.EXPECT().ReadMessagesFromDLQ(gomock.Any(), tt.firstID, tt.lastID, tt.pageSize, tt.pageToken).Return(nil, nil, errors.New(\"read error\"))\n\t\t\t}\n\n\t\t\treplicationTasks, token, err := rq.GetMessagesFromDLQ(context.Background(), tt.firstID, tt.lastID, tt.pageSize, tt.pageToken)\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Len(t, replicationTasks, 1, \"Expected one replication task to be returned\")\n\t\t\t\tassert.Equal(t, []byte(\"nextToken\"), token, \"Expected token to match 'nextToken'\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestUpdateDLQAckLevel(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tlastID    int64\n\t\twantErr   bool\n\t\tsetupMock func(q *persistence.MockQueueManager)\n\t}{\n\t\t{\n\t\t\tname:    \"successful DLQ ack level update\",\n\t\t\tlastID:  100,\n\t\t\twantErr: false,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().UpdateDLQAckLevel(gomock.Any(), gomock.Eq(int64(100)), gomock.Eq(\"domainReplication\")).Return(nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"DLQ ack level update fails\",\n\t\t\tlastID:  100,\n\t\t\twantErr: true,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().UpdateDLQAckLevel(gomock.Any(), gomock.Eq(int64(100)), gomock.Eq(\"domainReplication\")).Return(errors.New(\"update DLQ ack level error\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueue := persistence.NewMockQueueManager(ctrl)\n\t\t\trq := NewReplicationQueue(mockQueue, \"testCluster\", nil, nil)\n\t\t\ttt.setupMock(mockQueue)\n\t\t\terr := rq.UpdateDLQAckLevel(context.Background(), tt.lastID)\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDLQAckLevel(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\twant      int64\n\t\twantErr   bool\n\t\tsetupMock func(q *persistence.MockQueueManager)\n\t}{\n\t\t{\n\t\t\tname:    \"successful DLQ ack level retrieval\",\n\t\t\twant:    100,\n\t\t\twantErr: false,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().GetDLQAckLevels(gomock.Any()).Return(map[string]int64{\"domainReplication\": 100}, nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"DLQ ack level retrieval fails\",\n\t\t\twantErr: true,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().GetDLQAckLevels(gomock.Any()).Return(nil, errors.New(\"get DLQ ack level error\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueue := persistence.NewMockQueueManager(ctrl)\n\t\t\trq := NewReplicationQueue(mockQueue, \"testCluster\", nil, nil)\n\t\t\ttt.setupMock(mockQueue)\n\t\t\tgot, err := rq.GetDLQAckLevel(context.Background())\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, tt.want, got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRangeDeleteMessagesFromDLQ(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tfirstID   int64\n\t\tlastID    int64\n\t\twantErr   bool\n\t\tsetupMock func(q *persistence.MockQueueManager)\n\t}{\n\t\t{\n\t\t\tname:    \"successful range delete from DLQ\",\n\t\t\tfirstID: 10,\n\t\t\tlastID:  20,\n\t\t\twantErr: false,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().RangeDeleteMessagesFromDLQ(gomock.Any(), gomock.Eq(int64(10)), gomock.Eq(int64(20))).Return(nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"range delete from DLQ fails\",\n\t\t\tfirstID: 10,\n\t\t\tlastID:  20,\n\t\t\twantErr: true,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().RangeDeleteMessagesFromDLQ(gomock.Any(), gomock.Eq(int64(10)), gomock.Eq(int64(20))).Return(errors.New(\"range delete error\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueue := persistence.NewMockQueueManager(ctrl)\n\t\t\trq := NewReplicationQueue(mockQueue, \"testCluster\", nil, nil)\n\t\t\ttt.setupMock(mockQueue)\n\t\t\terr := rq.RangeDeleteMessagesFromDLQ(context.Background(), tt.firstID, tt.lastID)\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDeleteMessageFromDLQ(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tmessageID int64\n\t\twantErr   bool\n\t\tsetupMock func(q *persistence.MockQueueManager)\n\t}{\n\t\t{\n\t\t\tname:      \"successful delete from DLQ\",\n\t\t\tmessageID: 15,\n\t\t\twantErr:   false,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().DeleteMessageFromDLQ(gomock.Any(), gomock.Eq(int64(15))).Return(nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:      \"delete from DLQ fails\",\n\t\t\tmessageID: 15,\n\t\t\twantErr:   true,\n\t\t\tsetupMock: func(q *persistence.MockQueueManager) {\n\t\t\t\tq.EXPECT().DeleteMessageFromDLQ(gomock.Any(), gomock.Eq(int64(15))).Return(errors.New(\"delete error\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueue := persistence.NewMockQueueManager(ctrl)\n\t\t\trq := NewReplicationQueue(mockQueue, \"testCluster\", nil, nil)\n\t\t\ttt.setupMock(mockQueue)\n\t\t\terr := rq.DeleteMessageFromDLQ(context.Background(), tt.messageID)\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetDLQSize(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\twantSize  int64\n\t\twantErr   bool\n\t\tsetupMock func(m *persistence.MockQueueManager)\n\t}{\n\t\t{\n\t\t\tname:     \"returns correct size for non-empty DLQ\",\n\t\t\twantSize: 10,\n\t\t\twantErr:  false,\n\t\t\tsetupMock: func(m *persistence.MockQueueManager) {\n\t\t\t\tm.EXPECT().GetDLQSize(gomock.Any()).Return(int64(10), nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"returns zero for empty DLQ\",\n\t\t\twantSize: 0,\n\t\t\twantErr:  false,\n\t\t\tsetupMock: func(m *persistence.MockQueueManager) {\n\t\t\t\tm.EXPECT().GetDLQSize(gomock.Any()).Return(int64(0), nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"propagates error from underlying queue\",\n\t\t\twantErr: true,\n\t\t\tsetupMock: func(m *persistence.MockQueueManager) {\n\t\t\t\tm.EXPECT().GetDLQSize(gomock.Any()).Return(int64(0), errors.New(\"database error\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueueManager := persistence.NewMockQueueManager(ctrl)\n\t\t\ttt.setupMock(mockQueueManager)\n\t\t\tq := &replicationQueueImpl{queue: mockQueueManager}\n\t\t\tsize, err := q.GetDLQSize(context.Background())\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, tt.wantSize, size)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestPurgeAckedMessages(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\twantErr   bool\n\t\tsetupMock func(m *persistence.MockQueueManager)\n\t}{\n\t\t{\n\t\t\tname:    \"successfully purges messages\",\n\t\t\twantErr: false,\n\t\t\tsetupMock: func(m *persistence.MockQueueManager) {\n\t\t\t\tm.EXPECT().GetAckLevels(gomock.Any()).Return(map[string]int64{\"clusterA\": 5}, nil)\n\t\t\t\tm.EXPECT().DeleteMessagesBefore(gomock.Any(), int64(5)).Return(nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"does nothing when no ack levels\",\n\t\t\twantErr: false,\n\t\t\tsetupMock: func(m *persistence.MockQueueManager) {\n\t\t\t\tm.EXPECT().GetAckLevels(gomock.Any()).Return(map[string]int64{}, nil)\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"error on GetAckLevels\",\n\t\t\twantErr: true,\n\t\t\tsetupMock: func(m *persistence.MockQueueManager) {\n\t\t\t\tm.EXPECT().GetAckLevels(gomock.Any()).Return(nil, errors.New(\"database error\"))\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:    \"error on DeleteMessagesBefore\",\n\t\t\twantErr: true,\n\t\t\tsetupMock: func(m *persistence.MockQueueManager) {\n\t\t\t\tm.EXPECT().GetAckLevels(gomock.Any()).Return(map[string]int64{\"clusterA\": 5}, nil)\n\t\t\t\tm.EXPECT().DeleteMessagesBefore(gomock.Any(), int64(5)).Return(errors.New(\"delete error\"))\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tctrl := gomock.NewController(t)\n\t\t\tmockQueueManager := persistence.NewMockQueueManager(ctrl)\n\t\t\ttt.setupMock(mockQueueManager)\n\t\t\tq := &replicationQueueImpl{queue: mockQueueManager}\n\t\t\terr := q.purgeAckedMessages()\n\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}"
