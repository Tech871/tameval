[meta]
task = "create"
scenario = "extend_test_file"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "notaryproject/ratify"
sha = "67aa7a4993f915deac10ae371cdafb67a4bf697c"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out internal/policyenforcer/threshold/parse.go internal/policyenforcer/threshold/parse_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting internal/policyenforcer/threshold/parse.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 95.0
original_coverage = 95.0
mutation_kill_rate = 76.0
original_mutation_kill_rate = 76.0
covered_lines = [ 31, 32, 33, 34, 35, 36, 37, 39, 43, 44, 45, 46, 47, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 85, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101,]
missed_lines = [ 40, 41, 42,]

[input_info]
test_file_path = "internal/policyenforcer/threshold/parse_test.go"
focal_file_path = "internal/policyenforcer/threshold/parse.go"
test_file_url = "https://github.com/notaryproject/ratify/blob/67aa7a4993f915deac10ae371cdafb67a4bf697c/internal/policyenforcer/threshold/parse_test.go"
focal_file_url = "https://github.com/notaryproject/ratify/blob/67aa7a4993f915deac10ae371cdafb67a4bf697c/internal/policyenforcer/threshold/parse.go"
first_commit_date = "2025-07-15"
last_commit_date = "2025-07-17"
test_file_content = "/*\nCopyright The Ratify Authors.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage threshold\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/notaryproject/ratify-go\"\n\t\"github.com/notaryproject/ratify/v2/internal/policyenforcer\"\n)\n\nfunc TestNewThresholdPolicyEnforcer(t *testing.T) {\n\ttests := []struct {\n\t\tname       string\n\t\tparameters any\n\t\twantErr    bool\n\t}{\n\t\t{\n\t\t\tname:       \"unsupported params\",\n\t\t\tparameters: make(chan int),\n\t\t\twantErr:    true,\n\t\t},\n\t\t{\n\t\t\tname:       \"malformed params\",\n\t\t\tparameters: \"{\",\n\t\t\twantErr:    true,\n\t\t},\n\t\t{\n\t\t\tname:       \"nil policy\",\n\t\t\tparameters: map[string]any{},\n\t\t\twantErr:    true,\n\t\t},\n\t\t{\n\t\t\tname: \"no rules provided\",\n\t\t\tparameters: map[string]any{\n\t\t\t\t\"policy\": map[string]any{},\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"embedded nil rules\",\n\t\t\tparameters: map[string]any{\n\t\t\t\t\"policy\": map[string]any{\n\t\t\t\t\t\"rules\": nil,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Valid rules\",\n\t\t\tparameters: map[string]any{\n\t\t\t\t\"policy\": map[string]any{\n\t\t\t\t\t\"rules\": []any{\n\t\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\t\"verifierName\": \"test-verifier\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\topts := policyenforcer.NewOptions{\n\t\t\t\tType:       \"threshold-policy\",\n\t\t\t\tParameters: tt.parameters,\n\t\t\t}\n\t\t\t_, err := policyenforcer.New(opts)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"New() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseRule(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\traw     map[string]any\n\t\twant    *ratify.ThresholdPolicyRule\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"nil raw\",\n\t\t\traw:     nil,\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid verifier type\",\n\t\t\traw:     map[string]any{\"verifierName\": 123},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid threshold type\",\n\t\t\traw:     map[string]any{\"threshold\": \"bad\"},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"invalid rules type\",\n\t\t\traw:     map[string]any{\"rules\": \"not slice\"},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"rule element not a map\",\n\t\t\traw:     map[string]any{\"rules\": []any{\"not a map\"}},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"nested rule error\",\n\t\t\traw:     map[string]any{\"rules\": []any{map[string]any{\"verifierName\": 999}}},\n\t\t\twant:    nil,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"valid minimal\", // only valid for parseRule, not ratify.NewThresholdPolicyEnforcer\n\t\t\traw:  map[string]any{},\n\t\t\twant: &ratify.ThresholdPolicyRule{},\n\t\t},\n\t\t{\n\t\t\tname: \"valid full\",\n\t\t\traw: map[string]any{\n\t\t\t\t\"verifierName\": \"root\",\n\t\t\t\t\"threshold\":    2.0,\n\t\t\t\t\"rules\": []any{\n\t\t\t\t\tmap[string]any{\n\t\t\t\t\t\t\"verifierName\": \"child\",\n\t\t\t\t\t\t\"threshold\":    1.0,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: &ratify.ThresholdPolicyRule{\n\t\t\t\tVerifier:  \"root\",\n\t\t\t\tThreshold: 2,\n\t\t\t\tRules: []*ratify.ThresholdPolicyRule{\n\t\t\t\t\t{\n\t\t\t\t\t\tVerifier:  \"child\",\n\t\t\t\t\t\tThreshold: 1,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := parseRule(tt.raw)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"parseRule() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"parseRule() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_parseOrNil(t *testing.T) {\n\tdata := map[string]any{\n\t\t\"int\":    42,\n\t\t\"string\": \"test\",\n\t\t\"bool\":   true,\n\t\t\"nil\":    nil,\n\t\t\"slice\":  []any{1, 2, 3},\n\t\t\"map\": map[string]any{\n\t\t\t\"key\": \"value\",\n\t\t},\n\t}\n\n\tt.Run(\"parseOrNil[map[string]any]\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tname    string\n\t\t\tkey     string\n\t\t\twant    map[string]any\n\t\t\twantErr bool\n\t\t}{\n\t\t\t{\n\t\t\t\tname:    \"existing int\",\n\t\t\t\tkey:     \"int\",\n\t\t\t\twantErr: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"existing string\",\n\t\t\t\tkey:     \"string\",\n\t\t\t\twantErr: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"existing bool\",\n\t\t\t\tkey:     \"bool\",\n\t\t\t\twantErr: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"existing nil\",\n\t\t\t\tkey:  \"nil\",\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"existing slice\",\n\t\t\t\tkey:     \"slice\",\n\t\t\t\twantErr: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"existing map\",\n\t\t\t\tkey:  \"map\",\n\t\t\t\twant: map[string]any{\"key\": \"value\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"missing key\",\n\t\t\t\tkey:  \"notfound\",\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t}\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgot, err := parseOrNil[map[string]any](data, tt.key)\n\t\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"parseOrNil() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"parseOrNil() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"parseOrNil[string]\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tname    string\n\t\t\tkey     string\n\t\t\twant    string\n\t\t\twantErr bool\n\t\t}{\n\t\t\t{\n\t\t\t\tname:    \"existing int\",\n\t\t\t\tkey:     \"int\",\n\t\t\t\twantErr: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"existing string\",\n\t\t\t\tkey:  \"string\",\n\t\t\t\twant: \"test\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"existing nil\",\n\t\t\t\tkey:  \"nil\",\n\t\t\t\twant: \"\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"missing key\",\n\t\t\t\tkey:  \"notfound\",\n\t\t\t\twant: \"\",\n\t\t\t},\n\t\t}\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgot, err := parseOrNil[string](data, tt.key)\n\t\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"parseOrNil() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\tif got != tt.want {\n\t\t\t\t\tt.Errorf(\"parseOrNil() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"parseOrNil[int]\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tname    string\n\t\t\tkey     string\n\t\t\twant    int\n\t\t\twantErr bool\n\t\t}{\n\t\t\t{\n\t\t\t\tname: \"existing int\",\n\t\t\t\tkey:  \"int\",\n\t\t\t\twant: 42,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname:    \"existing string\",\n\t\t\t\tkey:     \"string\",\n\t\t\t\twantErr: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"existing nil\",\n\t\t\t\tkey:  \"nil\",\n\t\t\t\twant: 0,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"missing key\",\n\t\t\t\tkey:  \"notfound\",\n\t\t\t\twant: 0,\n\t\t\t},\n\t\t}\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgot, err := parseOrNil[int](data, tt.key)\n\t\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"parseOrNil() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\tif got != tt.want {\n\t\t\t\t\tt.Errorf(\"parseOrNil() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"parseOrNil[[]any]\", func(t *testing.T) {\n\t\ttests := []struct {\n\t\t\tname    string\n\t\t\tkey     string\n\t\t\twant    []any\n\t\t\twantErr bool\n\t\t}{\n\t\t\t{\n\t\t\t\tname:    \"existing int\",\n\t\t\t\tkey:     \"int\",\n\t\t\t\twantErr: true,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"existing slice\",\n\t\t\t\tkey:  \"slice\",\n\t\t\t\twant: []any{1, 2, 3},\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"existing nil\",\n\t\t\t\tkey:  \"nil\",\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"missing key\",\n\t\t\t\tkey:  \"notfound\",\n\t\t\t\twant: nil,\n\t\t\t},\n\t\t}\n\t\tfor _, tt := range tests {\n\t\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t\tgot, err := parseOrNil[[]any](data, tt.key)\n\t\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\t\tt.Errorf(\"parseOrNil() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t}\n\t\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\t\tt.Errorf(\"parseOrNil() = %v, want %v\", got, tt.want)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n"
