[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Go"
go_version = "1.23.0"

[repo_info]
repository = "go-dev-frame/sponge"
sha = "e72bb7443479d95928a16711696af6523999a717"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/sse/event.go pkg/sse/event_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/sse/event.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 100.0
mutation_kill_rate = 0.0
original_mutation_kill_rate = 100.0
covered_lines = []
missed_lines = [ 18, 19, 20, 21, 22, 23, 24, 25,]

[input_info]
test_file_path = "pkg/sse/event_test.go"
focal_file_path = "pkg/sse/event.go"
test_file_url = "https://github.com/go-dev-frame/sponge/blob/e72bb7443479d95928a16711696af6523999a717/pkg/sse/event_test.go"
focal_file_url = "https://github.com/go-dev-frame/sponge/blob/e72bb7443479d95928a16711696af6523999a717/pkg/sse/event.go"
first_commit_date = "2025-06-21"
last_commit_date = "2025-06-21"
test_file_content = "package sse\n\nimport (\n\t\"context\"\n\t\"sync\"\n\t\"testing\"\n)\n\n\ntype mockStore struct {\n\tmu     sync.RWMutex\n\tevents map[string][]*Event\n}\n\nfunc newMockStore() *mockStore {\n\treturn &mockStore{\n\t\tevents: make(map[string][]*Event),\n\t}\n}\n\nfunc (m *mockStore) Save(_ context.Context, e *Event) error {\n\tm.mu.Lock()\n\tif _, ok := m.events[e.Event]; !ok {\n\t\tm.events[e.Event] = make([]*Event, 0)\n\t}\n\tm.events[e.Event] = append(m.events[e.Event], e)\n\tm.mu.Unlock()\n\treturn nil\n}\n\nfunc (m *mockStore) GetSince(_ context.Context, eventType string, lastID string) ([]*Event, error) {\n\tm.mu.RLock()\n\tvar result []*Event\n\tif events, ok := m.events[eventType]; ok {\n\t\tfor _, e := range events {\n\t\t\tif e.ID > lastID {\n\t\t\t\tresult = append(result, e)\n\t\t\t}\n\t\t}\n\t}\n\tm.mu.RUnlock()\n\treturn result, nil\n}\n\nfunc TestStore(t *testing.T) {\n\tstore := newMockStore()\n\tevent1 := &Event{\n\t\tID:    \"1\",\n\t\tEvent: \"test\",\n\t\tData:  \"test data\",\n\t}\n\tevent2 := &Event{\n\t\tID:    \"2\",\n\t\tEvent: \"test\",\n\t\tData:  \"test data\",\n\t}\n\tevent3 := &Event{\n\t\tID:    \"3\",\n\t\tEvent: \"test\",\n\t\tData:  \"test data\",\n\t}\n\n\tctx := context.Background()\n\t_ = store.Save(ctx, event1)\n\t_ = store.Save(ctx, event2)\n\t_ = store.Save(ctx, event3)\n\tevents, _ := store.GetSince(ctx, \"test\", \"0\")\n\tif len(events) != 3 {\n\t\tt.Errorf(\"Expected 3 events, got %d\", len(events))\n\t}\n}\n\n// -------------------------------------------------------------------------------------\n\ntype memoryStore struct {\n\tmu     sync.RWMutex\n\tevents map[string][]*Event\n}\n\nfunc NewMemoryStore() Store {\n\treturn &memoryStore{\n\t\tevents: make(map[string][]*Event),\n\t}\n}\n\nfunc (m *memoryStore) Save(_ context.Context, e *Event) error {\n\tm.mu.Lock()\n\tm.events[e.Event] = append(m.events[e.Event], e)\n\tm.mu.Unlock()\n\treturn nil\n}\n\nfunc (m *memoryStore) ListByLastID(_ context.Context, eventType string, lastID string, pageSize int) ([]*Event, string, error) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\n\tvar result []*Event\n\tvar nextID string\n\n\tif events, ok := m.events[eventType]; ok {\n\t\t// find the starting position\n\t\tstart := 0\n\t\tif lastID != \"\" {\n\t\t\tfor i, e := range events {\n\t\t\t\tif e.ID > lastID {\n\t\t\t\t\tstart = i\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// get pagination data\n\t\tend := start + pageSize\n\t\tif end > len(events) {\n\t\t\tend = len(events)\n\t\t} else if end < len(events) {\n\t\t\tnextID = events[end].ID\n\t\t}\n\n\t\tresult = events[start:end]\n\t}\n\n\treturn result, nextID, nil\n}\n\n// -------------------------------------------------------------------------------------\n\n// redis store example\n\n//type redisStore struct {\n//\tclient *redis.Client\n//\texpire time.Duration\n//}\n//\n//func NewRedisStore(addr, password string, expire time.Duration) Store {\n//\trdb := redis.NewClient(&redis.Options{\n//\t\tAddr:     addr,\n//\t\tPassword: password,\n//\t})\n//\treturn &redisStore{client: rdb, expire: expire}\n//}\n//\n//func (s *redisStore) Save(ctx context.Context, e *Event) error {\n//\tkey := fmt.Sprintf(\"sse:%s\", e.Event)\n//\tb, _ := json.Marshal(e)\n//\ts.client.RPush(ctx, key, b)\n//\ts.client.Expire(ctx, key, s.expire)\n//\treturn nil\n//}\n//\n//func (s *redisStore) ListByLastID(ctx context.Context, eventType string, lastID string, pageSize int) ([]*Event, string, error) {\n//\tkey := fmt.Sprintf(\"sse:%s\", eventType)\n//\n//\t// get the total number of events\n//\ttotal, err := s.client.LLen(ctx, key).Result()\n//\tif err != nil {\n//\t\treturn nil, \"\", err\n//\t}\n//\n//\t// if no lastID is specified, start from 0\n//\tstart := int64(0)\n//\tif lastID != \"\" {\n//\t\t// use binary search to locate the position of lastID\n//\t\tlow := int64(0)\n//\t\thigh := total - 1\n//\t\tfound := false\n//\n//\t\tfor low <= high {\n//\t\t\tmid := (low + high) / 2\n//\t\t\tval, err := s.client.LIndex(ctx, key, mid).Result()\n//\t\t\tif err != nil {\n//\t\t\t\treturn nil, \"\", err\n//\t\t\t}\n//\n//\t\t\te := &Event{}\n//\t\t\tif err = json.Unmarshal([]byte(val), e); err != nil {\n//\t\t\t\treturn nil, \"\", err\n//\t\t\t}\n//\n//\t\t\tcmp := strings.Compare(e.ID, lastID)\n//\t\t\tif cmp == 0 {\n//\t\t\t\tstart = mid + 1\n//\t\t\t\tfound = true\n//\t\t\t\tbreak\n//\t\t\t} else if cmp < 0 {\n//\t\t\t\tlow = mid + 1\n//\t\t\t} else {\n//\t\t\t\thigh = mid - 1\n//\t\t\t}\n//\t\t}\n//\n//\t\tif !found {\n//\t\t\t// if not found lastID, return empty\n//\t\t\treturn nil, \"\", nil\n//\t\t}\n//\t}\n//\n//\tend := start + int64(pageSize) - 1\n//\tif end >= total {\n//\t\tend = total - 1\n//\t}\n//\n//\t// get the pagination data\n//\tvalues, err := s.client.LRange(ctx, key, start, end).Result()\n//\tif err != nil {\n//\t\treturn nil, \"\", err\n//\t}\n//\n//\tvar result []*Event\n//\tfor _, v := range values {\n//\t\te := &Event{}\n//\t\tif err = json.Unmarshal([]byte(v), e); err == nil {\n//\t\t\tresult = append(result, e)\n//\t\t}\n//\t}\n//\n//\t// calculate the next pagination start ID\n//\tvar nextID string\n//\tif end+1 < total {\n//\t\tnextVal, err := s.client.LIndex(ctx, key, end+1).Result()\n//\t\tif err == nil {\n//\t\t\te := &Event{}\n//\t\t\tif err = json.Unmarshal([]byte(nextVal), e); err == nil {\n//\t\t\t\tnextID = e.ID\n//\t\t\t}\n//\t\t}\n//\t}\n//\n//\treturn result, nextID, nil\n//}\n"
