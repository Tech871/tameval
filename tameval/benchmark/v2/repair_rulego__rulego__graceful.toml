[meta]
task = "repair"
scenario = "repair_syntax_error"

[lang_info]
lang = "Go"
go_version = "1.20"

[repo_info]
repository = "rulego/rulego"
sha = "22ba0b1e693a9fafb84858dffec8ff8cf5509925"

[run_info]
docker_image = "golang:1.23.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out components/base/graceful.go components/base/graceful_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting components/base/graceful.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 58.0
mutation_kill_rate = nan
original_mutation_kill_rate = 47.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "components/base/graceful_test.go"
focal_file_path = "components/base/graceful.go"
test_file_url = "https://github.com/rulego/rulego/blob/22ba0b1e693a9fafb84858dffec8ff8cf5509925/components/base/graceful_test.go"
focal_file_url = "https://github.com/rulego/rulego/blob/22ba0b1e693a9fafb84858dffec8ff8cf5509925/components/base/graceful.go"
first_commit_date = "2025-07-05"
last_commit_date = "2025-07-05"
test_file_content = "/*\n * Copyright 2024 The RuleGo Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http:\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage base\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/rulego/rulego/test/assert\"\n)\ntype mockLogger struct {\n\tmessages []string\n\tmu       sync.Mutex\n}\n\nfunc (m *mockLogger) Printf(format string, v ...interface{}) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.messages = append(m.messages, fmt.Sprintf(format, v...))\n}\n\nfunc (m *mockLogger) Print(v ...interface{}) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.messages = append(m.messages, fmt.Sprint(v...))\n}\n\nfunc (m *mockLogger) GetMessages() []string {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\treturn append([]string(nil), m.messages...)\n}\n\nfunc (m *mockLogger) Clear() {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.messages = nil\n}\nfunc TestGracefulShutdownBasicFunctionality(t *testing.T) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(logger, 5*time.Second)\n\tassert.False(t, graceful.IsShuttingDown())\n\tctx := graceful.GetShutdownContext()\n\tassert.NotNil(t, ctx)\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tt.Error(\"Context should not be cancelled initially\")\n\tdefault:\n\t}\n\terr := graceful.CheckShutdownSignal()\n\tassert.Nil(t, err)\n\tstopCalled := false\n\tgraceful.GracefulStop(func() {\n\t\tstopCalled = true\n\t})\n\tassert.True(t, graceful.IsShuttingDown())\n\tselect {\n\tcase <-ctx.Done():\n\t\tt.Error(\"Context should not be cancelled in phase 1 of graceful shutdown\")\n\tdefault:\n\t}\n\terr = graceful.CheckShutdownSignal()\n\tassert.NotNil(t, err)\n\tassert.True(t, strings.Contains(err.Error(), \"operation cancelled due to shutdown\"))\n\tassert.True(t, stopCalled)\n\tgraceful.ForceStop()\n\tselect {\n\tcase <-ctx.Done():\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Error(\"Context should be cancelled after ForceStop\")\n\t}\n}\nfunc TestGracefulShutdownDefaultTimeout(t *testing.T) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(logger, 0)\n\tassert.Equal(t, DefaultShutdownTimeout, graceful.shutdownTimeout)\n}\nfunc TestGracefulShutdownCustomTimeout(t *testing.T) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\n\tcustomTimeout := 10 * time.Second\n\tgraceful.InitGracefulShutdown(logger, customTimeout)\n\n\tassert.Equal(t, customTimeout, graceful.shutdownTimeout)\n}\nfunc TestGracefulShutdownConcurrentOperations(t *testing.T) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(logger, 5*time.Second)\n\n\tconst concurrentOperations = 100\n\tvar wg sync.WaitGroup\n\tvar successfulChecks int64\n\tvar shutdownChecks int64\n\n\twg.Add(concurrentOperations)\n\tfor i := 0; i < concurrentOperations; i++ {\n\t\tgo func(index int) {\n\t\t\tdefer wg.Done()\n\t\t\ttime.Sleep(time.Millisecond * time.Duration(index%10))\n\t\t\tif err := graceful.CheckShutdownSignal(); err != nil {\n\t\t\t\tatomic.AddInt64(&shutdownChecks, 1)\n\t\t\t} else {\n\t\t\t\tatomic.AddInt64(&successfulChecks, 1)\n\t\t\t}\n\t\t\t_ = graceful.IsShuttingDown()\n\t\t\t_ = graceful.GetShutdownContext()\n\t\t}(i)\n\t}\n\ttime.Sleep(50 * time.Millisecond)\n\tstopCalled := int32(0)\n\tgraceful.GracefulStop(func() {\n\t\tatomic.StoreInt32(&stopCalled, 1)\n\t})\n\n\twg.Wait()\n\tassert.Equal(t, int32(1), atomic.LoadInt32(&stopCalled))\n\tassert.True(t, graceful.IsShuttingDown())\n\ttotalChecks := atomic.LoadInt64(&successfulChecks) + atomic.LoadInt64(&shutdownChecks)\n\tassert.Equal(t, int64(concurrentOperations), totalChecks)\n}\nfunc TestGracefulShutdownMultipleStopCalls(t *testing.T) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(logger, 1*time.Second)\n\n\tvar stopCallCount int64\n\tstopFunc := func() {\n\t\tatomic.AddInt64(&stopCallCount, 1)\n\t}\n\tconst numCalls = 10\n\tvar wg sync.WaitGroup\n\twg.Add(numCalls)\n\n\tfor i := 0; i < numCalls; i++ {\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tgraceful.GracefulStop(stopFunc)\n\t\t}()\n\t}\n\n\twg.Wait()\n\tassert.Equal(t, int64(1), atomic.LoadInt64(&stopCallCount))\n\tassert.True(t, graceful.IsShuttingDown())\n}\nfunc TestGracefulShutdownWithNilStopFunc(t *testing.T) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(logger, 1*time.Second)\n\tgraceful.GracefulStop(nil)\n\tassert.True(t, graceful.IsShuttingDown())\n\tctx := graceful.GetShutdownContext()\n\tselect {\n\tcase <-ctx.Done():\n\t\tt.Error(\"Context should not be cancelled in phase 1 of graceful shutdown\")\n\tdefault:\n\t}\n\terr := graceful.CheckShutdownSignal()\n\tassert.NotNil(t, err)\n\tassert.True(t, strings.Contains(err.Error(), \"operation cancelled due to shutdown\"))\n\tgraceful.ForceStop()\n\tselect {\n\tcase <-ctx.Done():\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Error(\"Context should be cancelled after ForceStop\")\n\t}\n}\nfunc TestGracefulShutdownWithTimeout(t *testing.T) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(logger, 200*time.Millisecond)\n\n\tvar stopCalled int64\n\tstartTime := time.Now()\n\n\tgraceful.GracefulStop(func() {\n\t\tatomic.StoreInt64(&stopCalled, 1)\n\t\ttime.Sleep(150 * time.Millisecond)\n\t})\n\n\tendTime := time.Now()\n\telapsed := endTime.Sub(startTime)\n\tassert.Equal(t, int64(1), atomic.LoadInt64(&stopCalled))\n\tassert.True(t, elapsed >= 100*time.Millisecond, \"Shutdown took too little time: %v\", elapsed)\n\tassert.True(t, elapsed <= 300*time.Millisecond, \"Shutdown took too long: %v\", elapsed)\n\tassert.True(t, graceful.IsShuttingDown())\n}\nfunc TestCheckShutdownContext(t *testing.T) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(logger, 5*time.Second)\n\tnormalCtx := context.Background()\n\terr := graceful.CheckShutdownContext(normalCtx)\n\tassert.Nil(t, err)\n\terr = graceful.CheckShutdownContext(nil)\n\tassert.Nil(t, err)\n\tcancelledCtx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\tselect {\n\tcase <-cancelledCtx.Done():\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatal(\"Context should have been cancelled\")\n\t}\n\terr = graceful.CheckShutdownContext(cancelledCtx)\n\tassert.NotNil(t, err)\n\tif err != nil {\n\t\tassert.True(t, strings.Contains(err.Error(), \"operation cancelled\"))\n\t}\n\ttimeoutCtx, cancelTimeout := context.WithTimeout(context.Background(), time.Millisecond)\n\tdefer cancelTimeout()\n\tselect {\n\tcase <-timeoutCtx.Done():\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatal(\"Context should have timed out\")\n\t}\n\terr = graceful.CheckShutdownContext(timeoutCtx)\n\tassert.NotNil(t, err)\n\tif err != nil {\n\t\tassert.True(t, strings.Contains(err.Error(), \"operation cancelled\"))\n\t}\n}\nfunc TestGracefulShutdownIntegrationWithComponents(t *testing.T) {\n\ttype TestComponent struct {\n\t\t*GracefulShutdown\n\t\trunning       int32\n\t\toperationDone chan struct{}\n\t}\n\n\tlogger := &mockLogger{}\n\tcomponent := &TestComponent{\n\t\tGracefulShutdown: &GracefulShutdown{},\n\t\toperationDone:    make(chan struct{}),\n\t}\n\n\tcomponent.InitGracefulShutdown(logger, 2*time.Second)\n\tatomic.StoreInt32(&component.running, 1)\n\tgo func() {\n\t\tdefer close(component.operationDone)\n\t\tdefer atomic.StoreInt32(&component.running, 0)\n\n\t\tfor {\n\t\t\tif err := component.CheckShutdownSignal(); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t}()\n\ttime.Sleep(50 * time.Millisecond)\n\tassert.Equal(t, int32(1), atomic.LoadInt32(&component.running))\n\tcomponent.GracefulStop(func() {\n\t\t<-component.operationDone\n\t})\n\tassert.Equal(t, int32(0), atomic.LoadInt32(&component.running))\n\tassert.True(t, component.IsShuttingDown())\n\tselect {\n\tcase <-component.operationDone:\n\tdefault:\n\t\tt.Error(\"Operation should have completed\")\n\t}\n}\nfunc TestGracefulShutdownWithSimulatedWork(t *testing.T) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(logger, 1*time.Second)\n\n\tvar activeOperations int64\n\tvar completedOperations int64\n\tvar shutdownDetected int64\n\n\tconst numWorkers = 20\n\tvar wg sync.WaitGroup\n\twg.Add(numWorkers)\n\tfor i : 0; i < numWorkers; i++ {\n\t\tgo func(workerID int) {\n\t\t\tdefer wg.Done()\n\t\t\tatomic.AddInt64(&activeOperations, 1)\n\t\t\tdefer atomic.AddInt64(&activeOperations, -1)\n\t\t\tfor j := 0; j < 100; j++ {\n\t\t\t\tif err := graceful.CheckShutdownSignal(); err != nil {\n\t\t\t\t\tatomic.AddInt64(&shutdownDetected, 1)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t}\n\n\t\t\tatomic.AddInt64(&completedOperations, 1)\n\t\t}(i)\n\t}\n\ttime.Sleep(100 * time.Millisecond)\n\tassert.True(t, atomic.LoadInt64(&activeOperations) > 0)\n\tstartShutdown := time.Now()\n\tgraceful.GracefulStop(func() {\n\t\twg.Wait()\n\t})\n\tshutdownTime := time.Since(startShutdown)\n\tassert.True(t, graceful.IsShuttingDown())\n\tassert.True(t, atomic.LoadInt64(&shutdownDetected) > 0)\n\ttotal := atomic.LoadInt64(&completedOperations) + atomic.LoadInt64(&shutdownDetected)\n\tassert.Equal(t, int64(numWorkers), total)\n\tassert.True(t, shutdownTime < 5*time.Second, \"Shutdown took too long: %v\", shutdownTime)\n\tassert.Equal(t, int64(0), atomic.LoadInt64(&activeOperations))\n}\nfunc TestGracefulShutdownLogging(t *testing.T) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(logger, 100*time.Millisecond)\n\tdone := make(chan struct{})\n\tgraceful.GracefulStop(func() {\n\t\tselect {\n\t\tcase <-done:\n\t\tcase <-time.After(200 * time.Millisecond):\n\t\t}\n\t})\n\ttime.Sleep(50 * time.Millisecond)\n\tassert.True(t, graceful.IsShuttingDown(), \"Should be in shutdown state\")\n}\nfunc TestGracefulShutdownWithNilLogger(t *testing.T) {\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(nil, 100*time.Millisecond)\n\tstopCalled := false\n\tgraceful.GracefulStop(func() {\n\t\tstopCalled = true\n\t})\n\n\tassert.True(t, stopCalled)\n\tassert.True(t, graceful.IsShuttingDown())\n}\nfunc BenchmarkGracefulShutdownCheckSignal(b *testing.B) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(logger, 5*time.Second)\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = graceful.CheckShutdownSignal()\n\t\t}\n\t})\n}\nfunc BenchmarkGracefulShutdownIsShuttingDown(b *testing.B) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(logger, 5*time.Second)\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = graceful.IsShuttingDown()\n\t\t}\n\t})\n}\nfunc BenchmarkGracefulShutdownConcurrentAccess(b *testing.B) {\n\tlogger := &mockLogger{}\n\tgraceful := &GracefulShutdown{}\n\tgraceful.InitGracefulShutdown(logger, 5*time.Second)\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = graceful.IsShuttingDown()\n\t\t\t_ = graceful.CheckShutdownSignal()\n\t\t\t_ = graceful.GetShutdownContext()\n\t\t}\n\t})\n}\nfunc TestContextUtilsCheckContext(t *testing.T) {\n\terr := ContextUtils.CheckContext(nil, \"test operation\")\n\tassert.Nil(t, err)\n\tctx := context.Background()\n\terr = ContextUtils.CheckContext(ctx, \"test operation\")\n\tassert.Nil(t, err)\n\tcancelledCtx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\terr = ContextUtils.CheckContext(cancelledCtx, \"test operation\")\n\tassert.NotNil(t, err)\n\tassert.True(t, strings.Contains(err.Error(), \"test operation cancelled\"))\n\tassert.True(t, strings.Contains(err.Error(), \"context canceled\"))\n\terr = ContextUtils.CheckContext(cancelledCtx, \"\")\n\tassert.NotNil(t, err)\n\tassert.True(t, strings.Contains(err.Error(), \"operation cancelled\"))\n}\nfunc TestContextUtilsCheckContextWithTimeout(t *testing.T) {\n\terr := ContextUtils.CheckContextWithTimeout(nil, time.Second, \"test operation\")\n\tassert.Nil(t, err)\n\tctx := context.Background()\n\terr = ContextUtils.CheckContextWithTimeout(ctx, 100*time.Millisecond, \"test operation\")\n\tassert.Nil(t, err)\n\tcancelledCtx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\tselect {\n\tcase <-cancelledCtx.Done():\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatal(\"Context should have been cancelled\")\n\t}\n\terr = ContextUtils.CheckContextWithTimeout(cancelledCtx, time.Second, \"test operation\")\n\tassert.NotNil(t, err)\n\tassert.True(t, strings.Contains(err.Error(), \"test operation cancelled\"))\n\ttimeoutCtx, cancelTimeout := context.WithTimeout(context.Background(), 10*time.Millisecond)\n\tdefer cancelTimeout()\n\tselect {\n\tcase <-timeoutCtx.Done():\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatal(\"Context should have timed out\")\n\t}\n\terr = ContextUtils.CheckContextWithTimeout(timeoutCtx, time.Second, \"timeout operation\")\n\tassert.NotNil(t, err)\n\tassert.True(t, strings.Contains(err.Error(), \"timeout operation cancelled\"))\n}\nfunc TestContextUtilsShouldStop(t *testing.T) {\n\tshouldStop := ContextUtils.ShouldStop(nil)\n\tassert.False(t, shouldStop)\n\tctx := context.Background()\n\tshouldStop = ContextUtils.ShouldStop(ctx)\n\tassert.False(t, shouldStop)\n\tcancelledCtx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\tselect {\n\tcase <-cancelledCtx.Done():\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatal(\"Context should have been cancelled\")\n\t}\n\tshouldStop = ContextUtils.ShouldStop(cancelledCtx)\n\tassert.True(t, shouldStop)\n\ttimeoutCtx, cancelTimeout := context.WithTimeout(context.Background(), time.Millisecond)\n\tdefer cancelTimeout()\n\tselect {\n\tcase <-timeoutCtx.Done():\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatal(\"Context should have timed out\")\n\t}\n\tshouldStop = ContextUtils.ShouldStop(timeoutCtx)\n\tassert.True(t, shouldStop)\n}\nfunc TestContextUtilsWithGracefulShutdown(t *testing.T) {\n\toperationCalled := false\n\toperationFunc := func() error {\n\t\toperationCalled = true\n\t\treturn nil\n\t}\n\tctx := context.Background()\n\terr := ContextUtils.WithGracefulShutdown(ctx, operationFunc)\n\tassert.Nil(t, err)\n\tassert.True(t, operationCalled)\n\toperationCalled = false\n\tcancelledCtx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\terr = ContextUtils.WithGracefulShutdown(cancelledCtx, operationFunc)\n\tassert.NotNil(t, err)\n\tassert.False(t, operationCalled)\n\tassert.True(t, strings.Contains(err.Error(), \"operation cancelled\"))\n\toperationWithError := func() error {\n\t\treturn fmt.Errorf(\"operation error\")\n\t}\n\terr = ContextUtils.WithGracefulShutdown(context.Background(), operationWithError)\n\tassert.NotNil(t, err)\n\tassert.True(t, strings.Contains(err.Error(), \"operation error\"))\n}\nfunc TestContextUtilsIsContextCancelled(t *testing.T) {\n\tcancelled, err := ContextUtils.IsContextCancelled(nil)\n\tassert.False(t, cancelled)\n\tassert.Nil(t, err)\n\tctx := context.Background()\n\tcancelled, err = ContextUtils.IsContextCancelled(ctx)\n\tassert.False(t, cancelled)\n\tassert.Nil(t, err)\n\tcancelledCtx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\tselect {\n\tcase <-cancelledCtx.Done():\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatal(\"Context should have been cancelled\")\n\t}\n\tcancelled, err = ContextUtils.IsContextCancelled(cancelledCtx)\n\tassert.True(t, cancelled)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, context.Canceled, err)\n\ttimeoutCtx, cancelTimeout := context.WithTimeout(context.Background(), time.Millisecond)\n\tdefer cancelTimeout()\n\tselect {\n\tcase <-timeoutCtx.Done():\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatal(\"Context should have timed out\")\n\t}\n\tcancelled, err = ContextUtils.IsContextCancelled(timeoutCtx)\n\tassert.True(t, cancelled)\n\tassert.NotNil(t, err)\n\tassert.Equal(t, context.DeadlineExceeded, err)\n}\nfunc TestContextUtilsConcurrentAccess(t *testing.T) {\n\tconst numGoroutines = 100\n\tvar wg sync.WaitGroup\n\twg.Add(numGoroutines)\n\n\tctx := context.Background()\n\tcancelledCtx, cancel := context.WithCancel(context.Background())\n\tcancel()\n\n\tfor i := 0; i < numGoroutines; i++ {\n\t\tgo func(index int) {\n\t\t\tdefer wg.Done()\n\t\t\t_ = ContextUtils.CheckContext(ctx, \"concurrent test\")\n\t\t\t_ = ContextUtils.ShouldStop(ctx)\n\t\t\t_, _ = ContextUtils.IsContextCancelled(ctx)\n\n\t\t\tif index%2 == 0 {\n\t\t\t\t_ = ContextUtils.CheckContext(cancelledCtx, \"concurrent test\")\n\t\t\t\t_ = ContextUtils.ShouldStop(cancelledCtx)\n\t\t\t\t_, _ = ContextUtils.IsContextCancelled(cancelledCtx)\n\t\t\t}\n\t\t}(i)\n\t}\n\n\twg.Wait()\n}\nfunc TestContextUtilsIntegrationWithRealScenarios(t *testing.T) {\n\ttype ComponentOperation struct {\n\t\tcheckPoints []string\n\t\terrors      []error\n\t\tmu          sync.Mutex\n\t}\n\n\toperation := &ComponentOperation{}\n\n\tcheckAndRecord := func(ctx context.Context, checkPoint string) error {\n\t\terr := ContextUtils.CheckContext(ctx, checkPoint)\n\t\toperation.mu.Lock()\n\t\toperation.checkPoints = append(operation.checkPoints, checkPoint)\n\t\toperation.errors = append(operation.errors, err)\n\t\toperation.mu.Unlock()\n\t\treturn err\n\t}\n\tctx := context.Background()\n\n\terr := checkAndRecord(ctx, \"initialization\")\n\tassert.Nil(t, err)\n\n\terr = checkAndRecord(ctx, \"data validation\")\n\tassert.Nil(t, err)\n\n\terr = checkAndRecord(ctx, \"processing\")\n\tassert.Nil(t, err)\n\n\toperation.mu.Lock()\n\tassert.Equal(t, 3, len(operation.checkPoints))\n\tassert.Equal(t, []string{\"initialization\", \"data validation\", \"processing\"}, operation.checkPoints)\n\tfor _, err := range operation.errors {\n\t\tassert.Nil(t, err)\n\t}\n\toperation.mu.Unlock()\n\toperation.checkPoints = nil\n\toperation.errors = nil\n\tcancelledCtx, cancel := context.WithCancel(context.Background())\n\n\terr = checkAndRecord(cancelledCtx, \"initialization\")\n\tassert.Nil(t, err)\n\tcancel()\n\n\terr = checkAndRecord(cancelledCtx, \"data validation\")\n\tassert.NotNil(t, err)\n\tassert.True(t, strings.Contains(err.Error(), \"data validation cancelled\"))\n\n\toperation.mu.Lock()\n\tassert.Equal(t, 2, len(operation.checkPoints))\n\tassert.Equal(t, []string{\"initialization\", \"data validation\"}, operation.checkPoints)\n\tassert.Nil(t, operation.errors[0])\n\tassert.NotNil(t, operation.errors[1])\n\toperation.mu.Unlock()\n}\nfunc BenchmarkContextUtilsCheckContext(b *testing.B) {\n\tctx := context.Background()\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = ContextUtils.CheckContext(ctx, \"benchmark test\")\n\t\t}\n\t})\n}\nfunc BenchmarkContextUtilsShouldStop(b *testing.B) {\n\tctx := context.Background()\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_ = ContextUtils.ShouldStop(ctx)\n\t\t}\n\t})\n}\nfunc BenchmarkContextUtilsIsContextCancelled(b *testing.B) {\n\tctx := context.Background()\n\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\t_, _ = ContextUtils.IsContextCancelled(ctx)\n\t\t}\n\t})\n}"
