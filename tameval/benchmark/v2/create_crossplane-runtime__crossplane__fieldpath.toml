[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "crossplane/crossplane-runtime"
sha = "5eca3444c2f11ff8326b6f355877961a52552d05"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/fieldpath/fieldpath.go pkg/fieldpath/fieldpath_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/fieldpath/fieldpath.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 90.0
original_coverage = 100.0
mutation_kill_rate = 78.0
original_mutation_kill_rate = 89.0
covered_lines = [ 98, 99, 100, 101, 102, 103, 104, 108, 113, 114, 115, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 135, 175, 176, 177, 178, 180, 183, 184, 185, 186, 187, 189, 190, 191, 194, 195, 196, 197, 199, 200, 201, 203, 204, 207, 208, 209, 210, 211, 214, 215, 216, 217, 218, 223, 224, 225, 226, 227, 230, 231, 232, 233, 234, 236, 237, 238, 239, 240, 241, 242, 243, 244, 246, 247, 248, 250, 253, 254, 255, 256, 257, 259, 260, 261, 262, 267, 268, 269, 270, 271, 272, 273, 274, 275, 278, 279, 280, 283, 284, 285, 286, 289, 290, 291, 292, 293, 294,]
missed_lines = [ 74, 75, 76, 77, 78, 79, 80, 81, 82, 85, 86, 87, 91,]

[input_info]
test_file_path = "pkg/fieldpath/fieldpath_test.go"
focal_file_path = "pkg/fieldpath/fieldpath.go"
test_file_url = "https://github.com/crossplane/crossplane-runtime/blob/5eca3444c2f11ff8326b6f355877961a52552d05/pkg/fieldpath/fieldpath_test.go"
focal_file_url = "https://github.com/crossplane/crossplane-runtime/blob/5eca3444c2f11ff8326b6f355877961a52552d05/pkg/fieldpath/fieldpath.go"
first_commit_date = "2020-02-25"
last_commit_date = "2025-07-30"
test_file_content = "/*\nCopyright 2019 The Crossplane Authors.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\npackage fieldpath\n\nimport (\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\n\t\"github.com/crossplane/crossplane-runtime/v2/pkg/errors\"\n\t\"github.com/crossplane/crossplane-runtime/v2/pkg/test\"\n)\n\n\n\nfunc TestParse(t *testing.T) {\n\ttype want struct {\n\t\ts   Segments\n\t\terr error\n\t}\n\n\tcases := map[string]struct {\n\t\treason string\n\t\tpath   string\n\t\twant   want\n\t}{\n\t\t\"SingleField\": {\n\t\t\treason: \"A path with no brackets or periods should be interpreted as a single field segment\",\n\t\t\tpath:   \"spec\",\n\t\t\twant: want{\n\t\t\t\ts: Segments{Field(\"spec\")},\n\t\t\t},\n\t\t},\n\t\t\"SingleIndex\": {\n\t\t\treason: \"An integer surrounded by brackets should be interpreted as an index\",\n\t\t\tpath:   \"[0]\",\n\t\t\twant: want{\n\t\t\t\ts: Segments{FieldOrIndex(\"0\")},\n\t\t\t},\n\t\t},\n\t\t\"TwoFields\": {\n\t\t\treason: \"A path with one period should be interpreted as two field segments\",\n\t\t\tpath:   \"metadata.name\",\n\t\t\twant: want{\n\t\t\t\ts: Segments{Field(\"metadata\"), Field(\"name\")},\n\t\t\t},\n\t\t},\n\t\t\"APIConventionsExample\": {\n\t\t\treason: \"The example given by the Kubernetes API convention should be parse correctly\",\n\t\t\tpath:   \"fields[1].state.current\",\n\t\t\twant: want{\n\t\t\t\ts: Segments{\n\t\t\t\t\tField(\"fields\"),\n\t\t\t\t\tFieldOrIndex(\"1\"),\n\t\t\t\t\tField(\"state\"),\n\t\t\t\t\tField(\"current\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"SimpleIndex\": {\n\t\t\treason: \"Indexing an object field that is an array should result in a field and an index\",\n\t\t\tpath:   \"items[0]\",\n\t\t\twant: want{\n\t\t\t\ts: Segments{Field(\"items\"), FieldOrIndex(\"0\")},\n\t\t\t},\n\t\t},\n\t\t\"FieldsAndIndex\": {\n\t\t\treason: \"A path with periods and braces should be interpreted as fields and indices\",\n\t\t\tpath:   \"spec.containers[0].name\",\n\t\t\twant: want{\n\t\t\t\ts: Segments{\n\t\t\t\t\tField(\"spec\"),\n\t\t\t\t\tField(\"containers\"),\n\t\t\t\t\tFieldOrIndex(\"0\"),\n\t\t\t\t\tField(\"name\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"NestedArray\": {\n\t\t\treason: \"A nested array should result in two consecutive index fields\",\n\t\t\tpath:   \"nested[0][1].name\",\n\t\t\twant: want{\n\t\t\t\ts: Segments{\n\t\t\t\t\tField(\"nested\"),\n\t\t\t\t\tFieldOrIndex(\"0\"),\n\t\t\t\t\tFieldOrIndex(\"1\"),\n\t\t\t\t\tField(\"name\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"BracketStyleField\": {\n\t\t\treason: \"A field name can be specified using brackets rather than a period\",\n\t\t\tpath:   \"spec[containers][0].name\",\n\t\t\twant: want{\n\t\t\t\ts: Segments{\n\t\t\t\t\tField(\"spec\"),\n\t\t\t\t\tField(\"containers\"),\n\t\t\t\t\tFieldOrIndex(\"0\"),\n\t\t\t\t\tField(\"name\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"BracketFieldWithPeriod\": {\n\t\t\treason: \"A field name specified using brackets can include a period\",\n\t\t\tpath:   \"data[.config.yml]\",\n\t\t\twant: want{\n\t\t\t\ts: Segments{\n\t\t\t\t\tField(\"data\"),\n\t\t\t\t\tFieldOrIndex(\".config.yml\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"QuotedFieldWithPeriodInBracket\": {\n\t\t\treason: \"A field name specified using quote and in bracket can include a period\",\n\t\t\tpath:   \"metadata.labels['app.hash']\",\n\t\t\twant: want{\n\t\t\t\ts: Segments{\n\t\t\t\t\tField(\"metadata\"),\n\t\t\t\t\tField(\"labels\"),\n\t\t\t\t\tFieldOrIndex(\"app.hash\"),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t\"LeadingPeriod\": {\n\t\t\treason: \"A path may not start with a period (unlike a JSON path)\",\n\t\t\tpath:   \".metadata.name\",\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"unexpected '.' at position 0\"),\n\t\t\t},\n\t\t},\n\t\t\"TrailingPeriod\": {\n\t\t\treason: \"A path may not end with a period\",\n\t\t\tpath:   \"metadata.name.\",\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"unexpected '.' at position 13\"),\n\t\t\t},\n\t\t},\n\t\t\"BracketsFollowingPeriod\": {\n\t\t\treason: \"Brackets may not follow a period\",\n\t\t\tpath:   \"spec.containers.[0].name\",\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"unexpected '[' at position 16\"),\n\t\t\t},\n\t\t},\n\t\t\"DoublePeriod\": {\n\t\t\treason: \"A path may not include two consecutive periods\",\n\t\t\tpath:   \"metadata..name\",\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"unexpected '.' at position 9\"),\n\t\t\t},\n\t\t},\n\t\t\"DanglingRightBracket\": {\n\t\t\treason: \"A right bracket may not appear in a field name\",\n\t\t\tpath:   \"metadata.]name\",\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"unexpected ']' at position 9\"),\n\t\t\t},\n\t\t},\n\t\t\"DoubleOpenBracket\": {\n\t\t\treason: \"Brackets may not be nested\",\n\t\t\tpath:   \"spec[bracketed[name]]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"unexpected '[' at position 14\"),\n\t\t\t},\n\t\t},\n\t\t\"DanglingLeftBracket\": {\n\t\t\treason: \"A left bracket must be closed\",\n\t\t\tpath:   \"spec[name\",\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"unterminated '[' at position 4\"),\n\t\t\t},\n\t\t},\n\t\t\"EmptyBracket\": {\n\t\t\treason: \"Brackets may not be empty\",\n\t\t\tpath:   \"spec[]\",\n\t\t\twant: want{\n\t\t\t\terr: errors.New(\"unexpected ']' at position 5\"),\n\t\t\t},\n\t\t},\n\t}\n\tfor name, tc := range cases {\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot, err := Parse(tc.path)\n\t\t\tif diff := cmp.Diff(tc.want.err, err, test.EquateErrors()); diff != \"\" {\n\t\t\t\tt.Fatalf(\"\\nParse(%s): %s: -want error, +got error:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(tc.want.s, got); diff != \"\" {\n\t\t\t\tt.Errorf(\"\\nParse(%s): %s: -want, +got:\\n%s\", tc.path, tc.reason, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n"
