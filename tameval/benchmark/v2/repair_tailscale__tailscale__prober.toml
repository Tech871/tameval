[meta]
task = "repair"
scenario = "repair_undefined_enitity"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "tailscale/tailscale"
sha = "6bbf98bef457b4403f27da79eb1861e6197ab539"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/zimmski/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out prober/prober.go prober/prober_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting prober/prober.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0.0
original_coverage = 82.0
mutation_kill_rate = nan
original_mutation_kill_rate = nan
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "prober/prober_test.go"
focal_file_path = "prober/prober.go"
test_file_url = "https://github.com/tailscale/tailscale/blob/6bbf98bef457b4403f27da79eb1861e6197ab539/prober/prober_test.go"
focal_file_url = "https://github.com/tailscale/tailscale/blob/6bbf98bef457b4403f27da79eb1861e6197ab539/prober/prober.go"
first_commit_date = "2022-03-20"
last_commit_date = "2025-01-30"
test_file_content = "\n\npackage prober\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\t\"github.com/prometheus/client_golang/prometheus/testutil\"\n\t\"tailscale.com/syncs\"\n\t\"tailscale.com/tsweb\"\n)\n\nconst (\n\tprobeInterval        = 8 * time.Second\n\thalfProbeInterval    = probeInterval / 2\n\tquarterProbeInterval = probeInterval / 4\n\tconvergenceTimeout   = time.Second\n\tconvergenceSleep     = time.Millisecond\n\taFewMillis          = 20 * time.Millisecond\n)\n\nvar epoch = time.Unix(0, 0)\n\nfunc TestProberTiming(t *testing.T) {\n\tclk := newFakeTime()\n\tp := newForTest(clk.Now, clk.NewTicker)\n\n\tinvoked := make(chan struct{}, 1)\n\n\tnotCalled := func() {\n\t\tt.Helper()\n\t\tselect {\n\t\tcase <-invoked:\n\t\t\tt.Fatal(\"probe was invoked earlier than expected\")\n\t\tdefault:\n\t\t}\n\t}\n\tcalled := func() {\n\t\tt.Helper()\n\t\tselect {\n\t\tcase <-invoked:\n\t\tcase <-time.After(2 * time.Second):\n\t\t\tt.Fatal(\"probe wasn't invoked as expected\")\n\t\t}\n\t}\n\n\tp.Run(\"test-probe\", probeInterval, nil, FuncProbe(func(context.Context) error {\n\t\tinvoked <- struct{}{}\n\t\treturn nil\n\t}))\n\n\twaitActiveProbes(t, p, clk, 1)\n\n\tcalled()\n\tnotCalled()\n\tclk.advanceTime(probeInterval + halfProbeInterval)\n\tcalled()\n\tnotCalled()\n\tclk.Advance(quarterProbeInterval)\n\tnotCalled()\n\tclk.Advance(probeInterval)\n\tcalled()\n\tnotCalled()\n}\n\nfunc TestProberTimingSpread(t *testing.T) {\n\tclk := newFakeTime()\n\tp := newForTest(clk.Now, clk.NewTicker).WithSpread(true)\n\n\tinvoked := make(chan struct{}, 1)\n\n\tnotCalled := func() {\n\t\tt.Helper()\n\t\tselect {\n\t\tcase <-invoked:\n\t\t\tt.Fatal(\"probe was invoked earlier than expected\")\n\t\tdefault:\n\t\t}\n\t}\n\tcalled := func() {\n\t\tt.Helper()\n\t\tselect {\n\t\tcase <-invoked:\n\t\tcase <-time.After(2 * time.Second):\n\t\t\tt.Fatal(\"probe wasn't invoked as expected\")\n\t\t}\n\t}\n\n\tprobe := p.Run(\"test-spread-probe\", probeInterval, nil, FuncProbe(func(context.Context) error {\n\t\tinvoked <- struct{}{}\n\t\treturn nil\n\t}))\n\n\twaitActiveProbes(t, p, clk, 1)\n\n\tnotCalled()\n\tclk.Advance(halfProbeInterval)\n\tcalled()\n\tnotCalled()\n\n\terr := tstest.WaitFor(convergenceTimeout, func() error {\n\t\tclk.Lock()\n\t\tdefer clk.Unlock()\n\t\tfor _, tick := range clk.tickers {\n\t\t\ttick.Lock()\n\t\t\tstopped, interval := tick.stopped, tick.intervall\n\t\t\ttick.Unlock()\n\n\t\t\tif stopped {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif interval == probe.interval {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\treturn fmt.Errorf(\"no ticker with interval %d found\", probe.interval)\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tclk.Advance(quarterProbeInterval)\n\tnotCalled()\n\tclk.Advance(probeInterval)\n\tcalled()\n\tnotCalled()\n}\n\nfunc TestProberTimeout(t *testing.T) {\n\tclk := newFakeTime()\n\tp := newForTest(clk.Now, clk.NewTicker)\n\n\tvar done sync.WaitGroup\n\tdone.Add(1)\n\tpfunc := FuncProbe(func(ctx context.Context) error {\n\t\tdefer done.Done()\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn ctx.Err()\n\t\t}\n\t})\n\tpfunc.Timeout = time.Microsecond\n\tprobe := p.Run(\"foo\", 30*time.Second, nil, pfunc)\n\twaitActiveProbes(t, p, clk, 1)\n\tdone.Wait()\n\tprobe.mu.Lock()\n\tinfo := probe.probeInfoLocked()\n\tprobe.mu.Unlock()\n\twantInfo := ProbeInfo{\n\t\tName:            \"foo\",\n\t\tInterval:        30 * time.Second,\n\t\tLabels:          map[string]string{\"class\": \"\", \"name\": \"foo\"},\n\t\tStatus:          ProbeStatusFailed,\n\t\tError:           \"context deadline exceeded\",\n\t\tRecentResults:   []bool{false},\n\t\tRecentLatencies: nil,\n\t}\n\tif diff := cmp.Diff(wantInfo, info, cmpopts.IgnoreFields(ProbeInfo{}, \"Start\", \"End\", \"Latency\")); diff != \"\" {\n\t\tt.Fatalf(\"unexpected ProbeInfo (-want +got):\\n%s\", diff)\n\t}\n\tif got := info.Latency; got > time.Second {\n\t\tt.Errorf(\"info.Latency = %v, want at most 1s\", got)\n\t}\n}\n\nfunc TestProberConcurrency(t *testing.T) {\n\tclk := newFakeTime()\n\tp := newForTest(clk.Now, clk.NewTicker)\n\n\tvar ran atomic.Int64\n\tstopProbe := make(chan struct{})\n\tpfunc := FuncProbe(func(ctx context.Context) error {\n\t\tran.Add(1)\n\t\t<-stopProbe\n\t\treturn nil\n\t})\n\tpfunc.Timeout = time.Hour\n\tpfunc.Concurrency = 3\n\tp.Run(\"foo\", time.Second, nil, pfunc)\n\twaitActiveProbes(t, p, clk, 1)\n\n\tfor range 50 {\n\t\tclk.Advance(time.Second)\n\t}\n\n\tif err := tstest.WaitFor(convergenceTimeout, func() error {\n\t\tif got, want := ran.Load(), int64(3); got != want {\n\t\t\treturn fmt.Errorf(\"expected %d probes to run concurrently, got %d\", want, got)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tclose(stopProbe)\n}\n\nfunc TestProberRun(t *testing.T) {\n\tclk := newFakeTime()\n\tp := newForTest(clk.Now, clk.NewTicker)\n\n\tvar (\n\t\tmu  sync.Mutex\n\t\tcnt int\n\t)\n\n\tconst startingProbes = 100\n\tvar probes []*Probe\n\n\tfor i := range startingProbes {\n\t\tprobes = append(probes, p.Run(fmt.Sprintf(\"probe%d\", i), probeInterval, nil, FuncProbe(func(context.Context) error {\n\t\t\tmu.Lock()\n\t\t\tdefer mu.Unlock()\n\t\t\tcnt++\n\t\t\treturn nil\n\t\t})))\n\t}\n\n\tcheckCnt := func(want int) {\n\t\tt.Helper()\n\t\terr := tstest.WaitFor(convergenceTimeout, func() error {\n\t\t\tmu.Lock()\n\t\t\tdefer mu.Unlock()\n\t\t\tif cnt == want {\n\t\t\t\tcnt = 0\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn fmt.Errorf(\"wrong number of probe counter increments, got %d want %d\", cnt, want)\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\twaitActiveProbes(t, p, clk, startingProbes)\n\tcheckCnt(startingProbes)\n\tclk.Advance(probeInterval + halfProbeInterval)\n\tcheckCnt(startingProbes)\n\tif c, err := testutil.GatherAndCount(p.metrics, \"prober_result\"); c != startingProbes || err != nil {\n\t\tt.Fatalf(\"expected %d prober_result metrics; got %d (error %s)\", startingProbes, c, err)\n\t}\n\n\tkeep := startingProbes / 2\n\n\tfor i := keep; i < startingProbes; i++ {\n\t\tprobes[i].Close()\n\t}\n\twaitActiveProbes(t, p, clk, keep)\n\n\tclk.Advance(probeInterval)\n\tcheckCnt(keep)\n\tif c, err := testutil.GatherAndCount(p.metrics, \"prober_result\"); c != keep || err != nil {\n\t\tt.Fatalf(\"expected %d prober_result metrics; got %d (error %s)\", keep, c, err)\n\t}\n}\n\nfunc TestPrometheus(t *testing.T) {\n\tclk := newFakeTime()\n\tp := newForTest(clk.Now, clk.NewTicker).WithMetricNamespace(\"probe\")\n\n\tvar succeed atomic.Bool\n\tp.Run(\"testprobe\", probeInterval, map[string]string{\"label\": \"value\"}, FuncProbe(func(context.Context) error {\n\t\tclk.Advance(aFewMillis)\n\t\tif succeed.Load() {\n\t\t\treturn nil\n\t\t}\n\t\treturn errors.New(\"failing, as instructed by test\")\n\t}))\n\n\twaitActiveProbes(t, p, clk, 1)\n\n\terr := tstest.WaitFor(convergenceTimeout, func() error {\n\t\twant := fmt.Sprintf(`\n# HELP probe_interval_secs Probe interval in seconds\n# TYPE probe_interval_secs gauge\nprobe_interval_secs{class=\"\",label=\"value\",name=\"testprobe\"} %f\n# HELP probe_start_secs Latest probe start time (seconds since epoch)\n# TYPE probe_start_secs gauge\nprobe_start_secs{class=\"\",label=\"value\",name=\"testprobe\"} %d\n# HELP probe_end_secs Latest probe end time (seconds since epoch)\n# TYPE probe_end_secs gauge\nprobe_end_secs{class=\"\",label=\"value\",name=\"testprobe\"} %d\n# HELP probe_result Latest probe result (1 = success, 0 = failure)\n# TYPE probe_result gauge\nprobe_result{class=\"\",label=\"value\",name=\"testprobe\"} 0\n`, probeInterval.Seconds(), epoch.Unix(), epoch.Add(aFewMillis).Unix())\n\t\treturn testutil.GatherAndCompare(p.metrics, strings.NewReader(want),\n\t\t\t\"probe_interval_secs\", \"probe_start_secs\", \"probe_end_secs\", \"probe_result\")\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tsucceed.Store(true)\n\tclk.Advance(probeInterval + halfProbeInterval)\n\n\terr = tstest.WaitFor(convergenceTimeout, func() error {\n\t\tstart := epoch.Add(probeInterval + halfProbeInterval)\n\t\tend := start.Add(aFewMillis)\n\t\twant := fmt.Sprintf(`\n# HELP probe_interval_secs Probe interval in seconds\n# TYPE probe_interval_secs gauge\nprobe_interval_secs{class=\"\",label=\"value\",name=\"testprobe\"} %f\n# HELP probe_start_secs Latest probe start time (seconds since epoch)\n# TYPE probe_start_secs gauge\nprobe_start_secs{class=\"\",label=\"value\",name=\"testprobe\"} %d\n# HELP probe_end_secs Latest probe end time (seconds since epoch)\n# TYPE probe_end_secs gauge\nprobe_end_secs{class=\"\",label=\"value\",name=\"testprobe\"} %d\n# HELP probe_latency_millis Latest probe latency (ms)\n# TYPE probe_latency_millis gauge\nprobe_latency_millis{class=\"\",label=\"value\",name=\"testprobe\"} %d\n# HELP probe_result Latest probe result (1 = success, 0 = failure)\n# TYPE probe_result gauge\nprobe_result{class=\"\",label=\"value\",name=\"testprobe\"} 1\n`, probeInterval.Seconds(), start.Unix(), end.Unix(), aFewMillis.Milliseconds())\n\t\treturn testutil.GatherAndCompare(p.metrics, strings.NewReader(want),\n\t\t\t\"probe_interval_secs\", \"probe_start_secs\", \"probe_end_secs\", \"probe_latency_millis\", \"probe_result\")\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestOnceMode(t *testing.T) {\n\tclk := newFakeTime()\n\tp := newForTest(clk.Now, clk.NewTicker).WithOnce(true)\n\n\tp.Run(\"probe1\", probeInterval, nil, FuncProbe(func(context.Context) error { return nil }))\n\tp.Run(\"probe2\", probeInterval, nil, FuncProbe(func(context.Context) error { return fmt.Errorf(\"error2\") }))\n\tp.Run(\"probe3\", probeInterval, nil, FuncProbe(func(context.Context) error {\n\t\tp.Run(\"probe4\", probeInterval, nil, FuncProbe(func(context.Context) error {\n\t\t\treturn fmt.Errorf(\"error4\")\n\t\t}))\n\t\treturn nil\n\t}))\n\n\tp.Wait()\n\twantCount := 4\n\tfor _, metric := range []string{\"prober_result\", \"prober_end_secs\"} {\n\t\tif c, err := testutil.GatherAndCount(p.metrics, metric); c != wantCount || err != nil {\n\t\t\tt.Fatalf(\"expected %d %s metrics; got %d (error %s)\", wantCount, metric, c, err)\n\t\t}\n\t}\n}\n\nfunc TestProberProbeInfo(t *testing.T) {\n\tclk := newFakeTime()\n\tp := newForTest(clk.Now, clk.NewTicker).WithOnce(true)\n\n\tp.Run(\"probe1\", probeInterval, nil, FuncProbe(func(context.Context) error {\n\t\tclk.Advance(500 * time.Millisecond)\n\t\treturn nil\n\t}))\n\tp.Run(\"probe2\", probeInterval, nil, FuncProbe(func(context.Context) error { return fmt.Errorf(\"error2\") }))\n\tp.Wait()\n\n\tinfo := p.ProbeInfo()\n\twantInfo := map[string]ProbeInfo{\n\t\t\"probe1\": {\n\t\t\tName:            \"probe1\",\n\t\t\tInterval:        probeInterval,\n\t\t\tLabels:          map[string]string{\"class\": \"\", \"name\": \"probe1\"},\n\t\t\tLatency:         500 * time.Millisecond,\n\t\t\tStatus:          ProbeStatusSucceeded,\n\t\t\tRecentResults:   []bool{true},\n\t\t\tRecentLatencies: []time.Duration{500 * time.Millisecond},\n\t\t},\n\t\t\"probe2\": {\n\t\t\tName:            \"probe2\",\n\t\t\tInterval:        probeInterval,\n\t\t\tLabels:          map[string]string{\"class\": \"\", \"name\": \"probe2\"},\n\t\t\tStatus:          ProbeStatusFailed,\n\t\t\tError:           \"error2\",\n\t\t\tRecentResults:   []bool{false},\n\t\t\tRecentLatencies: nil,\n\t\t},\n\t}\n\n\tif diff := cmp.Diff(wantInfo, info, cmpopts.IgnoreFields(ProbeInfo{}, \"Start\", \"End\")); diff != \"\" {\n\t\tt.Fatalf(\"unexpected ProbeInfo (-want +got):\\n%s\", diff)\n\t}\n}\n\nfunc TestProbeInfoRecent(t *testing.T) {\n\ttype probeResult struct {\n\t\tlatency time.Duration\n\t\terr     error\n\t}\n\ttests := []struct {\n\t\tname                    string\n\t\tresults                 []probeResult\n\t\twantProbeInfo          ProbeInfo\n\t\twantRecentSuccessRatio float64\n\t\twantRecentMedianLatency time.Duration\n\t}{\n\t\t{\n\t\t\tname:                    \"no_runs\",\n\t\t\twantProbeInfo:           ProbeInfo{Status: ProbeStatusUnknown},\n\t\t\twantRecentSuccessRatio:  0,\n\t\t\twantRecentMedianLatency: 0,\n\t\t},\n\t\t{\n\t\t\tname:    \"single_success\",\n\t\t\tresults: []probeResult{{latency: 100 * time.Millisecond, err: nil}},\n\t\t\twantProbeInfo: ProbeInfo{\n\t\t\t\tLatency:         100 * time.Millisecond,\n\t\t\t\tStatus:          ProbeStatusSucceeded,\n\t\t\t\tRecentResults:   []bool{true},\n\t\t\t\tRecentLatencies: []time.Duration{100 * time.Millisecond},\n\t\t\t},\n\t\t\twantRecentSuccessRatio:  1,\n\t\t\twantRecentMedianLatency: 100 * time.Millisecond,\n\t\t},\n\t\t{\n\t\t\tname:    \"single_failure\",\n\t\t\tresults: []probeResult{{latency: 100 * time.Millisecond, err: errors.New(\"error123\")}},\n\t\t\twantProbeInfo: ProbeInfo{\n\t\t\t\tStatus:          ProbeStatusFailed,\n\t\t\t\tRecentResults:   []bool{false},\n\t\t\t\tRecentLatencies: nil,\n\t\t\t\tError:           \"error123\",\n\t\t\t},\n\t\t\twantRecentSuccessRatio:  0,\n\t\t\twantRecentMedianLatency: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"recent_mix\",\n\t\t\tresults: []probeResult{\n\t\t\t\t{latency: 10 * time.Millisecond, err: errors.New(\"error1\")},\n\t\t\t\t{latency: 20 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 30 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 40 * time.Millisecond, err: errors.New(\"error4\")},\n\t\t\t\t{latency: 50 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 60 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 70 * time.Millisecond, err: errors.New(\"error7\")},\n\t\t\t\t{latency: 80 * time.Millisecond, err: nil},\n\t\t\t},\n\t\t\twantProbeInfo: ProbeInfo{\n\t\t\t\tStatus:        ProbeStatusSucceeded,\n\t\t\t\tLatency:       80 * time.Millisecond,\n\t\t\t\tRecentResults: []bool{false, true, true, false, true, true, false, true},\n\t\t\t\tRecentLatencies: []time.Duration{\n\t\t\t\t\t20 * time.Millisecond,\n\t\t\t\t\t30 * time.Millisecond,\n\t\t\t\t\t50 * time.Millisecond,\n\t\t\t\t\t60 * time.Millisecond,\n\t\t\t\t\t80 * time.Millisecond,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantRecentSuccessRatio:  0.625,\n\t\t\twantRecentMedianLatency: 50 * time.Millisecond,\n\t\t},\n\t\t{\n\t\t\tname: \"only_last_10\",\n\t\t\tresults: []probeResult{\n\t\t\t\t{latency: 10 * time.Millisecond, err: errors.New(\"old_error\")},\n\t\t\t\t{latency: 20 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 30 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 40 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 50 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 60 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 70 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 80 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 90 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 100 * time.Millisecond, err: nil},\n\t\t\t\t{latency: 110 * time.Millisecond, err: nil},\n\t\t\t},\n\t\t\twantProbeInfo: ProbeInfo{\n\t\t\t\tStatus:        ProbeStatusSucceeded,\n\t\t\t\tLatency:       110 * time.Millisecond,\n\t\t\t\tRecentResults: []bool{true, true, true, true, true, true, true, true, true, true},\n\t\t\t\tRecentLatencies: []time.Duration{\n\t\t\t\t\t20 * time.Millisecond,\n\t\t\t\t\t30 * time.Millisecond,\n\t\t\t\t\t40 * time.Millisecond,\n\t\t\t\t\t50 * time.Millisecond,\n\t\t\t\t\t60 * time.Millisecond,\n\t\t\t\t\t70 * time.Millisecond,\n\t\t\t\t\t80 * time.Millisecond,\n\t\t\t\t\t90 * time.Millisecond,\n\t\t\t\t\t100 * time.Millisecond,\n\t\t\t\t\t110 * time.Millisecond,\n\t\t\t\t},\n\t\t\t},\n\t\t\twantRecentSuccessRatio:  1,\n\t\t\twantRecentMedianLatency: 70 * time.Millisecond,\n\t\t},\n\t}\n\n\tclk := newFakeTime()\n\tp := newForTest(clk.Now, clk.NewTicker).WithOnce(true)\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tprobe := newProbe(p, \"\", probeInterval, nil, FuncProbe(func(context.Context) error { return nil }))\n\t\t\tfor _, r := range tt.results {\n\t\t\t\tprobe.recordStart()\n\t\t\t\tclk.Advance(r.latency)\n\t\t\t\tprobe.recordEndLocked(r.err)\n\t\t\t}\n\t\t\tprobe.mu.Lock()\n\t\t\tinfo := probe.probeInfoLocked()\n\t\t\tprobe.mu.Unlock()\n\t\t\tif diff := cmp.Diff(tt.wantProbeInfo, info, cmpopts.IgnoreFields(ProbeInfo{}, \"Start\", \"End\", \"Interval\")); diff != \"\" {\n\t\t\t\tt.Fatalf(\"unexpected ProbeInfo (-want +got):\\n%s\", diff)\n\t\t\t}\n\t\t\tif got := info.RecentSuccessRatio(); got != tt.wantRecentSuccessRatio {\n\t\t\t\tt.Errorf(\"recentSuccessRatio() = %v, want %v\", got, tt.wantRecentSuccessRatio)\n\t\t\t}\n\t\t\tif got := info.RecentMedianLatency(); got != tt.wantRecentMedianLatency {\n\t\t\t\tt.Errorf(\"recentMedianLatency() = %v, want %v\", got, tt.wantRecentMedianLatency)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProberRunHandler(t *testing.T) {\n\tclk := newFakeTime()\n\n\ttests := []struct {\n\t\tname                  string\n\t\tprobeFunc            func(context.Context) error\n\t\twantResponseCode     int\n\t\twantJSONResponse     RunHandlerResponse\n\t\twantPlaintextResp    string\n\t}{\n\t\t{\n\t\t\tname:             \"success\",\n\t\t\tprobeFunc:        func(context.Context) error { return nil },\n\t\t\twantResponseCode: 200,\n\t\t\twantJSONResponse: RunHandlerResponse{\n\t\t\t\tProbeInfo: ProbeInfo{\n\t\t\t\t\tName:          \"success\",\n\t\t\t\t\tInterval:      probeInterval,\n\t\t\t\t\tStatus:        ProbeStatusSucceeded,\n\t\t\t\t\tRecentResults: []bool{true, true},\n\t\t\t\t},\n\t\t\t\tPreviousSuccessRatio: 1,\n\t\t\t},\n\t\t\twantPlaintextResp: \"Probe succeeded\",\n\t\t},\n\t\t{\n\t\t\tname:             \"failure\",\n\t\t\tprobeFunc:        func(context.Context) error { return fmt.Errorf(\"error123\") },\n\t\t\twantResponseCode: 424,\n\t\t\twantJSONResponse: RunHandlerResponse{\n\t\t\t\tProbeInfo: ProbeInfo{\n\t\t\t\t\tName:          \"failure\",\n\t\t\t\t\tInterval:      probeInterval,\n\t\t\t\t\tStatus:        ProbeStatusFailed,\n\t\t\t\t\tError:         \"error123\",\n\t\t\t\t\tRecentResults: []bool{false, false},\n\t\t\t\t},\n\t\t\t},\n\t\t\twantPlaintextResp: \"Probe failed\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tfor _, reqJSON := range []bool{true, false} {\n\t\t\tt.Run(fmt.Sprintf(\"%s_json-%v\", tt.name, reqJSON), func(t *testing.T) {\n\t\t\t\tp := newForTest(clk.Now, clk.NewTicker).WithOnce(true)\n\t\t\t\tprobe := p.Run(tt.name, probeInterval, nil, FuncProbe(tt.probeFunc))\n\t\t\t\tdefer probe.Close()\n\t\t\t\t<-probe.stopped\n\n\t\t\t\tw := httptest.NewRecorder()\n\n\t\t\t\treq := httptest.NewRequest(\"GET\", \"/prober/run/?name=\"+tt.name, nil)\n\t\t\t\tif reqJSON {\n\t\t\t\t\treq.Header.Set(\"Accept\", \"application/json\")\n\t\t\t\t}\n\t\t\t\ttsweb.StdHandler(tsweb.ReturnHandlerFunc(p.RunHandler), tsweb.HandlerOptions{}).ServeHTTP(w, req)\n\t\t\t\tif w.Result().StatusCode != tt.wantResponseCode {\n\t\t\t\t\tt.Errorf(\"unexpected response code: got %d, want %d\", w.Code, tt.wantResponseCode)\n\t\t\t\t}\n\n\t\t\t\tif reqJSON {\n\t\t\t\t\tvar gotJSON RunHandlerResponse\n\t\t\t\t\tif err := json.Unmarshal(w.Body.Bytes(), &gotJSON); err != nil {\n\t\t\t\t\t\tt.Fatalf(\"failed to unmarshal JSON response: %v; body: %s\", err, w.Body.String())\n\t\t\t\t\t}\n\t\t\t\t\tif diff := cmp.Diff(tt.wantJSONResponse, gotJSON, cmpopts.IgnoreFields(ProbeInfo{}, \"Start\", \"End\", \"Labels\", \"RecentLatencies\")); diff != \"\" {\n\t\t\t\t\t\tt.Errorf(\"unexpected JSON response (-want +got):\\n%s\", diff)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbody, _ := io.ReadAll(w.Result().Body)\n\t\t\t\t\tif !strings.Contains(string(body), tt.wantPlaintextResp) {\n\t\t\t\t\t\tt.Errorf(\"unexpected response body: got %q, want to contain %q\", body, tt.wantPlaintextResp)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n}\n\ntype fakeTicker struct {\n\tch       chan time.Time\n\tinterval time.Duration\n\n\tsync.Mutex\n\tnext    time.Time\n\tstopped bool\n}\n\nfunc (t *fakeTicker) Chan() <-chan time.Time {\n\treturn t.ch\n}\n\nfunc (t *fakeTicker) Stop() {\n\tt.Lock()\n\tdefer t.Unlock()\n\tt.stopped = true\n}\n\nfunc (t *fakeTicker) fire(now time.Time) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tselect {\n\tcase t.ch <- now:\n\tdefault:\n\t}\n\tfor now.After(t.next) {\n\t\tt.next = t.next.Add(t.interval)\n\t}\n}\n\ntype fakeTime struct {\n\tsync.Mutex\n\t*sync.Cond\n\tcurTime time.Time\n\ttickers []*fakeTicker\n}\n\nfunc newFakeTime() *fakeTime {\n\tret := &fakeTime{\n\t\tcurTime: epoch,\n\t}\n\tret.Cond = &sync.Cond{L: &ret.Mutex}\n\treturn ret\n}\n\nfunc (t *fakeTime) Now() time.Time {\n\tt.Lock()\n\tdefer t.Unlock()\n\tret := t.curTime\n\treturn ret\n}\n\nfunc (t *fakeTime) NewTicker(d time.Duration) ticker {\n\tt.Lock()\n\tdefer t.Unlock()\n\tret := &fakeTicker{\n\t\tch:       make(chan time.Time, 1),\n\t\tinterval: d,\n\t\tnext:     t.curTime.Add(d),\n\t}\n\tt.tickers = append(t.tickers, ret)\n\tt.Cond.Broadcast()\n\treturn ret\n}\n\nfunc (t *fakeTime) Advance(d time.Duration) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tt.curTime = t.curTime.Add(d)\n\tfor _, tick := range t.tickers {\n\t\tif t.curTime.After(tick.next) {\n\t\t\ttick.fire(t.curTime)\n\t\t}\n\t}\n}\n\nfunc (t *fakeTime) activeTickers() (count int) {\n\tt.Lock()\n\tdefer t.Unlock()\n\tfor _, tick := range t.tickers {\n\t\tif !tick.stopped {\n\t\t\tcount += 1\n\t\t}\n\t}\n\treturn\n}\n\nfunc waitActiveProbes(t *testing.T, p *Prober, clk *fakeTime, want int) {\n\tt.Helper()\n\terr := tstest.WaitFor(convergenceTimeout, func() error {\n\t\tif got := p.activeProbes(); got != want {\n\t\t\treturn fmt.Errorf(\"installed probe count is %d, want %d\", got, want)\n\t\t}\n\t\tif got := clk.activeTickers(); got != want {\n\t\t\treturn fmt.Errorf(\"active ticker count is %d, want %d\", got, want)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}"
