[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Go"
go_version = "1.24.0"

[repo_info]
repository = "bacalhau-project/bacalhau"
sha = "942823bbb893e9dfeedca16bd151e2f15228a198"

[run_info]
docker_image = "golang:1.24.0"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/authz/capabilities.go pkg/authz/capabilities_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/authz/capabilities.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 69.0
original_coverage = 100.0
mutation_kill_rate = 44.0
original_mutation_kill_rate = 85.0
covered_lines = [ 13, 14, 15, 28, 29, 30, 31, 47, 48, 49, 54, 55, 62, 63, 64, 65, 66, 67, 68, 69, 70, 89, 94, 95, 96, 97, 98, 99, 100, 101, 102, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 121, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,]
missed_lines = [ 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 56, 57, 58, 73, 74, 75, 78, 79, 80, 83, 84, 85,]

[input_info]
test_file_path = "pkg/authz/capabilities_test.go"
focal_file_path = "pkg/authz/capabilities.go"
test_file_url = "https://github.com/bacalhau-project/bacalhau/blob/942823bbb893e9dfeedca16bd151e2f15228a198/pkg/authz/capabilities_test.go"
focal_file_url = "https://github.com/bacalhau-project/bacalhau/blob/942823bbb893e9dfeedca16bd151e2f15228a198/pkg/authz/capabilities.go"
first_commit_date = "2025-03-18"
last_commit_date = "2025-04-16"
test_file_content = "package authz\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/bacalhau-project/bacalhau/pkg/config/types\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// TestGetRequiredCapability verifies that the correct capability is returned for different resource types and HTTP methods\n\n// TestHasRequiredCapability verifies that capability checking works for various capability patterns\n\n// TestCheckUserAccess verifies that the complete access checking flow works correctly\n\n// TestMapEndpointToResourceType verifies that endpoint paths are correctly mapped to resource types\n\n// TestGetDefaultEndpointPermissions verifies that the default endpoint permissions are returned correctly\nfunc TestGetDefaultEndpointPermissions(t *testing.T) {\n\tpermissions := GetDefaultEndpointPermissions()\n\n\t// Test for a few key endpoints\n\tassert.Equal(t, \"open\", permissions[\"/api/v1/version\"])\n\tassert.Equal(t, \"agent\", permissions[\"/api/v1/agent\"])\n\tassert.Equal(t, \"open\", permissions[\"/api/v1/agent/alive\"])\n\tassert.Equal(t, \"node\", permissions[\"/api/v1/orchestrator/nodes\"])\n\tassert.Equal(t, \"job\", permissions[\"/api/v1/orchestrator/jobs\"])\n\n\t// Ensure all important endpoints are covered\n\tassert.Greater(t, len(permissions), 7, \"Default permissions should include all important endpoints\")\n}\n\n// TestDefaultEndpointSpecificMatching tests that URL matching works correctly with the actual\n// default endpoint permissions, prioritizing more specific paths over general ones\nfunc TestDefaultEndpointSpecificMatching(t *testing.T) {\n\t// Get actual default permissions\n\tdefaultPermissions := GetDefaultEndpointPermissions()\n\n\t// Test cases for specific paths that should override general paths\n\ttestCases := []struct {\n\t\tname           string\n\t\tpath           string\n\t\texpectedType   ResourceType\n\t\tunexpectedType ResourceType\n\t}{\n\t\t{\n\t\t\tname:           \"Agent Alive Path\",\n\t\t\tpath:           \"/api/v1/agent/alive\",\n\t\t\texpectedType:   ResourceTypeOpen,\n\t\t\tunexpectedType: ResourceTypeAgent,\n\t\t},\n\t\t{\n\t\t\tname:           \"Agent Version Path\",\n\t\t\tpath:           \"/api/v1/agent/version\",\n\t\t\texpectedType:   ResourceTypeOpen,\n\t\t\tunexpectedType: ResourceTypeAgent,\n\t\t},\n\t\t{\n\t\t\tname:           \"Agent with Unknown Subpath\",\n\t\t\tpath:           \"/api/v1/agent/unknown\",\n\t\t\texpectedType:   ResourceTypeAgent,\n\t\t\tunexpectedType: ResourceTypeOpen,\n\t\t},\n\t\t{\n\t\t\tname:           \"Agent Alive with Query Params\",\n\t\t\tpath:           \"/api/v1/agent/alive?health=true&timeout=30\",\n\t\t\texpectedType:   ResourceTypeOpen,\n\t\t\tunexpectedType: ResourceTypeAgent,\n\t\t},\n\t\t{\n\t\t\tname:           \"Agent Alive with Extra Path Segments\",\n\t\t\tpath:           \"/api/v1/agent/alive/details\",\n\t\t\texpectedType:   ResourceTypeOpen,\n\t\t\tunexpectedType: ResourceTypeAgent,\n\t\t},\n\t}\n\n\t// Run all test cases\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresourceType := MapEndpointToResourceType(tc.path, defaultPermissions)\n\t\t\tassert.Equal(t, tc.expectedType, resourceType,\n\t\t\t\t\"Should map to the expected resource type\")\n\t\t\tassert.NotEqual(t, tc.unexpectedType, resourceType,\n\t\t\t\t\"Should not map to the unexpected resource type\")\n\t\t})\n\t}\n}\n\n// TestResourceTypeAgent tests the capability checker with the ResourceTypeAgent resource type\n\n// TestEdgeCaseEmptyCapabilities tests the capability checker with empty capabilities\n\n// TestResourceTypeOpenDetection tests detection and handling of open resource types\n\n// TestMultipleHTTPMethods tests the capability checker with various HTTP methods\n\n// TestEmptyOrInvalidEndpointPatterns tests handling of empty or invalid endpoint patterns\n\n// TestMissingCapability tests what happens when an endpoint doesn't have a corresponding capability defined\nfunc TestMissingCapability(t *testing.T) {\n\t// Create a limited permissions map without some common endpoints\n\tlimitedPermissions := map[string]string{\n\t\t\"/api/v1/agent\": \"agent\",\n\t\t\"/api/v1/jobs\":  \"job\",\n\t}\n\n\t// Test an endpoint that doesn't exist in the map\n\tmissingPath := \"/api/v1/unknown/endpoint\"\n\tresourceType := MapEndpointToResourceType(missingPath, limitedPermissions)\n\tassert.Equal(t, ResourceType(\"\"), resourceType, \"Undefined endpoint should return empty resource type\")\n\n\t// Test partial match that doesn't match any prefix\n\tpartialPath := \"/api/v2/agent\"\n\tpartialResourceType := MapEndpointToResourceType(partialPath, limitedPermissions)\n\tassert.Equal(t, ResourceType(\"\"), partialResourceType, \"Endpoint with unmatched prefix should return empty resource type\")\n\n\t// Test what happens when we have an empty permissions map\n\temptyPermissions := map[string]string{}\n\temptyMapResourceType := MapEndpointToResourceType(\"/api/v1/agent\", emptyPermissions)\n\tassert.Equal(t, ResourceType(\"\"), emptyMapResourceType, \"Any endpoint with empty permissions map should return empty resource type\")\n\n\t// Test behavior with CheckUserAccess when resource type is empty\n\tchecker := NewCapabilityChecker()\n\tuser := types.AuthUser{\n\t\tAlias: \"test_user\",\n\t\tCapabilities: []types.Capability{\n\t\t\t{Actions: []string{\"*\"}}, // Even with all permissions\n\t\t},\n\t}\n\n\t// When a resource type is not mapped (resulting in empty resource type),\n\t// GetRequiredCapability will return write:node as default\n\treq := httptest.NewRequest(http.MethodGet, \"/api/v1/unknown/endpoint\", nil)\n\thasAccess, requiredCapability := checker.CheckUserAccess(user, \"\", req)\n\tassert.Equal(t, \"write:node\", requiredCapability, \"Unknown resource type should default to requiring write:node\")\n\tassert.True(t, hasAccess, \"User with * capability should have access even to unknown resources\")\n\n\t// Test with a user without the required capability\n\tlimitedUser := types.AuthUser{\n\t\tAlias: \"limited_user\",\n\t\tCapabilities: []types.Capability{\n\t\t\t{Actions: []string{\"read:job\"}}, // Limited permissions\n\t\t},\n\t}\n\tlimitedHasAccess, _ := checker.CheckUserAccess(limitedUser, \"\", req)\n\tassert.False(t, limitedHasAccess, \"User without write:node capability should not have access to unknown resources\")\n}\n\n// TestHasRequiredCapabilityWithUndefinedCapabilities specifically tests the HasRequiredCapability function\n// with various scenarios involving undefined or missing capabilities\n"
