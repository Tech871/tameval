[meta]
task = "update"
scenario = "update_test"

[lang_info]
lang = "Go"
go_version = "1.24"

[repo_info]
repository = "trickstercache/trickster"
sha = "99ac2462add00d5014794ec929eec27c7f1ceaa7"

[run_info]
docker_image = "golang:1.24"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/VirtualRoyalty/go-mutesting/cmd/go-mutesting@v1.0.9 && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out pkg/proxy/ranges/byterange/range.go pkg/proxy/ranges/byterange/range_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting pkg/proxy/ranges/byterange/range.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 0
original_coverage = 84.0
mutation_kill_rate = nan
original_mutation_kill_rate = 61.0
covered_lines = []
missed_lines = []

[input_info]
test_file_path = "pkg/proxy/ranges/byterange/range_test.go"
focal_file_path = "pkg/proxy/ranges/byterange/range.go"
test_file_url = "https://github.com/trickstercache/trickster/blob/99ac2462add00d5014794ec929eec27c7f1ceaa7/pkg/proxy/ranges/byterange/range_test.go"
focal_file_url = "https://github.com/trickstercache/trickster/blob/99ac2462add00d5014794ec929eec27c7f1ceaa7/pkg/proxy/ranges/byterange/range.go"
first_commit_date = "2020-04-01"
last_commit_date = "2025-06-02"
test_file_content = "/*\n * Copyright 2018 The Trickster Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage byterange\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestRanges_CalculateDelta(t *testing.T) {\n\n\ttests := []struct {\n\t\twant, have, expected Ranges\n\t\tcl                   int64\n\t}{\n\t\t{\n\t\t\t// case 0  where we need both outer permiters of the wanted range\n\t\t\twant:     Ranges{Range{Start: 5, End: 10}},\n\t\t\thave:     Ranges{Range{Start: 6, End: 9}},\n\t\t\texpected: Ranges{Range{Start: 5, End: 5}, Range{Start: 10, End: 10}},\n\t\t\tcl:       62,\n\t\t},\n\t\t{\n\t\t\t// case 1  where the needed range is out of known bounds\n\t\t\twant:     Ranges{Range{Start: 100, End: 100}},\n\t\t\thave:     Ranges{Range{Start: 6, End: 9}},\n\t\t\texpected: Ranges{Range{Start: 100, End: 100}},\n\t\t\tcl:       62,\n\t\t},\n\t\t{\n\t\t\t// case 2  where the needed range is identical to have range\n\t\t\twant:     Ranges{Range{Start: 6, End: 9}},\n\t\t\thave:     Ranges{Range{Start: 6, End: 9}},\n\t\t\texpected: Ranges{},\n\t\t\tcl:       62,\n\t\t},\n\t\t{\n\t\t\t// case 3  where we want a suffix range (\"bytes=-50\")\n\t\t\twant:     Ranges{Range{Start: -1, End: 50}},\n\t\t\thave:     Ranges{Range{Start: 0, End: 30}},\n\t\t\texpected: Ranges{Range{Start: 31, End: 69}},\n\t\t\tcl:       70,\n\t\t},\n\t\t{\n\t\t\t// case 4  where we want a prefix range (\"bytes=50-\")\n\t\t\twant:     Ranges{Range{Start: 30, End: -1}},\n\t\t\thave:     Ranges{Range{Start: 0, End: 40}},\n\t\t\texpected: Ranges{Range{Start: 41, End: 69}},\n\t\t\tcl:       70,\n\t\t},\n\t\t{\n\t\t\t// case 5  where we have a few absolute ranges #1\n\t\t\twant:     Ranges{Range{Start: 0, End: 10}, Range{Start: 20, End: 29}},\n\t\t\thave:     Ranges{Range{Start: 0, End: 25}},\n\t\t\texpected: Ranges{Range{Start: 26, End: 29}},\n\t\t\tcl:       70,\n\t\t},\n\t\t{\n\t\t\t// case 6  where we have a few absolute ranges #2\n\t\t\twant:     Ranges{Range{Start: 0, End: 10}, Range{Start: 20, End: 29}},\n\t\t\thave:     Ranges{Range{Start: 0, End: 6}, Range{Start: 17, End: 32}},\n\t\t\texpected: Ranges{Range{Start: 7, End: 10}},\n\t\t\tcl:       70,\n\t\t},\n\t\t{\n\t\t\t// case 7  where we have a few absolute ranges #3\n\t\t\twant:     Ranges{Range{Start: 0, End: 10}, Range{Start: 20, End: 29}},\n\t\t\thave:     Ranges{Range{Start: 0, End: 6}, Range{Start: 25, End: 32}},\n\t\t\texpected: Ranges{Range{Start: 7, End: 10}, Range{Start: 20, End: 24}},\n\t\t\tcl:       70,\n\t\t},\n\t\t{\n\t\t\t// case 8  where we have a few absolute ranges #4\n\t\t\twant:     Ranges{Range{Start: 0, End: 10}, Range{Start: 20, End: 29}},\n\t\t\thave:     Ranges{Range{Start: 0, End: 6}, Range{Start: 20, End: 27}},\n\t\t\texpected: Ranges{Range{Start: 7, End: 10}, Range{Start: 28, End: 29}},\n\t\t\tcl:       70,\n\t\t},\n\t\t{\n\t\t\t// case 9 where we have all empty ranges\n\t\t\twant:     Ranges{},\n\t\t\thave:     Ranges{},\n\t\t\texpected: Ranges{},\n\t\t\tcl:       1,\n\t\t},\n\t\t{\n\t\t\t// case 10 where we have no saved ranges\n\t\t\twant:     Ranges{Range{Start: 0, End: 10}, Range{Start: 20, End: 29}},\n\t\t\thave:     nil,\n\t\t\texpected: Ranges{Range{Start: 0, End: 10}, Range{Start: 20, End: 29}},\n\t\t\tcl:       1,\n\t\t},\n\t\t{\n\t\t\t// case 11 partial hit between 2 ranges\n\t\t\twant:     Ranges{Range{Start: 5, End: 20}},\n\t\t\thave:     Ranges{Range{Start: 1, End: 9}},\n\t\t\texpected: Ranges{Range{Start: 10, End: 20}},\n\t\t\tcl:       21,\n\t\t},\n\t\t{\n\t\t\t// case 12 full range miss\n\t\t\twant:     Ranges{Range{Start: 15, End: 20}},\n\t\t\thave:     Ranges{Range{Start: 1, End: 9}},\n\t\t\texpected: Ranges{Range{Start: 15, End: 20}},\n\t\t\tcl:       21,\n\t\t},\n\t\t{\n\t\t\t// case 13 cache hit\n\t\t\twant:     Ranges{Range{Start: 29, End: 29}},\n\t\t\thave:     Ranges{Range{Start: 0, End: 10}, Range{Start: 20, End: 32}},\n\t\t\texpected: Ranges{},\n\t\t\tcl:       70,\n\t\t},\n\t\t// case 14 two separate partial hit areas in the same request\n\t\t{\n\t\t\twant:     Ranges{Range{Start: 9, End: 22}, Range{Start: 28, End: 60}},\n\t\t\thave:     Ranges{Range{Start: 0, End: 10}, Range{Start: 20, End: 32}},\n\t\t\texpected: Ranges{Range{Start: 11, End: 19}, Range{Start: 33, End: 60}},\n\t\t\tcl:       70,\n\t\t},\n\t}\n\n\tfor i, test := range tests {\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tres := test.want.CalculateDelta(test.have, test.cl)\n\t\t\tif !res.Equal(test.expected) {\n\t\t\t\tt.Errorf(\"got     : %s\\nexpected: %s\", res, test.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRangesString(t *testing.T) {\n\n\ttests := []struct {\n\t\tout, expected string\n\t}{\n\t\t{\n\t\t\tout:      Ranges{}.String(),\n\t\t\texpected: \"\",\n\t\t},\n\t\t{\n\t\t\tout:      Ranges{Range{Start: 0, End: 50}}.String(),\n\t\t\texpected: \"bytes=0-50\",\n\t\t},\n\t\t{\n\t\t\tout:      Ranges{Range{Start: -1, End: 50}}.String(),\n\t\t\texpected: \"bytes=-50\",\n\t\t},\n\t\t{\n\t\t\tout:      Ranges{Range{Start: 50, End: -1}}.String(),\n\t\t\texpected: \"bytes=50-\",\n\t\t},\n\t\t{\n\t\t\tout:      Ranges{Range{Start: 0, End: 20}, Range{Start: 50, End: -1}}.String(),\n\t\t\texpected: \"bytes=0-20, 50-\",\n\t\t},\n\t}\n\tfor i, test := range tests {\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tif test.out != test.expected {\n\t\t\t\tt.Errorf(\"expected: %s\\ngot:      %s\", test.out, test.expected)\n\t\t\t}\n\t\t})\n\t}\n\n}\n\nfunc TestParseContentRangeHeader(t *testing.T) {\n\ter := Range{Start: 0, End: 20}\n\tel := int64(100)\n\tr, cl, err := ParseContentRangeHeader(\"bytes 0-20/100\")\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif er != r {\n\t\tt.Errorf(\"expected %s, got %s\", er.String(), r.String())\n\t}\n\tif cl != el {\n\t\tt.Errorf(\"expected %d, got %d\", el, cl)\n\t}\n\n\t// trickster does not support caching raanges with  * content lengths\n\t_, _, err = ParseContentRangeHeader(\"bytes 0-20/*\")\n\tif err == nil || err.Error() != \"invalid input format\" {\n\t\tt.Errorf(\"expected error: %s\", \"invalid input format\")\n\t}\n\n\ter = Range{}\n\tel = -1\n\tr, cl, err = ParseContentRangeHeader(\"bytes a-20/*\")\n\tif err == nil || err.Error() != \"invalid input format\" {\n\t\tt.Errorf(\"expected error: %s\", \"invalid input format\")\n\t}\n\tif er != r {\n\t\tt.Errorf(\"expected %s, got %s\", er.String(), r.String())\n\t}\n\tif cl != el {\n\t\tt.Errorf(\"expected %d, got %d\", el, cl)\n\t}\n}\n\nfunc TestRangesFilter(t *testing.T) {\n\trs := Ranges{\n\t\tRange{1, 2},\n\t\tRange{4, 5},\n\t}\n\ts := []byte{0, 1, 2, 3, 4}\n\tcmp := func(bs0, bs1 []byte) error {\n\t\tif len(bs0) != len(bs1) {\n\t\t\treturn fmt.Errorf(\"slice lengths %d and %d not eq\", len(bs0), len(bs1))\n\t\t}\n\t\tfor i := 0; i < len(bs0); i++ {\n\t\t\tif bs0[i] != bs1[i] {\n\t\t\t\treturn fmt.Errorf(\"slices not eq at %d, got %b and %b\", i, bs0[i], bs1[i])\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\tif err := cmp(rs.FilterByteSlice(s), []byte{0, 1, 2, 0, 4}); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestRangesEqual(t *testing.T) {\n\n\twant := Ranges{Range{Start: 0, End: 20}}\n\tif want.Equal(nil) {\n\t\tt.Errorf(\"expected %t got %t\", false, true)\n\t}\n\n}\n\nfunc TestRangeSort(t *testing.T) {\n\tr := Ranges{Range{Start: 10, End: 20}, Range{Start: 0, End: 8}}\n\tsort.Sort(r)\n\tif r[0].Start != 0 || r[1].End != 20 {\n\t\tt.Errorf(\"sort failed on %s\", r.String())\n\t}\n}\n\nfunc TestRangeLess(t *testing.T) {\n\tr1 := Range{Start: 10, End: 20}\n\tr2 := Range{Start: 22, End: 30}\n\tif !r1.Less(r2) {\n\t\tt.Errorf(\"expected %t got %t\", true, r1.Less(r2))\n\t}\n}\n\nfunc TestContentRangeHeader(t *testing.T) {\n\n\tconst expected = \"bytes 0-20/100\"\n\n\tr := Range{Start: 0, End: 20}\n\th := r.ContentRangeHeader(100)\n\n\tif h != expected {\n\t\tt.Errorf(\"expected %s got %s\", expected, h)\n\t}\n\n}\n\nfunc TestParseRangeHeader_EmptyString(t *testing.T) {\n\tr := ParseRangeHeader(\"\")\n\tif r != nil {\n\t\tt.Errorf(\"expected empty byte range\")\n\t}\n}\n\nfunc TestParseRangeHeader_InvalidRange(t *testing.T) {\n\tr := ParseRangeHeader(\"bytes=abc-def\")\n\tif r != nil {\n\t\tt.Errorf(\"expected empty byte range\")\n\t}\n\tr = ParseRangeHeader(\"bytes0-100\")\n\tif r != nil {\n\t\tt.Errorf(\"expected empty byte range\")\n\t}\n\tr = ParseRangeHeader(\"0-100\")\n\tif r != nil {\n\t\tt.Errorf(\"expected empty byte range\")\n\t}\n\tr = ParseRangeHeader(\"100\")\n\tif r != nil {\n\t\tt.Errorf(\"expected empty byte range\")\n\t}\n\tr = ParseRangeHeader(\"-\")\n\tif r != nil {\n\t\tt.Errorf(\"expected empty byte range\")\n\t}\n\tr = ParseRangeHeader(\"bytes=20-30-40-50\")\n\tif r != nil {\n\t\tt.Errorf(\"expected empty byte range\")\n\t}\n\tr = ParseRangeHeader(\"bytes=20-blah\")\n\tif r != nil {\n\t\tt.Errorf(\"expected empty byte range\")\n\t}\n}\n\nfunc TestParseRangeHeader_SingleRange(t *testing.T) {\n\tbyteRange := \"bytes=0-50\"\n\tres := ParseRangeHeader(byteRange)\n\tif res == nil {\n\t\tt.Errorf(\"expected a non empty byte range, but got an empty range\")\n\t}\n\tif res[0].Start != 0 || res[0].End != 50 {\n\t\tt.Errorf(\"expected start %d end %d, got start %d end %d\", 0, 50, res[0].Start, res[0].End)\n\t}\n}\n\nfunc TestParseRangeHeader_Ends(t *testing.T) {\n\tbyteRange := \"bytes=500-\"\n\tres := ParseRangeHeader(byteRange)\n\tif res == nil {\n\t\tt.Errorf(\"expected a non empty byte range, but got an empty range\")\n\t}\n\tif res[0].Start != 500 || res[0].End != -1 {\n\t\tt.Errorf(\"expected start %d end %d, got start %d end %d\", 500, -1, res[0].Start, res[0].End)\n\t}\n\n\tbyteRange = \"bytes=10-20, 500-\"\n\tres = ParseRangeHeader(byteRange)\n\tif res == nil {\n\t\tt.Errorf(\"expected a non empty byte range, but got an empty range\")\n\t}\n\tif res[0].Start != 10 || res[0].End != 20 {\n\t\tt.Errorf(\"expected start %d end %d, got start %d end %d\", 10, 20, res[0].Start, res[0].End)\n\t}\n\tif res[1].Start != 500 || res[1].End != -1 {\n\t\tt.Errorf(\"expected start %d end %d, got start %d end %d\", -1, 500, res[0].Start, res[0].End)\n\t}\n\n\tbyteRange = \"bytes=-500\"\n\tres = ParseRangeHeader(byteRange)\n\tif res == nil {\n\t\tt.Errorf(\"expected a non empty byte range, but got an empty range\")\n\t}\n\tif res[0].Start != -1 || res[0].End != 500 {\n\t\tt.Errorf(\"expected start %d end %d, got start %d end %d\", 500, -1, res[0].Start, res[0].End)\n\t}\n\n}\n\nfunc TestParseRangeHeader_MultiRange(t *testing.T) {\n\tbyteRange := \"bytes=0-50, 100-150\"\n\tres := ParseRangeHeader(byteRange)\n\tif res == nil {\n\t\tt.Errorf(\"expected a non empty byte range, but got an empty range\")\n\t}\n\tif res[0].Start != 0 || res[0].End != 50 {\n\t\tt.Errorf(\"expected start %d end %d, got start %d end %d\", 0, 50, res[0].Start, res[0].End)\n\t}\n\tif res[1].Start != 100 || res[1].End != 150 {\n\t\tt.Errorf(\"expected start %d end %d, got start %d end %d\", 100, 150, res[1].Start, res[1].End)\n\t}\n}\n\nfunc TestRangeCrop(t *testing.T) {\n\tr1 := Range{0, 1}\n\tr2 := Range{0, 3}\n\tb := []byte{0, 1}\n\tif cr, _ := r1.CropByteSlice(b); len(cr) != 2 || cr[0] != 0 || cr[1] != 1 {\n\t\tt.Error(cr)\n\t}\n\tif cr, _ := r2.CropByteSlice(b); len(cr) != 2 || cr[0] != 0 || cr[1] != 1 {\n\t\tt.Error(cr)\n\t}\n}"
