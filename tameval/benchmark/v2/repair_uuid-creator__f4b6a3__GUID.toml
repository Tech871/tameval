[meta]
task = "repair"
scenario = "repair_missed_asserts"

[lang_info]
lang = "Java"
java_builder = "Maven"
is_multi_module = false

[repo_info]
repository = "f4b6a3/uuid-creator"
sha = "3f41c3e6ed9fa3c229303672960570281f35a125"

[run_info]
docker_image = "maven:3.8.3-openjdk-17"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "mvn -Dmaven.repo.local=/.m2 -T 4 clean install"
test_run_command = "mvn clean -Dmaven.repo.local=/.m2 test -q -Dtest=GUIDTest && mvn jacoco:report -Djacoco.append=false"
mutation_run_command = "mvn -Dmaven.repo.local=/.m2 org.pitest:pitest-maven:mutationCoverage -DtargetClasses=**.GUID  -DtargetTests=**.GUIDTest  -DoutputFormats=XML"
coverage_report_path = "target/site/jacoco/jacoco.xml"
coverage_report_type = "jacoco"
mutation_report_path = "target/pit-reports/mutations.xml"
mutation_report_type = "pitest"

[coverage]
coverage = 75.0
original_coverage = 95.0
mutation_kill_rate = 0
original_mutation_kill_rate = 83.0
covered_lines = [ 76, 80, 85, 89, 93, 97, 136, 137, 140, 141, 142, 152, 153, 156, 157, 158, 166, 167, 168, 169, 177, 178, 179, 182, 183, 184, 185, 194, 195, 215, 236, 240, 241, 242, 243, 262, 286, 287, 288, 306, 344, 364, 365, 383, 421, 442, 446, 447, 448, 449, 466, 484, 488, 489, 490, 491, 510, 539, 627, 631, 636, 637, 638, 642, 643, 648, 649, 651, 652, 653, 654, 655, 658, 659, 661, 662, 664, 669, 670, 671, 677, 679, 680, 684, 688, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705, 706, 707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717, 718, 719, 720, 729, 731, 732, 734, 735, 738, 739, 742, 743, 746, 747, 750, 751, 754, 768, 769, 773, 774, 777, 785, 788, 789, 792, 804, 807,]
missed_lines = [ 138, 154, 282, 324, 401, 501, 518, 548, 556, 557, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574, 602, 605, 607, 608, 610, 611, 612, 613, 615, 616, 618, 619, 620, 621, 623, 691, 759, 760, 761, 762, 770, 775, 781, 786, 790,]

[input_info]
test_file_path = "src/test/java/com/github/f4b6a3/uuid/alt/GUIDTest.java"
focal_file_path = "src/main/java/com/github/f4b6a3/uuid/alt/GUID.java"
test_file_url = "https://github.com/f4b6a3/uuid-creator/blob/3f41c3e6ed9fa3c229303672960570281f35a125/src/test/java/com/github/f4b6a3/uuid/alt/GUIDTest.java"
focal_file_url = "https://github.com/f4b6a3/uuid-creator/blob/3f41c3e6ed9fa3c229303672960570281f35a125/src/main/java/com/github/f4b6a3/uuid/alt/GUID.java"
first_commit_date = "2023-04-30"
last_commit_date = "2025-03-29"
test_file_content = "package com.github.f4b6a3.uuid.alt;\n\nimport static org.junit.Assert.*;\n\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.security.SecureRandom;\nimport java.time.Instant;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.SplittableRandom;\nimport java.util.UUID;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.regex.Pattern;\n\nimport org.junit.Test;\n\nimport com.github.f4b6a3.uuid.codec.other.TimeOrderedCodec;\nimport com.github.f4b6a3.uuid.util.UuidTime;\nimport com.github.f4b6a3.uuid.util.UuidUtil;\n\npublic class GUIDTest {\n\n\tprivate static final int DEFAULT_LOOP_MAX = 100;\n\n\tprivate static final SecureRandom secure = new SecureRandom();\n\n\tprivate static final String REGEX = \"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\";\n\tprivate static final Pattern PATTERN = Pattern.compile(REGEX, Pattern.CASE_INSENSITIVE);\n\n\t@Test\n\tpublic void testConstructorGUID() {\n\t\tSplittableRandom random = new SplittableRandom(1);\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tfinal long msb = random.nextLong();\n\t\t\tfinal long lsb = random.nextLong();\n\t\t\tGUID guid = new GUID(new GUID(msb, lsb));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testConstructorLongs() {\n\t\tSplittableRandom random = new SplittableRandom(1);\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tfinal long msb = random.nextLong();\n\t\t\tfinal long lsb = random.nextLong();\n\t\t\tGUID guid = new GUID(msb, lsb);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testConstructorJdkUUID() {\n\t\tSplittableRandom random = new SplittableRandom(1);\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tfinal long msb = random.nextLong();\n\t\t\tfinal long lsb = random.nextLong();\n\t\t\tGUID guid = new GUID(new UUID(msb, lsb));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testConstructorString() {\n\t\tSplittableRandom random = new SplittableRandom(1);\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tfinal long msb = random.nextLong();\n\t\t\tfinal long lsb = random.nextLong();\n\t\t\tUUID uuid = new UUID(msb, lsb);\n\t\t\tString str = uuid.toString();\n\t\t\tGUID guid = new GUID(str);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testConstructorBytes() {\n\t\tSplittableRandom seeder = new SplittableRandom(1);\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tbyte[] bytes = new byte[GUID.GUID_BYTES];\n\t\t\t(new Random(seeder.nextLong())).nextBytes(bytes);\n\t\t\tGUID guid = new GUID(bytes);\n\t\t}\n\n\t\ttry {\n\t\t\tbyte[] bytes = null;\n\t\t\tnew GUID(bytes);\n\t\t\tfail(\"Should throw an exception\");\n\t\t} catch (IllegalArgumentException e) {\n\t\t}\n\n\t\ttry {\n\t\t\tbyte[] bytes = new byte[GUID.GUID_BYTES + 1];\n\t\t\tnew GUID(bytes);\n\t\t\tfail(\"Should throw an exception\");\n\t\t} catch (IllegalArgumentException e) {\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testV1() {\n\t\ttestV1(() -> GUID.v1());\n\t\ttestV1(() -> GUID.v1(null, null));\n\t\ttestV1(() -> GUID.v1(null, secure));\n\t\ttestV1(() -> GUID.v1(Instant.now(), null));\n\t\ttestV1(() -> GUID.v1(Instant.now(), secure));\n\t}\n\n\tpublic void testV1(Supplier<GUID> function) {\n\t\tGUID prev = function.get();\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tlong t0 = System.currentTimeMillis();\n\t\t\tGUID guid = function.get();\n\t\t\tlong t1 = UuidTime.toUnixTimestamp(guid.toUUID().timestamp()) / 10_000L;\n\t\t\tlong t2 = System.currentTimeMillis();\n\t\t\tprev = guid;\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testV2() {\n\t\tGUID prev = GUID.v2((byte) 0, (int) 0);\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tbyte ld = (byte) i;\n\t\t\tint li = (int) i * 31;\n\t\t\tGUID guid = GUID.v2(ld, li);\n\t\t\tbyte localDomain = UuidUtil.getLocalDomain(guid.toUUID());\n\t\t\tint localIdentifier = UuidUtil.getLocalIdentifier(guid.toUUID());\n\t\t\tprev = guid;\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testV3() {\n\t\tGUID prev = GUID.v3(GUID.NIL, \"\");\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tGUID namespace = new GUID(UUID.randomUUID());\n\t\t\tString name = UUID.randomUUID().toString();\n\t\t\tGUID guid = GUID.v3(namespace, name);\n\t\t\tprev = guid;\n\t\t}\n\t\t{\n\t\t\tGUID guid = GUID.v3(GUID.NAMESPACE_DNS, \"www.example.com\");\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testV4() {\n\t\ttestV4(() -> GUID.v4());\n\t\ttestV4(() -> GUID.v4(secure));\n\t}\n\n\tpublic void testV4(Supplier<GUID> function) {\n\t\tGUID prev = function.get();\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tGUID guid = function.get();\n\t\t\tprev = guid;\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testV5() {\n\t\tGUID prev = GUID.v5(GUID.NIL, \"\");\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tGUID namespace = new GUID(UUID.randomUUID());\n\t\t\tString name = UUID.randomUUID().toString();\n\t\t\tGUID guid = GUID.v5(namespace, name);\n\t\t\tprev = guid;\n\t\t}\n\t\t{\n\t\t\tGUID guid = GUID.v5(GUID.NAMESPACE_DNS, \"www.example.com\");\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testV6() {\n\t\ttestV6(() -> GUID.v6());\n\t\ttestV6(() -> GUID.v6(null, null));\n\t\ttestV6(() -> GUID.v6(null, secure));\n\t\ttestV6(() -> GUID.v6(Instant.now(), null));\n\t\ttestV6(() -> GUID.v6(Instant.now(), secure));\n\t}\n\n\tpublic void testV6(Supplier<GUID> function) {\n\t\tGUID prev = function.get();\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tlong t0 = System.currentTimeMillis();\n\t\t\tGUID guid = function.get();\n\t\t\tGUID temp = new GUID(TimeOrderedCodec.INSTANCE.decode(guid.toUUID()));\n\t\t\tlong t1 = UuidTime.toUnixTimestamp(temp.toUUID().timestamp()) / 10_000L;\n\t\t\tlong t2 = System.currentTimeMillis();\n\t\t\tprev = guid;\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testV7() {\n\t\ttestV7(() -> GUID.v7());\n\t\ttestV7(() -> GUID.v7(null, null));\n\t\ttestV7(() -> GUID.v7(null, secure));\n\t\ttestV7(() -> GUID.v7(Instant.now(), null));\n\t\ttestV7(() -> GUID.v7(Instant.now(), secure));\n\t}\n\n\tpublic void testV7(Supplier<GUID> function) {\n\t\tGUID prev = function.get();\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tlong t0 = System.currentTimeMillis();\n\t\t\tGUID guid = function.get();\n\t\t\tlong t1 = guid.getMostSignificantBits() >>> 16;\n\t\t\tlong t2 = System.currentTimeMillis();\n\t\t\tprev = guid;\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testToUUID() {\n\t\tSplittableRandom random = new SplittableRandom(1);\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tfinal long msb = random.nextLong();\n\t\t\tfinal long lsb = random.nextLong();\n\t\t\tUUID uuid = (new GUID(msb, lsb)).toUUID();\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testToString() {\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tUUID uuid = UUID.randomUUID();\n\t\t\tGUID guid = new GUID(uuid);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testToBytes() {\n\t\tSplittableRandom seeder = new SplittableRandom(1);\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\n\t\t\tbyte[] bytes1 = new byte[16];\n\t\t\t(new Random(seeder.nextLong())).nextBytes(bytes1);\n\t\t\tGUID guid0 = new GUID(bytes1);\n\n\t\t\tbyte[] bytes2 = guid0.toBytes();\n\t\t\tfor (int j = 0; j < bytes1.length; j++) {\n\t\t\t}\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testHashCode() {\n\n\t\tSplittableRandom seeder = new SplittableRandom(1);\n\t\tbyte[] bytes = new byte[GUID.GUID_BYTES];\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\t(new Random(seeder.nextLong())).nextBytes(bytes);\n\t\t\tGUID guid1 = new GUID(bytes);\n\t\t}\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\t(new Random(seeder.nextLong())).nextBytes(bytes);\n\t\t\tGUID guid1 = new GUID(bytes);\n\t\t\tGUID guid2 = new GUID(bytes);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testEquals() {\n\n\t\tSplittableRandom seeder = new SplittableRandom(1);\n\t\tbyte[] bytes = new byte[GUID.GUID_BYTES];\n\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\n\t\t\t(new Random(seeder.nextLong())).nextBytes(bytes);\n\t\t\tGUID guid1 = new GUID(bytes);\n\t\t\tGUID guid2 = new GUID(bytes);\n\t\t\tfor (int j = 0; j < bytes.length; j++) {\n\t\t\t\tbytes[j]++;\n\t\t\t}\n\t\t\tGUID guid3 = new GUID(bytes);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testCompareTo() {\n\n\t\tfinal long zero = 0L;\n\t\tSplittableRandom random = new SplittableRandom(1);\n\t\tbyte[] bytes = new byte[GUID.GUID_BYTES];\n\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\n\t\t\tbytes = ByteBuffer.allocate(16).putLong(random.nextLong()).putLong(random.nextLong()).array();\n\t\t\tGUID guid1 = new GUID(bytes);\n\t\t\tBigInteger number1 = new BigInteger(1, bytes);\n\n\t\t\tbytes = ByteBuffer.allocate(16).putLong(random.nextLong()).putLong(random.nextLong()).array();\n\t\t\tGUID guid2 = new GUID(bytes);\n\t\t\tGUID guid3 = new GUID(bytes);\n\t\t\tBigInteger number2 = new BigInteger(1, bytes);\n\t\t\tBigInteger number3 = new BigInteger(1, bytes);\n\n\t\t}\n\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\n\t\t\tbytes = ByteBuffer.allocate(16).putLong(zero).putLong(random.nextLong()).array();\n\t\t\tGUID guid1 = new GUID(bytes);\n\t\t\tBigInteger number1 = new BigInteger(1, bytes);\n\n\t\t\tbytes = ByteBuffer.allocate(16).putLong(zero).putLong(random.nextLong()).array();\n\t\t\tGUID guid2 = new GUID(bytes);\n\t\t\tGUID guid3 = new GUID(bytes);\n\t\t\tBigInteger number2 = new BigInteger(1, bytes);\n\t\t\tBigInteger number3 = new BigInteger(1, bytes);\n\n\t\t}\n\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\n\t\t\tbytes = ByteBuffer.allocate(16).putLong(random.nextLong()).putLong(zero).array();\n\t\t\tGUID guid1 = new GUID(bytes);\n\t\t\tBigInteger number1 = new BigInteger(1, bytes);\n\n\t\t\tbytes = ByteBuffer.allocate(16).putLong(random.nextLong()).putLong(zero).array();\n\t\t\tGUID guid2 = new GUID(bytes);\n\t\t\tGUID guid3 = new GUID(bytes);\n\t\t\tBigInteger number2 = new BigInteger(1, bytes);\n\t\t\tBigInteger number3 = new BigInteger(1, bytes);\n\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testProtectedGregorian() {\n\t\ttestProtectedGregorianInstant(Instant.parse(\"1582-10-15T00:00:00.000Z\").toEpochMilli());\n\t\ttestProtectedGregorianInstant(Instant.parse(\"1970-01-01T00:00:00.000Z\").toEpochMilli());\n\t\ttestProtectedGregorianInstant(Instant.parse(\"1955-11-12T06:38:00.000Z\").toEpochMilli());\n\t\ttestProtectedGregorianInstant(Instant.parse(\"1985-10-26T09:00:00.000Z\").toEpochMilli());\n\t\ttestProtectedGregorianInstant(Instant.parse(\"2015-10-21T07:28:00.000Z\").toEpochMilli());\n\t}\n\n\tprivate static void testProtectedGregorianInstant(final long time) {\n\t\tlong epoch = 12219292800L;\n\t}\n\n\t@Test\n\tpublic void testProtectedHash() {\n\t\tString name = \"THIS IS A TEST\";\n\t\tGUID guid = GUID.v3(null, name);\n\t\tUUID uuid = UUID.nameUUIDFromBytes(name.getBytes(StandardCharsets.UTF_8));\n\t}\n\n\t@Test\n\tpublic void testProtectedHasher() {\n\t\ttry {\n\t\t\tGUID.hasher(\"AAA\");\n\t\t\tfail(\"Should throw exception\");\n\t\t} catch (IllegalArgumentException e) {\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testProtectedVersion() {\n\t\tfor (int i = 0; i < 32; i++) {\n\t\t\tGUID guid = GUID.version(GUID.NIL.getMostSignificantBits(), GUID.NIL.getLeastSignificantBits(), i);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testValid() {\n\t\ttestValidator((String string) -> {\n\t\t\treturn GUID.valid(string);\n\t\t});\n\t}\n\n\t@Test\n\tpublic void testParser() {\n\t\tfor (int i = 0; i < DEFAULT_LOOP_MAX; i++) {\n\t\t\tString string = UUID.randomUUID().toString();\n\t\t\tGUID guid = GUID.Parser.parse(string);\n\t\t}\n\n\t\ttestValidator((String string) -> {\n\t\t\ttry {\n\t\t\t\treturn GUID.Parser.parse(string) != null;\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void testValidator(Function<String, Boolean> validator) {\n\n\t\tString guid = null;\n\n\t\tguid = \"\";\n\n\t\tguid = \"0-0-0-0-0\";\n\n\t\tguid = \"this should be invalid\";\n\n\t\tguid = \"01234567-89ab-4def-abcd-ef0123456789\";\n\n\t\tguid = \"01234567-89ab-4def-abcdef01-23456789\";\n\n\t\tguid = \"01234567-89ab-4def-abcd-ef01-3456789\";\n\n\t\tguid = \"01234567-89ab-4def-abcddef0123456789\";\n\n\t\tguid = \"0123456789ab4defabcdef0123456789\";\n\n\t\tguid = UUID.randomUUID().toString();\n\n\t\tguid = \"01234567-89ab-4def-abcd-ef0123456789\";\n\n\t\tguid = \"01234567-89AB-4DEF-ABCD-EF0123456789\";\n\n\t\tguid = \"01234567-89ab-4DEF-abcd-EF0123456789\";\n\n\t\tguid = \"01234567-89ab-4def-abcd-SOPQRSTUVXYZ\";\n\n\t\tguid = \"01234567-89ab-4def-!@#$-ef0123456789\";\n\t}\n}"
