[meta]
task = "create"
scenario = "add_new_test"

[lang_info]
lang = "Go"
go_version = "1.24.1"

[repo_info]
repository = "VictoriaMetrics/VictoriaMetrics"
sha = "099b2fdba79582dcc1c32a604b587deaf32270db"

[run_info]
docker_image = "golang:1.24.1"
volumes_to_mount = [ "{proj_path}:/app", "{host}/.m2:/.m2", "{host}/.cache/pip:/.pip_cache", "{host}/.cache/go-build:/.go_cache", "{proj_path}/_HOME_/go:/go",]
docker_wrap = "sudo docker run --rm -w /app -v {proj_path}:/app -v {host}/.m2:/.m2 -v {host}/.cache/pip:/.pip_cache -v {host}/.cache/go-build:/.go_cache -v {proj_path}/_HOME_/go:/go {img} sh -c '{cmd}'"
env = []
prebuild_command = "go mod download && go install github.com/avito-tech/go-mutesting/cmd/go-mutesting@latest && go install github.com/jstemmer/go-junit-report@latest"
test_run_command = "go test -v -failfast -coverprofile=coverage.out lib/netutil/proxyprotocol.go lib/netutil/proxyprotocol_test.go 2>&1 && go tool cover -func=coverage.out"
mutation_run_command = "timeout {timeout} go-mutesting lib/netutil/proxyprotocol.go"
coverage_report_path = "coverage.out"
coverage_report_type = "go_cover"
mutation_report_path = "mutation_report.txt"
mutation_report_type = "go-mutesting"

[coverage]
coverage = 74.47
original_coverage = 75.0
mutation_kill_rate = 73.68
original_mutation_kill_rate = nan
covered_lines = [ 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 74, 77, 79, 80, 84, 85, 86, 87, 88, 89, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 126, 127,]
missed_lines = [ 17, 18, 19, 20, 21, 22, 24, 25, 26, 27, 28, 29, 30, 33, 34, 35, 37, 38, 39, 40, 43, 44, 45, 75,]

[input_info]
test_file_path = "lib/netutil/proxyprotocol_test.go"
focal_file_path = "lib/netutil/proxyprotocol.go"
test_file_url = "https://github.com/VictoriaMetrics/VictoriaMetrics/blob/099b2fdba79582dcc1c32a604b587deaf32270db/lib/netutil/proxyprotocol_test.go"
focal_file_url = "https://github.com/VictoriaMetrics/VictoriaMetrics/blob/099b2fdba79582dcc1c32a604b587deaf32270db/lib/netutil/proxyprotocol.go"
first_commit_date = "2023-01-27"
last_commit_date = "2025-03-17"
test_file_content = "package netutil\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestParseProxyProtocolSuccess(t *testing.T) {\n\tf := func(body, wantTail []byte, wantAddr net.Addr) {\n\t\tt.Helper()\n\t\tr := bytes.NewBuffer(body)\n\t\tgotAddr, err := readProxyProto(r)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"unexpected error: %s\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(gotAddr, wantAddr) {\n\t\t\tt.Fatalf(\"ip not match, got: %v, want: %v\", gotAddr, wantAddr)\n\t\t}\n\t\tgotTail, err := io.ReadAll(r)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"cannot read tail: %s\", err)\n\t\t}\n\t\tif !bytes.Equal(gotTail, wantTail) {\n\t\t\tt.Fatalf(\"unexpected tail after parsing proxy protocol\\ngot:\\n%q\\nwant:\\n%q\", gotTail, wantTail)\n\t\t}\n\t}\n\t// LOCAL addr\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x20, 0x11, 0x00, 0x0C,\n\t\t0x7F, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 80, 0, 0}, nil,\n\t\tnil)\n\t// ipv4\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x21, 0x11, 0x00, 0x0C,\n\t\t// ip data srcid,dstip,srcport,dstport\n\t\t0x7F, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 80, 0, 0}, nil,\n\t\t&net.TCPAddr{IP: net.ParseIP(\"127.0.0.1\"), Port: 80})\n\t// ipv4 with payload\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x21, 0x11, 0x00, 0x0C,\n\t\t// ip data\n\t\t0x7F, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 80, 0, 0,\n\t\t// some payload\n\t\t0x7F, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 80, 0, 0,\n\t}, []byte{0x7F, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 80, 0, 0},\n\t\t&net.TCPAddr{IP: net.ParseIP(\"127.0.0.1\"), Port: 80})\n\t// ipv6\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x21, 0x21, 0x00, 0x24,\n\t\t// src and dst ipv6\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n\t\t// ports\n\t\t0, 80, 0, 0}, nil,\n\t\t&net.TCPAddr{IP: net.ParseIP(\"::1\"), Port: 80})\n}\n\nfunc TestParseProxyProtocolFail(t *testing.T) {\n\tf := func(body []byte) {\n\t\tt.Helper()\n\t\tr := bytes.NewBuffer(body)\n\t\tgotAddr, err := readProxyProto(r)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"expected error at input %v\", body)\n\t\t}\n\t\tif gotAddr != nil {\n\t\t\tt.Fatalf(\"expected ip to be nil, got: %v\", gotAddr)\n\t\t}\n\t}\n\t// too short protocol prefix\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A})\n\t// broken protocol prefix\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x21})\n\t// invalid header\n\tf([]byte{0x0D, 0x1A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x21, 0x11, 0x00, 0x0C})\n\t// invalid version\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x31, 0x11, 0x00, 0x0C})\n\t// too long block\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x21, 0x11, 0xff, 0x0C})\n\t// missing bytes in address\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x21, 0x11, 0x00, 0x0C,\n\t\t// ip data srcid,dstip,srcport\n\t\t0x7F, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 80})\n\t// too short address length\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x21, 0x11, 0x00, 0x08,\n\t\t0x7F, 0x00, 0x00, 0x01, 0, 0, 0, 0})\n\t// unsupported family\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x21, 0x31, 0x00, 0x0C,\n\t\t0x7F, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 80, 0, 0})\n\t// unsupported command\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x22, 0x11, 0x00, 0x0C,\n\t\t0x7F, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 80, 0, 0})\n\t// mismatch ipv6 and ipv4\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x21, 0x21, 0x00, 0x0C,\n\t\t// ip data srcid,dstip,srcport\n\t\t0x7F, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 80, 0, 0})\n\t// ipv4 udp isn't supported\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x21, 0x12, 0x00, 0x0C,\n\t\t// ip data srcid,dstip,srcport,dstport\n\t\t0x7F, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 80, 0, 0})\n\t// ipv6 udp isn't supported\n\tf([]byte{0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A, 0x21, 0x22, 0x00, 0x24,\n\t\t// src and dst ipv6\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n\t\t// ports\n\t\t0, 80, 0, 0})\n}\n"
